<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Game Ultimate [HTML EDITION]</title>
	<link rel="icon" type="image/png" href="Grass Dirt Block.png">
	<input type="file" id="worldFileInput" accept=".bgu1" style="display: none;">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #70b6d5; 
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: sans-serif;
            color: white;
            transition: background-color 1s ease; 
        }
        canvas {
            border: 2px solid #555;
            display: block;
            width: 100%; 
            height: 100%; 
        }
        #gameContainer {
            position: relative;
            display: inline-block; 
            width: 100vw; 
            height: 100vh; 
            overflow: hidden; 
        }
        #hotbar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 5px;
            z-index: 50;
        }
        .hotbar-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #aaa;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            cursor: pointer;
            position: relative;
            background-color: rgba(255, 255, 255, 0.2);
        }
        .hotbar-slot.selected {
            border-color: yellow;
        }
        .hotbar-slot span {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            color: white; 
            text-shadow: 1px 1px 2px black; 
        }
        .hotbar-slot img {
            width: 30px;
            height: 30px;
            image-rendering: pixelated; 
        }
        .hotbar-slot .fallback {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            text-align: center;
            word-break: break-word; 
            padding: 2px;
            box-sizing: border-box; 
        }
		#itemTooltip {
			display: none; 
			position: fixed; 
			background-color: rgba(0, 0, 0, 0.8);
			color: white;
			padding: 5px 8px;
			border-radius: 4px;
			font-size: 14px;
			pointer-events: none; 
			z-index: 9999; 
			white-space: nowrap; 
		}
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            z-index: 100;
        }
         #coordsDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 50; 
        }
        #healthBar {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 2px;
            z-index: 50;
        }
        #healthBar img {
            width: 18px;
            height: 18px;
            image-rendering: pixelated;
        }
        #healthBar.glow-yellow img {
            filter: drop-shadow(0 0 5px #ffee00) drop-shadow(0 0 10px #ffee00);
            transition: filter 0.2s;
        }
        #healthBar.flash-red img {
            animation: red-flash 1s ease-out; 
        }
        #healthBar.glow-green img {
            animation: green-glow 1.5s ease-out; 
        }
        @keyframes red-flash {
            0% {
                filter: drop-shadow(0 0 10px red) brightness(2.0);
            }
            50% {
                filter: drop-shadow(0 0 20px red) brightness(3.0); 
            }
            100% {
                filter: none;
            }
        }
        @keyframes green-glow {
            0% {
                filter: drop-shadow(0 0 10px limegreen) drop-shadow(0 0 20px limegreen) brightness(1.5); 
            }
            100% {
                filter: none;
            }
        }
        #gameMenuOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85); 
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; 
            font-family: 'Inter', sans-serif; 
            color: #E0E0E0; 
            flex-direction: column;
            gap: 20px;
            display: none; 
        }
        #gameMenu {
            background-color: #333; 
            padding: 30px;
            border-radius: 15px; 
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); 
            width: 90%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            border: 2px solid #555; 
            max-height: 90vh; 
            overflow-y: auto; 
        }
        #gameMenu h2 {
            color: #00BFFF; 
            text-align: center;
            margin-bottom: 20px;
            font-size: 2em; 
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }
        #seedInput {
            width: calc(100% - 24px); 
            padding: 12px;
            margin-top: 10px;
            border: 1px solid #666;
            border-radius: 8px;
            background-color: #555;
            color: white;
            font-size: 1em;
            box-sizing: border-box; 
        }
        #seedInput::placeholder {
            color: #AAA;
        }
        .menu-buttons {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        .menu-buttons button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .menu-buttons button:hover {
            transform: translateY(-2px);
        }
        #resumeButton, #newGameButton {
            background-color: #6c757d; 
            color: white;
        }
        #resumeButton:hover, #newGameButton:hover {
            background-color: #5a6268;
        }
        @media (max-width: 600px) {
            #gameMenu {
                padding: 20px;
                width: 95%;
            }
            #gameMenu h2 {
                font-size: 1.5em;
            }
            .menu-buttons button {
                width: 100%;
            }
        }
        #gameMenuTipText {
            margin-top: 25px; 
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2); 
            border-radius: 8px;
            font-size: 0.9em; 
            font-style: italic;
            color: #CCC; 
            text-align: center;
            min-height: 40px; 
            transition: color 0.5s ease; 
        }
        #customMessageBoxOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; 
            font-family: 'Inter', sans-serif;
            color: white;
            display: none; 
        }
        #customMessageBox {
            background-color: #444;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            text-align: center;
            max-width: 400px;
            width: 80%;
            border: 1px solid #666;
        }
		#devConsoleOverlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background-color: rgba(0, 0, 0, 0.5);
			display: none; 
			justify-content: center;
			align-items: center;
			z-index: 3000; 
			font-family: 'Courier New', monospace;
		}
		#devConsole {
			width: 80%;
			max-width: 800px;
			height: 60%;
			background-color: #1E1E1E;
			border: 2px solid #555;
			border-radius: 10px;
			display: flex;
			flex-direction: column;
			overflow: hidden;
		}
		#consoleOutput {
			flex-grow: 1;
			overflow-y: auto;
			padding: 10px;
			color: #D4D4D4;
			font-size: 14px;
			white-space: pre-wrap;
			word-break: break-all;
		}
		#consoleOutput .log-input {
			color: #9CDCFE; 
		}
		#consoleOutput .log-output {
			color: #4EC9B0; 
		}
		#consoleOutput .log-error {
			color: #F44747; 
		}
		#consoleInputWrapper {
			display: flex;
			align-items: center;
			border-top: 1px solid #555;
			padding: 5px;
			background-color: #252526;
		}
		#consoleInputWrapper span {
			color: #D4D4D4;
			margin-right: 5px;
		}
		#consoleInput {
			flex-grow: 1;
			background-color: transparent;
			border: none;
			outline: none;
			color: #D4D4D4;
			font-family: 'Courier New', monospace;
			font-size: 14px;
		}
        #messageBoxText {
            margin-bottom: 20px;
            font-size: 1.1em;
        }
        #messageBoxButtons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        #messageBoxButtons button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            transition: background-color 0.2s ease;
        }
        #messageBoxButtons button:hover {
            background-color: #0056b3;
        }
        #messageBoxCancelButton {
            background-color: #6c757d;
        }
        #messageBoxCancelButton:hover {
            background-color: #5a6268;
        }
        #inventoryCraftingOverlay, #chestOverlay, #voidChestOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85);
            display: none; 
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-family: 'Inter', sans-serif;
            color: #E0E0E0;
        }
        #voidCharacterContainer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: none; 
            align-items: flex-end;
            gap: 15px;
            z-index: 1001; 
        }
        #voidCharacter {
            width: 80px; 
            height: auto;
            image-rendering: pixelated;
        }
        #voidTradeOffer {
            background-color: rgba(20, 0, 30, 0.9);
            border: 2px solid #8A2BE2;
            border-radius: 10px;
            padding: 15px;
            color: #E0E0E0;
            width: 250px;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        #voidDialogue {
            font-style: italic;
            text-align: center;
            margin: 0 0 10px 0;
            font-size: 0.9em;
        }
        #voidOfferItem {
            margin: 0 auto; 
        }
        #voidOfferCost {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
        }
        #voidOfferCost img {
            width: 20px;
            height: 20px;
            image-rendering: pixelated;
        }
        #voidTradeButtons {
            display: flex;
            justify-content: center;
            gap: 10px;
            width: 100%;
        }
        #voidTradeButtons button {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            font-size: 0.9em;
            cursor: pointer;
            flex-grow: 1;
        }
        #voidAcceptButton {
            background-color: #28a745;
            color: white;
        }
        #voidAcceptButton:disabled {
            background-color: #5a6268;
            cursor: not-allowed;
        }
        #voidDeclineButton {
            background-color: #dc3545;
            color: white;
        }
		.trade-row {
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 8px;
			margin-bottom: 8px;
			background-color: rgba(0, 0, 0, 0.2);
			border-radius: 6px;
			gap: 10px;
		}
		.trade-row .inventory-slot {
			width: 40px;
			height: 40px;
			cursor: default; 
		}
		.trade-row .trade-arrow {
			font-size: 1.5em;
			font-weight: bold;
		}
		.trade-row button {
			padding: 6px 12px;
			font-size: 0.9em;
		}
        #worldMoverConfigOverlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: rgba(0, 0, 0, 0.85); display: none;
            justify-content: center; align-items: center; z-index: 2000;
            font-family: 'Inter', sans-serif; color: #E0E0E0;
        }
        #worldMoverConfigMenu {
            background-color: #333; padding: 20px; border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); width: 90%;
            max-width: 400px; border: 2px solid #555; display: flex;
            flex-direction: column; gap: 15px; text-align: center;
        }
        #worldMoverConfigMenu h2 { color: #8A2BE2; margin: 0 0 10px 0; }
        .config-section { padding: 10px; background-color: #444; border-radius: 10px; }
        #worldMoverCodeInput {
            width: 50%; padding: 8px; border: 1px solid #666;
            border-radius: 5px; background-color: #555; color: white;
            font-size: 1.2em; text-align: center;
        }
        #saveWorldMoverButton {
            padding: 10px 20px; border: none; border-radius: 8px; font-size: 1.1em;
            cursor: pointer; background-color: #007bff; color: white;
            font-weight: bold; align-self: center; margin-top: 10px;
        }
        #worldMoverTeleportOverlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: rgba(0, 0, 0, 0.85); display: none;
            justify-content: center; align-items: center; z-index: 2000;
            font-family: 'Inter', sans-serif; color: #E0E0E0;
        }
        #worldMoverTeleportMenu {
            background-color: #2a2a2a; padding: 30px; border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.6); text-align: center;
            border: 2px solid #8A2BE2;
        }
        #teleportCodeInput {
            display: block; margin: 10px auto; width: 100px; font-size: 2em;
            text-align: center; background-color: #444; color: white;
            border: 1px solid #666; border-radius: 5px;
        }
        #inventoryCraftingMenu, #chestMenu, #voidChestMenu {
            background-color: #333;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 600px;
            border: 2px solid #555;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 90vh; 
            overflow-y: auto; 
        }
        #inventoryCraftingMenu h2, #chestMenu h2 {
            color: #00BFFF;
            text-align: center;
            margin: 0 0 10px 0;
        }
        .inventory-section {
            padding: 10px;
            background-color: #444;
            border-radius: 10px;
        }
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
            gap: 8px;
        }
        .inventory-slot {
            width: 45px;
            height: 45px;
            border: 2px solid #777;
            background-color: #555;
            border-radius: 5px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .inventory-slot:hover {
            background-color: #666;
        }
        .inventory-slot img {
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
        }
        .inventory-slot .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        #inventoryHotbarGrid .hotbar-slot {
            border-color: yellow; 
        }
        .crafting-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        #craftingGrid {
            display: grid;
            grid-template-columns: repeat(4, 45px); 
            grid-template-rows: repeat(4, 45px); 
            gap: 5px;
        }
        .crafting-arrow {
            font-size: 2em;
            color: #999;
        }
        #craftingOutput {
            width: 50px;
            height: 50px;
            border: 2px dashed #999;
        }
        #craftButton {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #28a745;
            color: white;
            font-weight: bold;
            align-self: center;
        }
        #craftButton:disabled {
            background-color: #5a6268;
            cursor: not-allowed;
        }
        #recipeMenu {
            padding: 10px;
            background-color: #444;
            border-radius: 10px;
            margin-top: 20px;
        }
        #recipeMenu h3 {
            color: #00BFFF;
            margin-top: 0;
            margin-bottom: 10px;
        }
        .recipe-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            background-color: #555;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #666;
        }
        .recipe-input-grid {
            display: grid;
            grid-template-columns: repeat(4, 35px); 
            grid-template-rows: repeat(4, 35px);
            gap: 3px;
            margin-right: 10px;
            flex-shrink: 0; 
        }
        .recipe-input-grid .inventory-slot {
            width: 35px;
            height: 35px;
            border: 1px solid #777;
            background-color: #666;
        }
        .recipe-output {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: bold;
        }
        .recipe-output .inventory-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #777;
            background-color: #555;
            border-radius: 5px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .recipe-output .inventory-slot img {
            width: 28px;
            height: 28px;
        }
        .recipe-output .inventory-slot .item-count {
            font-size: 10px;
        }
        .durability-bar {
            position: absolute;
            bottom: 0px; 
            left: 0;
            width: 100%;
            height: 4px; 
            background-color: #555; 
            border-radius: 2px;
            overflow: hidden;
        }
        .durability-fill {
            height: 100%;
            background-color: #28a745; 
            width: 100%; 
            transition: width 0.1s linear; 
        }
        #chestLabelInput {
            width: calc(100% - 20px);
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #666;
            border-radius: 5px;
            background-color: #555;
            color: white;
            font-size: 0.9em;
        }
        #deleteSlot {
            width: 45px;
            height: 45px;
            border: 2px dashed #dc3545;
            background-color: rgba(220, 53, 69, 0.2);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #dc3545;
            font-size: 24px;
            font-weight: bold;
            margin-top: 10px;
        }
        #deleteSlot:hover {
            background-color: rgba(220, 53, 69, 0.4);
        }
		#consoleInput {
			flex-grow: 1;
			background-color: transparent;
			border: none;
			outline: none;
			color: #D4D4D4;
			font-family: 'Courier New', monospace;
			font-size: 14px;
			resize: none; 
			overflow-y: auto; 
			max-height: 120px; 
			line-height: 1.4;
			white-space: pre-wrap;
			word-break: break-all;
		}
        #ovenOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85);
            display: none; 
            justify-content: center;
            align-items: center;
            z-index: 2000;
            font-family: 'Inter', sans-serif;
            color: #E0E0E0;
			pointer-events: auto; 
        }
        #ovenMenu {
            background-color: #333;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 600px;
            border: 2px solid #555;
            display: flex;
            flex-direction: column;
            gap: 15px;
			max-height: 90vh;
            overflow-y: auto;
        }
        #ovenMenu h2 {
            color: #FFA500; 
            text-align: center;
            margin: 0 0 10px 0;
        }
        .oven-ui-area {
            display: flex;
            justify-content: space-around;
            align-items: center;
            gap: 20px;
        }
        #ovenGrid {
            display: grid;
            grid-template-columns: repeat(3, 45px);
            grid-template-rows: repeat(3, 45px);
            gap: 5px;
        }
        .oven-fuel-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        #cookButton {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #28a745; 
            color: white;
            font-weight: bold;
            align-self: center;
            margin-top: 10px;
        }
        #cookButton:disabled {
            background-color: #5a6268;
            cursor: not-allowed;
        }
		#debugStats {
			position: absolute;
			top: 35px; 
			left: 10px;
			background-color: rgba(0, 0, 0, 0.6);
			color: white;
			padding: 8px;
			border-radius: 5px;
			font-family: 'Courier New', monospace;
			font-size: 12px;
			line-height: 1.4;
			z-index: 50;
			pointer-events: none; 
		}
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="healthBar"></div>
        <div id="hotbar"></div>
        <div id="loadingScreen" style="display:flex;flex-direction:column;align-items:center;gap:8px;position:fixed;left:50%;top:40%;transform:translate(-50%,-50%);z-index:9999;padding:12px;background:rgba(0,0,0,0.75);border-radius:8px;">
          <div id="loadingText" style="color:white;font-size:16px;">Loading assets...</div>
          <div id="loadingBar" style="width:360px;height:18px;background:#333;border-radius:9px;overflow:hidden;border:2px solid #222;">
            <div id="loadingBarFill" style="width:0%;height:100%;background:#7bd389;transition:width 0.12s linear;"></div>
          </div>
          <div id="loadingPercent" style="color:#ddd;font-size:13px;">0%</div>
          <div id="loadingTipText" style="margin-top: 15px; color: #bbb; font-size: 14px; font-style: italic; max-width: 360px; text-align: center;"></div>
        </div>
        <div id="coordsDisplay">Coords: (0, 0)</div>
		<div id="debugStats" style="display: none;"></div>
    </div>
    <div id="gameMenuOverlay" oncontextmenu="return false;">
        <div id="gameMenu">
            <h2>Game Menu</h2>
            <div class="menu-item" style="margin-bottom: 15px;">
                <label for="seedInput" style="display: block; margin-bottom: 5px; color: #CCC; text-align: center;">World Seed (optional):</label>
                <input type="text" id="seedInput" placeholder="Leave empty for random seed">
            </div>
            <div class="menu-buttons">
                <button id="newGameButton">New Game</button>
                <button id="resumeButton">Resume Game</button>
            </div>
            <label style="margin-top: 10px; display: flex; align-items: center; justify-content: center;">
                <input type="checkbox" id="maintainDurabilityCheckbox" style="margin-right: 8px;"> Maintain Block Durability
            </label>
			<label style="margin-top: 10px; display: flex; align-items: center; justify-content: center;">
				<input type="checkbox" id="animateDropsCheckbox" style="margin-right: 8px;"> Animate Item Drops
			</label>
            <div id="gameMenuTipText"></div>
        </div>
    </div>
    <div id="inventoryCraftingOverlay" oncontextmenu="return false;">
        <div id="inventoryCraftingMenu">
            <h2>Inventory & Crafting</h2>
            <div class="inventory-section">
				<h3>Crafting</h3>
                <div class="crafting-area">
                    <div id="craftingGrid">
                    </div>
                    <div class="crafting-arrow">&#10144;</div>
                    <div class="inventory-slot" id="craftingOutput"></div>
                </div>
                 <button id="craftButton" disabled>Craft</button>
            </div>
            <div class="inventory-section">
                <h3>Your Inventory</h3>
                <div id="playerInventoryGrid" class="inventory-grid">
                </div>
            </div>
             <div class="inventory-section">
                <h3>Hotbar Slots</h3>
                <div id="inventoryHotbarGrid" class="inventory-grid">
                </div>
            </div>
            <div class="inventory-section" style="text-align: center;">
                <h3>Delete Item</h3>
                <div id="deleteSlot" class="inventory-slot" data-source-type="delete" data-slot-index="0">X</div>
            </div>
            <div id="recipeMenu" class="inventory-section">
                <h3>Recipes</h3>
                <div id="recipeList">
                </div>
            </div>
        </div>
    </div>
	<div id="devConsoleOverlay">
		<div id="devConsole">
			<div id="consoleOutput"></div>
			<div id="consoleInputWrapper">
				<span>&gt;</span>
				<textarea id="consoleInput" rows="1" autocomplete="off" spellcheck="false"></textarea>
			</div>
		</div>
	</div>
    <div id="chestOverlay" oncontextmenu="return false;">
        <div id="chestMenu">
            <h2 id="chestTitle">Chest (Esc to Exit)</h2>
            <div class="inventory-section">
                 <input type="text" id="chestLabelInput" placeholder="Chest Label..." maxlength="30">
                <div id="chestGrid" class="inventory-grid">
                </div>
            </div>
			<button id="transferAllButton" style="width: 100%; padding: 8px; margin-bottom: 10px; font-size: 1em;">
                &darr; Transfer Most Items &darr;
            </button>
            <div class="inventory-section">
                <h3>Your Inventory</h3>
                <div id="chestPlayerInventoryGrid" class="inventory-grid">
                </div>
            </div>
        </div>
    </div>
	<div id="voidChestOverlay" oncontextmenu="return false;">
		<div id="voidChestMenu" class="inventory-section"> <h2 id="voidChestTitle">The Void (Esc to Exit), Don't Leave Items Floating...</h2>
			<div id="voidChestGrid" class="inventory-grid">
				</div>
			<div class="inventory-section">
				<h3>Your Inventory</h3>
				<div id="voidChestPlayerInventoryGrid" class="inventory-grid">
					</div>
			</div>
		</div>
    	</div> <div id="voidCharacterContainer">
        <img id="voidCharacter" src="Dark Armored Player.png" alt="Void Dealer">
        <div id="voidTradeOffer">
            <p id="voidDialogue">Care to make a deal for what's been lost?</p>
            <div id="voidOfferItem" class="inventory-slot"></div>
            <div id="voidOfferCost"></div>
            <div id="voidTradeButtons">
                <button id="voidAcceptButton">Accept</button>
                <button id="voidDeclineButton">Decline</button>
            </div>
        </div>
    </div>
	<div id="traderCharacterContainer" style="display:none; position:absolute; bottom:20px; left:20px; z-index:1001; align-items:flex-end; gap:15px;">
	  <img id="traderCharacter" src="Trader.png" alt="Trader" style="width:80px; image-rendering:pixelated;">
	  <div id="traderTradeOffer" class="inventory-section" style="background-color:rgba(10,10,30,0.9); border-radius:10px; padding:10px; width:260px;">
		<p id="traderDialogue" style="font-style:italic; text-align:center; margin:0 0 8px 0;">Got goods if you've got coin.</p>
		<div id="traderOfferList"></div>
		<div id="traderOfferCost" style="margin-top:8px;"></div>
		<div id="traderTradeButtons" style="display:flex; justify-content:center; gap:8px; margin-top:8px;">
		  <button id="traderAcceptButton">Accept</button>
		  <button id="traderDeclineButton">Close</button>
            </div>
          </div>
		</div>
	  </div>
	</div>
	<div id="worldMoverConfigOverlay" oncontextmenu="return false;">
        <div id="worldMoverConfigMenu">
            <h2>World Mover Configuration</h2>
            <div class="config-section">
                <label for="worldMoverCodeInput">3-Digit Code:</label>
                <input type="text" id="worldMoverCodeInput" placeholder="e.g., 123" maxlength="3">
            </div>
            <div class="config-section">
                <h3>Fuel (Pure Energy)</h3>
                <p style="font-size: 0.8em; color: #ccc;">Requires 20 Pure Fuel per use.</p>
                <div id="worldMoverFuelSlot" class="inventory-slot">
                    </div>
            </div>
            <button id="saveWorldMoverButton">Save & Close</button>
        </div>
    </div>
    <div id="worldMoverTeleportOverlay" oncontextmenu="return false;">
        <div id="worldMoverTeleportMenu">
            <h2>Teleport Network</h2>
            <label for="teleportCodeInput">Enter 3-Digit Code:</label>
            <input type="text" id="teleportCodeInput" placeholder="e.g., 123" maxlength="3">
            <p style="font-size: 0.8em; color: #ccc;">Press 'Enter' to teleport.</p>
        </div>
    </div>
	<div id="ovenOverlay" oncontextmenu="return false;">
        <div id="ovenMenu">
            <h2>Oven</h2>
            <div class="oven-ui-area">
                <div class="inventory-section">
                    <h3>Input</h3>
                    <div id="ovenGrid" class="inventory-grid">
                        </div>
                </div>
                <div class="oven-fuel-section">
                    <h3>Fuel</h3>
                    <div id="ovenFuelSlot" class="inventory-slot">
                        </div>
                </div>
                <div class="crafting-arrow" style="font-size: 2em;">&#10144;</div>
                <div class="inventory-section">
                    <div style="display: flex; justify-content: space-around; text-align: center;">
                        <div>
                            <h3>Output</h3>
                            <div id="ovenOutputSlot" class="inventory-slot">
                                </div>
                        </div>
                        <div>
                            <h3>Byproduct</h3>
                            <div id="ovenByproductSlot" class="inventory-slot">
                                </div>
                        </div>
                    </div>
                </div>
            </div>
            <button id="cookButton" disabled>Cook</button>
            <div class="inventory-section">
                <h3>Your Inventory</h3>
                <div id="ovenPlayerInventoryGrid" class="inventory-grid">
                    </div>
            </div>
            <div class="inventory-section" id="ovenRecipeMenu">
                <h3>Recipes</h3>
                <div id="ovenRecipeList">
                    </div>
            </div>
        </div>
    </div>
    <div id="customMessageBoxOverlay">
        <div id="customMessageBox">
            <p id="messageBoxText"></p>
            <div id="messageBoxButtons">
            </div>
        </div>
    </div>
<div id="itemTooltip"></div>
    <script>
		const itemTooltip = document.getElementById('itemTooltip');
        const loadingTipText = document.getElementById('loadingTipText');
		let cheatItems = false
        const loadingTips = [
            "Don't Eat Any Food When You Are At Full Health, You Dum Dum!!!",
            "Having A Bed Is Almost Like A Hack! You Can Press The ';' Key And You Will Teleport To Your Bed But At The Cost Of A Little Health. Farm Cotton First Though!",
            "When You Use Tools To Make New Tools, The Durability Resets. If You Ever Get A Steel Pickaxe, For Example, Save It At A Very Low Durability To Use It Later To Craft A Better Tool!",
            "Before You Go Underground, Stock Up On A High Supply Of Wood Planks And Sticks. If Possible, Craft A Rock Pickaxe Due To Their Superiority Over Wood. There's No Such Thing As Too Many Rock Pickaxes.",
            "Craft A Refrigerator For Any Crops Or Meat You Collect, And Store Them Carefully. They Will Otherwise Spoil In Your Inventory! Spoilables Are Often Quite Useful.",
            "Coal Is Most Common In The Stone Layer, So It Is Wise To Stock Up On Coal Before Entering The Underground Depths, Even Though Coal Thrives There Too!",
            "Press The '[' Button To Load Your World And The ']' Button To Save Your World. This Exports Your World As A .bgu1 (Block Game Ultimate) File You Can Use To Load Up Later!",
            "Press The '{' Button To Load Your World With Reduced File Size And The '}' Button To Save Your World With Reduced File Size (Up To 10x Smaller!). This Exports Your World As A .bgu2 (Block Game Ultimate) File You Can Use To Load Up Later!",
            "If You Get A Power Orb, Don't Waste It! Make A Powered Tool, Which NEVER BREAKS! Or Make Power Soup To PERMANENTLY Increase Health And Fully Heal.",
            "Pickaxes Are Best Used On Hard Blocks Like Stone, Otherwise Their Mining Power Makes No Difference And You Should Find Another Tool!",
            "Axes Are Best Used On Wood Blocks And Cactuses, Otherwise They Are Practically Useless And You Should Find A Better Tool Or Use Your Hands!",
            "Shovels Are Best Used On Softer Blocks Like Dirt And Sand, So Don't Waste Your Shovel Trying To Break Hard Stuff And Find A Better Tool!",
            "To Optimize Your Game's Loading Speeds, Use '?' Button To Set The Particle Count And Reduce The Lag!",
            "Do You Have Any World Movers Placed? Use The ':' Button To Teleport To Any Of Them, But Make Sure They Have Codes And Are All Loaded With Fuel!",
			"Go Play Terraria. Go Play Minecraft. Just Don't Try To Convince Me Any Of These Games Are The Same...",
			"Use A Void Chest To Look Into The Void... That's What Happens When An Item Has No Where To Go. Deletion!",
			"Brick Blocks Look Nice.",
			"The world is divided into extreme-hardness layers. The Compressed Stone Layer (around depth 1,000) features blocks with a hardness of 10,000, while the Core Molten Stone layer reaches 250,000 hardness.",
			"Prioritize mining Compacted Stone (hardness 1,000) once you can break it easily, as this layer is the primary source of valuable gem veins like Ruby, Sapphire, Diamond, and Emerald.",
			"Build paths from Asphalt Blocks to increase your walking speed by 50% (1.5x) when on the ground. Use them for quick travel around your base or mining routes.",
			"Do not stand on Magma Stone Blocks. They apply a rapid 50 health damage per second to the player, making them extremely dangerous even in short bursts.",
			"If you get caught in a Cobweb block, your movement speed, jump strength, and gravity are all reduced by 80% or more, effectively halting all movement. Use a tool to quickly cut yourself free.",
			"This Game And Mechanics Were Made By BPR! Also, THIS GAME IS NOT JUST '2D MINECRAFT,' So Don't Call It That!"
        ];
        let currentTipIndex = 0;
        let tipIntervalId = null; 
		console.log('This is the monitor and cheat console! Try using this command: addToInventory("sky", 120)');
		const playerImg = new Image();
		playerImg.src = 'Player.png'; 
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let inventorySize = 40 
		const hotbarSize = 10;
        let totalInventorySlots = hotbarSize + (inventorySize); 
        let chestInventorySize = 27; 
        let maxStackSize = 120; 
		let handMiningPower = 0.1 
		const SUPER_HEAVEN_Y_OFFSET = -100000; 
		let portals = []; 
		let gameTime = 0; 
		const DAY_CYCLE_DURATION = 600000; 
		let plantSpoilageAccumulator = 0;
		const PLANT_SPOILAGE_INTERVAL = 1000; 
        const hotbarDiv = document.getElementById('hotbar');
        const loadingScreen = document.getElementById('loadingScreen');
        const coordsDisplay = document.getElementById('coordsDisplay');
        const healthBarDiv = document.getElementById('healthBar');
		const moonColumns = new Set(); 
        const moonRegions = []; 
        const moonProbability = 0.03; 
        const gameMenuOverlay = document.getElementById('gameMenuOverlay');
        const gameMenu = document.getElementById('gameMenu');
        const seedInput = document.getElementById('seedInput');
        const newGameButton = document.getElementById('newGameButton');
        const resumeButton = document.getElementById('resumeButton');
        const maintainDurabilityCheckbox = document.getElementById('maintainDurabilityCheckbox');
        const inventoryCraftingOverlay = document.getElementById('inventoryCraftingOverlay');
        const playerInventoryGrid = document.getElementById('playerInventoryGrid');
        const inventoryHotbarGrid = document.getElementById('inventoryHotbarGrid');
        const craftingGridDiv = document.getElementById('craftingGrid'); 
        const craftingOutputSlot = document.getElementById('craftingOutput');
        const craftButton = document.getElementById('craftButton');
        const recipeListDiv = document.getElementById('recipeList'); 
        const deleteSlot = document.getElementById('deleteSlot');
        const ovenOverlay = document.getElementById('ovenOverlay');
        const ovenGrid = document.getElementById('ovenGrid');
        const ovenFuelSlot = document.getElementById('ovenFuelSlot');
        const ovenOutputSlot = document.getElementById('ovenOutputSlot');
        const cookButton = document.getElementById('cookButton');
        const ovenPlayerInventoryGrid = document.getElementById('ovenPlayerInventoryGrid');
        const ovenRecipeList = document.getElementById('ovenRecipeList');
        let currentlyOpenFurnace = null; 
		const worldMoverConfigOverlay = document.getElementById('worldMoverConfigOverlay');
        const worldMoverCodeInput = document.getElementById('worldMoverCodeInput');
        const worldMoverFuelSlot = document.getElementById('worldMoverFuelSlot');
        const saveWorldMoverButton = document.getElementById('saveWorldMoverButton');
        let currentlyOpenWorldMover = null; 
        const worldMoverTeleportOverlay = document.getElementById('worldMoverTeleportOverlay');
        const teleportCodeInput = document.getElementById('teleportCodeInput');
        let isTeleportMenuOpen = false;
		let voidStorage = []; 
		const voidChestOverlay = document.getElementById('voidChestOverlay');
		const voidChestGrid = document.getElementById('voidChestGrid');
		const voidChestPlayerInventoryGrid = document.getElementById('voidChestPlayerInventoryGrid');
		let isVoidChestOpen = false;
		let currentVoidTrade = null; 
		let voidCharacterBob = 0; 
		let voidCharacterBobDirection = 1;
		let showDebugStats = false;
		const debugStatsDiv = document.getElementById('debugStats');
		let frameCount = 0;
		let lastFpsUpdate = 0;
		let currentFps = 0;
        let isCreativeMode = 0;
        const CREATIVE_FLIGHT_SPEED = 5; 
		const traderCharacterContainer = document.getElementById('traderCharacterContainer');
        const chestOverlay = document.getElementById('chestOverlay');
        const chestGrid = document.getElementById('chestGrid');
        const chestPlayerInventoryGrid = document.getElementById('chestPlayerInventoryGrid');
        const chestTitle = document.getElementById('chestTitle');
        const chestLabelInput = document.getElementById('chestLabelInput');
        let currentlyOpenChest = null; 
		const particles = [];
		const activePlants = new Set();
		const activeSpoilage = new Set();
        const particleGravity = 0.3;
		let worldLimitEnabled = false; 
		let worldMinX = -5000;
		let worldMaxX = 5000;
		let worldMinY = -1000; 
		let worldMaxY = 1500;
		seedInput.onkeydown = (e) => e.stopPropagation();
		chestLabelInput.onkeydown = (e) => e.stopPropagation();
		worldMoverCodeInput.onkeydown = (e) => e.stopPropagation();
		const heldItemState = {
            angle: 0,          
            offsetX: 0,        
            offsetY: 0,        
            bobTimer: 0,       
            swingTimer: 0,     
            isSwinging: false, 
            lastSwingTime: 0   
        };
        const customMessageBoxOverlay = document.getElementById('customMessageBoxOverlay');
        const messageBoxText = document.getElementById('messageBoxText');
        const messageBoxButtons = document.getElementById('messageBoxButtons');
        let heldItem = null; 
		const devConsoleOverlay = document.getElementById('devConsoleOverlay');
		const consoleOutput = document.getElementById('consoleOutput');
		const consoleInput = document.getElementById('consoleInput');
		let isConsoleOpen = false;
		let commandHistory = [];
		let historyIndex = -1;
		const consoleAutocompleteSuggestions = [
			'addToInventory("",1)', 'player', 'tp(0,0)', 'killMyself()', 'handMiningPower'
		];
		function syncHotbarIndices() {
			for (let h = 0; h < hotbarSize; h++) {
				hotbarIndices[h] = (inventorySlots[h] ? h : null);
			}
			updateHotbar();
		}
		function logToConsole(message, type = 'log-output') {
			const logEntry = document.createElement('div');
			logEntry.textContent = message;
			logEntry.className = type;
			consoleOutput.appendChild(logEntry);
			consoleOutput.scrollTop = consoleOutput.scrollHeight;
		}
		function toggleDevConsole() {
			isConsoleOpen = !isConsoleOpen;
			if (isConsoleOpen) {
				devConsoleOverlay.style.display = 'flex';
				isGamePaused = true; 
				consoleInput.focus(); 
			} else {
				devConsoleOverlay.style.display = 'none'; 
				if (gameMenuOverlay.style.display !== 'flex' && inventoryCraftingOverlay.style.display !== 'flex' && chestOverlay.style.display !== 'flex') {
					isGamePaused = false;
					lastTime = performance.now(); 
				}
			}
		}
		consoleInput.addEventListener('keydown', (e) => {
			e.stopPropagation(); 
			if (e.key === '#') {
                e.preventDefault();
                isCreativeMode = 1;
                if (isCreativeMode === 1) {
                    showMessageBox("Creative Mode ON: No clip, no gravity. Use W/S or Up/Down arrows to fly.", 'info');
                    player.dy = 0;
                    player.onGround = true; 
                } else {
                    showMessageBox("Creative Mode OFF: Gravity and collisions restored.", 'info');
                }
            } else if (e.key === 'Enter' && !e.shiftKey) { 
				e.preventDefault(); 
				const command = consoleInput.value.trim();
				if (command) {
					logToConsole(`> ${command}`, 'log-input');
					if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== command) {
						commandHistory.push(command);
					}
					historyIndex = commandHistory.length; 
					try {
						const result = eval.call(window, command);
						logToConsole(result !== undefined ? JSON.stringify(result, null, 2) : 'undefined', 'log-output');
					} catch (error) {
						logToConsole(error, 'log-error');
					}
					consoleInput.value = '';
					setTimeout(() => consoleInput.style.height = 'auto', 0);
					consoleOutput.scrollTop = consoleOutput.scrollHeight;
				}
			} else if (e.key === 'ArrowUp') {
				e.preventDefault();
				if (historyIndex > 0) {
					historyIndex--;
					consoleInput.value = commandHistory[historyIndex];
					setTimeout(() => consoleInput.selectionStart = consoleInput.selectionEnd = consoleInput.value.length, 0);
				}
			} else if (e.key === 'ArrowDown') {
				e.preventDefault();
				if (historyIndex < commandHistory.length - 1) {
					historyIndex++;
					consoleInput.value = commandHistory[historyIndex];
					setTimeout(() => consoleInput.selectionStart = consoleInput.selectionEnd = consoleInput.value.length, 0);
				} else {
					historyIndex = commandHistory.length;
					consoleInput.value = '';
				}
			} else if (e.key === 'Tab') {
				e.preventDefault();
				const currentInput = consoleInput.value;
				if (currentInput.trim() === '') return;
				const matches = consoleAutocompleteSuggestions.filter(suggestion =>
					suggestion.toLowerCase().startsWith(currentInput.toLowerCase())
				);
				if (matches.length === 1) {
					consoleInput.value = matches[0];
				} else if (matches.length > 1) {
					logToConsole(`Suggestions: ${matches.join('  ')}`, 'log-output');
				}
			}
		});
		consoleInput.addEventListener('input', () => {
			consoleInput.style.height = 'auto'; 
			consoleInput.style.height = (consoleInput.scrollHeight) + 'px'; 
		});
		saveWorldMoverButton.addEventListener('click', saveWorldMoverConfig);
        teleportCodeInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                executeTeleport();
            }
        });
		document.getElementById('voidAcceptButton').addEventListener('click', () => {
			if (!currentVoidTrade || !isVoidChestOpen) return;
			const totalCost = currentVoidTrade.costPerItem * currentVoidTrade.count;
			let coinsToRemove = totalCost;
			for (let i = inventorySlots.length - 1; i >= 0; i--) {
				const item = inventorySlots[i];
				if (item && item.type === currentVoidTrade.coinType) {
					const amountToRemove = Math.min(coinsToRemove, item.count);
					item.count -= amountToRemove;
					coinsToRemove -= amountToRemove;
					if (item.count <= 0) {
						inventorySlots[i] = null;
					}
					if (coinsToRemove <= 0) break;
				}
			}
			let itemsToFind = currentVoidTrade.count;
			for (let i = voidStorage.length - 1; i >= 0; i--) {
				const item = voidStorage[i];
				if (item && item.type === currentVoidTrade.itemType) {
					const amountToRemove = Math.min(itemsToFind, item.count);
					item.count -= amountToRemove;
					itemsToFind -= amountToRemove;
					if (item.count <= 0) {
						voidStorage.splice(i, 1);
					}
					if (itemsToFind <= 0) break;
				}
			}
			addToInventory(currentVoidTrade.itemType, currentVoidTrade.count, currentVoidTrade.durability);
			currentVoidTrade = null;
			updateVoidChestMenu();
			syncHotbarIndices(); 
		});
		document.getElementById('voidDeclineButton').addEventListener('click', () => {
			if (isVoidChestOpen) {
				toggleVoidChestMenu(); 
			}
		});
        window.addEventListener('keydown', (e) => {
            if (e.key === ':') { 
                e.preventDefault();
                if (canOpenTeleportMenu()) {
                    toggleTeleportMenu();
                } else {
                    showMessageBox("You haven't configured any World Movers yet.", 'alert');
                }
            }
        });
        let heldItemSource = { type: null, index: -1 }; 
        let tileSize = 40;
        const DEFAULT_PARTICLE_COUNT = 15; 
        function loadSavedParticleCount() {
          const saved = localStorage.getItem('gameParticles');
          if (saved === null) return DEFAULT_PARTICLE_COUNT;
          const n = parseInt(saved, 10);
          return Number.isFinite(n) && n >= 0 ? n : DEFAULT_PARTICLE_COUNT;
        }
        let particleCount = loadSavedParticleCount();
        const playerHeightBlocks = 3;
        const playerWidthBlocks = 1;
        playerHeight = playerHeightBlocks * tileSize; 
        playerWidth = playerWidthBlocks * tileSize; 
        let generationBuffer = 60; 
        const baseSurfaceLevel = 0;
        let minSurfaceVariation = 0;
        let maxSurfaceVariation = 10; 
        const surfaceLevelRange = 0;
        const coalVeinProbability = 0.025;
		const stumpStoneVeinProbability = 0.05;
		const limestoneVeinProbability = 0.25;
		const surfaceIronVeinProbability = 0.002;
		const deepCoalVeinProbability = 0.003;
		const amethystVeinProbability = 0.004;
		const zincVeinProbability = 0.003;
        const copperVeinProbability = 0.0025;
		const tinVeinProbability = 0.0015;
        const ironVeinProbability = 0.001;
		const tungstenVeinProbability = 0.0005;
		const rareMineralProbability = 0.0008
        const goldVeinProbability = 0.0001; 
        const topazVeinProbability = rareMineralProbability / 10;
		const diamondVeinProbability = rareMineralProbability / 12;
		const jadeVeinProbability = rareMineralProbability / 12;
		const opalVeinProbability = rareMineralProbability / 13;
		const sapphireVeinProbability = rareMineralProbability / 13;
		const emeraldVeinProbability = rareMineralProbability / 14;
		const rubyVeinProbability = rareMineralProbability / 16; 
		const hellsteelVeinProbability = 0.005;
		const mighterrumVeinProbability = 0.0007;
        const obsidianVeinProbability = 0.008;
        const gravelVeinProbability = 0.03;
		const graniteVeinProbability = 0.004;
        const slateVeinProbability = 0.003;
        const schistVeinProbability = 0.002;
		const saltVeinProbability = 0.0005;
		const rockVeinProbability = 0.0003;
        const antLarvaVeinProbability = 0.015;
        const boneSpineProbability = 0.001;
        let caveProbability = 0.0004; 
        let mineshaftProbability = 0.00005; 
        let dungeonProbability = 0.00003; 
        let skyIslandProbability = 0.0075; 
        let watchtowerProbability = 0.0005; 
		let chasmProbability = 0.0007;
		let powertowerProbability = 0.00015; 
		let plantationProbability = 0.007; 
		let mineChamberProbability = 0.002; 
		let jungleTempleProbability = 0.005; 
        let lavaCaveProbability = caveProbability / 2; 
        let bunkerProbability = 0.00005; 
		const cowProbability = 0.02; 
        const grassProbability = 0.4;
        const tallGrassProbability = 0.1;
        const cactusProbability = 0.1;
        const anthillMoundProbability = 0.5;
        const worldBiomes = {};
        let lastBiomeEndCol = -1; 
        let firstBiomeStartCol = 0;
        const underworldBiomes = {};
        let lastUnderworldBiomeEndCol = -1;
        let firstUnderworldBiomeStartCol = 0;
		const heavenBiomes = {};
        let lastHeavenBiomeEndCol = -1;
        let firstHeavenBiomeStartCol = 0;
        const columnSurfaceHeights = {};
        const heavenColumnSurfaceHeights = {}; 
		const superHeavenColumnSurfaceHeights = {}; 
        worldBlocks = {}; 
        const caveBlocks = new Set(); 
        const skyIslandColumns = new Set(); 
		const mineChamberColumns = new Set(); 
		const voidRealmColumns = new Set();
        const watchtowerColumns = new Set(); 
        const traderProbability = 0.04; 
		let traderColumns = new Set(); 
		const chasmColumns = new Set();
        const bunkerColumns = new Set();
		const plantationColumns = new Set(); 
		const redRockColumns = new Set(); 
		const graniteMountainColumns = new Set();
		const icyHillColumns = new Set();
		const jungleTempleColumns = new Set();
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }
        function stringToHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0; 
            }
            return Math.abs(hash); 
        }
        let currentSeed = Date.now(); 
        let random = mulberry32(currentSeed); 
        function setSeed(seed) {
            currentSeed = seed;
            random = mulberry32(seed);
        }
        let blockTypes = {
            'sky': { imgSrc: null, solid: false, miningHardness: 0, drops: [], color: '#87ceeb' },
			'': { imgSrc: null, solid: false, miningHardness: 0, drops: [], color: '#87ceeb' }, 
            'cobweb': { imgSrc: 'Cobweb.png', solid: false, miningHardness: 50, drops: [], color: '#EEEEEE' },
            'bed': { imgSrc: 'Bed.png', solid: true, miningHardness: 100, drops: [{item: 'bed', chance: 1, min: 1, max: 1}], color: '#FF0000' },
			'trader': { imgSrc: 'Trader.png', solid: true, miningHardness: 100, drops: null, color: '#FF0000' },
            'chest': { imgSrc: 'Chest.png', solid: true, miningHardness: 150, drops: [{item: 'chest', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'magical_chest': { imgSrc: 'Magical Chest.png', solid: true, miningHardness: 150, drops: [{item: 'magical_chest', chance: 1, min: 1, max: 1}], color: '#8B4513' },
            'void_chest': { imgSrc: 'Void Chest.png', solid: true, miningHardness: 150, drops: [{item: 'chest', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'refrigerator': { imgSrc: 'Refrigerator.png', solid: true, miningHardness: 150, drops: [{item: 'refrigerator', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'oven': { imgSrc: 'Oven.png', solid: true, miningHardness: 750, drops: [{item: 'oven', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'magma_furnace': { imgSrc: 'Magma Furnace.png', solid: true, miningHardness: 750, drops: [{item: 'magma_furnace', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'item_frame': { imgSrc: 'Item Frame.png', solid: true, miningHardness: 50, drops: [{item: 'item_frame', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'world_mover': { imgSrc: 'World Mover.png', solid: true, miningHardness: 250, drops: [{item: 'world_mover', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'napalm_bomb': { imgSrc: 'Napalm Bomb.png', solid: true, miningHardness: 80, drops: [], color: '#8B4513', bombDamage: 3, bombRadius: 9, playerDamageMin: 10, playerDamageMax: 90 },
			'dynamite_bomb': { imgSrc: 'Dynamite Bomb.png', solid: true, miningHardness: 80, drops: [], color: '#8B4513', bombDamage: 15, bombRadius: 9, playerDamageMin: 10, playerDamageMax: 220 },
			'octogen_bomb': { imgSrc: 'Octogen Bomb.png', solid: true, miningHardness: 80, drops: [], color: '#8B4513', bombDamage: 45, bombRadius: 9, playerDamageMin: 10, playerDamageMax: 180 },
			'weak_nuclear_bomb': { imgSrc: 'Weak Nuclear Bomb.png', solid: true, miningHardness: 80, drops: [], color: '#8B4513', bombDamage: 100, bombRadius: 15, playerDamageMin: 10, playerDamageMax: 500 },
			'subnuclear_bomb': { imgSrc: 'Subnuclear Bomb.png', solid: true, miningHardness: 80, drops: [], color: '#8B4513', bombDamage: 300, bombRadius: 25, playerDamageMin: 10, playerDamageMax: 1000 },
            'nuclear_bomb': { imgSrc: 'Nuclear Bomb.png', solid: true, miningHardness: 80, drops: [], color: '#8B4513', bombDamage: 500, bombRadius: 60, playerDamageMin: 10, playerDamageMax: 10000 },
			'traps': { imgSrc: 'Trap Stone Block.png', solid: true, miningHardness: 500, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#8B4513', bombDamage: 15, bombRadius: 9, playerDamageMin: 10, playerDamageMax: 180 },
			'trap_cs': { imgSrc: 'Trap Compacted Stone Block.png', solid: true, miningHardness: 1000, drops: [{item: 'cs', chance: 1, min: 1, max: 1}], color: '#8B4513', bombDamage: 45, bombRadius: 9, playerDamageMin: 10, playerDamageMax: 220 },
			'trap_cps': { imgSrc: 'Trap Compressed Stone Block.png', solid: true, miningHardness: 10000, drops: [{item: 'cps', chance: 1, min: 1, max: 1}], color: '#8B4513', bombDamage: 100, bombRadius: 15, playerDamageMin: 10, playerDamageMax: 500 },
			'lever_on': { imgSrc: 'Lever On.png', solid: true, miningHardness: 80, drops: [], color: '#8B4513' },
			'lever_off': { imgSrc: 'Lever Off.png', solid: true, miningHardness: 80, drops: [], color: '#8B4513' },
			'chest_lever_on': { imgSrc: 'Chest Lever On.png', solid: true, miningHardness: 3000, drops: [], color: '#8B4513' },
			'chest_lever_off': { imgSrc: 'Chest Lever Off.png', solid: true, miningHardness: 3000, drops: [], color: '#8B4513' },
			'reactant': { imgSrc: 'Reactant.png', solid: true, miningHardness: 80, drops: [], color: '#8B4513' },
			'trailer': { imgSrc: 'Trailer.png', solid: true, miningHardness: 5, drops: [], color: '#8B4513' },
			'lit_trailer': { imgSrc: 'Lit Trailer.png', solid: true, miningHardness: 5, drops: [], color: '#8B4513' },
			'stone_trailer': { imgSrc: 'Trailer Stone Block.png', solid: true, miningHardness: 500, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'stone_stairs_right': { imgSrc: 'Stone Stairs Right.png', solid: true, miningHardness: 500, drops: [{item: 'stone_stairs_right', chance: 1, min: 1, max: 1}], color: '#C2B280' },
			'stone_stairs_left': { imgSrc: 'Stone Stairs Left.png', solid: true, miningHardness: 500, drops: [{item: 'stone_stairs_left', chance: 1, min: 1, max: 1}], color: '#C2B280' },
			'dead_body_chest': { imgSrc: 'Dead Body Chest.png', solid: true, miningHardness: 150, drops: [{item: 'dead_bodyb', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'dead_bodyb': { imgSrc: 'Dead Body Chest.png', solid: true, miningHardness: 150, drops: [{item: 'dead_bodyb', chance: 1, min: 1, max: 1}], color: '#8B4513' },
            'seed_dirtb': { imgSrc: 'Seed Dirt Block.png', solid: true, miningHardness: 50, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'hop_seeds', chance: 1, min: 1, max: 3}], color: '#A0522D', shovelBlock: true },
			'gd': { imgSrc: 'Grass Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'd', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'overgrown_grassd': { imgSrc: 'Overgrown Grass Dirt Block.png', solid: true, miningHardness: 80, drops: [{item: 'd', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'dark_grassd': { imgSrc: 'Dark Grass Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'd', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'overgrown_dark_grassd': { imgSrc: 'Overgrown Dark Grass Dirt Block.png', solid: true, miningHardness: 70, drops: [{item: 'd', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'dark_grasss': { imgSrc: 'Dark Grass Soil Block.png', solid: true, miningHardness: 80, drops: [{item: 'd', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'overgrown_dark_grasss': { imgSrc: 'Overgrown Dark Grass Soil Block.png', solid: true, miningHardness: 90, drops: [{item: 'd', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
            'd': { imgSrc: 'Dirt Block.png', solid: true, miningHardness: 50, drops: [{item: 'd', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
			'gs': { imgSrc: 'Grass Soil Block.png', solid: true, miningHardness: 80, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#90EE90', shovelBlock: true },
			'overgrown_grasss': { imgSrc: 'Overgrown Grass Soil Block.png', solid: true, miningHardness: 90, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#90EE90', shovelBlock: true },
            'so': { imgSrc: 'Soil Block.png', solid: true, miningHardness: 70, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
			'plantations': { imgSrc: 'Plantation Soil Block.png', solid: true, miningHardness: 70, drops: [{item: 'plantations', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'f': { imgSrc: 'Fertilizer Block.png', solid: true, miningHardness: 70, drops: [{item: 'f', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
            's': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 500, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#808080' },
			'outer_mantle_moltens': { imgSrc: 'Outer Mantle Molten Stone Block.png', solid: true, miningHardness: 50000, drops: [{item: 'ironn', chance: 0.15, min: 1, max: 3}, {item: 'nickeln', chance: 0.1, min: 1, max: 3}], color: '#808080', requiredMiningPower: 2.5 },
			'inner_mantle_moltens': { imgSrc: 'Inner Mantle Molten Stone Block.png', solid: true, miningHardness: 150000, drops: [{item: 'ironn', chance: 0.3, min: 1, max: 3}, {item: 'nickeln', chance: 0.2, min: 1, max: 3}], color: '#808080', requiredMiningPower: 5 },
			'core_moltens': { imgSrc: 'Core Molten Stone Block.png', solid: true, miningHardness: 250000, drops: [{item: 'ironn', chance: 0.6, min: 1, max: 3}, {item: 'nickeln', chance: 0.4, min: 1, max: 3}], color: '#808080', requiredMiningPower: 10 },
			'stumps': { imgSrc: 'Stump Stone Block.png', solid: true, miningHardness: 500, drops: [{item: 'stumps', chance: 1, min: 1, max: 1}], color: '#808080' },
			'taigad': { imgSrc: 'Taiga Dirt Block.png', solid: true, miningHardness: 50, drops: [{item: 'taigad', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
			'taiga_grass_dirt_block_1': { imgSrc: 'Taiga Grass Dirt Block 1.png', solid: true, miningHardness: 60, drops: [{item: 'taigad', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'taiga_grass_dirt_block_2': { imgSrc: 'Taiga Grass Dirt Block 2.png', solid: true, miningHardness: 60, drops: [{item: 'taigad', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'watchtower_stoneb': { imgSrc: 'Watchtower Stone Block.png', solid: true, miningHardness: 800, drops: [{item: 'watchtower_stoneb', chance: 1, min: 1, max: 1}], color: '#686868' },
			'powertower_stoneb': { imgSrc: 'Powertower Stone Block.png', solid: true, miningHardness: 800, drops: [{item: 'powertower_stoneb', chance: 1, min: 1, max: 1}], color: '#686868' },
            'rockb': { imgSrc: 'Rock Block.png', solid: true, miningHardness: 500, drops: [{item: 'rockb', chance: 1, min: 1, max: 1}], color: '#A9A9A9' },
			'salt_rockb': { imgSrc: 'Salt Rock Block.png', solid: true, miningHardness: 500, drops: [{item: 'salt_rockb', chance: 0.8, min: 1, max: 1}, {item: 'rock_salt', chance: 0.08, min: 1, max: 2}], color: '#A9A9A9' },
			'limestone': { imgSrc: 'Limestone Block.png', solid: true, miningHardness: 300, drops: [{item: 'limestone', chance: 1, min: 1, max: 1}], color: '#A9A9A9' },
            'sand': { imgSrc: 'Sand Block.png', solid: true, miningHardness: 40, drops: [{item: 'sand', chance: 1, min: 1, max: 1}], color: '#F4A460', shovelBlock: true },
			'red_sandb': { imgSrc: 'Red Sand Block.png', solid: true, miningHardness: 40, drops: [{item: 'red_sandb', chance: 1, min: 1, max: 1}], color: '#F4A460', shovelBlock: true },
            'sandstone': { imgSrc: 'Sandstone Block.png', solid: true, miningHardness: 450, drops: [{item: 'sandstone', chance: 1, min: 1, max: 1}], color: '#E3B48E' },
			'red_sandstoneb': { imgSrc: 'Red Sandstone Block.png', solid: true, miningHardness: 450, drops: [{item: 'red_sandstoneb', chance: 1, min: 1, max: 1}], color: '#E3B48E' },
            'compactings': { imgSrc: 'Compacting Stone Block.png', solid: true, miningHardness: 750, drops: [{item: 'cs', chance: 1, min: 1, max: 1}], color: '#696969' },
            'glassb': { imgSrc: 'Glass Block.png', solid: true, miningHardness: 40, drops: [{item: 'glassb', chance: 1, min: 1, max: 1}], color: '#F4A460' },
			'cs': { imgSrc: 'Compacted Stone Block.png', solid: true, miningHardness: 1000, drops: [{item: 'cs', chance: 1, min: 1, max: 1}], color: '#708090', requiredMiningPower: 0.2 },
			'cps': { imgSrc: 'Compressed Stone Block.png', solid: true, miningHardness: 10000, drops: [{item: 'cps', chance: 1, min: 1, max: 1}], color: '#708090' },
			'voids': { imgSrc: 'Void Stone Block.png', solid: true, miningHardness: 1000, drops: [{item: 'voids', chance: 1, min: 1, max: 1}], color: '#708090', requiredMiningPower: 0.3 },
			'void_dustb': { imgSrc: 'Void Dust Block.png', solid: true, miningHardness: 100, drops: [{item: 'void_dust', chance: 1, min: 1, max: 16}], color: '#708090' },
			'void_crystal': { imgSrc: 'Void Crystal Block.png', solid: true, miningHardness: 1000, drops: [{item: 'void_crystal', chance: 1, min: 1, max: 1}], color: '#708090', requiredMiningPower: 0.2 },
			'red_void_crystal': { imgSrc: 'Red Void Crystal Block.png', solid: true, miningHardness: 1000, drops: [{item: 'red_void_crystal', chance: 1, min: 1, max: 1}], color: '#708090', requiredMiningPower: 0.2 },
			'bedrocks': { imgSrc: 'Bedrock Stone Block.png', solid: true, miningHardness: 50000, drops: [{item: 'bedrocks', chance: 1, min: 1, max: 1}], color: '#708090', requiredMiningPower: 2.5 },
			'hellstone': { imgSrc: 'Hellstone Block.png', solid: true, miningHardness: 500, drops: [{item: 'hellstone', chance: 1, min: 1, max: 1}], color: '#808080' },
			'hellrock': { imgSrc: 'Hellrock Block.png', solid: true, miningHardness: 500, drops: [{item: 'hellrock', chance: 1, min: 1, max: 1}], color: '#808080' },
			'magma_stoneb': { imgSrc: 'Magma Stone Block.png', solid: true, miningHardness: 500, drops: [{item: 'magma_stoneb', chance: 1, min: 1, max: 1}], color: '#808080' },
			'chasm_magma_stoneb': { imgSrc: 'Chasm Magma Stone Block.png', solid: true, miningHardness: 500, drops: [{item: 'chasm_magma_stoneb', chance: 1, min: 1, max: 1}], color: '#808080' },
			'meteorite': { imgSrc: 'Meteorite.png', solid: true, miningHardness: 500, drops: [{item: 'goldn', chance: 0.3, min: 1, max: 3}, {item: 'palladiumn', chance: 0.2, min: 1, max: 3}, {item: 'ironn', chance: 0.6, min: 1, max: 3}, {item: 'nickeln', chance: 0.6, min: 1, max: 3}], color: '#808080' },
			'hellsteel_hellstone': { imgSrc: 'Hellsteel Hellstone Block.png', solid: true, miningHardness: 750, drops: [{item: 'hellsteeln', chance: 1, min: 1, max: 3}], color: '#808080' },
			'mighterrum_hellstone': { imgSrc: 'Mighterrum Hellstone Block.png', solid: true, miningHardness: 750, drops: [{item: 'mighterrumn', chance: 1, min: 1, max: 1}], color: '#808080' },
			'coalb': { imgSrc: 'Coal Block.png', solid: true, miningHardness: 500, drops: [{item: 'coal', chance: 1, min: 1, max: 9}], color: '#A0522D' },
			'stone_brickb': { imgSrc: 'Stone Brick Block.png', solid: true, miningHardness: 500, drops: [{item: 'stone_brickb', chance: 1, min: 1, max: 1}], color: '#A0522D' },
			'clay_brickb': { imgSrc: 'Clay Brick Block.png', solid: true, miningHardness: 400, drops: [{item: 'clay_brickb', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'steel_brickb': { imgSrc: 'Steel Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'steel_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'bronze_brickb': { imgSrc: 'Bronze Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'bronze_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'brass_brickb': { imgSrc: 'Brass Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'brass_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'gold_brickb': { imgSrc: 'Gold Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'gold_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'gold_power_brickb': { imgSrc: 'Gold Power Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'gold_power_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'iron_brickb': { imgSrc: 'Iron Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'iron_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'tungsten_brickb': { imgSrc: 'Tungsten Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'tungsten_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'tin_brickb': { imgSrc: 'Tin Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'tin_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'zinc_brickb': { imgSrc: 'Zinc Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'zinc_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'lead_brickb': { imgSrc: 'Lead Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'lead_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'nickel_brickb': { imgSrc: 'Nickel Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'nickel_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'copper_brickb': { imgSrc: 'Copper Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'copper_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'slightly_oxidizing_copper_brickb': { imgSrc: 'Slightly Oxidizing Copper Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'slightly_oxidizing_copper_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'oxidizing_copper_brickb': { imgSrc: 'Oxidizing Copper Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'oxidizing_copper_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'highly_oxidizing_copper_brickb': { imgSrc: 'Highly Oxidizing Copper Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'highly_oxidizing_copper_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'oxidized_copper_brickb': { imgSrc: 'Oxidized Copper Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'oxidized_copper_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'aluminum_brickb': { imgSrc: 'Aluminum Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'aluminum_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'palladium_brickb': { imgSrc: 'Palladium Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'palladium_brickb', chance: 1, min: 1, max: 1}], color: '#FCC201' },
            'heaven_brickb': { imgSrc: 'Heaven Brick Block.png', solid: true, miningHardness: 1200, drops: [{item: 'heaven_brickb', chance: 1, min: 1, max: 1}], color: '#F0EAD6' },
			'coals': { imgSrc: 'Coal Stone Block.png', solid: true, miningHardness: 750, drops: [{item: 'coal', chance: 1, min: 1, max: 1}], color: '#36454F' },
			'coal_cs': { imgSrc: 'Coal Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'coal', chance: 1, min: 1, max: 1}], color: '#36454F', requiredMiningPower: 0.2 },
            'coal_cps': { imgSrc: 'Coal Compressed Stone Block.png', solid: true, miningHardness: 15000, drops: [{item: 'coal', chance: 1, min: 1, max: 1}], color: '#708090', requiredMiningPower: 0.8 },
			'copper_cs': { imgSrc: 'Copper Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'coppern', chance: 1, min: 1, max: 1}], color: '#B87333', requiredMiningPower: 0.2 },
            'tin_cs': { imgSrc: 'Tin Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'tinn', chance: 1, min: 1, max: 1}], color: '#C0C0C0', requiredMiningPower: 0.2 },
			'zinc_cs': { imgSrc: 'Zinc Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'zincn', chance: 1, min: 1, max: 1}], color: '#C0C0C0', requiredMiningPower: 0.2 },
			'irons': { imgSrc: 'Iron Stone Block.png', solid: true, miningHardness: 750, drops: [{item: 'ironn', chance: 1, min: 1, max: 1}], color: '#A19D94' },
            'iron_cs': { imgSrc: 'Iron Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'ironn', chance: 1, min: 1, max: 1}], color: '#A19D94', requiredMiningPower: 0.2 },
			'iron_granite': { imgSrc: 'Iron Granite Block.png', solid: true, miningHardness: 1050, drops: [{item: 'ironn', chance: 1, min: 1, max: 1}], color: '#708090', requiredMiningPower: 0.8 },
			'iron_cps': { imgSrc: 'Iron Compressed Stone Block.png', solid: true, miningHardness: 15000, drops: [{item: 'ironn', chance: 1, min: 1, max: 1}], color: '#708090' },
			'tungsten_cs': { imgSrc: 'Tungsten Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'tungstenn', chance: 1, min: 1, max: 1}], color: '#A19D94', requiredMiningPower: 0.2 },
            'gold_cs': { imgSrc: 'Gold Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'goldn', chance: 1, min: 1, max: 1}], color: '#FFD700', requiredMiningPower: 0.2 },
            'ruby_cs': { imgSrc: 'Ruby Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'rubyn', chance: 1, min: 1, max: 1}], color: '#E0115F', requiredMiningPower: 0.2 },
            'diamond_cs': { imgSrc: 'Diamond Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'diamondn', chance: 1, min: 1, max: 1}], color: '#B9F2FF', requiredMiningPower: 0.2 },
			'topaz_cs': { imgSrc: 'Topaz Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'topazn', chance: 1, min: 1, max: 1}], color: '#FFC87C', requiredMiningPower: 0.2 },
            'sapphire_cs': { imgSrc: 'Sapphire Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'sapphiren', chance: 1, min: 1, max: 1}], color: '#0F52BA', requiredMiningPower: 0.2 },
            'emerald_cs': { imgSrc: 'Emerald Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'emeraldn', chance: 1, min: 1, max: 1}], color: '#50C878', requiredMiningPower: 0.2 },
            'amethyst_cs': { imgSrc: 'Amethyst Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'amethystn', chance: 1, min: 1, max: 1}], color: '#9966CC', requiredMiningPower: 0.2 },
            'opal_cs': { imgSrc: 'Opal Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'opaln', chance: 1, min: 1, max: 1}], color: '#E0E9E7', requiredMiningPower: 0.2 },
			'jade_cs': { imgSrc: 'Jade Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'jaden', chance: 1, min: 1, max: 1}], color: '#E0E9E7', requiredMiningPower: 0.2 },
            'aluminum_granite': { imgSrc: 'Aluminum Granite Block.png', solid: true, miningHardness: 1050, drops: [{item: 'aluminumn', chance: 1, min: 1, max: 1}], color: '#708090' },
			'aluminum_cps': { imgSrc: 'Aluminum Compressed Stone Block.png', solid: true, miningHardness: 15000, drops: [{item: 'aluminumn', chance: 1, min: 1, max: 1}], color: '#708090', requiredMiningPower: 0.8 },
			'palladium_cps': { imgSrc: 'Palladium Compressed Stone Block.png', solid: true, miningHardness: 15000, drops: [{item: 'palladiumn', chance: 1, min: 1, max: 1}], color: '#708090', requiredMiningPower: 0.8 },
			'any_plank': { imgSrc: 'Any Plank.png', solid: false, miningHardness: 0, drops: [], color: '#654321' },
			'any_gilded': { imgSrc: 'Any Gilded.png', solid: false, miningHardness: 0, drops: [], color: '#654321' },
			'roak': { imgSrc: 'Raw Oak Block.png', solid: true, miningHardness: 150, drops: [{item: 'roak', chance: 1, min: 1, max: 1}], color: '#654321' },
            'oak_bush': { imgSrc: 'Oak Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'oak_bush', chance: 0.05, min: 1, max: 1}], color: '#228B22' },
            'poak': { imgSrc: 'Planked Oak Block.png', solid: true, miningHardness: 150, drops: [{item: 'poak', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'rapple': { imgSrc: 'Raw Apple Block.png', solid: true, miningHardness: 150, drops: [{item: 'rapple', chance: 1, min: 1, max: 1}], color: '#654321' },
            'apple_bush': { imgSrc: 'Apple Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'apple_bush', chance: 0.05, min: 1, max: 1}], color: '#228B22' },
			'apple_bush_fruit': { imgSrc: 'Apple Bush Block Fruit.png', solid: true, miningHardness: 20, drops: [{item: 'apple_bush', chance: 0.05, min: 1, max: 1}, {item: 'apple', chance: 1, min: 1, max: 3}], color: '#228B22' },
            'papple': { imgSrc: 'Planked Apple Block.png', solid: true, miningHardness: 150, drops: [{item: 'papple', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
            'rbirch': { imgSrc: 'Raw Birch Block.png', solid: true, miningHardness: 150, drops: [{item: 'rbirch', chance: 1, min: 1, max: 1}], color: '#C0C0C0' },
            'birch_bush': { imgSrc: 'Birch Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'birch_bush', chance: 0.05, min: 1, max: 1}], color: '#6B8E23' },
            'pbirch': { imgSrc: 'Planked Birch Block.png', solid: true, miningHardness: 150, drops: [{item: 'pbirch', chance: 1, min: 1, max: 1}], color: '#F5DEB3' },
            'rspruce': { imgSrc: 'Raw Spruce Block.png', solid: true, miningHardness: 150, drops: [{item: 'rspruce', chance: 1, min: 1, max: 1}], color: '#4A3B2F' },
            'spruce_bush': { imgSrc: 'Spruce Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'spruce_bush', chance: 0.05, min: 1, max: 1}, {item: 'pine_needle_living', chance: 0.2, min: 1, max: 1}, {item: 'pinecone', chance: 0.1, min: 1, max: 1}], color: '#0A4A2A' },
			'pspruce': { imgSrc: 'Planked Spruce Block.png', solid: true, miningHardness: 150, drops: [{item: 'pspruce', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'rredwood': { imgSrc: 'Raw Redwood Block.png', solid: true, miningHardness: 150, drops: [{item: 'rredwood', chance: 1, min: 1, max: 1}], color: '#4A3B2F' },
            'redwood_bush': { imgSrc: 'Redwood Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'redwood_bush', chance: 0.05, min: 1, max: 1}, {item: 'pine_needle_living', chance: 0.2, min: 1, max: 1}, {item: 'pinecone', chance: 0.1, min: 1, max: 1}], color: '#0A4A2A' },
			'predwood': { imgSrc: 'Planked Redwood Block.png', solid: true, miningHardness: 150, drops: [{item: 'predwood', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'rrubber': { imgSrc: 'Raw Rubber Block.png', solid: true, miningHardness: 150, drops: [{item: 'rrubber', chance: 1, min: 1, max: 1}], color: '#C0C0C0' },
            'rubber_bush': { imgSrc: 'Rubber Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'rubber_bush', chance: 0.05, min: 1, max: 1}], color: '#6B8E23' },
            'prubber': { imgSrc: 'Planked Rubber Block.png', solid: true, miningHardness: 150, drops: [{item: 'prubber', chance: 1, min: 1, max: 1}], color: '#F5DEB3' },
			'rmahogany': { imgSrc: 'Raw Mahogany Block.png', solid: true, miningHardness: 150, drops: [{item: 'rmahogany', chance: 1, min: 1, max: 1}], color: '#C0C0C0' },
            'mahogany_bush': { imgSrc: 'Mahogany Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'mahogany_bush', chance: 0.05, min: 1, max: 1}], color: '#6B8E23' },
            'pmahogany': { imgSrc: 'Planked Mahogany Block.png', solid: true, miningHardness: 150, drops: [{item: 'pmahogany', chance: 1, min: 1, max: 1}], color: '#F5DEB3' },
			'rcinnamon': { imgSrc: 'Raw Cinnamon Block.png', solid: true, miningHardness: 150, drops: [{item: 'rcinnamon', chance: 1, min: 1, max: 1}], color: '#C0C0C0' },
            'cinnamon_bush': { imgSrc: 'Cinnamon Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'cinnamon_bush', chance: 0.05, min: 1, max: 1}], color: '#6B8E23' },
            'pcinnamon': { imgSrc: 'Planked Cinnamon Block.png', solid: true, miningHardness: 150, drops: [{item: 'pcinnamon', chance: 1, min: 1, max: 1}], color: '#F5DEB3' },
			'rbluegloww': { imgSrc: 'Raw Blueglow Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'rbluegloww', chance: 1, min: 1, max: 1}], color: '#C0C0C0' },
            'blueglow_bush': { imgSrc: 'Blueglow Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'blueglow_bush', chance: 0.05, min: 1, max: 1}], color: '#6B8E23' },
            'pbluegloww': { imgSrc: 'Planked Blueglow Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'pbluegloww', chance: 1, min: 1, max: 1}], color: '#F5DEB3' },
			'meatw': { imgSrc: 'Meat Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'meatw', chance: 0.1, min: 1, max: 1}, {item: 'beef', chance: 0.3, min: 1, max: 3}, {item: 'pork', chance: 0.3, min: 1, max: 3}, {item: 'human_flesh', chance: 0.2, min: 1, max: 3}], color: '#4A3B2F' },
			'spoiled_meatw': { imgSrc: 'Spoiled Meat Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'spoiled_meatw', chance: 0.1, min: 1, max: 1}, {item: 'spoiled_beef', chance: 0.3, min: 1, max: 3}, {item: 'spoiled_pork', chance: 0.3, min: 1, max: 3}, {item: 'human_flesh', chance: 0.2, min: 1, max: 3}], color: '#4A3B2F' },
			'rhellw': { imgSrc: 'Raw Hell Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'rhellw', chance: 1, min: 1, max: 1}], color: '#4A3B2F' },
            'hell_wood_bush': { imgSrc: 'Hell Wood Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'hell_wood_bush', chance: 0.05, min: 1, max: 1}], color: '#0A4A2A' },
			'phellw': { imgSrc: 'Planked Hell Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'phellw', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'leaf_plant': { imgSrc: 'Leaf Plant.png', solid: false, miningHardness: 15, drops: [], color: '#7CFC00' },
			'grass_sprouts': { imgSrc: 'Grass Sprouts.png', solid: false, miningHardness: 5, drops: [{item: 'grass_seeds', chance: 0.3, min: 1, max: 2}, {item: 'pumpkin_seeds', chance: 0.2, min: 1, max: 2}], color: '#7CFC00' },
            'grass': { imgSrc: 'Grass.png', solid: false, miningHardness: 10, drops: [{item: 'grass_seeds', chance: 0.4, min: 1, max: 3}, {item: 'wheat_seeds', chance: 0.2, min: 1, max: 2}, {item: 'barley_seeds', chance: 0.2, min: 1, max: 2}], color: '#7CFC00' },
			'tall_grass': { imgSrc: 'Tall Grass.png', solid: false, miningHardness: 20, drops: [{item: 'grass_seeds', chance: 0.5, min: 1, max: 5}, {item: 'wheat_seeds', chance: 0.3, min: 1, max: 3}, {item: 'cotton_seeds', chance: 0.1, min: 1, max: 2}], color: '#6B8E23' },
			'yellow_flower': { imgSrc: 'Yellow Flower.png', solid: false, miningHardness: 10, drops: [{item: 'yellow_flower', chance: 1, min: 1, max: 1}], color: '#7CFC00' },
			'red_flower': { imgSrc: 'Red Flower.png', solid: false, miningHardness: 10, drops: [{item: 'red_flower', chance: 1, min: 1, max: 1}], color: '#7CFC00' },
			'blue_flower': { imgSrc: 'Blue Flower.png', solid: false, miningHardness: 10, drops: [{item: 'blue_flower', chance: 1, min: 1, max: 1}], color: '#7CFC00' },
			'pinecone_pile': { imgSrc: 'Pinecone Pile.png', solid: false, miningHardness: 10, drops: [{item: 'pinecone', chance: 1, min: 1, max: 3}], color: '#7CFC00' },
			'pine_needle_pile': { imgSrc: 'Pine Needle Pile.png', solid: false, miningHardness: 10, drops: [{item: 'pine_needle_living', chance: 0.5, min: 1, max: 2}, {item: 'pine_needle_dying', chance: 0.5, min: 1, max: 2}, {item: 'pine_needle_dead', chance: 0.5, min: 1, max: 2}], color: '#7CFC00' },
            'mossy_root': { imgSrc: 'Mossy Root.png', solid: false, miningHardness: 10, drops: [{item: 'mossy_root', chance: 1, min: 1, max: 1}], color: '#7CFC00' },
			'leaf_pile': { imgSrc: 'Leaf Pile.png', solid: false, miningHardness: 10, drops: [], color: '#7CFC00' },
			'fern': { imgSrc: 'Fern.png', solid: false, miningHardness: 10, drops: [], color: '#7CFC00' },
			'fern_stalk': { imgSrc: 'Fern Stalk.png', solid: false, miningHardness: 10, drops: [], color: '#7CFC00' },
			'sugarcane': { imgSrc: 'Sugar Cane.png', solid: false, miningHardness: 10, drops: [{item: 'sugarcane', chance: 1, min: 1, max: 1}], color: '#7CFC00' },
			'snow': { imgSrc: 'Snow Pile.png', solid: false, miningHardness: 5, drops: [{item: 'snow_ball', chance: 1, min: 1, max: 1}], color: '#FFFAFA' },
            'large_snow_pile': { imgSrc: 'Large Snow Pile.png', solid: false, miningHardness: 10, drops: [{item: 'snow_ball', chance: 1, min: 2, max: 2}], color: '#F0FFFF' },
            'snowb': { imgSrc: 'Snow Block.png', solid: true, miningHardness: 25, drops: [{item: 'snowb', chance: 1, min: 1, max: 1}], color: '#F0FFFF' },
            'desert_brush': { imgSrc: 'Desert Brush.png', solid: false, miningHardness: 5, drops: [{item: 'tomato_seeds', chance: 0.2, min: 1, max: 2}], color: '#D2B48C' },
			'desert_grass': { imgSrc: 'Desert Grass.png', solid: false, miningHardness: 5, drops: [{item: 'coffee_seeds', chance: 0.2, min: 1, max: 2}], color: '#D2B48C' },
            'prickly_pear_cactus': { imgSrc: 'Prickly Pear Cactus.png', solid: false, miningHardness: 5, drops: [{item: 'prickly_pear_fruit', chance: 0.6, min: 1, max: 1}], color: '#93C572' },
            'cactusb': { imgSrc: 'Cactus Block.png', solid: true, miningHardness: 80, drops: [{item: 'cactusb', chance: 1, min: 1, max: 1}], color: '#556B2F', shovelBlock: true },
            'anthill_sandb': { imgSrc: 'Anthill Sand Block.png', solid: true, miningHardness: 45, drops: [{item: 'anthill_sandb', chance: 1, min: 1, max: 1}], color: '#C19A6B' },
            'colony_heart_sandb': { imgSrc: 'Colony Heart Sand Block.png', solid: true, miningHardness: 500, drops: [{item: 'colony_heart', chance: 1, min: 1, max: 1}], color: '#FF4444' },
            'anthill_sand_mound': { imgSrc: 'Anthill Sand Mound.png', solid: false, miningHardness: 10, drops: [], color: '#D2B48C' },
            'slate': { imgSrc: 'Slate Block.png', solid: true, miningHardness: 600, drops: [{item: 'slate', chance: 1, min: 1, max: 1}], color: '#708090' },
            'schist': { imgSrc: 'Schist Block.png', solid: true, miningHardness: 600, drops: [{item: 'schist', chance: 1, min: 1, max: 1}], color: '#848482' },
            'granite': { imgSrc: 'Granite Block.png', solid: true, miningHardness: 700, drops: [{item: 'granite', chance: 1, min: 1, max: 1}], color: '#F8C8DC' },
			'asphalt': { imgSrc: 'Asphalt Block.png', solid: true, miningHardness: 600, drops: [{item: 'asphalt_fragment', chance: 1, min: 1, max: 4}], color: '#F8C8DC' },
			'concrete': { imgSrc: 'Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'concrete', chance: 1, min: 1, max: 1}], color: '#F8C8DC' },
			'vulcanized_rubber': { imgSrc: 'Vulcanized Rubber Block.png', solid: true, miningHardness: 200, drops: [{item: 'vulcanized_rubber', chance: 1, min: 1, max: 1}], color: '#F8C8DC' },
            'vines': { imgSrc: 'Vine Stone Block.png', solid: true, miningHardness: 550, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#556B2F' },
            'packed_iceb': { imgSrc: 'Packed Ice Block.png', solid: true, miningHardness: 80, drops: [{item: 'packed_iceb', chance: 1, min: 1, max: 1}], color: '#ADD8E6' },
			'iceb': { imgSrc: 'Ice Block.png', solid: true, miningHardness: 50, drops: [{item: 'iceb', chance: 1, min: 1, max: 1}], color: '#ADD8E6' },
            'gravel': { imgSrc: 'Gravel Block.png', solid: true, miningHardness: 60, drops: [{item: 'gravel', chance: 1, min: 1, max: 1}], color: '#A9A9A9', shovelBlock: true },
            'mossd': { imgSrc: 'Moss Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'd', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'dark_mossd': { imgSrc: 'Dark Moss Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'd', chance: 1, min: 1, max: 1}], color: '#4A442A', shovelBlock: true },
			'mosss': { imgSrc: 'Moss Soil Block.png', solid: true, miningHardness: 60, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'dark_mosss': { imgSrc: 'Dark Moss Soil Block.png', solid: true, miningHardness: 60, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#4A442A', shovelBlock: true },
            'moss_stone_brickb': { imgSrc: 'Moss Stone Brick Block.png', solid: true, miningHardness: 510, drops: [{item: 'stone_brickb', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'dark_moss_stone_brickb': { imgSrc: 'Dark Moss Stone Brick Block.png', solid: true, miningHardness: 510, drops: [{item: 'stone_brickb', chance: 1, min: 1, max: 1}], color: '#4A442A', shovelBlock: true },
			'weedd': { imgSrc: 'Weed Dirt Block.png', solid: true, miningHardness: 65, drops: [{item: 'd', chance: 1, min: 1, max: 1}], color: '#5A5030', shovelBlock: true },
            'mud': { imgSrc: 'Mud Block.png', solid: true, miningHardness: 100, drops: [{item: 'mud', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'thick_mud': { imgSrc: 'Thick Mud Block.png', solid: true, miningHardness: 150, drops: [{item: 'thick_mud', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'surface_mud': { imgSrc: 'Surface Mud Block.png', solid: true, miningHardness: 110, drops: [{item: 'mud', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'grass_mud': { imgSrc: 'Grass Mud Block.png', solid: true, miningHardness: 110, drops: [{item: 'mud', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'overgrown_grass_mud': { imgSrc: 'Overgrown Grass Mud Block.png', solid: true, miningHardness: 120, drops: [{item: 'mud', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
            'pestd': { imgSrc: 'Pest Dirt Block.png', solid: true, miningHardness: 80, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'pest', chance: 1, min: 1, max: 3}], color: '#6B4226', shovelBlock: true },
            'rdarkwood': { imgSrc: 'Raw Darkwood Block.png', solid: true, miningHardness: 160, drops: [{item: 'rdarkwood', chance: 1, min: 1, max: 1}], color: '#2F271B' },
            'darkwood_bush': { imgSrc: 'Darkwood Bush Block.png', solid: true, miningHardness: 25, drops: [{item: 'darkwood_bush', chance: 0.05, min: 1, max: 1}], color: '#3A3125' },
            'pdarkwood': { imgSrc: 'Planked Darkwood Block.png', solid: true, miningHardness: 160, drops: [{item: 'pdarkwood', chance: 1, min: 1, max: 1}], color: '#4A3B2F' },
            'pest_stone_block_weak': { imgSrc: 'Pest Stone Block (Weak).png', solid: true, miningHardness: 400, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'pest', chance: 1, min: 1, max: 1}], color: '#6A675A' },
            'pest_stone_block_strong': { imgSrc: 'Pest Stone Block (Strong).png', solid: true, miningHardness: 600, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'pest', chance: 1, min: 1, max: 5}], color: '#5A574A' },
            'moss': { imgSrc: 'Moss.png', solid: false, miningHardness: 5, drops: [{item: 'moss_seeds', chance: 0.4, min: 1, max: 3}], color: '#4A5D23' },
            'dark_moss': { imgSrc: 'Dark Moss.png', solid: false, miningHardness: 5, drops: [{item: 'moss_seeds', chance: 0.4, min: 1, max: 3}], color: '#3B4A1C' },
            'weed': { imgSrc: 'Weed.png', solid: false, miningHardness: 5, drops: [], color: '#6B8E23' },
            'shroom': { imgSrc: 'Shroom.png', solid: false, miningHardness: 10, drops: [{item: 'shroom', chance: 1, min: 1, max: 1}], color: '#8B0000' },
			'big_shroom': { imgSrc: 'Big Shroom.png', solid: true, miningHardness: 50, drops: [{item: 'big_shroom', chance: 1, min: 1, max: 1}], color: '#8B0000' },
			'devil_shroom': { imgSrc: 'Devil Shroom.png', solid: true, miningHardness: 2500, drops: [{item: 'devil_shroom', chance: 1, min: 1, max: 1}], color: '#8B0000' },
            'hay_bale': { imgSrc: 'Hay Bale Block.png', solid: true, miningHardness: 100, drops: [{item: 'hat_bale', chance: 1, min: 1, max: 2}], color: '#F0F0F0' },
		    'cotton': { imgSrc: 'Cotton.png', solid: false, miningHardness: 10, drops: [{item: 'cotton_item', chance: 1, min: 1, max: 2}, {item: 'cotton_seeds', chance: 0.2, min: 0, max: 2}], color: '#F0F0F0' },
			'cottond': { imgSrc: 'Cotton Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'cotton_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'cottonso': { imgSrc: 'Cotton Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'cotton_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
			'cottonf': { imgSrc: 'Cotton Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'f', chance: 1, min: 1, max: 1}, {item: 'cotton_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'planted_cotton_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'rice': { imgSrc: 'Rice.png', solid: false, miningHardness: 10, drops: [{item: 'rice_item', chance: 1, min: 1, max: 2}, {item: 'rice_seeds', chance: 0.2, min: 0, max: 2}], color: '#FFFFFF' },
            'riced': { imgSrc: 'Rice Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'rice_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'riceso': { imgSrc: 'Rice Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'rice_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'ricef': { imgSrc: 'Rice Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'f', chance: 1, min: 1, max: 1}, {item: 'rice_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
            'planted_rice_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
            'wheat': { imgSrc: 'Wheat.png', solid: false, miningHardness: 10, drops: [{item: 'wheat_item', chance: 1, min: 1, max: 2}, {item: 'wheat_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'wheatd': { imgSrc: 'Wheat Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'wheatso': { imgSrc: 'Wheat Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'wheatf': { imgSrc: 'Wheat Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'f', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'planted_wheat_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'barley': { imgSrc: 'Barley.png', solid: false, miningHardness: 10, drops: [{item: 'barley_item', chance: 1, min: 1, max: 2}, {item: 'wheat_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'barleyd': { imgSrc: 'Barley Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'barleyso': { imgSrc: 'Barley Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'barleyf': { imgSrc: 'Barley Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'f', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'planted_barley_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'pumpkin': { imgSrc: 'Pumpkin.png', solid: false, miningHardness: 10, drops: [{item: 'pumpkin', chance: 1, min: 1, max: 3}, {item: 'pumpkin_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347', spoilable: { into: 'plant_mush', time: 300000 } },
            'pumpkind': { imgSrc: 'Pumpkin Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'pumpkin_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'pumpkinso': { imgSrc: 'Pumpkin Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'pumpkin_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'pumpkinf': { imgSrc: 'Pumpkin Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'f', chance: 1, min: 1, max: 1}, {item: 'pumpkin_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'planted_pumpkin_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'tomato_bush': { imgSrc: 'Tomato Bush.png', solid: false, miningHardness: 10, drops: [{item: 'tomato', chance: 1, min: 1, max: 3}, {item: 'tomato_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'tomatod': { imgSrc: 'Tomato Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'tomato_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'tomatoso': { imgSrc: 'Tomato Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'tomato_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'tomatof': { imgSrc: 'Tomato Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'f', chance: 1, min: 1, max: 1}, {item: 'tomato_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'planted_tomato_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'hop': { imgSrc: 'Hop Plant.png', solid: false, miningHardness: 10, drops: [{item: 'hop_item', chance: 1, min: 1, max: 4}, {item: 'hop_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'hopd': { imgSrc: 'Hop Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'hop_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'hopso': { imgSrc: 'Hop Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'hop_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'hopf': { imgSrc: 'Hop Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'f', chance: 1, min: 1, max: 1}, {item: 'hop_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'planted_hop_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'coffee': { imgSrc: 'Coffee.png', solid: false, miningHardness: 10, drops: [{item: 'coffee', chance: 1, min: 1, max: 1}, {item: 'coffee_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'coffeed': { imgSrc: 'Coffee Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'coffee_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'coffeeso': { imgSrc: 'Coffee Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'coffee_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'coffeef': { imgSrc: 'Coffee Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'f', chance: 1, min: 1, max: 1}, {item: 'coffee_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'planted_coffee_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'oat': { imgSrc: 'Oat.png', solid: false, miningHardness: 10, drops: [{item: 'oat_item', chance: 1, min: 1, max: 2}, {item: 'oat_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'oatd': { imgSrc: 'Oat Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'oat_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'oatso': { imgSrc: 'Oat Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'oat_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'oatf': { imgSrc: 'Oat Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'f', chance: 1, min: 1, max: 1}, {item: 'oat_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'planted_oat_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'corn': { imgSrc: 'Corn.png', solid: false, miningHardness: 10, drops: [{item: 'corn_item', chance: 1, min: 1, max: 2}, {item: 'corn_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'cornd': { imgSrc: 'Corn Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'corn_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'cornso': { imgSrc: 'Corn Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'corn_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'cornf': { imgSrc: 'Corn Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'f', chance: 1, min: 1, max: 1}, {item: 'corn_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'planted_corn_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'onion': { imgSrc: 'Onion Plant.png', solid: false, miningHardness: 10, drops: [{item: 'onion_item', chance: 1, min: 1, max: 2}, {item: 'onion_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'oniond': { imgSrc: 'Onion Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'onion_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'onionso': { imgSrc: 'Onion Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'onion_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'onionf': { imgSrc: 'Onion Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'f', chance: 1, min: 1, max: 1}, {item: 'onion_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'planted_onion_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'garlic': { imgSrc: 'Garlic Plant.png', solid: false, miningHardness: 10, drops: [{item: 'garlic_item', chance: 1, min: 1, max: 3}, {item: 'garlic_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'garlicd': { imgSrc: 'Garlic Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'garlic_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'garlicso': { imgSrc: 'Garlic Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'garlic_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'garlicf': { imgSrc: 'Garlic Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'f', chance: 1, min: 1, max: 1}, {item: 'garlic_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'planted_garlic_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'chili_pepper_bush': { imgSrc: 'Chili Pepper Bush.png', solid: false, miningHardness: 10, drops: [{item: 'chili_pepper', chance: 1, min: 1, max: 4}, {item: 'chili_pepper_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'chili_pepperd': { imgSrc: 'Chili Pepper Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'd', chance: 1, min: 1, max: 1}, {item: 'chili_pepper_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'chili_pepperso': { imgSrc: 'Chili Pepper Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 's', chance: 1, min: 1, max: 1}, {item: 'chili_pepper_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
            'chili_pepperf': { imgSrc: 'Chili Pepper Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'f', chance: 1, min: 1, max: 1}, {item: 'chili_pepper_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'planted_chili_pepper_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
            'gilded_grass_dirtb': { imgSrc: 'Gilded Grass Dirt Block.png', solid: true, miningHardness: 80, drops: [{item: 'gilded_dirtb', chance: 1, min: 1, max: 1}], color: '#F0E68C', shovelBlock: true },
            'gilded_dirtb': { imgSrc: 'Gilded Dirt Block.png', solid: true, miningHardness: 70, drops: [{item: 'gilded_dirtb', chance: 1, min: 1, max: 1}], color: '#DAA520', shovelBlock: true },
            'rgildedw': { imgSrc: 'Raw Gilded Wood Block.png', solid: true, miningHardness: 180, drops: [{item: 'rgildedw', chance: 1, min: 1, max: 1}], color: '#BDB76B' },
            'pgildedw': { imgSrc: 'Planked Gilded Wood Block.png', solid: true, miningHardness: 180, drops: [{item: 'pgildedw', chance: 1, min: 1, max: 1}], color: '#CFB53B' },
            'gilded_tree_bush': { imgSrc: 'Gilded Tree Bush Block.png', solid: true, miningHardness: 30, drops: [{item: 'gilded_tree_bush', chance: 0.05, min: 1, max: 1}], color: '#FFD700' },
            'cloudb': { imgSrc: 'Cloud Block.png', solid: true, miningHardness: 10, drops: [], color: '#F0F8FF', shovelBlock: true },
			'cloud_rockb': { imgSrc: 'Cloud Rock Block.png', solid: true, miningHardness: 500, drops: [{item: 'cloud_rockb', chance: 1, min: 1, max: 1}], color: '#F0F8FF' },
			'diviniron_cloudb': { imgSrc: 'Diviniron Cloud Block.png', solid: true, miningHardness: 15, drops: [{item: 'divinironn', chance: 1, min: 1, max: 1}], color: '#F0F8FF' },
			'heavensteel_cloudb': { imgSrc: 'Heavensteel Cloud Block.png', solid: true, miningHardness: 15, drops: [{item: 'heavensteeln', chance: 1, min: 1, max: 3}], color: '#F0F8FF' },
			'corroded_heaven_debrisb': { imgSrc: 'Corroded Heaven Debris Block.png', solid: true, miningHardness: 500, drops: [{item: 'corroded_heaven_debrisb', chance: 1, min: 1, max: 1}], color: '#F0F8FF' },
			'ancient_heaven_debrisb': { imgSrc: 'Ancient Heaven Debris Block.png', solid: true, miningHardness: 2000, drops: [{item: 'ancient_heaven_debrisb', chance: 1, min: 1, max: 1}], color: '#F0F8FF' },
			'strong_heaven_debrisb': { imgSrc: 'Strong Heaven Debris Block.png', solid: true, miningHardness: 8000, drops: [{item: 'strong_heaven_debrisb', chance: 1, min: 1, max: 1}], color: '#F0F8FF' },
			'pure_heaven_debrisb': { imgSrc: 'Pure Heaven Debris Block.png', solid: true, miningHardness: 25000, drops: [{item: 'pure_heaven_debrisb', chance: 1, min: 1, max: 1}], color: '#F0F8FF' },
			'heaven_gate_brickb': { imgSrc: 'Heaven Gate Brick Block.png', solid: true, miningHardness: 75000, drops: [{item: 'heaven_gate_brickb', chance: 1, min: 1, max: 1}], color: '#F0F8FF' },
			'heaven_portal': { imgSrc: 'Heaven Portal.png', solid: false, miningHardness: 75000, drops: [], color: '#F0F8FF' },
			'meatb': { imgSrc: 'Meat Block.png', solid: true, miningHardness: 200, drops: [{item: 'meatb', chance: 0.1, min: 1, max: 1}, {item: 'beef', chance: 0.3, min: 1, max: 3}, {item: 'pork', chance: 0.3, min: 1, max: 3}, {item: 'human_flesh', chance: 0.2, min: 1, max: 3}], color: '#E0DBCB', shovelBlock: true },
			'spoiled_meatb': { imgSrc: 'Spoiled Meat Block.png', solid: true, miningHardness: 200, drops: [{item: 'spoiled_meatb', chance: 0.1, min: 1, max: 1}, {item: 'spoiled_beef', chance: 0.3, min: 1, max: 3}, {item: 'spoiled_pork', chance: 0.3, min: 1, max: 3}, {item: 'human_flesh', chance: 0.2, min: 1, max: 3}], color: '#E0DBCB', shovelBlock: true },
			'fleshb': { imgSrc: 'Flesh Block.png', solid: true, miningHardness: 300, drops: [{item: 'fleshb', chance: 1, min: 1, max: 1}], color: '#E0DBCB', shovelBlock: true },
			'boneb': { imgSrc: 'Bone Block.png', solid: true, miningHardness: 500, drops: [{item: 'boneb', chance: 1, min: 1, max: 1}], color: '#E0DBCB' },
			'obsidianb': { imgSrc: 'Obsidian Block.png', solid: true, miningHardness: 300, drops: [{item: 'obsidianb', chance: 1, min: 1, max: 1}], color: '#3C2A4D' },
			'ashb': { imgSrc: 'Ash Block.png', solid: true, miningHardness: 40, drops: [{item: 'ashb', chance: 1, min: 1, max: 1}], color: '#3C2A4D', shovelBlock: true },
			'ant_larvab': { imgSrc: 'Ant Larva Block.png', solid: true, miningHardness: 30, drops: [], color: '#F5F5DC', shovelBlock: true },
			'blueglow_grass_dirtb': { imgSrc: 'Blueglow Grass Dirt Block.png', solid: true, miningHardness: 80, drops: [{item: 'blueglow_dirtb', chance: 1, min: 1, max: 1}], color: '#F0E68C', shovelBlock: true },
            'blueglow_dirtb': { imgSrc: 'Blueglow Dirt Block.png', solid: true, miningHardness: 70, drops: [{item: 'blueglow_dirtb', chance: 1, min: 1, max: 1}], color: '#DAA520', shovelBlock: true },
			'blueglow_grass_soilb': { imgSrc: 'Blueglow Grass Soil Block.png', solid: true, miningHardness: 80, drops: [{item: 'blueglow_soilb', chance: 1, min: 1, max: 1}], color: '#F0E68C', shovelBlock: true },
            'blueglow_soilb': { imgSrc: 'Blueglow Soil Block.png', solid: true, miningHardness: 70, drops: [{item: 'blueglow_soilb', chance: 1, min: 1, max: 1}], color: '#DAA520', shovelBlock: true },
			'flesh_grass_dirtb': { imgSrc: 'Flesh Grass Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'd', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'flesh_grass_soilb': { imgSrc: 'Flesh Grass Soil Block.png', solid: true, miningHardness: 60, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'flesh_hellstone': { imgSrc: 'Flesh Hellstone Block.png', solid: true, miningHardness: 510, drops: [{item: 'hellstone', chance: 1, min: 1, max: 1}], color: '#808080' },
			'doom_grass_dirtb': { imgSrc: 'Doom Grass Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'd', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'doom_grass_soilb': { imgSrc: 'Doom Grass Soil Block.png', solid: true, miningHardness: 60, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'doom_hellstone': { imgSrc: 'Doom Hellstone Block.png', solid: true, miningHardness: 510, drops: [{item: 'hellstone', chance: 1, min: 1, max: 1}], color: '#808080' },
			'invisible_barrier': { imgSrc: 'Barrier Invisible.png', solid: true, miningHardness: 50, drops: [], color: '#8B4513', requiredTool: 'test_axe' },
			'visible_barrier': { imgSrc: 'Barrier Visible.png', solid: true, miningHardness: 50, drops: [], color: '#8B4513', requiredTool: 'test_axe' },
			'masterb': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 1000000000, drops: [{item: 's', chance: 1, min: 240, max: 240}], color: '#8B4513' },
			'test_block_mine_power': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 100, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#8B4513', requiredMiningPower: 0.5 },
			'test_block_test_axe': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 100, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#8B4513', requiredTool: 'test_axe' },
            'test_block_shovel': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 100, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
            'rtest_block_axe': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 100, drops: [{item: 's', chance: 1, min: 1, max: 1}], color: '#8B4513' },
        };
        let itemTypes = {
			 'cooked_beef': { imgSrc: 'Cooked Beef.png', color: '#802600', isFood: true, healAmount: 10 },
			 'cooked_pork': { imgSrc: 'Cooked Pork.png', color: '#802600', isFood: true, healAmount: 8 },
			 'wooden_bowl': { imgSrc: 'Wooden Bowl.png', color: '#8B4513' },
			 'glass_cup': { imgSrc: 'Glass Cup.png', color: '#8B4513' },
             'asphalt_fragment': { imgSrc: 'Asphalt Fragment.png', color: '#36454F' },
			 'void_dust': { imgSrc: 'Void Dust.png', color: '#36454F' },
             'snow_ball': { imgSrc: 'Snow Ball.png', color: '#FFFAFA' },
             'prickly_pear_fruit': { imgSrc: 'Prickly Pear Fruit.png', color: '#8B008B', isFood: true, healAmount: 2 },
             'wooden_stick': { imgSrc: 'Wooden Stick.png', color: '#8B4513' },
			 'wield_wooden_stick': { imgSrc: 'Wield Wooden Stick.png', color: '#8B4513' },
             'colony_heart': { imgSrc: 'Colony Heart.png', color: '#FF0000' },
			 'paper': { imgSrc: 'Paper.png', color: '#36454F' },
			 'soggy_paper': { imgSrc: 'Paper.png', color: '#36454F' },
			 'cinnamon': { imgSrc: 'Cinnamon.png', color: '#36454F' },
			 'bronze_coin': { imgSrc: 'Bronze Coin.png', color: '#FFD700' },
			 'gold_coin': { imgSrc: 'Gold Coin.png', color: '#FFD700' },
             'coal': { imgSrc: 'Coal Nugget.png', color: '#36454F' },
			 'pure_fuel': { imgSrc: 'Pure Fuel.png', color: '#36454F' },
			 'coppern': { imgSrc: 'Copper Nugget.png', color: '#B87333' },
			 'tinn': { imgSrc: 'Tin Nugget.png', color: '#C0C0C0' },
			 'zincn': { imgSrc: 'Zinc Nugget.png', color: '#C0C0C0' },
             'bronzen': { imgSrc: 'Bronze Nugget.png', color: '#CD7F32' },
			 'brassn': { imgSrc: 'Brass Nugget.png', color: '#CD7F32' },
             'ironn': { imgSrc: 'Iron Nugget.png', color: '#A19D94' },
			 'tungstenn': { imgSrc: 'Tungsten Nugget.png', color: '#A19D94' },
			 'steeln': { imgSrc: 'Steel Nugget.png', color: '#43464B' },
             'goldn': { imgSrc: 'Gold Nugget.png', color: '#FFD700' },
			 'hellsteeln': { imgSrc: 'Hellsteel Nugget.png', color: '#CD7F32' },
			 'divinironn': { imgSrc: 'Diviniron Nugget.png', color: '#CD7F32' },
			 'mighterrumn': { imgSrc: 'Mighterrum Nugget.png', color: '#CD7F32' },
			 'heavensteeln': { imgSrc: 'Heavensteel Nugget.png', color: '#CD7F32' },
			 'impure_infinitungstenn': { imgSrc: 'Impure Infinitungsten Nugget.png', color: '#CD7F32' },
			 'infinitungstenn': { imgSrc: 'Infinitungsten Nugget.png', color: '#CD7F32' },
			 'mythicalithiumn': { imgSrc: 'Mythicalithium Nugget.png', color: '#CD7F32' },
             'nuclear_core': { imgSrc: 'Nuclear Core.png', color: '#CD7F32' },
			 'power_orb': { imgSrc: 'Power Orb.png', color: '#CD7F32' },
			 'nickeln': { imgSrc: 'Nickel Nugget.png', color: '#FFD700' },
			 'leadn': { imgSrc: 'Lead Nugget.png', color: '#FFD700' },
			 'aluminumn': { imgSrc: 'Aluminum Nugget.png', color: '#FFD700' },
			 'palladiumn': { imgSrc: 'Palladium Nugget.png', color: '#FFD700' },
			 'tungstenn': { imgSrc: 'Tungsten Nugget.png', color: '#FFD700' }, 
			 'titaniumn': { imgSrc: 'Titanium Nugget.png', color: '#FFD700' }, 
             'diamondn': { imgSrc: 'Diamond Nugget.png', color: '#B9F2FF' },
			 'rubyn': { imgSrc: 'Ruby Nugget.png', color: '#E0115F' },
			 'topazn': { imgSrc: 'Topaz Nugget.png', color: '#FFC87C' },
             'sapphiren': { imgSrc: 'Sapphire Nugget.png', color: '#0F52BA' },
             'emeraldn': { imgSrc: 'Emerald Nugget.png', color: '#50C878' },
             'amethystn': { imgSrc: 'Amethyst Nugget.png', color: '#9966CC' },
             'opaln': { imgSrc: 'Opal Nugget.png', color: '#E0E9E7' },
			 'jaden': { imgSrc: 'Jade Nugget.png', color: '#E0E9E7' },
			 'plant_mush': { imgSrc: 'Plant Mush.png', color: '#FF0000', isFood: true, healAmount: 1 },
			 'grass_seeds': { imgSrc: 'Grass Seeds.png', color: '#32CD32' },
			 'moss_seeds': { imgSrc: 'Moss Seeds.png', color: '#32CD32' },
			 'tomato_seeds': { imgSrc: 'Tomato Seeds.png', color: '#FF6347' },
             'tomato': { imgSrc: 'Tomato.png', color: '#FF0000', isFood: true, healAmount: 2, spoilable: { into: 'plant_mush', time: 300000 } },
			 'wheat_seeds': { imgSrc: 'Wheat Seeds.png', color: '#F5DEB3' },
			 'wheat_item': { imgSrc: 'Wheat.png', color: '#F5DEB3', spoilable: { into: 'plant_mush', time: 300000 } },
			 'pumpkin_seeds': { imgSrc: 'Pumpkin Seeds.png', color: '#F5DEB3' },
			 'barley_seeds': { imgSrc: 'Barley Seeds.png', color: '#F5DEB3' },
			 'barley_item': { imgSrc: 'Barley.png', color: '#F5DEB3', spoilable: { into: 'plant_mush', time: 300000 } },
			 'cotton_seeds': { imgSrc: 'Cotton Seeds.png', color: '#D3D3D3' },
             'cotton_item': { imgSrc: 'Cotton.png', color: '#F5F5F5', spoilable: { into: 'plant_mush', time: 300000 } },
             'rice_seeds': { imgSrc: 'Rice Seeds.png', color: '#F5F5DC' },
             'rice_item': { imgSrc: 'Rice.png', color: '#FFFFFF', spoilable: { into: 'plant_mush', time: 300000 } },
			 'hop_seeds': { imgSrc: 'Hop Seeds.png', color: '#F5F5DC' },
             'hop_item': { imgSrc: 'Hop.png', color: '#FFFFFF', spoilable: { into: 'plant_mush', time: 300000 } },
			 'coffee_seeds': { imgSrc: 'Coffee Seeds.png', color: '#F5F5DC' },
			 'oat_seeds': { imgSrc: 'Oat Seeds.png', color: '#F5F5DC' },
             'oat_item': { imgSrc: 'Oat.png', color: '#FFFFFF', spoilable: { into: 'plant_mush', time: 300000 } },
			 'corn_seeds': { imgSrc: 'Corn Seeds.png', color: '#F5F5DC' },
             'corn_item': { imgSrc: 'Corn.png', color: '#FFFFFF', isFood: true, healAmount: 2, spoilable: { into: 'plant_mush', time: 300000 } },
			 'garlic_seeds': { imgSrc: 'Garlic Seeds.png', color: '#F5F5DC' },
			 'garlic_item': { imgSrc: 'Garlic.png', color: '#FFFFFF', isFood: true, healAmount: 1, spoilable: { into: 'plant_mush', time: 300000 } },
			 'onion_seeds': { imgSrc: 'Onion Seeds.png', color: '#F5F5DC' },
			 'onion_item': { imgSrc: 'Onion.png', color: '#FFFFFF', isFood: true, healAmount: 1, spoilable: { into: 'plant_mush', time: 300000 } },
			 'chili_pepper_seeds': { imgSrc: 'Chili Pepper Seeds.png', color: '#F5F5DC' },
			 'chili_pepper': { imgSrc: 'Chili Pepper.png', color: '#FFFFFF', isFood: true, healAmount: 1, spoilable: { into: 'plant_mush', time: 300000 } },
			 'taco_salad': { imgSrc: 'Taco Salad.png', color: '#FFFFFF', isFood: true, healAmount: 12 },
			 'mushroom_soup': { imgSrc: 'Mushroom Soup.png', color: '#FFFFFF', isFood: true, healAmount: 4 },
			 'tomato_soup': { imgSrc: 'Tomato Soup.png', color: '#FFFFFF', isFood: true, healAmount: 7 },
			 'power_soup': { imgSrc: 'Power Soup.png', color: '#FFFFFF', isFood: true, healAmount: 100, addsMaxHealth: 10, fullHeal: true },
			 'tomato_sandwich': { imgSrc: 'Tomato Sandwich.png', color: '#D24F33', isFood: true, healAmount: 20 },
			 'coffee_bean': { imgSrc: 'Coffee Bean.png', color: '#FF0000' },
			 'apple': { imgSrc: 'Apple.png', color: '#FF0000', isFood: true, healAmount: 2, spoilable: { into: 'plant_mush', time: 300000 } },
			 'beef': { imgSrc: 'Beef.png', color: '#C04040', isFood: true, healAmount: 4, spoilable: { into: 'spoiled_beef', time: 300000 } },
			 'spoiled_beef': { imgSrc: 'Spoiled Beef.png', color: '#D24F33', isFood: true, healAmount: -5 },
			 'pork': { imgSrc: 'Pork.png', color: '#C04040', isFood: true, healAmount: 3, spoilable: { into: 'spoiled_pork', time: 300000 } },
			 'spoiled_pork': { imgSrc: 'Spoiled Pork.png', color: '#D24F33', isFood: true, healAmount: -5 },
			 'human_flesh': { imgSrc: 'Human Flesh.png', color: '#D24F33', isFood: true, healAmount: 1 },
			 'cup_of_water': { imgSrc: 'Cup Of Water.png', color: '#D24F33', isFood: true, healAmount: 0 },
			 'cup_of_coffee': { imgSrc: 'Cup Of Coffee.png', color: '#D24F33', isFood: true, healAmount: 2 },
             'cup_of_pine_needle_tea': { imgSrc: 'Cup Of Pine Needle Tea.png', color: '#D24F33', isFood: true, healAmount: 1 },
			 'cup_of_beer': { imgSrc: 'Cup Of Beer.png', color: '#D24F33', isFood: true, healAmount: 7 },
			 'cup_of_urine': { imgSrc: 'Cup Of Urine.png', color: '#D24F33', isFood: true, healAmount: 0 },
			 'pinecone': { imgSrc: 'Pinecone.png', color: '#FF0000' },
			 'pine_needle_living': { imgSrc: 'Pine Needle Living.png', color: '#FF0000', spoilable: { into: 'pine_needle_dying', time: 50000 } },
			 'pine_needle_dying': { imgSrc: 'Pine Needle Dying.png', color: '#FF0000', spoilable: { into: 'pine_needle_dead', time: 50000 } },
			 'pine_needle_dead': { imgSrc: 'Pine Needle Dead.png', color: '#FF0000' },
			 'wheat_bread': { imgSrc: 'Wheat Bread.png', color: '#E6BF83', isFood: true, healAmount: 4 },
			 'barley_bread': { imgSrc: 'Barley Bread.png', color: '#E6BF83', isFood: true, healAmount: 4 },
			 'noodles': { imgSrc: 'Noodles.png', color: '#E6BF83', isFood: true, healAmount: 1 },
			 'cake': { imgSrc: 'Cake.png', color: '#E6BF83', isFood: true, healAmount: 33 },
			 'pumpkin_pie': { imgSrc: 'Pumpkin Pie.png', color: '#E6BF83', isFood: true, healAmount: 33 },
			 'ramen_noodles': { imgSrc: 'Ramen Noodles.png', color: '#E6BF83', isFood: true, healAmount: 28 },
			 'spaghetti': { imgSrc: 'Spaghetti.png', color: '#E6BF83', isFood: true, healAmount: 22 },
			 'rsugar': { imgSrc: 'Raw Sugar.png', color: '#FF0000' },
			 'refined_sugar': { imgSrc: 'Refined Sugar.png', color: '#FF0000' },
			 'molasses': { imgSrc: 'Molasses.png', color: '#FF0000' },
			 'egg': { imgSrc: 'Egg.png', color: '#FF0000' },
			 'flour': { imgSrc: 'Flour.png', color: '#FF0000' },
			 'rock_salt': { imgSrc: 'Rock Salt.png', color: '#FF0000' },
			 'iodized_salt': { imgSrc: 'Iodized Salt.png', color: '#FF0000' },
			 'butter': { imgSrc: 'Butter.png', color: '#FF0000' },
			 'cup_of_milk': { imgSrc: 'Cup Of Milk.png', color: '#FF0000', isFood: true, healAmount: 2 },
			 'rusted_iron_pickaxe': { imgSrc: 'Rusted Iron Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 0.1, maxDurability: 5000 },
			 'rusted_steel_pickaxe': { imgSrc: 'Rusted Iron Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 0.15, maxDurability: 15000 },
			 'rusted_ruby_plated_steel_pickaxe': { imgSrc: 'Rusted Ruby Plated Steel Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 0.18, maxDurability: 19000 },
			 'rusted_diamond_plated_steel_pickaxe': { imgSrc: 'Rusted Diamond Plated Steel Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 0.21, maxDurability: 19000 },
			 'rusted_diviniron_pickaxe': { imgSrc: 'Rusted Diviniron Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 0.5, maxDurability: 2000 },
			 'wooden_pickaxe': { imgSrc: 'Wooden Pickaxe.png', color: '#A0522D', isTool: true, miningPower: 0.2, maxDurability: 7500 },
			 'powered_wooden_pickaxe': { imgSrc: 'Wooden Pickaxe.png', color: '#A0522D', isTool: true, miningPower: 0.2, maxDurability: 9999999999999 }, 
             'rock_pickaxe': { imgSrc: 'Rock Pickaxe.png', color: '#888888', isTool: true, miningPower: 0.3, maxDurability: 12000 },
			 'reinforced_rock_pickaxe': { imgSrc: 'Reinforced Rock Pickaxe.png', color: '#888888', isTool: true, miningPower: 0.3, maxDurability: 36000 },
             'copper_pickaxe': { imgSrc: 'Copper Pickaxe.png', color: '#B87333', isTool: true, miningPower: 0.6, maxDurability: 20000 },
             'tin_pickaxe': { imgSrc: 'Tin Pickaxe.png', color: '#C0C0C0', isTool: true, miningPower: 0.5, maxDurability: 8000 },
             'bronze_pickaxe': { imgSrc: 'Bronze Pickaxe.png', color: '#CD7F32', isTool: true, miningPower: 0.8, maxDurability: 35000 },
             'iron_pickaxe': { imgSrc: 'Iron Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 1.0, maxDurability: 38000 },
			 'tungsten_pickaxe': { imgSrc: 'Tungsten Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 1.5, maxDurability: 32000 },
             'steel_pickaxe': { imgSrc: 'Steel Pickaxe.png', color: '#43464B', isTool: true, miningPower: 1.5, maxDurability: 100000 },
			 'ruby_plated_steel_pickaxe': { imgSrc: 'Ruby Plated Steel Pickaxe.png', color: '#E0115F', isTool: true, miningPower: 1.8, maxDurability: 120000 },
             'diamond_plated_steel_pickaxe': { imgSrc: 'Diamond Plated Steel Pickaxe.png', color: '#B9F2FF', isTool: true, miningPower: 2.1, maxDurability: 120000 },
			 'mighterrum_pickaxe': { imgSrc: 'Mighterrum Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 1.0, maxDurability: 30000 },
			 'diviniron_pickaxe': { imgSrc: 'Diviniron Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 5.0, maxDurability: 20000 },
			 'hellrock_pickaxe': { imgSrc: 'Hellrock Pickaxe.png', color: '#43464B', isTool: true, miningPower: 0.5, maxDurability: 16000 }, 
			 'hellsteel_pickaxe': { imgSrc: 'Hellsteel Pickaxe.png', color: '#43464B', isTool: true, miningPower: 2.5, maxDurability: 133333 }, 
			 'anthill_hellsteel_pickaxe': { imgSrc: 'Anthill Hellsteel Pickaxe.png', color: '#43464B', isTool: true, miningPower: 5, maxDurability: 106666 },
			 'void_hellsteel_pickaxe': { imgSrc: 'Void Hellsteel Pickaxe.png', color: '#43464B', isTool: true, miningPower: 2, maxDurability: 199999 },
			 'heavenrock_pickaxe': { imgSrc: 'Heavenrock Pickaxe.png', color: '#43464B', isTool: true, miningPower: 0.6, maxDurability: 12000 }, 
			 'heavensteel_pickaxe': { imgSrc: 'Heavensteel Pickaxe.png', color: '#43464B', isTool: true, miningPower: 3, maxDurability: 100000 }, 
			 'anthill_heavensteel_pickaxe': { imgSrc: 'Anthill Heavensteel Pickaxe.png', color: '#43464B', isTool: true, miningPower: 6, maxDurability: 80000 },
			 'void_heavensteel_pickaxe': { imgSrc: 'Void Heavensteel Pickaxe.png', color: '#43464B', isTool: true, miningPower: 2.4, maxDurability: 150000 },
			 'infinitungsten_pickaxe': { imgSrc: 'Infinitungsten Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 10.0, maxDurability: 400000 },
             'anthill_infinitungsten_pickaxe': { imgSrc: 'Anthill Infinitungsten Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 20.0, maxDurability: 320000 },
             'void_infinitungsten_pickaxe': { imgSrc: 'Void Infinitungsten Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 8.0, maxDurability: 600000 },
			 'mythicalithium_pickaxe': { imgSrc: 'Mythicalithium Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 20.0, maxDurability: 600000 },
			 'pest': { imgSrc: 'Pest.png', color: '#36454F' },
			 'wooden_shovel': { imgSrc: 'Wooden Shovel.png', color: '#A0522D', isTool: true, miningPower: 0.1, shovelPower: 0.2, maxDurability: 7500 },
			 'rock_shovel': { imgSrc: 'Rock Shovel.png', color: '#A0522D', isTool: true, miningPower: 0.1, shovelPower: 0.3, maxDurability: 12000 },
			 'copper_shovel': { imgSrc: 'Copper Shovel.png', color: '#A0522D', isTool: true, miningPower: 0.1, shovelPower: 0.6, maxDurability: 20000 },
			 'tin_shovel': { imgSrc: 'Tin Shovel.png', color: '#A0522D', isTool: true, miningPower: 0.1, shovelPower: 0.5, maxDurability: 8000 },
             'iron_shovel': { imgSrc: 'Iron Shovel.png', color: '#A0522D', isTool: true, miningPower: 0.1, shovelPower: 0.8, maxDurability: 38000 },
			 'tungsten_shovel': { imgSrc: 'Tungsten Shovel.png', color: '#A0522D', isTool: true, miningPower: 0.1, shovelPower: 1.5, maxDurability: 32000 },
			 'bronze_shovel': { imgSrc: 'Bronze Shovel.png', color: '#A0522D', isTool: true, miningPower: 0.1, shovelPower: 0.8, maxDurability: 35000 },
			 'steel_shovel': { imgSrc: 'Steel Shovel.png', color: '#A0522D', isTool: true, miningPower: 0.1, shovelPower: 1.5, maxDurability: 100000 },
			 'wooden_axe': { imgSrc: 'Wooden Axe.png', color: '#A0522D', isTool: true, miningPower: 0.1, axePower: 0.2, maxDurability: 7500 },
             'rock_axe': { imgSrc: 'Rock Axe.png', color: '#A0522D', isTool: true, miningPower: 0.1, axePower: 0.3, maxDurability: 12000 },
			 'copper_axe': { imgSrc: 'Copper Axe.png', color: '#A0522D', isTool: true, miningPower: 0.1, axePower: 0.6, maxDurability: 20000 },
			 'tin_axe': { imgSrc: 'Tin Axe.png', color: '#A0522D', isTool: true, miningPower: 0.1, axePower: 0.5, maxDurability: 8000 },
             'iron_axe': { imgSrc: 'Iron Axe.png', color: '#A0522D', isTool: true, miningPower: 0.1, axePower: 0.8, maxDurability: 38000 },
			 'tungsten_axe': { imgSrc: 'Tungsten Axe.png', color: '#A0522D', isTool: true, miningPower: 0.1, axePower: 1.5, maxDurability: 32000 },
			 'bronze_axe': { imgSrc: 'Bronze Axe.png', color: '#A0522D', isTool: true, miningPower: 0.1, axePower: 0.8, maxDurability: 35000 },
			 'steel_axe': { imgSrc: 'Steel Axe.png', color: '#A0522D', isTool: true, miningPower: 0.1, axePower: 1.5, maxDurability: 100000 },
			 'bucket': { imgSrc: 'Bucket.png', color: '#A9A9A9' },
			 'test_axe': { imgSrc: 'Wooden Pickaxe.png', color: '#A0522D', isTool: true, miningPower: 0.5, maxDurability: 10000 },
			 'hammer_of_infinity': { imgSrc: 'Wooden Pickaxe.png', color: '#A0522D', isTool: true, miningPower: 0.01, maxDurability: 9999999999999 },
			 'hammer_of_eternity': { imgSrc: 'Wooden Pickaxe.png', color: '#A0522D', isTool: true, miningPower: 0.003, maxDurability: 9999999999999 },
			 'gravity_sandwich': { color: '#D24F33', isFood: true, healAmount: 20, effectLength: 10, effect: {duration: 10, changes: [ { prop: 'gravity', type: 'set', value: -0.05 } ] } },
			 'speed_snack': { color: '#D24F33', isFood: true, healAmount: 20, effectLength: 10, effect: {duration: 10, changes: [ { prop: 'speed', type: 'add', value: 1 } ] } },
			 'jump_juice': { color: '#D24F33', isFood: true, healAmount: 20, effectLength: 10, effect: {duration: 10, changes: [ { prop: 'jumpStrength', type: 'add', value: -5 } ] } },
			 'trader_mask': { imgSrc: 'Armor/Trader Mask Icon.png', equippedImgSrc: 'Armor/Trader Mask.png', color: '#A9A9A9', armorType: 'helmet', protectionFactor: 0.03, maxDurability: 30 },
		};
        const breakingStageAssets = {
            'breaking_stage_1': { imgSrc: 'Breaking Stage 1.png' },
            'breaking_stage_2': { imgSrc: 'Breaking Stage 2.png' },
            'breaking_stage_3': { imgSrc: 'Breaking Stage 3.png' }
        };
        const healthAssets = {
            'full_heart': { imgSrc: 'Full Heart Icon.png' },
            'half_heart': { imgSrc: 'Half Heart Icon.png' },
            'empty_heart': { imgSrc: 'Empty Heart Icon.png' }
        };
        const assetsToLoadList = { ...blockTypes, ...itemTypes, ...breakingStageAssets, ...healthAssets };
        const assets = {};            
		const failedAssets = {};      
		let assetsToLoad = 0;
		let assetsLoaded = 0;
		function getAssetGroups() {
			return [blockTypes, itemTypes, breakingStageAssets, healthAssets];
		}
		function loadAssets() {
			const loadingText = document.getElementById('loadingText');
			const loadingBarFill = document.getElementById('loadingBarFill');
			const loadingPercent = document.getElementById('loadingPercent');
            let tipInterval; 
            function showRandomTip() {
                const randomIndex = Math.floor(Math.random() * loadingTips.length);
                loadingTipText.textContent = `Tip: ${loadingTips[randomIndex]}`;
            }
            showRandomTip(); 
            tipInterval = setInterval(showRandomTip, 4000); 
			const srcToKeys = {};
			const groups = getAssetGroups();
			for (const group of groups) {
				if (!group) continue;
				for (const key in group) {
					const src = group[key]?.imgSrc;
					if (!src) continue;
					if (!srcToKeys[src]) srcToKeys[src] = [];
					srcToKeys[src].push(key);
				}
			}
			const srcs = Object.keys(srcToKeys);
			assetsToLoad = srcs.length;
			assetsLoaded = 0;
			if (assetsToLoad === 0) {
				loadingScreen.style.display = 'none';
				init();
				return;
			}
			let idx = 0;
			function updateUI() {
				const pct = Math.round((assetsLoaded / Math.max(1, assetsToLoad)) * 100);
				loadingBarFill.style.width = pct + '%';
				loadingPercent.textContent = pct + '%';
			}
			function finishLoading() {
				clearInterval(tipInterval);
                updateUI();
				setTimeout(() => {
					loadingScreen.style.display = 'none';
					init();
				}, 120);
			}
			function loadNext() {
				if (idx >= srcs.length) {
					finishLoading();
					return;
				}
				const src = srcs[idx];
				const filename = src.split('/').pop();
				loadingText.textContent = `Loading: ${filename}`;
				const img = new Image();
				img.onload = () => {
					(srcToKeys[src] || []).forEach(typeKey => {
						assets[typeKey] = img;
					});
					assetsLoaded++;
					idx++;
					updateUI();
					loadNext();
				};
				img.onerror = () => {
					console.error('Failed to load asset:', src);
					failedAssets[src] = true;
					(srcToKeys[src] || []).forEach(typeKey => {
						assets[typeKey] = null;
					});
					assetsLoaded++;
					loadingText.textContent = `Failed: ${filename}`;
					idx++;
					updateUI();
					loadNext();
				};
				img.src = src;
			}
			loadNext();
		}
		const playerReach = 5 * tileSize; 
        const player = {
            x: 0 * tileSize, y: 0, dx: 0, dy: 0,
            speed: 5, jumpStrength: -15, onGround: false, gravity: 0.8,
            health: 100, maxHealth: 100,
            fallStartY: 0, 
            spawnPoint: { x: 0 * tileSize, y: -10 },
            bedSpawnPoint: null,
			portalCooldown: 0,
			facingDirection: 1,
			lastHealth: 100
        };
        let playerMiningPower = 0.1; 
        const camera = { x: 0, y: 0 };
        const keys = {}; 
		const npcs = [];
		const animatedDrops = [];
        const mouse = { x: 0, y: 0, down: false, rightDown: false }; 
        let miningTarget = null; 
        const inventorySlots = new Array(totalInventorySlots).fill(null);
        const hotbarIndices = new Array(hotbarSize).fill(null);
        let selectedHotbarSlot = 0;
        let isGameActive = true; 
        let isGamePaused = false; 
        let maintainBlockDurability = true;
		let animateDrops = false;
        function isTreeBlock(type) {
            return type === 'roak' || type === 'oak_bush' ||
                   type === 'rbirch' || type === 'birch_bush' ||
                   type === 'rspruce' || type === 'spruce_bush' ||
                   type === 'rdarkwood' || type === 'darkwood_bush' ||
                   type === 'rgildedw' || type === 'gilded_tree_bush';
        }
        function generateCactus(col, surfaceRow) {
            const height = 2 + Math.floor(random() * 4); 
            for (let i = 0; i < height; i++) {
                const key = `${col},${surfaceRow - 1 - i}`;
                if (getBlockType(col, surfaceRow - 1 - i) === '') {
                    worldBlocks[key] = { type: 'cactusb', mineProg: 0 };
                } else {
                    break; 
                }
            }
        }
        function generateTree(col, surfaceRow, treeType) {
			let trunkBlockType, bushBlockType, minTrunkHeight, maxTrunkHeight, trunkHeight, minCanopyRadius, maxCanopyRadius, horizontalSpreadFactorMin, horizontalSpreadFactorMax;
			if (treeType === 'oak') {
				trunkBlockType = 'roak'; bushBlockType = 'oak_bush'; minTrunkHeight = 6; maxTrunkHeight = 10;
				minCanopyRadius = 3; maxCanopyRadius = 4; horizontalSpreadFactorMin = 0.5; horizontalSpreadFactorMax = 1.5;
			} else if (treeType === 'birch') {
				trunkBlockType = 'rbirch'; bushBlockType = 'birch_bush'; minTrunkHeight = 4; maxTrunkHeight = 8;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.7; horizontalSpreadFactorMax = 0.9;
			} else if (treeType === 'spruce') {
				trunkBlockType = 'rspruce'; bushBlockType = 'spruce_bush'; minTrunkHeight = 8; maxTrunkHeight = 12;
				const canopyBaseWidth = 5; minCanopyRadius = 1; maxCanopyRadius = 2.5;
			} else if (treeType === 'rubber') {
				trunkBlockType = 'rrubber'; bushBlockType = 'rubber_bush'; minTrunkHeight = 5; maxTrunkHeight = 7;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.6; horizontalSpreadFactorMax = 0.9;
			} else if (treeType === 'mahogany') {
				trunkBlockType = 'rmahogany'; bushBlockType = 'mahogany_bush'; minTrunkHeight = 9; maxTrunkHeight = 13;
				minCanopyRadius = 3; maxCanopyRadius = 4; horizontalSpreadFactorMin = 0.9; horizontalSpreadFactorMax = 1.1;
			} else if (treeType === 'cinnamon') {
				trunkBlockType = 'rcinnamon'; bushBlockType = 'cinnamon_bush'; minTrunkHeight = 5; maxTrunkHeight = 7;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.8; horizontalSpreadFactorMax = 0.9;
			} else if (treeType === 'redwood') {
				trunkBlockType = 'rredwood'; bushBlockType = 'redwood_bush'; minTrunkHeight = 32; maxTrunkHeight = 46;
				const canopyBaseWidth = 5; minCanopyRadius = 1; maxCanopyRadius = 2.5; horizontalSpreadFactorMin = 1.8; horizontalSpreadFactorMax = 2;
			} else if (treeType === 'darkwood') {
				trunkBlockType = 'rdarkwood'; bushBlockType = 'darkwood_bush'; minTrunkHeight = 9; maxTrunkHeight = 15;
				minCanopyRadius = 4; maxCanopyRadius = 6; horizontalSpreadFactorMin = 0.8; horizontalSpreadFactorMax = 1.2;
			} else if (treeType === 'fern') {
				trunkBlockType = 'fern_stalk'; minTrunkHeight = 3; maxTrunkHeight = 8;
				minCanopyRadius = 3; maxCanopyRadius = 4; horizontalSpreadFactorMin = 1; horizontalSpreadFactorMax = 1;
			} else if (treeType === 'sugarcane') {
				trunkBlockType = 'sugarcane'; minTrunkHeight = 1; maxTrunkHeight = 4;
				minCanopyRadius = 3; maxCanopyRadius = 4; horizontalSpreadFactorMin = 1; horizontalSpreadFactorMax = 1;
			} else if (treeType === 'hell') {
				trunkBlockType = 'rhellw'; bushBlockType = 'hell_wood_bush'; minTrunkHeight = 6; maxTrunkHeight = 8;
				minCanopyRadius = 2; maxCanopyRadius = 4; horizontalSpreadFactorMin = 0.6; horizontalSpreadFactorMax = 1;
			} else if (treeType === 'gilded') {
				trunkBlockType = 'rgildedw'; bushBlockType = 'gilded_tree_bush'; minTrunkHeight = 6; maxTrunkHeight = 8;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.7; horizontalSpreadFactorMax = 1;
			} else if (treeType === 'blueglow') {
				trunkBlockType = 'rbluegloww'; bushBlockType = 'blueglow_bush'; minTrunkHeight = 6; maxTrunkHeight = 8;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.7; horizontalSpreadFactorMax = 1.1;
			} else if (treeType === 'ash') {
				trunkBlockType = 'ashb'; bushBlockType = 'ashb'; minTrunkHeight = 5; maxTrunkHeight = 80;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.7; horizontalSpreadFactorMax = 1;
			} else if (treeType === 'magma') {
				trunkBlockType = 'magma_stoneb'; minTrunkHeight = 1; maxTrunkHeight = 5;
			} else if (treeType === 'granite') {
				trunkBlockType = 'granite'; minTrunkHeight = 1; maxTrunkHeight = 5;
			} else if (treeType === 'meat') {
				trunkBlockType = 'meatw'; bushBlockType = 'meatb'; minTrunkHeight = 25; maxTrunkHeight = 30;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.7; horizontalSpreadFactorMax = 1.2;
			} else if (treeType === 'spoiled_meat') {
				trunkBlockType = 'spoiled_meatw'; bushBlockType = 'spoiled_meatb'; minTrunkHeight = 20; maxTrunkHeight = 25;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.7; horizontalSpreadFactorMax = 1.2;
			} else if (treeType === 'dirt_column') {
				trunkBlockType = 'd'; minTrunkHeight = 45; maxTrunkHeight = 47;
			}
			else if (treeType === 'apple') {
				trunkBlockType = 'rapple';
				const baseBushBlockType = 'apple_bush';
				const fruitBushBlockType = 'apple_bush_fruit';
				minTrunkHeight = 7; maxTrunkHeight = 9;
				minCanopyRadius = 3; maxCanopyRadius = 4; horizontalSpreadFactorMin = 0.5; horizontalSpreadFactorMax = 1.5;
				trunkHeight = minTrunkHeight + Math.floor(random() * (maxTrunkHeight - minTrunkHeight + 1));
				const trunkBaseWidth = (random() < 0.3) ? 2 : 1;
				for (let i = 0; i < trunkHeight; i++) {
					let currentTrunkWidth = (i < 2 && trunkBaseWidth === 2) ? 2 : 1;
					for (let w = 0; w < currentTrunkWidth; w++) {
						const trunkCol = col - Math.floor((currentTrunkWidth - 1) / 2) + w;
						const key = `${trunkCol},${surfaceRow - 1 - i}`;
						if (getBlockType(trunkCol, surfaceRow - 1 - i) === '') {
							worldBlocks[key] = { type: trunkBlockType, mineProg: 0 };
						}
					}
				}
				const topOfTrunkRow = surfaceRow - trunkHeight;
				const canopyRadius = minCanopyRadius + Math.floor(random() * (maxCanopyRadius - minCanopyRadius + 1));
				for (let yOffset = 0; yOffset <= canopyRadius + 2; yOffset++) {
					let currentLayerRadius = Math.max(0, canopyRadius - Math.floor(yOffset / 1.5));
					const horizontalSpread = horizontalSpreadFactorMin + random() * (horizontalSpreadFactorMax - horizontalSpreadFactorMin);
					const effectiveRadius = currentLayerRadius * horizontalSpread;
					for (let x = -Math.ceil(effectiveRadius); x <= Math.ceil(effectiveRadius); x++) {
						if (random() < 0.85) {
							const leafCol = col + Math.round(x);
							const leafRow = topOfTrunkRow - yOffset;
							const key = `${leafCol},${leafRow}`;
							if (getBlockType(leafCol, leafRow) === '' && (!worldBlocks[key] || worldBlocks[key].type !== trunkBlockType)) {
								const chosenBushType = random() < 0.2 ? fruitBushBlockType : baseBushBlockType;
								worldBlocks[key] = { type: chosenBushType, mineProg: 0 };
							}
						}
					}
				}
				const branchCount = Math.floor(random() * 3);
				for(let i = 0; i < branchCount; i++) {
					const branchY = topOfTrunkRow + 1 - Math.floor(random() * 4);
					const branchDir = random() < 0.5 ? -1 : 1;
					const branchLength = 1 + Math.floor(random() * 2);
					for(let l = 1; l <= branchLength; l++) {
						const branchCol = col + (l * branchDir);
						const branchKey = `${branchCol},${branchY}`;
						if(getBlockType(branchCol, branchY) === '') {
							 worldBlocks[branchKey] = { type: trunkBlockType, mineProg: 0 };
						}
					}
					const leafClusterRadius = 1 + Math.floor(random() * 1.5);
					for (let lx = -leafClusterRadius; lx <= leafClusterRadius; lx++) {
						for (let ly = -leafClusterRadius; ly <= leafClusterRadius; ly++) {
							const leafCol = col + (branchLength * branchDir) + lx;
							if (lx*lx + ly*ly <= leafClusterRadius*leafClusterRadius && random() < 0.9) {
								const leafKey = `${leafCol},${branchY - 1 + ly}`;
								if(getBlockType(leafCol, branchY - 1 + ly) === '' && (!worldBlocks[leafKey] || worldBlocks[leafKey].type !== trunkBlockType)) {
									const chosenBushType = random() < 0.2 ? fruitBushBlockType : baseBushBlockType;
									worldBlocks[leafKey] = { type: chosenBushType, mineProg: 0 };
								}
							}
						}
					}
				}
				return;
			}
			trunkHeight = minTrunkHeight + Math.floor(random() * (maxTrunkHeight - minTrunkHeight + 1));
			const trunkBaseWidth = (random() < 0.4 && (treeType === 'oak' || treeType === 'darkwood')) ? 2 : 1;
			if (treeType === 'redwood') {
				const topOfTrunkRow = surfaceRow - trunkHeight;
				for (let w = 0; w < 3; w++) {
					const trunkCol = col - 1 + w; 
					const trunkSurfaceRow = columnSurfaceHeights[trunkCol] || surfaceRow;
					for (let row = topOfTrunkRow; row < trunkSurfaceRow; row++) {
						const key = `${trunkCol},${row}`;
						if (getBlockType(trunkCol, row) === '') {
							worldBlocks[key] = { type: trunkBlockType, mineProg: 0 };
						}
					}
				}
			} else { 
				for (let i = 0; i < trunkHeight; i++) {
					const currentTrunkWidth = (i < 2 && trunkBaseWidth === 2) ? 2 : 1;
					for (let w = 0; w < currentTrunkWidth; w++) {
						const trunkCol = col - Math.floor((currentTrunkWidth - 1) / 2) + w;
						const key = `${trunkCol},${surfaceRow - 1 - i}`;
						const biome = getBiome(trunkCol);
						const validBaseBlock = biome === 'overgrown_forest' ? 'dark_mossd' : (biome === 'deciduous_forest' ? 'gd' : 'gs');
						if (getBlockType(trunkCol, surfaceRow - 1 - i) === '' || (i === 0 && getBlockType(trunkCol, surfaceRow) === validBaseBlock)) {
							worldBlocks[key] = { type: trunkBlockType, mineProg: 0 };
						}
					}
				}
			}
			const topOfTrunkRow = surfaceRow - trunkHeight;
			if (treeType === 'oak' || treeType === 'birch' || treeType === 'darkwood' || treeType === 'mahogany' || treeType === 'cinnamon' || treeType === 'rubber' || treeType === 'hell' || treeType === 'meat' || treeType === 'spoiled_meat' || treeType === 'gilded' || treeType === 'blueglow' || treeType === 'meat' || treeType === 'spoiled meat'|| treeType === 'ash') {
				const canopyRadius = minCanopyRadius + Math.floor(random() * (maxCanopyRadius - minCanopyRadius + 1));
				for (let yOffset = 0; yOffset <= canopyRadius + 2; yOffset++) {
					let currentLayerRadius = Math.max(0, canopyRadius - Math.floor(yOffset / 1.5));
					const horizontalSpread = horizontalSpreadFactorMin + random() * (horizontalSpreadFactorMax - horizontalSpreadFactorMin);
					const effectiveRadius = currentLayerRadius * horizontalSpread;
					for (let x = -Math.ceil(effectiveRadius); x <= Math.ceil(effectiveRadius); x++) {
						if (random() < 0.85) {
							const leafCol = col + Math.round(x);
							const leafRow = topOfTrunkRow - yOffset;
							const key = `${leafCol},${leafRow}`;
							if (getBlockType(leafCol, leafRow) === '' && (!worldBlocks[key] || worldBlocks[key].type !== trunkBlockType)) {
								worldBlocks[key] = { type: bushBlockType, mineProg: 0 };
							}
						}
					}
				}
				if (treeType === 'oak' || treeType === 'darkwood') {
					const branchCount = Math.floor(random() * (treeType === 'darkwood' ? 5 : 3));
					for(let i = 0; i < branchCount; i++) {
						const branchY = topOfTrunkRow + 1 - Math.floor(random() * 4);
						const branchDir = random() < 0.5 ? -1 : 1;
						const branchLength = 1 + Math.floor(random() * (treeType === 'darkwood' ? 4 : 2));
						for(let l = 1; l <= branchLength; l++) {
							const branchCol = col + (l * branchDir);
							const branchKey = `${branchCol},${branchY}`;
							if(getBlockType(branchCol, branchY) === '') {
								 worldBlocks[branchKey] = { type: trunkBlockType, mineProg: 0 };
							}
						}
						const leafClusterRadius = 1 + Math.floor(random() * 1.5);
						for (let lx = -leafClusterRadius; lx <= leafClusterRadius; lx++) {
							for (let ly = -leafClusterRadius; ly <= leafClusterRadius; ly++) {
								const leafCol = col + (branchLength * branchDir) + lx;
								if (lx*lx + ly*ly <= leafClusterRadius*leafClusterRadius && random() < 0.9) {
									const leafKey = `${leafCol},${branchY - 1 + ly}`;
									if(getBlockType(leafCol, branchY - 1 + ly) === '' && (!worldBlocks[leafKey] || worldBlocks[leafKey].type !== trunkBlockType)) {
										worldBlocks[leafKey] = { type: bushBlockType, mineProg: 0 };
									}
								}
							}
						}
					}
				}
			} else if (treeType === 'spruce') {
				const canopyBottomRow = topOfTrunkRow + Math.floor(trunkHeight * 0.3);
				for (let r = canopyBottomRow; r >= topOfTrunkRow - 3; r--) {
					let currentCanopyRadius = Math.max(0, Math.floor(maxCanopyRadius - (canopyBottomRow - r) / 1.5));
					for (let x = -currentCanopyRadius; x <= currentCanopyRadius; x++) {
						const leafCol = col + x;
						const key = `${leafCol},${r}`;
						if (getBlockType(leafCol, r) === '' && (!worldBlocks[key] || worldBlocks[key].type !== trunkBlockType)) {
							if (random() < 0.95) {
								worldBlocks[key] = { type: bushBlockType, mineProg: 0 };
							}
						}
					}
				}
			} else if (treeType === 'redwood') {
				const canopyBaseWidth = 8; 
				const taperFactor = 2.2;
				const canopyBottomRow = topOfTrunkRow + Math.floor(trunkHeight * 0.4);
				for (let r = canopyBottomRow; r >= topOfTrunkRow - 3; r--) {
					let currentCanopyRadius = Math.max(0, Math.floor(canopyBaseWidth - (canopyBottomRow - r) / taperFactor));
					for (let x = -currentCanopyRadius; x <= currentCanopyRadius; x++) {
						const leafCol = col + x;
						const key = `${leafCol},${r}`;
						if (getBlockType(leafCol, r) === '' && (!worldBlocks[key] || worldBlocks[key].type !== trunkBlockType)) {
							if (random() < 0.95) {
								worldBlocks[key] = { type: bushBlockType, mineProg: 0 };
							}
						}
					}
				}
			}
		}
        function generateDustPad(startX, startY) {
            const padSize = 30 + Math.floor(random() * 31); 
            let blocksPlaced = 0;
            const toPlace = new Set([`${startX},${startY}`]);
            const placed = new Set();
            while (blocksPlaced < padSize && toPlace.size > 0) {
                const currentKey = Array.from(toPlace)[Math.floor(random() * toPlace.size)];
                toPlace.delete(currentKey);
                if (placed.has(currentKey) || worldBlocks[currentKey]) continue;
                worldBlocks[currentKey] = { type: 'void_dustb', mineProg: 0 };
                placed.add(currentKey);
                blocksPlaced++;
                const [x, y] = currentKey.split(',').map(Number);
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (random() < 0.6) {
                            const nextKey = `${x + dx},${y + dy}`;
                            if (!placed.has(nextKey)) {
                                toPlace.add(nextKey);
                            }
                        }
                    }
                }
            }
        }
		function generateGeode(cx, cy) {
			const radius = 2 + Math.floor(random() * 3); 
			const bboxRadius = radius + 1;
			let placed = false;
			const tries = 5;
			for (let t = 0; t < tries && !placed; t++) {
				const offX = Math.floor((random() - 0.5) * 6); 
				const offY = Math.floor((random() - 0.5) * 6);
				const baseX = cx + offX;
				const baseY = cy + offY;
				let ok = true;
				for (let dx = -bboxRadius; dx <= bboxRadius && ok; dx++) {
					for (let dy = -bboxRadius; dy <= bboxRadius; dy++) {
						const k = `${baseX + dx},${baseY + dy}`;
						if (worldBlocks[k]) { ok = false; break; }
					}
				}
				if (!ok) continue;
				for (let dx = -radius; dx <= radius; dx++) {
					for (let dy = -radius; dy <= radius; dy++) {
						if (Math.hypot(dx, dy) <= radius + 0.2) {
							const px = baseX + dx;
							const py = baseY + dy;
							const k = `${px},${py}`;
							if (!worldBlocks[k]) {
								worldBlocks[k] = { type: 'void_crystal', mineProg: 0 };
							}
						}
					}
				}
				for (let dx = -radius-1; dx <= radius+1; dx++) {
					for (let dy = -radius-1; dy <= radius+1; dy++) {
						const dist = Math.hypot(dx, dy);
						if (dist > radius + 0.9 && dist <= radius + 1.2 && random() < 0.5) {
							const hx = baseX + dx;
							const hy = baseY + dy;
							const hk = `${hx},${hy}`;
							if (!worldBlocks[hk]) worldBlocks[hk] = { type: 'voids', mineProg: 0 };
						}
					}
				}
				placed = true;
			}
		}
		function generateRockArch(startCol, surfaceRow) {
			const archLength = 12 + Math.floor(random() * 24); 
			const peakIndex = Math.floor(archLength * (0.35 + random() * 0.3)); 
			let cx = startCol;
			let cy = surfaceRow - 1;
			const dirX = (random() < 0.5 ? 1 : -1); 
			const verticalWobbleChance = 0.12;
			const extraThicknessChance = 0.25;
			for (let i = 0; i < archLength; i++) {
				if (i < peakIndex) cy -= 1;
				else cy += 1;
				if (random() < verticalWobbleChance) cy += (random() < 0.5 ? -1 : 1);
				cx += dirX;
				let thickness = 1 + (random() < extraThicknessChance ? 1 : 0);
				for (let dx = -thickness; dx <= thickness; dx++) {
					for (let dy = -thickness; dy <= thickness; dy++) {
						if (Math.hypot(dx, dy) > thickness + 0.25) continue;
						const px = cx + dx;
						const py = cy + dy;
						const key = `${px},${py}`;
						if (!worldBlocks[key] || getBlockType(px, py) === '') {
							worldBlocks[key] = { type: 'red_sandstoneb', mineProg: 0 };
						}
					}
				}
			}
			for (let anchor = 0; anchor < 2; anchor++) {
				const endCol = startCol + (dirX * (anchor === 0 ? 0 : archLength - 1));
				const anchorDepth = 0 + Math.floor(random() * 3);
				for (let d = 0; d <= anchorDepth; d++) {
					const key = `${endCol},${surfaceRow + d}`;
					if (!worldBlocks[key] || getBlockType(endCol, surfaceRow + d) === '') {
						worldBlocks[key] = { type: 'red_sandstoneb', mineProg: 0 };
					}
				}
			}
		}
		function generateSpire(centerCol, surfaceRow, blockTyper) {
			const height = 4 + Math.floor(random() * 16); 
			const baseRadius = 1 + Math.floor(random() * 3); 
			const wobbleChance = 0.18;
			redRockColumns.add(centerCol);
			for (let h = 0; h < height; h++) {
				const row = surfaceRow - h;
				const radius = Math.max(0, Math.round(baseRadius * (1 - (h / (height + 1)))));
				const colShift = (random() < wobbleChance) ? (random() < 0.5 ? -1 : 1) : 0;
				const thisCenter = centerCol + colShift;
				for (let dx = -radius; dx <= radius; dx++) {
					for (let dy = -radius; dy <= radius; dy++) {
						if (Math.hypot(dx, dy) > radius + 0.3) continue;
						const px = thisCenter + dx;
						const py = row;
						const key = `${px},${py}`;
						if (!worldBlocks[key] || getBlockType(px, py) === '') {
							worldBlocks[key] = { type: blockTyper, mineProg: 0 };
						}
					}
				}
				if (random() < 0.12) {
					const outCol = thisCenter + (random() < 0.5 ? -1 : 1);
					const outKey = `${outCol},${row}`;
					if (!worldBlocks[outKey] || getBlockType(outCol, row) === '') {
						worldBlocks[outKey] = { type: blockTyper, mineProg: 0 };
					}
				}
			}
		}
		function generateVoidArch(startX, startY) {
			const voidVoidArchLength = 300 + Math.floor(random() * 401); 
			let cx = startX;
			let cy = startY;
			let dirX = (random() < 0.5 ? 1 : -1);
			let dirY = 0;
			const baseThickness = 2;             
			const extraThicknessChance = 0.4;    
			const orePocketChance = 0.08;        
			const orePocketSizeMin = 3;
			const orePocketSizeMax = 8;
			const oreSpawnMultiplier = 2.5;      
			function pickOreType() {
				const weights = [
					['copper_cs', (typeof copperVeinProbability === 'number' ? copperVeinProbability : 0)],
					['tin_cs', (typeof tinVeinProbability === 'number' ? tinVeinProbability : 0)],
					['zinc_cs', (typeof zincVeinProbability === 'number' ? zincVeinProbability : 0)],
					['coal_cs', (typeof deepCoalVeinProbability === 'number' ? deepCoalVeinProbability : 0)],
					['iron_cs', (typeof ironVeinProbability === 'number' ? ironVeinProbability : 0)],
					['tungsten_cs', (typeof tungstenVeinProbability === 'number' ? tungstenVeinProbability : 0)],
					['gold_cs', (typeof goldVeinProbability === 'number' ? goldVeinProbability : 0)],
					['amethyst_cs', (typeof amethystVeinProbability === 'number' ? amethystVeinProbability : 0)],
					['ruby_cs', (typeof rubyVeinProbability === 'number' ? rubyVeinProbability : 0)],
					['sapphire_cs', (typeof sapphireVeinProbability === 'number' ? sapphireVeinProbability : 0)],
					['topaz_cs', (typeof topazVeinProbability === 'number' ? topazVeinProbability : 0)],
					['diamond_cs', (typeof diamondVeinProbability === 'number' ? diamondVeinProbability : 0)],
					['emerald_cs', (typeof emeraldVeinProbability === 'number' ? emeraldVeinProbability : 0)],
					['opal_cs', (typeof opalVeinProbability === 'number' ? opalVeinProbability : 0)],
					['jade_cs', (typeof jadeVeinProbability === 'number' ? jadeVeinProbability : 0)],
				];
				let total = 0;
				for (let i = 0; i < weights.length; i++) {
					weights[i][1] *= oreSpawnMultiplier;
					total += weights[i][1];
				}
				if (total <= 0) return null;
				let r = random() * total;
				for (let i = 0; i < weights.length; i++) {
					if (r < weights[i][1]) return weights[i][0];
					r -= weights[i][1];
				}
				return null;
			}
			function placeOreCluster(ox, oy, size, oreType) {
				let px = ox;
				let py = oy;
				for (let i = 0; i < size; i++) {
					const key = `${px},${py}`;
					if (worldBlocks[key] && worldBlocks[key].type === 'voids') {
						worldBlocks[key] = { type: oreType, mineProg: 0 };
						const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
						for (const n of neighbors) {
							const nk = `${px + n[0]},${py + n[1]}`;
							if (!worldBlocks[nk]) worldBlocks[nk] = { type: 'voids', mineProg: 0 };
							else if (worldBlocks[nk].type !== 'voids' && worldBlocks[nk].type.indexOf('cs') === -1) {
							}
						}
					}
					const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
					const d = dirs[Math.floor(random() * dirs.length)];
					px += d[0]; py += d[1];
				}
			}
			for (let i = 0; i < voidVoidArchLength; i++) {
				if (random() < 0.06) {
					const d = Math.floor(random() * 4);
					if (d === 0) { dirX = 1; dirY = 0; }
					else if (d === 1) { dirX = -1; dirY = 0; }
					else if (d === 2) { dirX = 0; dirY = 1; }
					else { dirX = 0; dirY = -1; }
				}
				cx += dirX;
				cy += dirY;
				let thickness = baseThickness;
				if (random() < extraThicknessChance) thickness += 1 + Math.floor(random() * 2); 
				for (let dx = -thickness; dx <= thickness; dx++) {
					for (let dy = -thickness; dy <= thickness; dy++) {
						if (Math.hypot(dx, dy) > thickness + 0.2) continue;
						const bx = cx + dx;
						const by = cy + dy;
						const key = `${bx},${by}`;
						if (!worldBlocks[key]) {
							worldBlocks[key] = { type: 'voids', mineProg: 0 };
						}
					}
				}
				if (random() < orePocketChance) {
					const oreType = pickOreType();
					if (oreType) {
						const pocketSize = orePocketSizeMin + Math.floor(random() * (orePocketSizeMax - orePocketSizeMin + 1));
						const offX = Math.floor((random() - 0.5) * (thickness - 0.5) * 2);
						const offY = Math.floor((random() - 0.5) * (thickness - 0.5) * 2);
						const ox = cx + offX;
						const oy = cy + offY;
						placeOreCluster(ox, oy, pocketSize, oreType);
					}
				}
				if (random() < 0.04) cy += (random() < 0.5 ? -1 : 1);
			}
		}
        function getBiome(col) {
            if (worldBiomes[col]) {
                return worldBiomes[col].type;
            }
            function selectNextBiome() {
                const biomeRoll = random();
                if (biomeRoll < 0.03) return 'anthill';
                if (biomeRoll < 0.08) return 'overgrown_forest';
                if (biomeRoll < 0.13) return 'apple_grove';
				if (biomeRoll < 0.15) return 'lush_grasslands';
				if (biomeRoll < 0.23) return 'grass_field';
				if (biomeRoll < 0.25) return 'salt_flats';
				if (biomeRoll < 0.30) return 'rainforest';
				if (biomeRoll < 0.34) return 'muddy_swamp';
				if (biomeRoll < 0.54) return 'deciduous_forest';
				if (biomeRoll < 0.68) return 'coniferous_forest';
                if (biomeRoll < 0.80) return 'desert';
				if (biomeRoll < 0.82) return 'icy_hills';
                if (biomeRoll < 0.83) return 'lava_flats';
				if (biomeRoll < 0.88) return 'red_rocks';
				if (biomeRoll < 0.92) return 'redwood_forest';
				if (biomeRoll < 0.94) return 'granite_mountain';
				if (biomeRoll < 0.941) return 'dirt_plateau';
                return 'rocky';
            }
            if (col > lastBiomeEndCol) {
                const biomeType = selectNextBiome();
                const biomeWidth = 40 + Math.floor(random() * 21); 
                const biomeStartCol = lastBiomeEndCol + 1;
                const biomeEndCol = biomeStartCol + biomeWidth - 1;
                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    worldBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                lastBiomeEndCol = biomeEndCol;
            } 
            else if (col < firstBiomeStartCol) {
                const biomeType = selectNextBiome();
                const biomeWidth = 40 + Math.floor(random() * 21); 
                const biomeEndCol = firstBiomeStartCol - 1;
                const biomeStartCol = biomeEndCol - biomeWidth + 1;
                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    worldBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                firstBiomeStartCol = biomeStartCol;
            }
            return worldBiomes[col] ? worldBiomes[col].type : 'deciduous_forest'; 
        }
		function getUnderworldBiome(col) {
            if (underworldBiomes[col]) {
                return underworldBiomes[col].type;
            }
            function selectNextUnderworldBiome() {
				return (r = random()) < 0.5 ? 'hell' : r < 0.6 ? 'golden_city' : r < 0.7 ? 'meat_world' : r < 0.8 ? 'magma_basin' : r < 0.85 ? 'doom_forest' : r < 0.9 ? 'flesh_forest' : 'ash_wastes';
			}
            if (col > lastUnderworldBiomeEndCol) {
                const biomeType = selectNextUnderworldBiome();
                const biomeWidth = 50 + Math.floor(random() * 31); 
                const biomeStartCol = lastUnderworldBiomeEndCol + 1;
                const biomeEndCol = biomeStartCol + biomeWidth - 1;
                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    underworldBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                lastUnderworldBiomeEndCol = biomeEndCol;
            } else if (col < firstUnderworldBiomeStartCol) {
                const biomeType = selectNextUnderworldBiome();
                const biomeWidth = 50 + Math.floor(random() * 31);
                const biomeEndCol = firstUnderworldBiomeStartCol - 1;
                const biomeStartCol = biomeEndCol - biomeWidth + 1;
                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    underworldBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                firstUnderworldBiomeStartCol = biomeStartCol;
            }
            return underworldBiomes[col] ? underworldBiomes[col].type : 'hell'; 
        }
		function getHeavenBiome(col) {
            if (heavenBiomes[col]) {
                return heavenBiomes[col].type;
            }
            function selectNextHeavenBiome() {
                if (random() < 0.1) {
                    return 'gilded_forest';
                } else if (random() < 0.15) {
                    return 'blueglow_forest';
                } else if (random() < 0.35) {
                    return 'debris_flats';
                } else {
					return 'cloudscape'; 
				}
            }
            if (col > lastHeavenBiomeEndCol) {
                const biomeType = selectNextHeavenBiome();
                const biomeWidth = 50 + Math.floor(random() * 31); 
                const biomeStartCol = lastHeavenBiomeEndCol + 1;
                const biomeEndCol = biomeStartCol + biomeWidth - 1;
                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    heavenBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                lastHeavenBiomeEndCol = biomeEndCol;
            } 
            else if (col < firstHeavenBiomeStartCol) {
                const biomeType = selectNextHeavenBiome();
                const biomeWidth = 50 + Math.floor(random() * 31);
                const biomeEndCol = firstHeavenBiomeStartCol - 1;
                const biomeStartCol = biomeEndCol - biomeWidth + 1;
                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    heavenBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                firstHeavenBiomeStartCol = biomeStartCol;
            }
            return heavenBiomes[col] ? heavenBiomes[col].type : 'cloudscape'; 
        }
		function checkAndCreateHeavenPortal(col, row) {
			const portalPatterns = [
				{ 
					frame: [ [0,0], [1,0], [0,-1], [0,-2], [0,-3], [0,-4], [0,-5], [0,-6], [1,-6] ],
					inner: [ [1,-1], [1,-2], [1,-3], [1,-4], [1,-5] ],
					anchorOffset: { col: 1, row: -3 } 
				},
				{ 
					frame: [ [0,0], [1,0], [1,-1], [1,-2], [1,-3], [1,-4], [1,-5], [0,-6], [1,-6] ],
					inner: [ [0,-1], [0,-2], [0,-3], [0,-4], [0,-5] ],
					anchorOffset: { col: 0, row: -3 } 
				}
			];
			for (let offsetX = -1; offsetX <= 0; offsetX++) {
				for (let offsetY = 0; offsetY <= 6; offsetY++) {
					const startCol = col + offsetX;
					const startRow = row + offsetY; 
					for (const pattern of portalPatterns) {
						let isFrameValid = true;
						for (const pos of pattern.frame) {
							if (getBlockType(startCol + pos[0], startRow + pos[1]) !== 'heaven_gate_brickb') {
								isFrameValid = false;
								break;
							}
						}
						if (!isFrameValid) continue; 
						let isInnerEmpty = true;
						for (const pos of pattern.inner) {
							if (getBlockType(startCol + pos[0], startRow + pos[1]) !== '') {
								isInnerEmpty = false;
								break;
							}
						}
						if (!isInnerEmpty) continue;
						for (const pos of pattern.inner) {
							const pCol = startCol + pos[0];
							const pRow = startRow + pos[1];
							worldBlocks[`${pCol},${pRow}`] = { type: 'heaven_portal', mineProg: 0 };
						}
						const portalAnchorCol = startCol + pattern.anchorOffset.col;
						const portalAnchorRow = startRow + pattern.anchorOffset.row;
						const portalAnchorKey = `${portalAnchorCol},${portalAnchorRow}`;
						if (portals.some(p => p.key === portalAnchorKey)) continue;
						portals.push({
							key: portalAnchorKey,
							col: portalAnchorCol, 
							row: portalAnchorRow,
							dim: (portalAnchorRow > SUPER_HEAVEN_Y_OFFSET) ? 'overworld' : 'superHeaven',
							linkedPortalKey: null
						});
						console.log("Super Heaven Portal Activated at:", portalAnchorKey);
						return; 
					}
				}
			}
		}
		function teleportPlayer(fromPortal) {
			const inSuperHeaven = fromPortal.row < SUPER_HEAVEN_Y_OFFSET;
			const destCol = fromPortal.col; 
			const destRow = inSuperHeaven ? fromPortal.row - SUPER_HEAVEN_Y_OFFSET : fromPortal.row + SUPER_HEAVEN_Y_OFFSET;
			player.portalCooldown = 1500; 
			const destKey = `${destCol},${destRow}`;
			let destinationPortal = portals.find(p => p.key === destKey);
			if (!destinationPortal) {
				console.log("No destination portal found. Generating one at", destKey);
				const startCol = destCol - 1;
				const startRow = destRow + 3;
				const pattern = { 
					frame: [ [0,0], [1,0], [0,-1], [0,-2], [0,-3], [0,-4], [0,-5], [0,-6], [1,-6] ],
					inner: [ [1,-1], [1,-2], [1,-3], [1,-4], [1,-5] ]
				};
				for(let x = -1; x <= 2; x++) {
					for(let y = -7; y <= 1; y++) {
						const clearKey = `${startCol + x},${startRow + y}`;
						if(getBlockType(startCol + x, startRow + y) !== 'heaven_gate_brickb') {
							worldBlocks[clearKey] = { type: '', mineProg: 0 };
						}
					}
				}
				for (const pos of pattern.frame) {
					worldBlocks[`${startCol + pos[0]},${startRow + pos[1]}`] = { type: 'heaven_gate_brickb', mineProg: 0 };
				}
				for (const pos of pattern.inner) {
					worldBlocks[`${startCol + pos[0]},${startRow + pos[1]}`] = { type: 'heaven_portal', mineProg: 0 };
				}
				destinationPortal = {
					key: destKey,
					col: destCol, 
					row: destRow,
					dim: inSuperHeaven ? 'overworld' : 'superHeaven',
					linkedPortalKey: fromPortal.key
				};
				portals.push(destinationPortal);
				const sourcePortal = portals.find(p => p.key === fromPortal.key);
				if (sourcePortal) {
					sourcePortal.linkedPortalKey = destKey;
				}
			}
			player.x = ((destinationPortal.col - 1) * tileSize); 
			player.y = (destinationPortal.row * tileSize) - (playerHeight / 2); 
			player.dy = 0; 
			console.log(`Teleported to ${destinationPortal.key}`);
		}
        function getBlockData(col, row) {
			if (worldLimitEnabled) {
				if (col < worldMinX || col > worldMaxX || row < worldMinY || row > worldMaxY) {
					return { type: 'invisible_barrier', mineProg: 0 };
				}
			}
            const key = `${col},${row}`;
            if (worldBlocks[key] !== undefined) {
                return worldBlocks[key];
            }
			const spaceStartHeight = -500;
            if (row < spaceStartHeight && row > -99000) {
                const spaceChunkSize = 300; 
                const chunkIndex = Math.floor(row / spaceChunkSize);
                const chunkKey = `${col},${chunkIndex}`; 
                if (!moonColumns.has(chunkKey)) {
                    moonColumns.add(chunkKey); 
                    if (random() < moonProbability) {
                        const moonCenterY = (chunkIndex * spaceChunkSize) + Math.floor(random() * spaceChunkSize);
                        generateMoon(col, moonCenterY);
                    }
                }
                if (worldBlocks[key]) {
                    return worldBlocks[key];
                }
                return (worldBlocks[key] = { type: ''}); 
            }
            const heavenStartHeight = -145;
            if (row < heavenStartHeight + 25) { 
                let heavenSurfaceHeight;
                if (heavenColumnSurfaceHeights[col] !== undefined) {
                    heavenSurfaceHeight = heavenColumnSurfaceHeights[col];
                } else {
                    let prevSurface = 0;
                     if (heavenColumnSurfaceHeights[col - 1] !== undefined) {
                        prevSurface = heavenColumnSurfaceHeights[col - 1];
                    } else if (heavenColumnSurfaceHeights[col + 1] !== undefined) {
                        prevSurface = heavenColumnSurfaceHeights[col + 1];
                    }
                    const offset = Math.floor(random() * 5) - 2; 
                    let potentialHeight = prevSurface + offset;
                    heavenSurfaceHeight = Math.max(0, Math.min(20, potentialHeight)); 
                    heavenColumnSurfaceHeights[col] = heavenSurfaceHeight;
                }
                const heavenBaseY = heavenStartHeight - heavenSurfaceHeight;
                if (row >= heavenBaseY) {
                    const heavenBiome = getHeavenBiome(col);
                    let blockType;
                    if (heavenBiome === 'gilded_forest' && row < heavenBaseY + 10) { 
                        if (row === heavenBaseY) {
                            blockType = 'gilded_grass_dirtb';
                            if (random() < 0.2) {
                                generateTree(col, heavenBaseY, 'gilded');
                            }
                        } else {
                            blockType = 'gilded_dirtb';
                        }
                        return (worldBlocks[key] = { type: blockType, mineProg: 0 });
                    } else if (heavenBiome === 'blueglow_forest' && row < heavenBaseY + 15) { 
                        if (row === heavenBaseY) {
							if (random() < 0.05) {
								blockType = 'blueglow_grass_soilb';
							} else {
								blockType = 'blueglow_grass_dirtb';
							}
                            if (random() < 0.2) {
                                generateTree(col, heavenBaseY, 'blueglow');
                            }
                        } else {
                            if (random() < 0.05) {
								blockType = 'blueglow_soilb';
							} else {
								blockType = 'blueglow_dirtb';
							}
                        }
                        return (worldBlocks[key] = { type: blockType, mineProg: 0 });
                    } else if (heavenBiome === 'debris_flats' && row < heavenBaseY + 10) { 
                        if (row === heavenBaseY) {
                            if (random() < 0.005) {
                                blockType = 'pure_heaven_debrisb';
                            }
							else if (random() < 0.05) {
                                blockType = 'strong_heaven_debrisb';
                            }
							else if (random() < 0.2) {
                                blockType = 'ancient_heaven_debrisb';
                            }
							else {
                                blockType = 'corroded_heaven_debrisb';
                            }
                        } else {
                            if (random() < 0.005) {
                                blockType = 'pure_heaven_debrisb';
                            }
							else if (random() < 0.035) {
                                blockType = 'strong_heaven_debrisb';
                            }
							else if (random() < 0.2) {
                                blockType = 'ancient_heaven_debrisb';
                            }
							else {
                                blockType = 'corroded_heaven_debrisb';
                            }
                        }
                        return (worldBlocks[key] = { type: blockType, mineProg: 0 });
                    } else { 
                        const houseChunk = Math.floor(col / 50);
                        const housePos = houseChunk * 50 + 25;
                        const houseWidth = 10;
                        const houseHeight = 6;
                        if (col >= housePos && col < housePos + houseWidth && row < heavenBaseY + houseHeight && row >= heavenBaseY) {
                             const houseX = col - housePos;
                             const houseY = row - heavenBaseY;
                             if (houseX === 0 || houseX === houseWidth - 1 || houseY === 0) {
                                 return (worldBlocks[key] = { type: 'heaven_brickb', mineProg: 0 });
                             } else {
                                  return (worldBlocks[key] = { type: '', mineProg: 0 });
                             }
                        }
                        if (random() < 0.0005) {
                            return (worldBlocks[key] = { type: 'heavensteel_cloudb', mineProg: 0 });
                        }
                        if (random() < 0.003) {
                            return (worldBlocks[key] = { type: 'diviniron_cloudb', mineProg: 0 });
                        }
                        if (random() < 0.1) {
                            return (worldBlocks[key] = { type: 'cloud_rockb', mineProg: 0 });
                        }
                        else {
                            return (worldBlocks[key] = { type: 'cloudb', mineProg: 0 });
                        }
                    }
                }
            }
			const superHeavenStartHeight = SUPER_HEAVEN_Y_OFFSET; 
			if (row < superHeavenStartHeight + 25) { 
				let heavenSurfaceHeight; 
				if (superHeavenColumnSurfaceHeights[col] !== undefined) {
					heavenSurfaceHeight = superHeavenColumnSurfaceHeights[col];
				} else {
					let prevSurface = 0;
					if (superHeavenColumnSurfaceHeights[col - 1] !== undefined) {
						prevSurface = superHeavenColumnSurfaceHeights[col - 1];
					} else if (superHeavenColumnSurfaceHeights[col + 1] !== undefined) {
						prevSurface = superHeavenColumnSurfaceHeights[col + 1];
					}
					const offset = Math.floor(random() * 5) - 2; 
					let potentialHeight = prevSurface + offset;
					heavenSurfaceHeight = Math.max(0, Math.min(20, potentialHeight)); 
					superHeavenColumnSurfaceHeights[col] = heavenSurfaceHeight;
				}
				const heavenBaseY = superHeavenStartHeight - heavenSurfaceHeight;
				if (row >= heavenBaseY) {
					const heavenBiome = getHeavenBiome(col); 
					let blockType;
						const houseChunk = Math.floor(col / 50);
						const housePos = houseChunk * 50 + 25;
						const houseWidth = 10;
						const houseHeight = 6;
						if (col >= housePos && col < housePos + houseWidth && row < heavenBaseY + houseHeight && row >= heavenBaseY) {
							const houseX = col - housePos;
							const houseY = row - heavenBaseY;
							if (houseX === 0 || houseX === houseWidth - 1 || houseY === 0) {
								return (worldBlocks[key] = { type: 'heaven_brickb', mineProg: 0 });
							} else {
								return (worldBlocks[key] = { type: '', mineProg: 0 });
							}
						}
						if (random() < 0.3)    return (worldBlocks[key] = { type: 'gold_brickb', mineProg: 0 });
						return (worldBlocks[key] = { type: 'cloudb', mineProg: 0 });
				}
			}
            const biome = getBiome(col);
            let surfaceHeight;
            if (columnSurfaceHeights[col] !== undefined) {
                surfaceHeight = columnSurfaceHeights[col];
            } else {
                let prevSurface = baseSurfaceLevel + Math.floor(surfaceLevelRange / 2);
                if (columnSurfaceHeights[col - 1] !== undefined) {
                    prevSurface = columnSurfaceHeights[col - 1];
                } else if (columnSurfaceHeights[col + 1] !== undefined) {
                     prevSurface = columnSurfaceHeights[col + 1];
                }
                const offset = Math.floor(random() * 3) - 1;
                let potentialHeight = prevSurface + offset;
                surfaceHeight = Math.max(baseSurfaceLevel + minSurfaceVariation, Math.min(baseSurfaceLevel + maxSurfaceVariation, potentialHeight));
                columnSurfaceHeights[col] = surfaceHeight;
                if (random() < skyIslandProbability && !skyIslandColumns.has(col)) {
                    const islandCenterY = surfaceHeight - 60 - Math.floor(random() * 20);
                    generateSkyIsland(col, islandCenterY);
                }
                if (random() < watchtowerProbability && !watchtowerColumns.has(col)) {
                    generateWatchtower(col, surfaceHeight);
                }
                if (random() < powertowerProbability && !watchtowerColumns.has(col)) {
                    generatePowertower(col, surfaceHeight);
                }
				if (random() < chasmProbability && !chasmColumns.has(col)) {
					generateChasm(col, surfaceHeight);
				}
				if ( (biome === 'rainforest')
					 && random() < jungleTempleProbability
					 && !jungleTempleColumns.has(col) ) {
				  generateJungleTemple(col, surfaceHeight);
				}
				const suitableBiomesForMineChamber = ['deciduous_forest', 'grass_field', 'coniferous_forest', 'rocky', 'icy_hills'];
                if (suitableBiomesForMineChamber.includes(biome) && random() < mineChamberProbability && !mineChamberColumns.has(col)) {
                    generateMineChamber(col, surfaceHeight);
                }
				if (biome === 'grass_field' && random() < plantationProbability && !plantationColumns.has(col)) {
                    generatePlantation(col, surfaceHeight);
                }
				if (biome === 'red_rocks') {
					if (!redRockColumns.has(col) && random() < 0.02 && getBlockType(col, surfaceHeight - 1) === '') {
						generateRockArch(col, surfaceHeight);
						for (let r = -6; r <= 6; r++) redRockColumns.add(col + r);
					}
					if (!redRockColumns.has(col) && random() < 0.06 && getBlockType(col, surfaceHeight - 1) === '') {
						const spawnCol = col + (Math.floor(random() * 3) - 1);
						generateSpire(spawnCol, surfaceHeight, 'red_sandstoneb');
						for (let r = -3; r <= 3; r++) redRockColumns.add(spawnCol + r);
					}
				}
				if (biome === 'icy_hills') {
					if (!icyHillColumns.has(col) && random() < 0.06 && getBlockType(col, surfaceHeight - 1) === '') {
						const spawnCol = col + (Math.floor(random() * 3) - 1);
						generateSpire(spawnCol, surfaceHeight, 'iceb');
						for (let r = -3; r <= 3; r++) icyHillColumns.add(spawnCol + r);
					}
				}
				if (biome === 'granite_mountain') {
					if (!graniteMountainColumns.has(col) && random() < 0.08 && getBlockType(col, surfaceHeight - 1) === '') {
						const spawnCol = col + (Math.floor(random() * 3) - 1);
						generateSpire(spawnCol, surfaceHeight, 'granite');
						for (let r = -3; r <= 3; r++) graniteMountainColumns.add(spawnCol + r);
					}
				}
            }
            let blockType;
            const depth = row - surfaceHeight;
            if (depth < 0) {
                blockType = '';
            } else {
                if (biome === 'deciduous_forest') {
                    if (depth === 0) blockType = blockType = (random() < 0.05) ? 'gs' : 'gd';
                    else if (depth >= 1 && depth <= 9) blockType = (random() < 0.01) ? 'seed_dirtb' : blockType = (random() < 0.06) ? 'so' : 'd';
                } if (biome === 'grass_field') {
                    if (depth === 0) blockType = blockType = (random() < 0.1) ? 'gs' : 'gd';
                    else if (depth >= 1 && depth <= 9) blockType = (random() < 0.02) ? 'seed_dirtb' : blockType = (random() < 0.12) ? 'so' : 'd';
                } else if (biome === 'lush_grasslands') {
                    if (depth === 0) blockType = blockType = (random() < 0.4) ? (random() < 0.4) ? 'overgrown_grasss' : 'overgrown_grasss' : (random() < 0.4) ? blockType = (random() < 0.4) ? 'overgrown_grass_mud' : 'grass_mud' : blockType = (random() < 0.4) ? 'gs' : 'gd';
                    else if (depth >= 1 && depth <= 9) blockType = (random() < 0.4) ? 'so' : blockType = (random() < 0.2) ? blockType = (random() < 0.1) ? 'f' : 'mud' : 'd';
                } else if (biome === 'coniferous_forest') {
                    if (depth === 0) blockType = random() < 0.25 ? 'taiga_grass_dirt_block_2' : 'taiga_grass_dirt_block_1';
                    else if (depth >= 1 && depth <= 9) blockType = 'taigad';
                } else if (biome === 'rocky') {
                    if (depth >= 0 && depth <= 9) blockType = (random() < 0.03) ? 'packed_iceb' : 'rockb';
                } else if (biome === 'muddy_swamp') {
                    if (depth === 0) blockType = (random() < 0.5) ? 'thick_mud' : 'mud';
                    else if (depth >= 1 && depth <= 4) blockType = (random() < 0.7) ? 'thick_mud' : 'mud'
					else if (depth >= 5 && depth <= 9) blockType = (random() < 0.9) ? 'thick_mud' : 'mud'
                } else if (biome === 'lava_flats') {
                    if (depth >= 0 && depth <= 9) blockType = (random() < 0.02) ? 'ashb' : (random() < 0.1) ? 'cs' : 'magma_stoneb';
                } else if (biome === 'salt_flats') {
                    if (depth >= 0 && depth <= 9) blockType = (random() < 0.03) ? 'limestone' : 'salt_rockb';
                } else if (biome === 'icy_hills') {
                    if (depth >= 0 && depth <= 9) blockType = (random() < 0.1) ? 'iceb' : 'packed_iceb';
                } else if (biome === 'desert') {
                    if (depth >= 0 && depth <= 9) blockType = 'sand';
                } else if (biome === 'red_rocks') {
                    if (depth === 0) blockType = random() < 0.2 ? 'red_sandb' : 'red_sandstoneb';
                    else if (depth >= 1 && depth <= 9) blockType = random() < 0.2 ? 'red_sandb' : 'red_sandstoneb';
                } else if (biome === 'redwood_forest') {
                    if (depth === 0) blockType = 'taiga_grass_dirt_block_1';
                    else if (depth >= 1 && depth <= 9) blockType = random() < 0.006 ? 'limestone' : random() < 0.006 ? 'schist' : 'taigad'
                } else if (biome === 'granite_mountain') {
                    if (depth >= 0 && depth <= 9) blockType = (random() < 0.004) ? 'aluminum_granite' : (random() < 0.001) ? 'iron_granite' : 'granite';
                } else if (biome === 'dirt_plateau') {
                    if (depth >= 0 && depth <= 9) blockType = 'd';
                } else if (biome === 'anthill') {
                    if (depth >= 0 && depth <= 9) { 
                        const blockRoll = random();
                        if (blockRoll < 0.88) blockType = 'anthill_sandb';       
                        else if (blockRoll < 0.92) blockType = '';                 
                        else if (blockRoll < 0.96) blockType = 'sand';          
                        else if (blockRoll < 0.999) blockType = 'sandstone';    
                        else blockType = 'colony_heart_sandb';                   
                    }
                    if (blockType === 'anthill_sandb' && random() < antLarvaVeinProbability) {
                        generateVein(col, row, 'ant_larvab', 6, 8, 'anthill_sandb');
                        blockType = 'ant_larvab';
                    }
                } else if (biome === 'overgrown_forest') {
                    if (depth === 0) blockType = random() < 0.3 ? 'weedd' : 'dark_mossd';
                    else if (depth >= 1 && depth <= 9) {
                        const subRoll = random();
                        if (subRoll < 0.6) blockType = 'd';
                        else if (subRoll < 0.8) blockType = 'mud';
                        else if (subRoll < 0.95) blockType = 'pestd';
                        else blockType = 'rdarkwood';
                    }
                } else if (biome === 'apple_grove') {
                    if (depth === 0) blockType = random() < 0.05 ? 'dark_grasss' : 'dark_grassd';
                    else if (depth >= 1 && depth <= 9) blockType = (random() < 0.01) ? 'seed_dirtb' : blockType = (random() < 0.06) ? 'so' : 'd';
                } else if (biome === 'rainforest') {
                    if (depth === 0) {
						const b = random();
						if (b < 0.9) blockType = 'surface_mud';
						else blockType = 'mud';
					} else if (depth >= 1 && depth <= 9) {
						const b = random();
						if (b < 0.99) blockType = 'mud';
						else blockType = 'so';
					}
                }
				if (!blockType) {
					if (depth >= 10 && depth <= 19) {
						blockType = 's';
					} else if (depth === 20) {
						blockType = 'compactings';
					} else if (depth >= 21 && depth <= 199) {
						blockType = 'cs';
					} else if (depth >= 200 && depth <= 205) {
						blockType = 'cps';
					} else if (depth >= 206 && depth <= 299) {
						blockType = '';
					}
					else if (depth >= 300 && depth < 600) {
						const underworldBiome = getUnderworldBiome(col);
						if (underworldBiome === 'golden_city' && depth < 315) {
							if (depth === 300) blockType = 'gilded_grass_dirtb';
							else blockType = 'gilded_dirtb';
						} else if (underworldBiome === 'meat_world' && depth < 315) {
							if (depth === 300) {
								const b = random();
								if (b < 0.6) blockType = 'meatb';
								else if (b < 0.95) blockType = 'spoiled_meatb';
								else blockType = 'fleshb';
							} else {
								const b = random();
								if (b < 0.7) blockType = 'meatb';
								else if (b < 0.95) blockType = 'spoiled_meatb';
								else blockType = 'fleshb';
							}
						} else if (underworldBiome === 'doom_forest' && depth < 315) {
							if (depth === 300) {
								blockType = 'doom_hellstone';
							} else {
								blockType = 'hellstone';
							}
						} else if (underworldBiome === 'flesh_forest' && depth < 315) {
							if (depth === 300) {
								blockType = 'flesh_hellstone';
							} else {
								blockType = 'hellstone';
							}
						} else if (underworldBiome === 'ash_wastes' && depth < 315) {
							if (depth === 300) {
								const b = random();
								if (b < 0.8) blockType = 'ashb';
								else blockType = 'obsidianb';
							} else {
								const b = random();
								if (b < 0.8) blockType = 'ashb';
								else blockType = 'obsidianb';
							}
						} else if (underworldBiome === 'magma_basin' && depth < 315) {
							if (depth === 300) {
								const b = random();
								if (b < 0.9) blockType = 'magma_stoneb';
								else blockType = 'obsidianb';
							} else {
								const b = random();
								if (b < 0.9) blockType = 'magma_stoneb';
								else blockType = 'obsidianb';
							}
						} else {
							const b = random();
								if (b < 0.05) blockType = 'hellrock';
								else if (b < 0.08) blockType = 'magma_stoneb';
								else blockType = 'hellstone';
						}
					}
					else if (depth >= 600 && depth < 900) {
						const entranceCenter = (typeof player !== 'undefined' && player && typeof tileSize !== 'undefined')
							? Math.floor(player.x / tileSize)
							: 0;
						const entranceLeft = entranceCenter - Math.floor(13 / 2);
						const entranceRight = entranceCenter + Math.floor(13 / 2);
						if (depth >= 600 && depth < 600 + 5) {
							blockType = 'bedrocks';
						} else {
							blockType = '';
							if (!voidRealmColumns.has(col)) {
								voidRealmColumns.add(col);
								const spawnY = surfaceHeight + 600 + 10 + Math.floor(random() * (900 - 600 - 20)); 
								const r = random();
								if (r < 0.03) {
									generateGeode(col, spawnY);
								}
								else if (r < 0.2) {
									generateVoidArch(col, spawnY);
								}
								else if (r < 0.8) {
									generateDustPad(col, spawnY);
								}
								else {
									if (random() < 0.02) {
										generateDustPad(col + (random() < 0.5 ? -1 : 1), spawnY + (Math.floor(random() * 5) - 2));
									}
								}
							}
						}
					}
					else if (depth >= 900 && depth < 1200) {
						const b = random();
						if (b < 0.005) blockType = 'iron_cps';
						else if (b < 0.008) blockType = 'aluminum_cps';
						else if (b < 0.0085) blockType = 'palladium_cps';
						else if (b < 0.03) blockType = 'coal_cps';
						else blockType = 'cps';
					}
					else if (depth >= 1200 && depth < 1225) {
						const b = random();
						blockType = 'outer_mantle_moltens';
					}
					else if (depth >= 1225 && depth < 1250) {
						const b = random();
						blockType = 'inner_mantle_moltens';
					}
					else if (depth >= 1250 && depth < 1300) {
						const b = random();
						blockType = 'core_moltens';
					}
					else if (depth >= 1300 && depth < 1305) {
						const b = random();
						blockType = 'bedrocks';
					}
					else if (depth >= 1305 && depth < 1500) {
						const b = random();
						if (b < 0.01) blockType = 'vines';
						else blockType = '';
					}
					else if (depth >= 1500) {
						const b = random();
						blockType = 'vines';
					}
				}
                if (biome === 'desert' && blockType === 'sand' && random() < 0.2) {
                    blockType = 'sandstone';
                }
                if (biome === 'overgrown_forest' && blockType === 's' && random() < 0.15) {
                    blockType = random() < 0.6 ? 'pest_stone_block_weak' : 'pest_stone_block_strong';
                }
            }
            if (blockType === 's' && random() < gravelVeinProbability) {
                 blockType = 'gravel';
            }
            if (blockType === 'cs') {
                if (random() < dungeonProbability) {
                    generateDungeon(col, row);
                    blockType = worldBlocks[key] ? worldBlocks[key].type : getBlockType(col, row);
                } else if (random() < mineshaftProbability) {
                    generateMineshaft(col, row);
                    blockType = worldBlocks[key] ? worldBlocks[key].type : getBlockType(col, row);
                } else if (random() < lavaCaveProbability) { 
                    generateLavaCave(col, row);
                    blockType = worldBlocks[key] ? worldBlocks[key].type : '';
                } else if (random() < caveProbability) {
                    generateCave(col, row);
                    blockType = worldBlocks[key] ? worldBlocks[key].type : '';
                } else if (random() < bunkerProbability && !bunkerColumns.has(col)) { 
                    generateBunker(col, row);
                    blockType = worldBlocks[key] ? worldBlocks[key].type : getBlockType(col, row);
                }
            }
            let isNearCave = false;
            if (row > baseSurfaceLevel + 25) { 
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        if (caveBlocks.has(`${col + dx},${row + dy}`)) {
                            isNearCave = true;
                            break;
                        }
                    }
                    if (isNearCave) break;
                }
            }
            const oreSpawnMultiplier = isNearCave ? 2 : 1;
            if (blockType === 's' && random() < coalVeinProbability * oreSpawnMultiplier) {
                blockType = 'coals';
            }
			if (blockType === 's' && random() < stumpStoneVeinProbability * oreSpawnMultiplier) {
                blockType = 'stumps';
            }
			if (blockType === 's' && random() < limestoneVeinProbability * oreSpawnMultiplier) {
                blockType = 'limestone';
            }
			if (blockType === 's' && random() < surfaceIronVeinProbability * oreSpawnMultiplier) {
                blockType = 'irons';
            }
            if (blockType === 'cs') {
                const veinRoll = random();
                if (veinRoll < graniteVeinProbability) {
                    generateVein(col, row, 'granite', 8, 12, 'cs');
                    blockType = 'granite';
                } else if (veinRoll < graniteVeinProbability + schistVeinProbability) {
                    generateVein(col, row, 'schist', 8, 12, 'cs');
                    blockType = 'schist';
                } else if (veinRoll < graniteVeinProbability + schistVeinProbability + slateVeinProbability) {
                    generateVein(col, row, 'slate', 8, 12, 'cs');
                    blockType = 'slate';
                } else if (veinRoll < graniteVeinProbability + schistVeinProbability + slateVeinProbability + rockVeinProbability) {
                    generateVein(col, row, 'rockb', 4, 12, 'cs');
                    blockType = 'rockb';
                } else if (veinRoll < graniteVeinProbability + schistVeinProbability + slateVeinProbability + rockVeinProbability + saltVeinProbability) {
                    generateVein(col, row, 'salt_rockb', 4, 12, 'cs');
                    blockType = 'salt_rockb';
                }
            }
            if (blockType === 'cs') {
                if (depth >= 21) { 
                    if (random() < copperVeinProbability * oreSpawnMultiplier) blockType = 'copper_cs';
                    else if (random() < tinVeinProbability * oreSpawnMultiplier) blockType = 'tin_cs';
					else if (random() < zincVeinProbability * oreSpawnMultiplier) blockType = 'zinc_cs';
					else if (random() < deepCoalVeinProbability * oreSpawnMultiplier) blockType = 'coal_cs';
                } 
                if (depth >= 35) { 
                    if (random() < ironVeinProbability * oreSpawnMultiplier) blockType = 'iron_cs';
                } 
                if (depth >= 45) { 
                    if (random() < goldVeinProbability * oreSpawnMultiplier) blockType = 'gold_cs';
					else if (random() < tungstenVeinProbability * oreSpawnMultiplier) blockType = 'tungsten_cs';
                } 
                if (depth >= 60) { 
                    if (random() < amethystVeinProbability * oreSpawnMultiplier) blockType = 'amethyst_cs';
                    else if (random() < rubyVeinProbability * oreSpawnMultiplier) blockType = 'ruby_cs';
                    else if (random() < sapphireVeinProbability * oreSpawnMultiplier) blockType = 'sapphire_cs';
                    else if (random() < topazVeinProbability * oreSpawnMultiplier) blockType = 'topaz_cs';
                }
                if (depth >= 60) {
                     if (random() < diamondVeinProbability * oreSpawnMultiplier) blockType = 'diamond_cs';
                     else if (random() < emeraldVeinProbability * oreSpawnMultiplier) blockType = 'emerald_cs';
                }
                if (depth >= 65) {
                    if (random() < opalVeinProbability * oreSpawnMultiplier) blockType = 'opal_cs';
					else if (random() < jadeVeinProbability * oreSpawnMultiplier) blockType = 'jade_cs';
                }
            }
			if (blockType === 'hellstone') {
                if (random() < hellsteelVeinProbability * oreSpawnMultiplier) {
                    blockType = 'hellsteel_hellstone';
                } else if (random() < mighterrumVeinProbability * oreSpawnMultiplier) {
                    blockType = 'mighterrum_hellstone';
                } else if (random() < obsidianVeinProbability) {
                    generateVein(col, row, 'obsidianb', 3, 5, 'hellstone');
                    blockType = 'obsidianb';
                } else if (random() < boneSpineProbability) {
                    generateSpinalVein(col, row, 'boneb', 20, 30);
                    blockType = 'boneb';
                }
            }
            if (depth === 0) { 
                if (biome === 'deciduous_forest') {
                    if (getBlockType(col, row - 1) === '') {
						if (random() < 0.02) worldBlocks[`${col},${row - 1}`] = { type: 'red_flower', mineProg: 0 };
						else if (random() < 0.05) worldBlocks[`${col},${row - 1}`] = { type: 'yellow_flower', mineProg: 0 };
						else if (random() < 0.08) worldBlocks[`${col},${row - 1}`] = { type: 'leaf_plant', mineProg: 0 };
                        else if (random() < 0.18) worldBlocks[`${col},${row - 1}`] = { type: 'tall_grass', mineProg: 0 };
                        else if (random() < 0.35) worldBlocks[`${col},${row - 1}`] = { type: 'grass', mineProg: 0 };
                    }
                    if (random() < 0.15 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, random() < 0.66 ? 'oak' : 'birch');
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'grass_field') {
                    if (getBlockType(col, row - 1) === '') {
						if (random() < 0.02) worldBlocks[`${col},${row - 1}`] = { type: 'red_flower', mineProg: 0 };
						else if (random() < 0.05) worldBlocks[`${col},${row - 1}`] = { type: 'yellow_flower', mineProg: 0 };
						else if (random() < 0.06) worldBlocks[`${col},${row - 1}`] = { type: 'blue_flower', mineProg: 0 };
                        else if (random() < 0.40) worldBlocks[`${col},${row - 1}`] = { type: 'tall_grass', mineProg: 0 };
						else if (random() < 0.55) worldBlocks[`${col},${row - 1}`] = { type: 'grass_sprouts', mineProg: 0 };
                        else worldBlocks[`${col},${row - 1}`] = { type: 'grass', mineProg: 0 };
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'lush_grasslands') {
                    if (getBlockType(col, row - 1) === '') {
						if (random() < 0.5) worldBlocks[`${col},${row - 1}`] = { type: 'tall_grass', mineProg: 0 };
						else if (random() < 0.6) worldBlocks[`${col},${row - 1}`] = { type: 'grass_sprouts', mineProg: 0 };
						else worldBlocks[`${col},${row - 1}`] = { type: 'grass', mineProg: 0 };
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'coniferous_forest') {
                    if (getBlockType(col, row - 1) === '') {
                        if (random() < 0.05) worldBlocks[`${col},${row - 1}`] = { type: 'pinecone_pile', mineProg: 0 };
                        else if (random() < 0.3) worldBlocks[`${col},${row - 1}`] = { type: 'pine_needle_pile', mineProg: 0 };
                    }
                    if (random() < 0.18 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'spruce');
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'apple_grove') {
                    if (getBlockType(col, row - 1) === '') {
                        if (random() < 0.5) worldBlocks[`${col},${row - 1}`] = { type: 'grass', mineProg: 0 };
                    }
                    if (random() < 0.12 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'apple');
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'rainforest') {
                    if (getBlockType(col, row - 1) === '') {
                        if (random() < 0.02) worldBlocks[`${col},${row - 1}`] = { type: 'mossy_root', mineProg: 0 };
                        else if (random() < 0.16) worldBlocks[`${col},${row - 1}`] = { type: 'leaf_pile', mineProg: 0 };
						else if (random() < 0.22) worldBlocks[`${col},${row - 1}`] = { type: 'dark_moss', mineProg: 0 };
						else if (random() < 0.24) worldBlocks[`${col},${row - 1}`] = { type: 'moss', mineProg: 0 };
						else if (random() < 0.30) worldBlocks[`${col},${row - 1}`] = { type: 'fern', mineProg: 0 };
                    }
                    if (random() < 0.35 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, random() < 0.5 ? 'mahogany' : random() < 0.3 ? 'cinnamon' : 'rubber');
                    }
					if (random() < 0.15 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'fern');
                    } else if (random() < 0.25 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'sugarcane');
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'overgrown_forest') { 
                    if (getBlockType(col, row - 1) === '') {
                        const foliageRoll = random();
                        if (foliageRoll < 0.1) worldBlocks[`${col},${row - 1}`] = { type: 'grass', mineProg: 0 };
                        else if (foliageRoll < 0.2) worldBlocks[`${col},${row - 1}`] = { type: 'weed', mineProg: 0 };
                        else if (foliageRoll < 0.3) worldBlocks[`${col},${row - 1}`] = { type: 'shroom', mineProg: 0 };
                        else if (foliageRoll < 0.5) worldBlocks[`${col},${row - 1}`] = { type: 'dark_moss', mineProg: 0 };
                        else if (foliageRoll < 0.7) worldBlocks[`${col},${row - 1}`] = { type: 'moss', mineProg: 0 };
						else if (foliageRoll < 0.75) worldBlocks[`${col},${row - 1}`] = { type: 'big_shroom', mineProg: 0 };
						else if (foliageRoll < 0.76) worldBlocks[`${col},${row - 1}`] = { type: 'devil_shroom', mineProg: 0 };
                    }
                    if (random() < 0.24 && getBlockType(col, row - 1) === '') { 
                        generateTree(col, row, 'darkwood');
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'rocky') {
                    if (getBlockType(col, row - 1) === '') {
                        if (random() < 0.2) worldBlocks[`${col},${row - 1}`] = { type: 'large_snow_pile', mineProg: 0 };
                        else worldBlocks[`${col},${row - 1}`] = { type: 'snow', mineProg: 0 };
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'salt_flats') {
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'lava_flats') {
                    if (random() < 0.32 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'magma');
                    }
                } else if (biome === 'icy_hills') {
                    if (getBlockType(col, row - 1) === '') {
                        if (random() < 0.3) worldBlocks[`${col},${row - 1}`] = { type: 'large_snow_pile', mineProg: 0 };
                        else worldBlocks[`${col},${row - 1}`] = { type: 'snow', mineProg: 0 };
                    }
                } else if (biome === 'desert') {
                    if (blockType === 'sand' && getBlockType(col, row - 1) === '') {
                        const foliageRoll = random();
                        if (foliageRoll < cactusProbability) generateCactus(col, row);
                        else if (foliageRoll < 0.20) worldBlocks[`${col},${row - 1}`] = { type: 'prickly_pear_cactus', mineProg: 0 };
                        else if (foliageRoll < 0.40) worldBlocks[`${col},${row - 1}`] = { type: 'desert_brush', mineProg: 0 };
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'red_rocks') {
                    if (getBlockType(col, row - 1) === '') {
                        if (random() < 0.2) worldBlocks[`${col},${row - 1}`] = { type: 'desert_grass', mineProg: 0 };
                    }
                } else if (biome === 'redwood_forest') {
                    if (getBlockType(col, row - 1) === '') {
                        if (random() < 0.3) worldBlocks[`${col},${row - 1}`] = { type: 'fern', mineProg: 0 };
                        else if (random() < 0.6) worldBlocks[`${col},${row - 1}`] = { type: 'pine_needle_pile', mineProg: 0 };
                    }
                    if (random() < 0.18 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'redwood');
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'anthill') {
                     if (blockType === 'anthill_sandb' && getBlockType(col, row - 1) === '' && random() < anthillMoundProbability) {
                        worldBlocks[`${col},${row - 1}`] = { type: 'anthill_sand_mound', mineProg: 0 };
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'granite_mountain') {
                    if (random() < 0.3 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'spruce');
                    } else if (random() < 0.6 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'granite');
                    }
                } else if (biome === 'dirt_plateau') {
                    if (random() < 1 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'dirt_column');
                    }
                }
            }
			if (blockType === 'hellstone' && depth === 300 && random() < 0.05) {
				generateTree(col, row, 'hell');
			}
            if (blockType === 'gilded_grass_dirtb' && depth === 300 && random() < 0.2) {
                generateTree(col, row, 'gilded');
            }
			if (blockType === 'meatb' && depth === 300 && random() < 0.2) {
                generateTree(col, row, 'meat');
            }
			if (blockType === 'spoiled_meatb' && depth === 300 && random() < 0.2) {
                generateTree(col, row, 'spoiled_meat');
            }
			if (blockType === 'ashb' && depth === 300 && random() < 0.2) {
                generateTree(col, row, 'ash');
            }
			if (blockType === 'magma_stoneb' && depth === 300 && random() < 0.2) {
                generateTree(col, row, 'magma');
            }
            const newBlockData = { type: blockType, mineProg: 0 };
            worldBlocks[key] = newBlockData;
            return newBlockData;
        }
        function generateVein(startX, startY, veinBlockType, minSize, maxSize, replaceBlock) {
            const veinSize = minSize + Math.floor(random() * (maxSize - minSize + 1));
            for (let i = 0; i < veinSize; i++) {
                const vCol = startX + Math.floor(random() * 3) - 1;
                const vRow = startY + Math.floor(random() * 3) - 1;
                const vKey = `${vCol},${vRow}`;
                const existingBlock = getBlockType(vCol, vRow);
                if (existingBlock === replaceBlock) {
                     worldBlocks[vKey] = { type: veinBlockType, mineProg: 0 };
                }
            }
        }
        function generateSpinalVein(startX, startY, veinBlockType, minLength, maxLength) {
            const length = minLength + Math.floor(random() * (maxLength - minLength + 1));
            let currentX = startX;
            let currentY = startY;
            let directionX = random() < 0.5 ? 1 : -1;
            for (let i = 0; i < length; i++) {
                worldBlocks[`${currentX},${currentY}`] = { type: veinBlockType, mineProg: 0 };
                if (i % 2 === 0) {
                    worldBlocks[`${currentX},${currentY - 1}`] = { type: veinBlockType, mineProg: 0 };
                    worldBlocks[`${currentX},${currentY + 1}`] = { type: veinBlockType, mineProg: 0 };
                    if (random() < 0.5) {
                         worldBlocks[`${currentX},${currentY - 2}`] = { type: veinBlockType, mineProg: 0 };
                         worldBlocks[`${currentX},${currentY + 2}`] = { type: veinBlockType, mineProg: 0 };
                    }
                }
                if (random() < 0.2) directionX *= -1;
                if (random() < 0.4) currentY += (random() < 0.5 ? 1 : -1);
                currentX += directionX;
            }
        }
        function generateCave(startX, startY) {
            console.log("Cave Generated");
			const caveSize = 100 + Math.floor(random() * 101); 
            let blocksCarved = 0;
            const toCarve = new Set([`${startX},${startY}`]);
            const carved = new Set();
            while (blocksCarved < caveSize && toCarve.size > 0) {
                const currentKey = Array.from(toCarve)[Math.floor(random() * toCarve.size)];
                toCarve.delete(currentKey);
                if (carved.has(currentKey)) continue;
                const [x, y] = currentKey.split(',').map(Number);
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const carveX = x + dx;
                        const carveY = y + dy;
                        const key = `${carveX},${carveY}`;
                        if (carveY < baseSurfaceLevel + 25) continue; 
                        const originalBlock = getBlockType(carveX, carveY);
                        if(originalBlock !== '') {
                            worldBlocks[key] = { type: 'vines', mineProg: 0 };
                        }
                        if (dx === 0 && dy === 0) {
                             worldBlocks[key] = { type: '', mineProg: 0 };
                             caveBlocks.add(key); 
                             carved.add(key);
                             blocksCarved++;
                        }
                    }
                }
                for (let i = 0; i < 4; i++) { 
                    if (random() < 0.6) { 
                        const direction = Math.floor(random() * 4);
                        let nextX = x, nextY = y;
                        if (direction === 0) nextX++;
                        else if (direction === 1) nextX--;
                        else if (direction === 2) nextY++;
                        else nextY--;
                        const nextKey = `${nextX},${nextY}`;
                        if (!carved.has(nextKey)) {
                            toCarve.add(nextKey);
                        }
                    }
                }
            }
        }
        function generateMineshaft(startX, startY) {
            console.log("Mineshaft Generated");
			const width = 20 + Math.floor(random() * 31); 
            const height = 4; 
            for (let x = startX; x < startX + width; x++) {
                for (let y = startY; y < startY + height + 2; y++) { 
                    const key = `${x},${y}`;
                    if (y === startY || y === startY + height + 1) {
                        worldBlocks[key] = { type: 'poak', mineProg: 0 };
                    } 
                    else if (x === startX || x === startX + width - 1) {
                        worldBlocks[key] = { type: 'pspruce', mineProg: 0 };
                    }
                    else {
                        if (random() < 0.3) {
                            worldBlocks[key] = { type: 'cobweb', mineProg: 0 };
                        } else {
                            worldBlocks[key] = { type: '', mineProg: 0 };
                        }
                    }
                }
            }
            const chestCol = startX + 1;
            const chestRow = startY + height;
            const chestKey = `${chestCol},${chestRow}`;
            const loot = [];
            const lootTypes = ['wooden_pickaxe', 'steeln', 'asphalt', 'rock_pickaxe', 'wheat_bread', 'phellw', 'rice_seeds'];
			const toolDurability = {'wooden_pickaxe': 11250, 'rock_pickaxe': 18750}; 
            const randomOre = lootTypes[Math.floor(random() * lootTypes.length)];
			loot.push({ type: 'ironn', count: 1 + Math.floor(random() * 5) });
			loot.push({ type: 'coppern', count: 1 + Math.floor(random() * 5) });
			loot.push({ type: 'rbirch', count: 1 + Math.floor(random() * 5) });
            loot.push({ type: 'rice_seeds', count: 1 + Math.floor(random() * 3) });
			if (toolDurability[randomOre]) {
				loot.push({
					type: randomOre,
					durability: toolDurability[randomOre],
					maxDurability: toolDurability[randomOre],
					count: 1
				});
			} else {
				loot.push({ type: randomOre, count: 1 + (randomOre === 'rice_seeds' ? Math.floor(random() * 3) : 0) });
			}
            worldBlocks[chestKey] = { 
                type: 'chest', 
                mineProg: 0, 
                inventory: new Array(chestInventorySize).fill(null),
                label: 'Mineshaft Chest'
            };
            loot.forEach((item, index) => {
                if (index < chestInventorySize) {
                    worldBlocks[chestKey].inventory[index] = item;
                }
            });
        }
        function generateDungeon(startX, startY) {
            console.log("Dungeon Generated at", startX, startY);
            const mainChamberWidth = 15 + Math.floor(random() * 10);
            const mainChamberHeight = 10 + Math.floor(random() * 6);
            for (let x = startX; x < startX + mainChamberWidth; x++) {
                for (let y = startY; y < startY + mainChamberHeight; y++) {
                    const key = `${x},${y}`;
                    if (x === startX || x === startX + mainChamberWidth - 1 || y === startY || y === startY + mainChamberHeight - 1) {
                        worldBlocks[key] = { type: random() < 0.5 ? 'pspruce' : 'pdarkwood', mineProg: 0 };
                    } else { 
                        worldBlocks[key] = { type: '', mineProg: 0 };
                        if (random() < 0.2) { 
                             worldBlocks[`${x},${y}`] = { type: 'cobweb', mineProg: 0 };
                        }
                    }
                }
            }
            const roomWidth = 5 + Math.floor(random() * 3);
            const roomHeight = 4 + Math.floor(random() * 2);
            for (let i = 0; i < 3; i++) {
                const roomStartX = startX + 2 + i * (roomWidth + 1);
                const roomStartY = startY + mainChamberHeight; 
                if (roomStartX + roomWidth >= startX + mainChamberWidth - 1) continue;
                for (let x = roomStartX - 1; x < roomStartX + roomWidth + 1; x++) {
                    for (let y = roomStartY - 1; y < roomStartY + roomHeight + 1; y++) {
                        const key = `${x},${y}`;
                        if (y === roomStartY - 1) {
                            worldBlocks[key] = { type: 'vines', mineProg: 0 };
                        } 
                        else if (x === roomStartX - 1 || x === roomStartX + roomWidth || y === roomStartY + roomHeight) {
                             worldBlocks[key] = { type: random() < 0.5 ? 'pspruce' : 'pdarkwood', mineProg: 0 };
                        }
                        else {
                            worldBlocks[key] = { type: '', mineProg: 0 };
                            if (random() < 0.3) { 
                                worldBlocks[key] = { type: 'cobweb', mineProg: 0 };
                            }
                        }
                    }
                }
                const chestCol = roomStartX + Math.floor(roomWidth / 2);
                const chestRow = roomStartY + roomHeight - 1;
                const chestKey = `${chestCol},${chestRow}`;
                worldBlocks[chestKey] = { 
                    type: 'chest', 
                    mineProg: 0, 
                    inventory: new Array(chestInventorySize).fill(null),
                    label: 'Dungeon Chest'
                };
                const loot = [];
                loot.push({ type: 'goldn', count: 1 + Math.floor(random() * 3) });
                loot.push({ type: 'ironn', count: 1 + Math.floor(random() * 5) });
                if (random() < 0.1) loot.push({ type: 'diamondn', count: 1 + Math.floor(random() * 2) });
                if (random() < 0.5) loot.push({ type: 'corn_seeds', count: 2 + Math.floor(random() * 5) });
                if (random() < 0.2) loot.push({ type: 'iron_pickaxe', count: 1, durability: 15000, maxDurability: 50000 }); 
                loot.forEach((item, index) => {
                    if (index < chestInventorySize) {
                        worldBlocks[chestKey].inventory[index] = item;
                    }
                });
            }
        }
        function generateLavaCave(startX, startY) {
            console.log("Deep Magma Cave Generated: Hotter, Fuller, and Branchier!");
            const caveSize = 100 + Math.floor(random() * 151); 
            let blocksCarved = 0;
            const toCarve = new Set([`${startX},${startY}`]);
            const carved = new Set();
            const floorBlocks = new Map(); 
            const carveRadius = 2; 
            while (blocksCarved < caveSize && toCarve.size > 0) {
                const currentKey = Array.from(toCarve)[Math.floor(random() * toCarve.size)];
                toCarve.delete(currentKey);
                if (carved.has(currentKey)) continue;
                const [x, y] = currentKey.split(',').map(Number);
                for (let dx = -carveRadius; dx <= carveRadius; dx++) {
                    for (let dy = -carveRadius; dy <= carveRadius; dy++) {
                        const carveX = x + dx;
                        const carveY = y + dy;
                        const key = `${carveX},${carveY}`;
                        if (carveY < baseSurfaceLevel + 25) continue; 
                        if (getBlockType(carveX, carveY) !== '') {
                            if (Math.abs(dx) === carveRadius || Math.abs(dy) === carveRadius) {
                                 worldBlocks[key] = { type: 'magma_stoneb', mineProg: 0 };
                            }
                        }
                        if (Math.abs(dx) <= carveRadius - 1 && Math.abs(dy) <= carveRadius - 1) { 
                            worldBlocks[key] = { type: '', mineProg: 0 };
                            carved.add(key);
                            blocksCarved++;
                            if (!floorBlocks.has(carveX) || carveY > floorBlocks.get(carveX)) {
                                floorBlocks.set(carveX, carveY);
                            }
                        }
                    }
                }
                for (let i = 0; i < 4; i++) {
                    if (random() < 0.80) { 
                        const direction = Math.floor(random() * 4);
                        let nextX = x, nextY = y;
                        if (direction === 0) nextX += carveRadius; 
                        else if (direction === 1) nextX -= carveRadius;
                        else if (direction === 2) nextY += carveRadius;
                        else nextY -= carveRadius;
                        const nextKey = `${nextX},${nextY}`;
                        if (!carved.has(nextKey)) {
                            toCarve.add(nextKey);
                        }
                    }
                }
            }
            floorBlocks.forEach((y, x) => {
                const floorY = y + 1;
                const ceilingY = y - 1;
                if (getBlockType(x, floorY) === 'magma_stoneb') {
                    if (random() < 0.60) {
                         worldBlocks[`${x},${y}`] = { type: 'lavab', mineProg: 0 };
                    }
                }
                if (getBlockType(x, ceilingY) === '') { 
                    if (random() < 0.3) { 
                        generateTree(x, floorY, 'magma'); 
                    }
                }
                if (random() < 0.15) {
                    if (getBlockType(x, ceilingY) === 'magma_stoneb') {
                        for(let dy = 0; dy < 3; dy++) {
                            const dropY = ceilingY + dy;
                            if (getBlockType(x, dropY) === '') {
                                 worldBlocks[`${x},${dropY}`] = { type: 'magma_stoneb', mineProg: 0 };
                            } else {
                                break; 
                            }
                        }
                    }
                }
            });
        }
        function generateBunker(startCol, startRow) {
            console.log("Generating Bunker at", startCol, startRow);
            const bunkerWidth = 12;
            const bunkerHeight = 7;
            for (let i = 0; i < bunkerWidth; i++) {
                bunkerColumns.add(startCol + i);
            }
            for (let x = 0; x < bunkerWidth; x++) {
                for (let y = 0; y < bunkerHeight; y++) {
                    const col = startCol + x;
                    const row = startRow + y;
                    const key = `${col},${row}`;
                    const isWall = x === 0 || x === bunkerWidth - 1 || y === 0 || y === bunkerHeight - 1;
                    if (isWall) {
                        worldBlocks[key] = { type: 'iron_brickb', mineProg: 0 };
                    } else {
                        worldBlocks[key] = { type: '', mineProg: 0 }; 
                    }
                }
            }
            const fridgeCol = startCol + bunkerWidth - 2;
            const fridgeRow = startRow + bunkerHeight - 2;
            const fridgeKey = `${fridgeCol},${fridgeRow}`;
            const fridgeInventory = new Array(chestInventorySize).fill(null);
            const possibleSeeds = ['grass_seeds', 'moss_seeds', 'wheat_seeds', 'cotton_seeds', 'rice_seeds', 'hop_seeds', 'coffee_seeds', 'oat_seeds', 'corn_seeds', 'barley_seeds', 'pumpkin_seeds', 'tomato_seeds', 'onion_seeds', 'garlic_seeds', 'chili_pepper_seeds'];
            const selectedSeeds = possibleSeeds.sort(() => 0.5 - random()).slice(0, 3);
            for(let i = 0; i < selectedSeeds.length; i++) {
                fridgeInventory[i] = { type: selectedSeeds[i], count: 2 };
            }
            const supplies = ['butter', 'cup_of_milk', 'egg', 'rsugar', 'beef'];
            let currentSlot = 3; 
            for (const supply of supplies) {
                if (random() < 0.80) { 
                    if (currentSlot >= chestInventorySize) break; 
                    const count = 1 + Math.floor(random() * 5); 
                    fridgeInventory[currentSlot] = { type: supply, count: count };
                    currentSlot++;
                }
            }
            worldBlocks[fridgeKey] = {
                type: 'refrigerator',
                mineProg: 0,
                inventory: fridgeInventory,
                label: 'Emergency Bunker'
            };
        }
        function generateSkyIsland(centerX, centerY) {
            console.log("Sky Island Generated");
			const islandSize = 100 + Math.floor(random() * 301); 
            let blocksPlaced = 0;
            const toPlace = new Set([`${centerX},${centerY}`]);
            const placed = new Set();
            while (blocksPlaced < islandSize && toPlace.size > 0) {
                const currentKey = Array.from(toPlace)[Math.floor(random() * toPlace.size)];
                toPlace.delete(currentKey);
                if (placed.has(currentKey)) continue;
                const [x, y] = currentKey.split(',').map(Number);
                worldBlocks[currentKey] = { type: 'cloudb', mineProg: 0 };
                placed.add(currentKey);
                blocksPlaced++;
                for (let i = 0; i < 4; i++) {
                    if (random() < 0.75) {
                        const direction = Math.floor(random() * 4);
                        let nextX = x, nextY = y;
                        if (direction === 0) nextX++; else if (direction === 1) nextX--;
                        else if (direction === 2) nextY++; else nextY--;
                        const nextKey = `${nextX},${nextY}`;
                        if (!placed.has(nextKey)) toPlace.add(nextKey);
                    }
                }
            }
            let topY = centerY;
            while(placed.has(`${centerX},${topY - 1}`)) {
                topY--;
            }
            const houseWidth = 5;
            const houseHeight = 4;
            const houseStartX = centerX - Math.floor(houseWidth / 2);
            const houseStartY = topY - houseHeight;
            for (let x = houseStartX; x < houseStartX + houseWidth; x++) {
                for (let y = houseStartY; y < houseStartY + houseHeight; y++) {
                    const key = `${x},${y}`;
                    if (x === houseStartX || x === houseStartX + houseWidth - 1 || y === houseStartY) {
                        worldBlocks[key] = { type: 'clay_brickb', mineProg: 0 };
                    } else {
                        worldBlocks[key] = { type: '', mineProg: 0 };
                    }
                }
            }
            const chestCol = centerX;
            const chestRow = topY - 1;
            const chestKey = `${chestCol},${chestRow}`;
            worldBlocks[chestKey] = { 
                type: 'chest', 
                mineProg: 0, 
                inventory: new Array(chestInventorySize).fill(null),
                label: 'Sky Chest'
            };
            const loot = [];
            loot.push({ type: 'diamondn', count: 1 });
            loot.push({ type: 'coal', count: 1 + Math.floor(random() * 25) });
            loot.push({ type: 'steel_pickaxe', count: 1, durability: 7500, maxDurability: 150000 }); 
			loot.push({ type: 'oat_seeds', count: 1 + Math.floor(random() * 3) });
			loot.push({ type: 'beef', count: 2 + Math.floor(random() * 3) });
            loot.forEach((item, index) => {
                if (index < chestInventorySize) {
                    worldBlocks[chestKey].inventory[index] = item;
                }
            });
            skyIslandColumns.add(centerX);
        }
        function generateWatchtower(startCol, surfaceRow) {
            console.log("Attempting to generate Watchtower at", startCol);
            const towerWidth = 6;
            const towerHeight = 40 + Math.floor(random() * 21); 
            let minSurface = surfaceRow;
            let maxSurface = surfaceRow;
            for (let i = 1; i < towerWidth; i++) {
                const currentSurface = columnSurfaceHeights[startCol + i] || surfaceRow;
                if (currentSurface < minSurface) minSurface = currentSurface;
                if (currentSurface > maxSurface) maxSurface = currentSurface;
            }
            if (maxSurface - minSurface > 2) {
                console.log("Ground not flat enough for watchtower.");
                return; 
            }
            const baseRow = maxSurface;
            for (let i = 0; i < towerWidth; i++) {
                watchtowerColumns.add(startCol + i);
            }
            for (let c = 0; c < towerWidth; c++) {
                for (let r = 0; r < 5; r++) {
                    worldBlocks[`${startCol + c},${baseRow + r}`] = { type: 's', mineProg: 0 };
                }
            }
            for (let y = 0; y < towerHeight; y++) {
                const currentRow = baseRow - 1 - y;
                for (let x = 0; x < towerWidth; x++) {
                    const currentCol = startCol + x;
                    const isWall = x === 0 || x === towerWidth - 1 || (y > 0 && (x === 1 || x === towerWidth - 2) && (y % 8 === 0)); 
                    if (isWall) {
                        worldBlocks[`${currentCol},${currentRow}`] = { type: 's', mineProg: 0 };
                    } else { 
                        worldBlocks[`${currentCol},${currentRow}`] = { type: '', mineProg: 0 };
                    }
                }
                if (y > 0 && y % 5 === 0) { 
                     for (let x = 1; x < towerWidth - 1; x++) {
                        worldBlocks[`${startCol + x},${currentRow}`] = { type: 'poak', mineProg: 0 };
                    }
                }
                const stairY = y % 10;
                if (stairY < 5 && stairY > 0) { 
                     worldBlocks[`${startCol + 1},${currentRow}`] = { type: 'pspruce', mineProg: 0 };
                } else if (stairY > 5) { 
                     worldBlocks[`${startCol + towerWidth - 2},${currentRow}`] = { type: 'pspruce', mineProg: 0 };
                }
            }
            const topRow = baseRow - towerHeight;
            for (let x = 0; x < towerWidth; x++) {
                for (let y = 0; y < 2; y++) {
                     worldBlocks[`${startCol + x},${topRow + y}`] = { type: 's', mineProg: 0 };
                }
                if (x === 0 || x === towerWidth - 1) { 
                     worldBlocks[`${startCol + x},${topRow - 1}`] = { type: 's', mineProg: 0 };
                }
            }
            const chestCol = startCol + Math.floor(towerWidth / 2);
            const chestRow = topRow - 1;
            worldBlocks[`${chestCol},${chestRow}`] = { 
                type: 'chest', 
                mineProg: 0, 
                inventory: new Array(chestInventorySize).fill(null),
                label: 'Watchtower Chest'
            };
            const loot = [];
            loot.push({ type: 'watchtower_stoneb', count: 10 + Math.floor(random() * 21) });
            loot.push({ type: 'goldn', count: 1 + Math.floor(random() * 2) });
            if (random() < 0.4) loot.push({ type: 'diamondn', count: 2 });
            loot.forEach((item, index) => {
                if (index < chestInventorySize) {
                    worldBlocks[`${chestCol},${chestRow}`].inventory[index] = item;
                }
            });
        }
        function generatePowertower(startCol, surfaceRow) {
            console.log("Attempting to generate Powertower at", startCol);
            const towerWidth = 10;
            const towerHeight = 60 + Math.floor(random() * 21); 
            let minSurface = surfaceRow;
            let maxSurface = surfaceRow;
            for (let i = 1; i < towerWidth; i++) {
                const currentSurface = columnSurfaceHeights[startCol + i] || surfaceRow;
                if (currentSurface < minSurface) minSurface = currentSurface;
                if (currentSurface > maxSurface) maxSurface = currentSurface;
            }
            if (maxSurface - minSurface > 2) {
                console.log("Ground not flat enough for powertower.");
                return; 
            }
            const baseRow = maxSurface;
            for (let i = 0; i < towerWidth; i++) {
                watchtowerColumns.add(startCol + i);
            }
            for (let c = 0; c < towerWidth; c++) {
                for (let r = 0; r < 5; r++) {
                    worldBlocks[`${startCol + c},${baseRow + r}`] = { type: 'oxidizing_copper_brickb', mineProg: 0 };
                }
            }
            for (let y = 0; y < towerHeight; y++) {
                const currentRow = baseRow - 1 - y;
                for (let x = 0; x < towerWidth; x++) {
                    const currentCol = startCol + x;
                    const isWall = x === 0 || x === towerWidth - 1 || (y > 0 && (x === 1 || x === towerWidth - 2) && (y % 8 === 0)); 
                    if (isWall) {
                        worldBlocks[`${currentCol},${currentRow}`] = { type: 'copper_brickb', mineProg: 0 };
                    } else { 
                        worldBlocks[`${currentCol},${currentRow}`] = { type: '', mineProg: 0 };
                    }
                }
                if (y > 0 && y % 5 === 0) { 
                     for (let x = 1; x < towerWidth - 1; x++) {
                        worldBlocks[`${startCol + x},${currentRow}`] = { type: 'predwood', mineProg: 0 };
                    }
                }
                const stairY = y % 10;
                if (stairY < 5 && stairY > 0) { 
                     worldBlocks[`${startCol + 1},${currentRow}`] = { type: 'prubber', mineProg: 0 };
                } else if (stairY > 5) { 
                     worldBlocks[`${startCol + towerWidth - 2},${currentRow}`] = { type: 'prubber', mineProg: 0 };
                }
            }
            const topRow = baseRow - towerHeight;
            for (let x = 0; x < towerWidth; x++) {
                for (let y = 0; y < 2; y++) {
                     worldBlocks[`${startCol + x},${topRow + y}`] = { type: 'copper_brickb', mineProg: 0 };
                }
                if (x === 0 || x === towerWidth - 1) { 
                     worldBlocks[`${startCol + x},${topRow - 1}`] = { type: 'copper_brickb', mineProg: 0 };
                }
            }
            const chestCol = startCol + Math.floor(towerWidth / 2);
            const chestRow = topRow - 1;
            worldBlocks[`${chestCol},${chestRow}`] = { 
                type: 'chest', 
                mineProg: 0, 
                inventory: new Array(chestInventorySize).fill(null),
                label: 'Powertower Chest'
            };
            const loot = [];
            loot.push({ type: 'powertower_stoneb', count: 10 + Math.floor(random() * 21) });
            loot.push({ type: 'jaden', count: 1 + Math.floor(random() * 2) });
            if (random() < 0.8) loot.push({ type: 'palladiumn', count: 2 });
            loot.forEach((item, index) => {
                if (index < chestInventorySize) {
                    worldBlocks[`${chestCol},${chestRow}`].inventory[index] = item;
                }
            });
        }
		function generateChasm(startCol, surfaceRow) {
			console.log("Attempting to generate Chasm at", startCol);
			const chasmWidth = 5 + Math.floor(random() * 4); 
			const underworldDepth = 200; 
			let minSurface = surfaceRow;
			let maxSurface = surfaceRow;
			for (let i = 1; i < chasmWidth; i++) {
				const currentSurface = columnSurfaceHeights[startCol + i] || surfaceRow;
				minSurface = Math.min(minSurface, currentSurface);
				maxSurface = Math.max(maxSurface, currentSurface);
			}
			if (maxSurface - minSurface > 3) {
				console.log("Ground not flat enough for chasm.");
				return; 
			}
			const baseRow = maxSurface;
			for (let i = -5; i < chasmWidth + 5; i++) { 
				chasmColumns.add(startCol + i);
			}
			let currentXOffset = 0; 
			const borderThickness = 4; 
			for (let y = 0; y < underworldDepth; y++) {
				const currentRow = baseRow + y;
				if (random() < 0.1) { 
					currentXOffset += Math.floor(random() * 3) - 1; 
				}
				currentXOffset = Math.max(-5, Math.min(5, currentXOffset));
				for (let x = 0; x < chasmWidth; x++) {
					const currentCol = startCol + x + currentXOffset;
					worldBlocks[`${currentCol},${currentRow}`] = { type: '', mineProg: 0 };
				}
				for (let i = 1; i <= borderThickness; i++) {
					const probability = 1.0 - (i / (borderThickness + 1));
					if (random() < probability) {
						const borderCol = startCol + currentXOffset - i;
						worldBlocks[`${borderCol},${currentRow}`] = { type: 'chasm_magma_stoneb', mineProg: 0 };
					}
				}
				for (let i = 1; i <= borderThickness; i++) {
					const probability = 1.0 - (i / (borderThickness + 1));
					if (random() < probability) {
						const borderCol = startCol + chasmWidth + currentXOffset + i - 1;
						worldBlocks[`${borderCol},${currentRow}`] = { type: 'chasm_magma_stoneb', mineProg: 0 };
					}
				}
			}
			console.log("Chasm Generated!");
		}
		function generateJungleTemple(startCol, surfaceRow) {
		  const width  = 16 + Math.floor(random() * 6);   
		  const height = 9  + Math.floor(random() * 3);   
		  let minSurface = surfaceRow, maxSurface = surfaceRow;
		  for (let i = 1; i < width; i++) {
			const s = columnSurfaceHeights[startCol + i] ?? surfaceRow;
			if (s < minSurface) minSurface = s;
			if (s > maxSurface) maxSurface = s;
		  }
		  if (maxSurface - minSurface > 3) return; 
		  const baseRow = maxSurface;
		  for (let i = 0; i < width; i++) jungleTempleColumns.add(startCol + i);
		  for (let x = 0; x < width; x++) {
			for (let y = 0; y < height; y++) {
			  const col = startCol + x;
			  const row = baseRow - y;              
			  const key = `${col},${row}`;
			  const isWallOrRoof = (x === 0 || x === width - 1 || y === 0 || y === height - 1);
			  if (isWallOrRoof) {
				worldBlocks[key] = { type: 'vines', mineProg: 0 };
			  } else {
				worldBlocks[key] = { type: 'mud', mineProg: 0 };
			  }
			}
		  }
		  const roofY = baseRow - height + 1;
		  for (let x = 2; x < width - 2; x += 3) {
			const key = `${startCol + x},${roofY}`;
			worldBlocks[key] = { type: '', mineProg: 0 };
		  }
		  const chestCol = startCol + width - 4;
		  const chestRow = baseRow - Math.floor(height / 2);
		  const chestKey = `${chestCol},${chestRow}`;
		  worldBlocks[chestKey] = {
			type: 'chest',
			mineProg: 0,
			inventory: new Array(chestInventorySize).fill(null),
			label: 'Mud Chest'
		  };
		  for (let i = 0; i < chestInventorySize; i++) {
			worldBlocks[chestKey].inventory[i] = { type: 'mud', count: 99 };
		  }
		}
        function generateMineChamber(startCol, surfaceRow) {
            console.log("Attempting to generate Mine Chamber at", startCol);
            const entranceWidth = 7;
            const shaftWidth = 5; 
            const shaftDepth = 100 + Math.floor(random() * 51); 
            const chamberWidth = 25 + Math.floor(random() * 11); 
            const chamberHeight = 7;
            let minSurface = surfaceRow;
            let maxSurface = surfaceRow;
            for (let i = 1; i < entranceWidth; i++) {
                const currentSurface = columnSurfaceHeights[startCol + i] || surfaceRow;
                minSurface = Math.min(minSurface, currentSurface);
                maxSurface = Math.max(maxSurface, currentSurface);
            }
            if (maxSurface - minSurface > 1) { 
                console.log("Ground not flat enough for Mine Chamber.");
                return;
            }
            const baseRow = maxSurface;
            for (let i = 0; i < Math.max(entranceWidth, chamberWidth); i++) {
                mineChamberColumns.add(startCol + i);
            }
            for (let x = 0; x < entranceWidth; x++) {
                const currentCol = startCol + x;
                worldBlocks[`${currentCol},${baseRow + 1}`] = { type: 'pbirch', mineProg: 0 };
                const isHole = x >= 2 && x <= 4;
                if (!isHole) {
                    worldBlocks[`${currentCol},${baseRow}`] = { type: 'pbirch', mineProg: 0 };
                } else {
                    worldBlocks[`${currentCol},${baseRow}`] = { type: '', mineProg: 0 };
                }
                for (let y = 1; y < 4; y++) {
                    if (x === 0 || x === entranceWidth - 1) {
                        worldBlocks[`${currentCol},${baseRow - y}`] = { type: 'pbirch', mineProg: 0 };
                    } else {
                        worldBlocks[`${currentCol},${baseRow - y}`] = { type: '', mineProg: 0 };
                    }
                }
            }
            for (let y = 0; y < 4; y++) {
                const roofRow = baseRow - 4 - y;
                for (let x = y; x < entranceWidth - y; x++) {
                    const currentCol = startCol + x;
                    if (x === y || x === entranceWidth - 1 - y) {
                         worldBlocks[`${currentCol},${roofRow}`] = { type: 'pbirch', mineProg: 0 };
                    } else if (getBlockType(currentCol, roofRow) !== 'pbirch') {
                         worldBlocks[`${currentCol},${roofRow}`] = { type: '', mineProg: 0 };
                    }
                }
            }
            const shaftStartCol = startCol + Math.floor((entranceWidth - shaftWidth) / 2);
            for (let y = 1; y <= shaftDepth; y++) {
                const currentRow = baseRow + y;
                for (let x = 0; x < shaftWidth; x++) {
                    const currentCol = shaftStartCol + x;
                    const isWall = x === 0 || x === shaftWidth - 1;
                    if (isWall) {
                        worldBlocks[`${currentCol},${currentRow}`] = { type: 'pbirch', mineProg: 0 };
                    } else {
                        worldBlocks[`${currentCol},${currentRow}`] = { type: '', mineProg: 0 };
                    }
                }
                const level = Math.floor((y-1) / 5); 
                if (y % 5 !== 0) { 
                    if (level % 2 === 0) { 
                        worldBlocks[`${shaftStartCol + 1},${currentRow}`] = { type: 'red_sandb', mineProg: 0 };
                    } else { 
                        worldBlocks[`${shaftStartCol + shaftWidth - 2},${currentRow}`] = { type: 'sand', mineProg: 0 };
                    }
				}
                for (let x = 1; x < shaftWidth - 1; x++) {
                    const currentCol = shaftStartCol + x;
                    if (getBlockType(currentCol, currentRow) === '' && random() < 0.03) {
                         worldBlocks[`${currentCol},${currentRow}`] = { type: 'cobweb', mineProg: 0 };
                    }
                }
            }
            const chamberStartRow = baseRow + shaftDepth;
            const chamberStartCol = startCol + Math.floor((entranceWidth - chamberWidth) / 2); 
            for (let y = 0; y < chamberHeight; y++) {
                for (let x = 0; x < chamberWidth; x++) {
                    const currentCol = chamberStartCol + x;
                    const currentRow = chamberStartRow + y;
                    const isWall = x === 0 || x === chamberWidth - 1 || y === 0 || y === chamberHeight - 1;
                    if (isWall) {
                        worldBlocks[`${currentCol},${currentRow}`] = { type: 'papple', mineProg: 0 };
                    } else {
                        worldBlocks[`${currentCol},${currentRow}`] = { type: '', mineProg: 0 };
                    }
                }
            }
            const pileHeight = 3;
            const pileWidth = 5;
            for (let y = 0; y < pileHeight; y++) {
                for (let x = 0; x < pileWidth; x++) {
                    if (random() < 0.75 - (y * 0.2)) { 
                        const currentCol = chamberStartCol + 2 + x;
                        const currentRow = chamberStartRow + chamberHeight - 2 - y;
                        worldBlocks[`${currentCol},${currentRow}`] = { type: 'coalb', mineProg: 0 };
                    }
                }
            }
            for (let y = 0; y < pileHeight; y++) {
                for (let x = 0; x < pileWidth; x++) {
                    if (random() < 0.75 - (y * 0.2)) {
                        const currentCol = chamberStartCol + chamberWidth - 3 - x;
                        const currentRow = chamberStartRow + chamberHeight - 2 - y;
                        worldBlocks[`${currentCol},${currentRow}`] = { type: 'coalb', mineProg: 0 };
                    }
                }
            }
            const chestCol = chamberStartCol + Math.floor(chamberWidth / 2);
            const chestRow = chamberStartRow + chamberHeight - 2; 
            const chestKey = `${chestCol},${chestRow}`;
            worldBlocks[chestKey] = { 
                type: 'chest', 
                mineProg: 0, 
                inventory: new Array(chestInventorySize).fill(null),
                label: 'Mine Chamber Chest'
            };
            const loot = [
                { type: 'topazn', count: 1 },
                { type: 'ironn', count: 2 + Math.floor(random() * 4) },
                { type: 'goldn', count: 2 },
                { type: 'steel_pickaxe', count: 1, durability: 150000 * (random() * 0.1), maxDurability: 150000 }
            ];
            loot.forEach((item, index) => {
                if (index < chestInventorySize) {
                    worldBlocks[chestKey].inventory[index] = item;
                }
            });
        }
        function generatePlantation(startCol, surfaceRow) {
			console.log("Attempting to generate Plantation at", startCol);
			const houseWidth = 9;
			const houseHeight = 6;
			const farmWidth = 20;
			const farmDepth = 2;
			const totalWidth = houseWidth + farmWidth;
			const isMirrored = random() < 0.5;
			let minSurface = surfaceRow;
			let maxSurface = surfaceRow;
			for (let i = 1; i < totalWidth; i++) {
				const currentSurface = columnSurfaceHeights[startCol + i] || surfaceRow;
				minSurface = Math.min(minSurface, currentSurface);
				maxSurface = Math.max(maxSurface, currentSurface);
			}
			if (maxSurface - minSurface > 2) {
				console.log("Ground not flat enough for plantation.");
				return;
			}
			const baseRow = maxSurface;
			for (let i = 0; i < totalWidth; i++) {
				plantationColumns.add(startCol + i);
			}
			const houseStartCol = isMirrored ? startCol + farmWidth : startCol;
			const farmStartCol = isMirrored ? startCol : startCol + houseWidth;
			const clearPadding = 6; 
			const clearStartRow = baseRow - (houseHeight + clearPadding); 
			const clearEndRow = baseRow - 1; 
			for (let x = 0; x < totalWidth; x++) {
				const col = startCol + x;
				for (let row = clearStartRow; row <= clearEndRow; row++) {
					worldBlocks[`${col},${row}`] = { type: '', mineProg: 0 };
				}
			}
			const dirtDepth = 3; 
			for (let x = 0; x < totalWidth; x++) {
				const col = startCol + x;
				for (let d = 1; d <= dirtDepth; d++) {
					const row = baseRow + d;
					worldBlocks[`${col},${row}`] = { type: 'd', mineProg: 0 };
				}
			}
			for (let x = 0; x < houseWidth; x++) {
				for (let y = 0; y < houseHeight; y++) {
					const currentCol = houseStartCol + x;
					const currentRow = baseRow - y;
					const isFoundation = (y === 0);
					const isFloor = (y === 1);
					const isRoof = (y === houseHeight - 1);
					let isDoor = false;
					if (isMirrored && x === houseWidth - 1 && y >= 1 && y <= 3) { 
						isDoor = true;
					} else if (!isMirrored && x === 0 && y >= 1 && y <= 3) { 
						isDoor = true;
					}
					let isWindow = false;
					if (isMirrored && x === 0 && y === 3) { 
						isWindow = true;
					} else if (!isMirrored && x === houseWidth - 1 && y === 3) { 
						isWindow = true;
					}
					if (isDoor) {
						delete worldBlocks[`${currentCol},${currentRow}`]; 
					} else if (isFoundation) {
						worldBlocks[`${currentCol},${currentRow}`] = { type: 'stone_brickb', mineProg: 0 };
					} else if (isFloor) {
						worldBlocks[`${currentCol},${currentRow}`] = { type: 'poak', mineProg: 0 };
					} else if (isWindow) {
						worldBlocks[`${currentCol},${currentRow}`] = { type: 'glassb', mineProg: 0 };
					} else if (x === 0 || x === houseWidth - 1 || isRoof) { 
						worldBlocks[`${currentCol},${currentRow}`] = { type: 'pspruce', mineProg: 0 };
					} else { 
						worldBlocks[`${currentCol},${currentRow}`] = { type: '', mineProg: 0 };
					}
				}
			}
			const floorRow = baseRow - 1; 
			const bedStartCol = isMirrored ? houseStartCol + 1 : houseStartCol + houseWidth - 4;
			worldBlocks[`${bedStartCol},${floorRow}`] = { type: 'bed', part: 'left' };
			worldBlocks[`${bedStartCol + 1},${floorRow}`] = { type: 'bed', part: 'middle' };
			worldBlocks[`${bedStartCol + 2},${floorRow}`] = { type: 'bed', part: 'right' };
			const chestCol = isMirrored ? houseStartCol + houseWidth - 2 : houseStartCol + 1;
			const chestKey = `${chestCol},${floorRow}`;
			worldBlocks[chestKey] = {
				type: 'chest',
				mineProg: 0,
				inventory: new Array(chestInventorySize).fill(null),
				label: 'Farmhouse Chest'
			};
			const loot = [
				{ type: 'wheat_seeds', count: 5 + Math.floor(random() * 6) },
				{ type: 'wooden_pickaxe', count: 1, durability: 15000, maxDurability: 15000 },
				{ type: 'apple', count: 2 + Math.floor(random() * 3) }
			];
			loot.forEach((item, index) => {
				if (index < chestInventorySize) {
					worldBlocks[chestKey].inventory[index] = item;
				}
			});
			for (let x = 0; x < farmWidth; x++) {
				for (let y = 0; y < farmDepth; y++) {
					const currentCol = farmStartCol + x;
					const currentRow = baseRow + y;
					worldBlocks[`${currentCol},${currentRow}`] = { type: 'plantations', mineProg: 0 };
				}
				const cropCol = farmStartCol + x;
				const cropRow = baseRow - 1;
				worldBlocks[`${cropCol},${cropRow}`] = { type: '', mineProg: 0 };
				const cropType = random() < 0.8 ? 'corn' : 'cotton';
				if (getBlockType(cropCol, cropRow) === '') {
					worldBlocks[`${cropCol},${cropRow}`] = { type: cropType, mineProg: 0 };
				}
			}
			console.log("Plantation generated at", startCol, "baseRow", baseRow);
		}
		function generateMoon(centerX, centerY) {
            const radius = 20 + Math.floor(random() * 31); 
            const buffer = 15; 
            const boundingBox = {
                minX: centerX - radius - buffer,
                maxX: centerX + radius + buffer,
                minY: centerY - radius - buffer,
                maxY: centerY + radius + buffer,
            };
            for (const region of moonRegions) {
                const intersects = (boundingBox.minX < region.maxX && boundingBox.maxX > region.minX &&
                                   boundingBox.minY < region.maxY && boundingBox.maxY > region.minY);
                if (intersects) {
                    return;
                }
            }
            moonRegions.push(boundingBox);
            console.log(`Generating moon at (${centerX}, ${centerY}) with radius ${radius}`);
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    if (dx * dx + dy * dy <= radius * radius) {
                        const key = `${centerX + dx},${centerY + dy}`;
                        if (!worldBlocks[key] || worldBlocks[key].type === '') {
                             worldBlocks[key] = { type: 'rockb', mineProg: 0 };
                        }
                    }
                }
            }
        }
		function createBlockBreakParticles(col, row, blockType) {
            const blockImg = assets[blockType];
            const blockProps = blockTypes[blockType];
            if (!blockImg || failedAssets[blockType]) {
                return;
            }
            const blockCenterX = col * tileSize + tileSize / 2;
            const blockCenterY = row * tileSize + tileSize / 2;
            for (let i = 0; i < particleCount; i++) {
                const particleTextureSize = 4;
                const particle = {
                    x: blockCenterX,
                    y: blockCenterY,
                    dx: (Math.random() - 0.5) * 8, 
                    dy: (Math.random() * -8) - 2,     
                    life: 1000 + Math.random() * 500,
                    maxLife: 0, 
                    img: blockImg,
                    sourceX: Math.floor(Math.random() * (blockImg.width - particleTextureSize)),
                    sourceY: Math.floor(Math.random() * (blockImg.height - particleTextureSize)),
                    sourceSize: particleTextureSize,
                    drawSize: 6 
                };
                particle.maxLife = particle.life; 
                particles.push(particle);
            }
        }
        function getBlockType(col, row) {
            const blockData = worldBlocks[`${col},${row}`];
            return blockData ? blockData.type : ''; 
        }
        function isSolid(col, row) {
            const blockData = getBlockData(col, row);
            return blockTypes[blockData.type] && blockTypes[blockData.type].solid;
        }
        function worldToGrid(x, y) {
            return { col: Math.floor(x / tileSize), row: Math.floor(y / tileSize) };
        }
        function gridToWorld(col, row) {
            return { x: col * tileSize, y: row * tileSize };
        }
        function rectIntersects(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
        }
		function killMyself() {
			respawnPlayer()
		}
        function respawnPlayer() {
			const playerHasItems = inventorySlots.some(item => item !== null);
			if (playerHasItems) {
				const deathCol = Math.floor((player.x + playerWidth / 2) / tileSize);
				const deathRow = Math.floor((player.y + playerHeight) / tileSize) - 1; 
				const deathKey = `${deathCol},${deathRow}`;
				const biomeAtDeath = getBiome(deathCol); 
				const deathChestInventory = new Array(50).fill(null);
				for (let i = 0; i < inventorySlots.length; i++) {
					if (inventorySlots[i]) {
						let itemToDrop = inventorySlots[i];
						if (biomeAtDeath === 'rainforest' && itemToDrop.type === 'paper' && deathRow <= 20 && deathRow >= -20 ) {
							itemToDrop.type = 'soggy_paper';
						}
						const spoilInfo = itemTypes[itemToDrop.type]?.spoilable;
						if (spoilInfo) {
							itemToDrop.type = spoilInfo.into;
							delete itemToDrop.acquiredTime;
						}
						deathChestInventory[i] = itemToDrop;
					}
				}
				if (Math.random() < 0.8) {
					const glassCupIndex = deathChestInventory.findIndex(item => item && item.type === 'glass_cup');
					const emptySlotIndex = deathChestInventory.findIndex(item => item === null);
					if (glassCupIndex !== -1 && emptySlotIndex !== -1) {
						const glassCupItem = deathChestInventory[glassCupIndex];
						glassCupItem.count--;
						if (glassCupItem.count <= 0) {
							deathChestInventory[glassCupIndex] = null;
						}
						deathChestInventory[emptySlotIndex] = { type: 'cup_of_urine', count: 1 };
					}
				}
				worldBlocks[deathKey] = {
					type: 'dead_body_chest',
					mineProg: 0,
					inventory: deathChestInventory,
					label: 'Dead Body' 
				};
				inventorySlots.fill(null);
				hotbarIndices.fill(null);
				updateHotbar();
			}
			player.x = 0;
			player.y = 0; 
			if (player.bedSpawnPoint) {
				player.x = player.bedSpawnPoint.x;
				player.y = player.bedSpawnPoint.y;
			}
			player.health = player.maxHealth;
		}
        function updatePlayer(dt) {
            const factor = isGameActive ? dt / 1000 * 60 : 0;
			if (player.portalCooldown > 0) {
				player.portalCooldown -= dt;
			} else {
				const playerCenterCol = Math.floor((player.x + playerWidth / 2) / tileSize);
				const playerCenterRow = Math.floor((player.y + playerHeight / 2) / tileSize);
				const blockAtPlayer = getBlockType(playerCenterCol, playerCenterRow);
				if (blockAtPlayer === 'heaven_portal') {
					let currentPortal = null;
					for(const portal of portals) {
						const distSq = (playerCenterCol - portal.col)**2 + (playerCenterRow - portal.row)**2;
						if (distSq < 100) { 
							currentPortal = portal;
							break;
						}
					}
					if (currentPortal) {
						teleportPlayer(currentPortal);
					}
				}
			}
            const playerGridPos = worldToGrid(player.x + playerWidth / 2, player.y + playerHeight / 2);
            const blockUnderPlayer = getBlockType(playerGridPos.col, playerGridPos.row);
			const blockUnderPlayerU = getBlockType(playerGridPos.col, playerGridPos.row +1);
			const blockUnderPlayerB = getBlockType(playerGridPos.col, playerGridPos.row -1);
			const feetRow = Math.floor((player.y + playerHeight) / tileSize);
			const blockBelowFeet = getBlockType(playerGridPos.col, feetRow);
			const isOnAsphalt = blockBelowFeet === 'asphalt';
			const isOnThickMud = blockBelowFeet === 'thick_mud';
            const isInCobweb = blockUnderPlayer === 'cobweb' || blockUnderPlayerU === 'cobweb' || blockUnderPlayerB === 'cobweb';
            const playerCenterCol = Math.floor((player.x + playerWidth / 2) / tileSize);
            const rowBelowFeet = Math.floor((player.y + playerHeight) / tileSize);
            const blockBelow = getBlockType(playerCenterCol, rowBelowFeet);
            if (blockBelow === 'magma_stoneb') {
                player.health -= 50 * (dt / 1000); 
                if (player.health <= 0) {
                    respawnPlayer();
					return;
                }
            } else if (blockBelow === 'chasm_magma_stoneb') {
                player.health -= 10 * (dt / 1000); 
                if (player.health <= 0) {
                    respawnPlayer();
					return;
                }
            }
            if (isCreativeMode === 1) {
                const flightSpeed = player.speed * factor * CREATIVE_FLIGHT_SPEED;
                player.dy = 0; 
                player.onGround = true; 
                if (keys['ArrowUp'] || keys['w'] || keys['W']) {
                    player.y -= flightSpeed;
                } else if (keys['ArrowDown'] || keys['s'] || keys['S']) {
                    player.y += flightSpeed;
                }
                player.x += player.dx;
            }
                const currentSpeed = isInCobweb ? player.speed * 0.2 : isOnAsphalt ? player.speed * 1.5 : isOnThickMud ? player.speed * 0.5 : player.speed;
                const currentJumpStrength = isInCobweb ? player.jumpStrength * 0.2 : isOnThickMud ? player.jumpStrength * 0 : player.jumpStrength;
                const currentGravity = isInCobweb ? player.gravity * 0.1 : player.gravity;
                player.dy += currentGravity * factor;
                if (keys['ArrowLeft'] || keys['KeyA']) { 
					player.dx = -currentSpeed;
					player.facingDirection = -1;
				}
				else if (keys['ArrowRight'] || keys['KeyD']) { 
					player.dx = currentSpeed;
					player.facingDirection = 1;
				}
    			else player.dx = 0;
            if (!player.onGround && player.dy > 0) {
                if (player.fallStartY === 0) {
                    player.fallStartY = player.y;
                }
            }
            let nextPlayerX = player.x + player.dx * factor;
            let nextPlayerY = player.y + player.dy * factor;
            const playerRectY = { x: player.x, y: nextPlayerY, width: playerWidth, height: playerHeight };
            const startRowY = Math.floor(Math.min(player.y, nextPlayerY) / tileSize) - 2;
            const endRowY = Math.ceil(Math.max(player.y + playerHeight, nextPlayerY + playerHeight) / tileSize) + 2;
            const startColY = Math.floor(player.x / tileSize);
            const endColY = Math.floor((player.x + playerWidth - 1) / tileSize);
            let wasOnGround = player.onGround;
            player.onGround = false;
            for (let col = startColY; col <= endColY; col++) {
                for (let row = startRowY; row <= endRowY; row++) {
                    if (isSolid(col, row)) {
                        const blockRect = { x: col * tileSize, y: row * tileSize, width: tileSize, height: tileSize };
                        if (rectIntersects(playerRectY, blockRect)) {
                            if (player.dy > 0) {
                                player.y = blockRect.y - playerHeight;
                                player.dy = 0;
                                player.onGround = true;
                            } else if (player.dy < 0) {
                                player.y = blockRect.y + tileSize;
                                player.dy = 0;
                            }
                            nextPlayerY = player.y;
                        }
                    }
                }
            }
            player.y = nextPlayerY;
			const playerBodyCol = Math.floor((player.x + playerWidth / 2) / tileSize);
			const playerBodyRow = Math.floor((player.y + playerHeight / 2) / tileSize);
			const blockAtPlayerBody = getBlockType(playerBodyCol, playerBodyRow);
            let FALL_INTENSITY = 4
			if (isInCobweb || blockAtPlayerBody === 'cobweb') {
				player.fallStartY = player.y;
			}
            if (player.onGround && !wasOnGround && player.fallStartY !== 0) {
                const fallDistance = player.y - player.fallStartY;
                const fallDistanceInBlocks = fallDistance / tileSize;
                if (fallDistanceInBlocks > (5 / player.gravity)) {
                    const damage = Math.floor(fallDistanceInBlocks - (5 / player.gravity)) * FALL_INTENSITY * player.gravity;
                    player.health -= damage;
                    if (player.health <= 0) {
                        respawnPlayer();
						return;
						player.x = 0;
						player.y = 0;
						let titleCycle = ["Block Game Ultimate [HTML EDITION]", "Block Game Ultimate [STOP DYING]", "Block Game Ultimate [TRY WINNING]"];
						let i = 0;
						setInterval(() => {
							document.title = titleCycle[i % titleCycle.length];
							i++;
						}, 600);
                    }
                }
                player.fallStartY = 0; 
            } else if (!player.onGround && wasOnGround) {
                player.fallStartY = player.y; 
            }
            const playerRectX = { x: nextPlayerX, y: player.y, width: playerWidth, height: playerHeight };
            const startColX = Math.floor(Math.min(player.x, nextPlayerX) / tileSize) - 2;
            const endColX = Math.ceil(Math.max(player.x + playerWidth, nextPlayerX + playerWidth) / tileSize) + 2;
            const startRowX = Math.floor(player.y / tileSize);
            const endRowX = Math.floor((player.y + playerHeight - 1) / tileSize);
            for (let col = startColX; col <= endColX; col++) {
                for (let row = startRowX; row <= endRowX; row++) {
                    if (isSolid(col, row)) {
                        const blockRect = { x: col * tileSize, y: row * tileSize, width: tileSize, height: tileSize };
                        if (rectIntersects(playerRectX, blockRect)) {
                            if (player.dx > 0) nextPlayerX = blockRect.x - playerWidth;
                            else if (player.dx < 0) nextPlayerX = blockRect.x + tileSize;
                            player.dx = 0;
                        }
                    }
                }
            }
            player.x = nextPlayerX;
            if ((keys['ArrowUp'] || keys['KeyW']) && player.onGround) { 
				player.dy = currentJumpStrength;
				player.onGround = false;
			}
			if (worldLimitEnabled) {
				if (player.x < worldMinX * tileSize) {
					player.x = worldMinX * tileSize;
					player.dx = 0;
				}
				if (player.x + playerWidth > worldMaxX * tileSize) {
					player.x = (worldMaxX * tileSize) - playerWidth;
					player.dx = 0;
				}
				if (player.y < worldMinY * tileSize) {
					player.y = worldMinY * tileSize;
					player.dy = 0;
				}
				if (player.y + playerHeight > worldMaxY * tileSize) {
					player.y = (worldMaxY * tileSize) - playerHeight;
					player.dy = 0;
					player.onGround = true; 
				}
			}
        }
        function updateCamera() {
            camera.x = player.x + playerWidth / 2 - canvas.width / 2;
            camera.y = player.y + playerHeight / 2 - canvas.height / 2;
        }
        function handleMiningDrops(blockProps, targetKey) {
            const [col, row] = targetKey.split(',').map(Number); 
			const blockData = worldBlocks[targetKey];
            if (blockData && blockData.type === 'world_mover' && blockData.inventory) {
                const fuelItem = blockData.inventory[0];
                if (fuelItem) {
                    addToInventory(fuelItem.type, fuelItem.count);
                    blockData.inventory[0] = null;
                }
            }
            if (blockData && blockData.type === 'chest' && blockData.inventory) {
                blockData.inventory.forEach(item => {
                    if (item) {
                        addToInventory(item.type, item.count, item.durability);
                    }
                });
            }
      if (blockData && blockData.type === 'bed') {
        const [col, row] = targetKey.split(',').map(Number);
        const bedPart = blockData.part;
        let startCol = col;
        if (bedPart === 'middle') {
          startCol = col - 1;
        } else if (bedPart === 'right') {
          startCol = col - 2;
        }
        let bedIntact = true;
        for (let i = 0; i < 3; i++) {
          const partKey = `${startCol + i},${row}`;
          if (!worldBlocks[partKey] || worldBlocks[partKey].type !== 'bed') {
            bedIntact = false;
            break;
          }
        }
        if (bedIntact) {
          for (let i = 0; i < 3; i++) {
            const key = `${startCol + i},${row}`;
						player.bedSpawnPoint = null
            worldBlocks[key] = {
              type: '',
              solid: false
            };
          }
          addToInventory('bed', 1);
        }
        return; 
      }
			if (blockData && blockData.type === 'trader') {
				const [col, row] = targetKey.split(',').map(Number);
				const part = blockData.part; 
				let bottomRow = row;
				if (part === 'middle') bottomRow = row + 1;
				else if (part === 'top') bottomRow = row + 2;
				let traderIntact = true;
				for (let dy = 0; dy <= 2; dy++) {
					const k = `${col},${bottomRow - dy}`; 
					if (!worldBlocks[k] || worldBlocks[k].type !== 'trader') {
						traderIntact = false; break;
					}
				}
				if (traderIntact) {
					for (let dy = 0; dy <= 2; dy++) {
						const k = `${col},${bottomRow - dy}`;
						worldBlocks[k] = { type: '', mineProg: 0 };
					}
					traderDropRandom = random() < 0.5 ? 'bronze_coin' : random() < 0.5 ? 'trader_mask' : 'gold_coin';
					addToInventory(traderDropRandom, 1);
				}
			}
            if (blockProps && blockProps.drops) {
                blockProps.drops.forEach(drop => {
                    if (random() < drop.chance) {
						if (animateDrops) {
							createAnimatedDrop(col, row, drop);
						} else {
							const count = drop.min + Math.floor(random() * (drop.max - drop.min + 1));
							if (count > 0) {
								addToInventory(drop.item, count);
							}
						}
					}
                });
            }
        }
        function handleBombDrops(blockProps, targetKey) {
            const blockData = worldBlocks[targetKey];
            if (blockData && blockData.inventory) {
                blockData.inventory.forEach(item => {
                    if (item) {
                        addToVoidStorage(item.type, item.count, item.durability, item.maxDurability);
                    }
                });
                blockData.inventory.fill(null);
            }
            if (blockProps && blockProps.drops) {
                blockProps.drops.forEach(drop => {
                    const count = drop.min + Math.floor(random() * (drop.max - drop.min + 1));
                    if (count > 0) {
                        addToVoidStorage(drop.item, count);
                    }
                });
            }
        }
		function updateAnimatedDrops(dt) {
			const dropSpeed = 0.08;
			const pickupRadiusSq = (tileSize * 1.5) * (tileSize * 1.5); 
			for (let i = animatedDrops.length - 1; i >= 0; i--) {
				const drop = animatedDrops[i];
				if (drop.pickupDelay > 0) {
					drop.pickupDelay -= dt;
				}
				drop.dy += 0.3; 
				if (drop.pickupDelay <= 0) {
					const playerCenterX = player.x + playerWidth / 2;
					const playerCenterY = player.y + playerHeight / 2;
					const vecX = playerCenterX - drop.x;
					const vecY = playerCenterY - drop.y;
					const dist = Math.sqrt(vecX * vecX + vecY * vecY);
					if (dist > 1) { 
						drop.dx += (vecX / dist) * dropSpeed * dt;
						drop.dy += (vecY / dist) * dropSpeed * dt;
					}
				}
				drop.dx *= 0.95;
				drop.dy *= 0.95;
				drop.x += drop.dx;
				drop.y += drop.dy;
				const distToPlayerSq = Math.pow(player.x + playerWidth / 2 - drop.x, 2) + Math.pow(player.y + playerHeight / 2 - drop.y, 2);
				if (drop.pickupDelay <= 0 && distToPlayerSq < pickupRadiusSq) {
					if (addToInventory(drop.type, drop.count)) {
						animatedDrops.splice(i, 1); 
					}
				}
			}
		}
		function createAnimatedDrop(col, row, drop) {
			const itemProps = itemTypes[drop.item] || blockTypes[drop.item];
			if (!itemProps) return;
			const count = drop.min + Math.floor(random() * (drop.max - drop.min + 1));
			if (count <= 0) return;
			const dropEntity = {
				x: col * tileSize + tileSize / 2, 
				y: row * tileSize + tileSize / 2,
				dx: (Math.random() - 0.5) * 6, 
				dy: -Math.random() * 5,
				type: drop.item,
				count: count,
				pickupDelay: 500, 
				img: assets[drop.item]
			};
			animatedDrops.push(dropEntity);
		}
        function canInventoryAcceptDrops(drops) {
            if (!drops || drops.length === 0) return true;
            const tempInventory = JSON.parse(JSON.stringify(inventorySlots));
            for (const drop of drops) {
                let remainingCount = drop.min; 
                const itemType = drop.item;
                const itemProps = itemTypes[itemType] || blockTypes[itemType];
                if (itemProps.isTool) {
                    let hasEmptySlot = false;
                    for (let i = 0; i < totalInventorySlots; i++) {
                        if (!tempInventory[i]) {
                            tempInventory[i] = { type: itemType, count: 1 }; 
                            hasEmptySlot = true;
                            remainingCount--;
                            break;
                        }
                    }
                    if (!hasEmptySlot) return false; 
                } else {
                    for (let i = 0; i < totalInventorySlots; i++) {
                        if (remainingCount === 0) break;
                        const slot = tempInventory[i];
                        if (slot && slot.type === itemType && slot.count < maxStackSize) {
                            const canAdd = Math.min(remainingCount, maxStackSize - slot.count);
                            slot.count += canAdd;
                            remainingCount -= canAdd;
                        }
                    }
                    if (remainingCount > 0) {
                        for (let i = 0; i < totalInventorySlots; i++) {
                            if (remainingCount === 0) break;
                            if (!tempInventory[i]) {
                                const canAdd = Math.min(remainingCount, maxStackSize);
                                tempInventory[i] = { type: itemType, count: canAdd }; 
                                remainingCount -= canAdd;
                            }
                        }
                    }
                }
                if (remainingCount > 0) return false; 
            }
            return true; 
        }
        function updateMining(dt) {
			if (!isGameActive || isGamePaused) return;
			const worldMouseX = mouse.x + camera.x;
			const worldMouseY = mouse.y + camera.y;
			const targetCol = Math.floor(worldMouseX / tileSize);
			const targetRow = Math.floor(worldMouseY / tileSize);
			const targetKey = `${targetCol},${targetRow}`;
			let blockData = worldBlocks[targetKey] || getBlockData(targetCol, targetRow);
			let effectiveBlockType = blockData.type;
			if (blockData.type.startsWith('planted_')) {
				const seedType = blockData.type.replace('planted_', '').replace('_seeds', '');
				effectiveBlockType = `${seedType}${blockData.baseBlockType}`;
			}
			const blockPropsForMining = blockTypes[effectiveBlockType];
			const equippedItemObject = getSelectedItem();
			const equippedItemProps = equippedItemObject ? itemTypes[equippedItemObject.type] : null;
			const equippedItemType = equippedItemObject ? equippedItemObject.type : null;
			let currentMiningPower;
			if (equippedItemProps && equippedItemProps.isTool) {
				const isAxeBlock = effectiveBlockType.startsWith('r') || effectiveBlockType.startsWith('p') || effectiveBlockType.startsWith('cactus_') || effectiveBlockType.endsWith('w');
				const isShovelBlock = blockPropsForMining && blockPropsForMining.shovelBlock;
                const isPickaxe = equippedItemType.includes('_pickaxe');
                if (isPickaxe && (isAxeBlock || isShovelBlock)) {
                    currentMiningPower = 0.1;
                } else if (isAxeBlock && equippedItemProps.axePower) {
					currentMiningPower = equippedItemProps.axePower;
				} else if (isShovelBlock && equippedItemProps.shovelPower) {
					currentMiningPower = equippedItemProps.shovelPower;
				} else {
                    currentMiningPower = equippedItemProps.miningPower;
				}
			} else {
				currentMiningPower = handMiningPower;
			}
			let canMine = true;
			if (blockPropsForMining) {
				if (blockPropsForMining.requiredMiningPower && currentMiningPower < blockPropsForMining.requiredMiningPower) {
					canMine = false;
				}
				if (blockPropsForMining.requiredTool) {
					const required = blockPropsForMining.requiredTool;
					if (Array.isArray(required)) {
						if (!required.includes(equippedItemType)) {
							canMine = false;
						}
					} else {
						if (equippedItemType !== required) {
							canMine = false;
						}
					}
				}
			}
			if (mouse.down && (!miningTarget || miningTarget.col !== targetCol || miningTarget.row !== targetRow)) {
				if (blockData && blockPropsForMining?.miningHardness > 0 && canMine) { 
					miningTarget = {
						col: targetCol,
						row: targetRow,
						progress: maintainBlockDurability ? (blockData.mineProg || 0) : 0,
						requiredProgress: blockPropsForMining.miningHardness
					};
				} else {
					miningTarget = null;
				}
			}
			if (mouse.down && miningTarget && miningTarget.col === targetCol && miningTarget.row === targetRow) {
				if (!canMine || !blockData || blockPropsForMining?.miningHardness === 0) {
					if (maintainBlockDurability && worldBlocks[targetKey]) worldBlocks[targetKey].mineProg = 0;
					miningTarget = null;
					return;
				}
				const blockToMine = worldBlocks[targetKey];
				if (blockToMine && (blockToMine.type === 'chest' || blockToMine.type === 'dead_body_chest' || blockToMine.type === 'refrigerator' || blockToMine.type === 'oven')) {
					if (blockToMine.inventory && blockToMine.inventory.some(item => item !== null)) {
						miningTarget = null;
						return;
					}
				}
				miningTarget.progress += dt * currentMiningPower;
				if (maintainBlockDurability) worldBlocks[targetKey].mineProg = miningTarget.progress;
				if (equippedItemObject && equippedItemProps?.isTool && equippedItemObject.durability !== undefined) {
					equippedItemObject.durability -= dt * currentMiningPower; 
					if (equippedItemObject.durability <= 0) {
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						miningTarget = null;
						updateHotbar();
						return;
					}
				}
				if (miningTarget.progress >= miningTarget.requiredProgress) {
					const blockToMineData = worldBlocks[targetKey];
                    if (blockToMineData && blockToMineData.type === 'world_mover') {
                        let spaceNeeded = 1; 
                        const fuel = blockToMineData.inventory ? blockToMineData.inventory[0] : null;
                        let hasSpace = false;
                        const tempInventory = JSON.parse(JSON.stringify(inventorySlots)); 
                        let moverSlotIndex = -1;
                        for (let i = 0; i < tempInventory.length; i++) {
                            if (!tempInventory[i]) {
                                moverSlotIndex = i;
                                tempInventory[i] = { type: 'world_mover', count: 1 }; 
                                break;
                            }
                        }
                        if (moverSlotIndex !== -1) {
                            if (!fuel) {
                                hasSpace = true; 
                            } else {
                                let fuelRemaining = fuel.count;
                                for (let i = 0; i < tempInventory.length; i++) {
                                    if (tempInventory[i] && tempInventory[i].type === fuel.type && tempInventory[i].count < maxStackSize) {
                                        const canAdd = maxStackSize - tempInventory[i].count;
                                        const toAdd = Math.min(fuelRemaining, canAdd);
                                        tempInventory[i].count += toAdd;
                                        fuelRemaining -= toAdd;
                                    }
                                }
                                while (fuelRemaining > 0) {
                                    let foundEmpty = false;
                                    for (let i = 0; i < tempInventory.length; i++) {
                                        if (!tempInventory[i]) {
                                            const toAdd = Math.min(fuelRemaining, maxStackSize);
                                            tempInventory[i] = { type: fuel.type, count: toAdd };
                                            fuelRemaining -= toAdd;
                                            foundEmpty = true;
                                            break;
                                        }
                                    }
                                    if (!foundEmpty) break; 
                                }
                                if (fuelRemaining <= 0) hasSpace = true;
                            }
                        }
                        if (!hasSpace) {
                            miningTarget.progress = miningTarget.requiredProgress - 1; 
                            return; 
                        }
                    }
					const minedBlockProps = blockTypes[effectiveBlockType];
					handleMiningDrops(minedBlockProps, targetKey);
					createBlockBreakParticles(miningTarget.col, miningTarget.row, effectiveBlockType);
					if (blockData.type !== 'bed') {
						worldBlocks[targetKey] = { type: '', mineProg: 0 };
					}
					const brokenBlockType = blockData.type;
                    const mechageezerComponents = ['lever_off', 'lever_on', 'chest_lever_off', 'chest_lever_on', 'reactant', 'trailer', 'lit_trailer', 'stone_trailer'];
                    if (mechageezerComponents.includes(brokenBlockType)) {
                        const [col, row] = targetKey.split(',').map(Number);
						const mechNeighbors = [
						  { col: col, row: row - 1 },
						  { col: col, row: row + 1 },
						  { col: col - 1, row: row },
						  { col: col + 1, row: row }
						];
						for (const n of mechNeighbors) {
						  const nt = getBlockType(n.col, n.row);
						  if (['lever_off','lever_on','chest_lever_off','chest_lever_on','reactant','trailer','lit_trailer','stone_trailer'].includes(nt)) {
							scheduleMechUpdate(n.col, n.row);
						  }
						}
                    }
					const blockAboveKey = `${targetCol},${targetRow - 1}`;
					const blockAboveData = worldBlocks[blockAboveKey];
					if (blockAboveData && (['grass', 'tall_grass', 'grass_sprouts', 'wheat', 'snow', 'large_snow_pile', 'desert_brush', 'desert_grass', 'prickly_pear_cactus', 'tomato_bush', 'pumpkin', 'anthill_sand_mound', 'moss', 'dark_moss', 'weed', 'shroom', 'cotton', 'rice', 'hop', 'coffee', 'oat', 'corn', 'barley', 'pinecone_pile', 'pine_needle_pile', 'leaf_pile', 'mossy_root', 'fern', 'leaf_plant', 'blue_flower', 'yellow_flower', 'red_flower', 'onion', 'garlic', 'chili_pepper_bush'].includes(blockAboveData.type))) {
						const blockAboveProps = blockTypes[blockAboveData.type];
						if (canInventoryAcceptDrops(blockAboveProps.drops)) {
							worldBlocks[blockAboveKey] = { type: '', mineProg: 0 };
							handleMiningDrops(blockAboveProps, blockAboveKey);
						}
					}
					miningTarget = null;
				}
			} else if (!mouse.down && miningTarget) {
				if (!maintainBlockDurability && worldBlocks[`${miningTarget.col},${miningTarget.row}`]) {
					worldBlocks[`${miningTarget.col},${miningTarget.row}`].mineProg = 0;
				}
				miningTarget = null;
			}
		}
		function updateParticles(dt) {
			for (let i = particles.length - 1; i >= 0; i--) {
				const p = particles[i];
				p.life -= dt;
				if (p.life <= 0) {
					particles.splice(i, 1);
					continue; 
				}
				p.dy += particleGravity;
				p.x += p.dx;
				p.y += p.dy;
			}
		}
		function updateHeldItemAnimation(dt) {
			const heldItem = getSelectedItem();
			const now = performance.now();
			const isPlacing = mouse.rightDown && heldItem && blockTypes[heldItem.type];
			const isMining = mouse.down && miningTarget;
			if (isPlacing || isMining) {
				if (!heldItemState.isSwinging) {
					heldItemState.isSwinging = true;
					heldItemState.swingTimer = 0; 
				}
			} else {
				heldItemState.isSwinging = false;
			}
			if (heldItemState.isSwinging) {
				const swingSpeed = 25; 
				heldItemState.swingTimer += dt / 1000 * swingSpeed;
				heldItemState.angle = Math.sin(heldItemState.swingTimer) * 1.8; 
				heldItemState.offsetX = Math.sin(heldItemState.swingTimer) * 20;
				heldItemState.offsetY = (Math.cos(heldItemState.swingTimer) * 10) - 10;
			} else {
				const returnSpeed = 0.15; 
				const defaultAngle = 0.5; 
				heldItemState.angle += (defaultAngle - heldItemState.angle) * returnSpeed;
				heldItemState.offsetX += (0 - heldItemState.offsetX) * returnSpeed;
				let bobOffsetY = 0;
				if (player.onGround && player.dx !== 0) {
					const bobSpeed = 15;
					const bobAmount = 3;
					heldItemState.bobTimer += dt / 1000 * bobSpeed;
					bobOffsetY = Math.sin(heldItemState.bobTimer) * bobAmount;
				} else {
					heldItemState.bobTimer = 0; 
				}
				let jumpOffsetY = 0;
				if (!player.onGround) {
					jumpOffsetY = player.dy * 0.8;
				}
				const targetY = bobOffsetY + jumpOffsetY;
				heldItemState.offsetY += (targetY - heldItemState.offsetY) * returnSpeed;
			}
		}
		const bombDamagePatterns = {
			'napalm_bomb': [90, 80, 70, 60, 50, 40, 30, 20, 10], 
			'dynamite_bomb': [90, 80, 70, 60, 50, 40, 30, 20, 10], 
			'octogen_bomb': [90, 80, 70, 60, 50, 40, 30, 20, 10], 
			'weak_nuclear_bomb': [150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10], 
			'subnuclear_bomb': [250, 240, 230, 220, 210, 200, 190, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10], 
            'nuclear_bomb': [600, 590, 580, 570, 560, 550, 540, 530, 520, 510, 500, 490, 480, 470, 460, 450, 440, 430, 420, 410, 400, 390, 380, 370, 360, 350, 340, 330, 320, 310, 300, 290, 280, 270, 260, 250, 240, 230, 220, 210, 200, 190, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10], 
			'traps': [90, 80, 70, 60, 50, 40, 30, 20, 10], 
			'trap_cs': [90, 80, 70, 60, 50, 40, 30, 20, 10], 
			'trap_cps': [150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10], 
		};
		function detonateBomb(col, row, bombType) {
			const bombProps = blockTypes[bombType];
			if (!bombProps) {
				console.error(`Bomb properties not found for type: ${bombType}`);
				return;
			}
			const radius = bombProps.bombRadius;
			const bombDamage = bombProps.bombDamage;
			const damageLayers = bombDamagePatterns[bombType];
			if (!damageLayers) {
				console.error(`Damage pattern not found for bomb type: ${bombType}`);
				return;
			}
			const originalParticleCount = particleCount;
			particleCount = 10; 
			createBlockBreakParticles(col, row, bombType);
			particleCount = originalParticleCount;
			for (let x = col - radius; x <= col + radius; x++) {
				for (let y = row - radius; y <= row + radius; y++) {
					const distance = Math.floor(Math.sqrt(Math.pow(x - col, 2) + Math.pow(y - row, 2)));
					if (distance < radius) {
						const targetKey = `${x},${y}`;
						const blockData = worldBlocks[targetKey];
						if (!blockData || blockData.type === 'sky' || blockData.type === '') continue;
						const blockProps = blockTypes[blockData.type];
						if (!blockProps || blockProps.miningHardness === 0 || blockProps.miningHardness > 250000) continue;
						const damageMultiplier = damageLayers[distance] || 0;
						const damageDealt = bombDamage * (damageMultiplier); 
						if (!blockData.mineProg) blockData.mineProg = 0;
						blockData.mineProg += damageDealt;
						if (blockData.mineProg >= blockProps.miningHardness) {
							if (canInventoryAcceptDrops(blockProps.drops)) {
								handleBombDrops(blockProps, targetKey);
								const tempParticleCount = particleCount;
								particleCount = 3; 
								createBlockBreakParticles(x, y, blockData.type);
								particleCount = tempParticleCount;
								worldBlocks[targetKey] = { type: '', mineProg: 0 };
							} else {
								blockData.mineProg = blockProps.miningHardness - 1;
							}
						}
					}
				}
			}
			worldBlocks[`${col},${row}`] = { type: '', mineProg: 0 };
			const playerCenterX = player.x + playerWidth / 2;
			const playerCenterY = player.y + playerHeight / 2;
			const bombCenterX = col * tileSize + tileSize / 2;
			const bombCenterY = row * tileSize + tileSize / 2;
			const distancePixels = Math.sqrt(Math.pow(playerCenterX - bombCenterX, 2) + Math.pow(playerCenterY - bombCenterY, 2));
			const distanceTiles = distancePixels / tileSize;
			if (distanceTiles < radius) {
				const { playerDamageMin, playerDamageMax } = bombProps;
				const damage = playerDamageMax - (distanceTiles / radius) * (playerDamageMax - playerDamageMin);
				if (damage > 0) {
					player.health -= Math.floor(damage);
					console.log(`Player took ${Math.floor(damage)} damage from explosion.`);
					if (player.health <= 0) {
						respawnPlayer();
					}
				}
			}
			worldBlocks[`${col},${row}`] = { type: '', mineProg: 0 };
		}
		function isPowerSource(col, row) {
			const type = getBlockType(col, row);
			return type === 'lever_on' || type === 'chest_lever_on' || type === 'reactant';
		}
		const pendingMechUpdates = new Set();
		let mechUpdateScheduled = false;
		function scheduleMechUpdate(col, row) {
		  pendingMechUpdates.add(`${col},${row}`);
		  if (!mechUpdateScheduled) {
			mechUpdateScheduled = true;
			setTimeout(() => { processMechUpdates(); }, 0);
		  }
		}
		function processMechUpdates() {
		  mechUpdateScheduled = false;
		  if (pendingMechUpdates.size === 0) return;
		  const starts = Array.from(pendingMechUpdates);
		  pendingMechUpdates.clear();
		  const globalVisited = new Set(); 
		  const bombsToDetonate = new Set();
		  for (const start of starts) {
			const [sc, sr] = start.split(',').map(Number);
			const key = `${sc},${sr}`;
			if (globalVisited.has(key)) continue;
			const stack = [{ col: sc, row: sr }];
			const component = [];
			const localVisited = new Set();
			const isMechBlock = (t) => ['lever_on','lever_off','chest_lever_off','chest_lever_on','reactant','trailer','lit_trailer','stone_trailer'].includes(t);
			while (stack.length) {
			  const { col, row } = stack.pop();
			  const k = `${col},${row}`;
			  if (localVisited.has(k)) continue;
			  localVisited.add(k);
			  if (globalVisited.has(k)) continue; 
			  const t = getBlockType(col, row);
			  if (!isMechBlock(t)) continue;
			  component.push({ col, row, type: t });
			  globalVisited.add(k);
			  const neighbors = [
				{ c: col, r: row - 1 }, { c: col, r: row + 1 },
				{ c: col - 1, r: row }, { c: col + 1, r: row }
			  ];
			  for (const n of neighbors) {
				const nk = `${n.c},${n.r}`;
				if (!localVisited.has(nk) && !globalVisited.has(nk)) {
				  const nt = getBlockType(n.c, n.r);
				  if (isMechBlock(nt)) stack.push({ col: n.c, row: n.r });
				}
			  }
			} 
			if (component.length === 0) continue;
			const hasRealSource = component.some(b => {
			  const t = b.type;
			  return t === 'lever_on' || t === 'chest_lever_on' || t === 'reactant';
			});
			const toChange = [];
			for (const b of component) {
			  const nowType = b.type; 
			  if (nowType === 'trailer' || nowType === 'lit_trailer') {
				const desired = hasRealSource ? 'lit_trailer' : 'trailer';
				if (nowType !== desired) toChange.push({ col: b.col, row: b.row, type: desired });
			  } else if (nowType === 'stone_trailer') {
				const desired = hasRealSource ? 'lit_trailer' : 'stone_trailer';
				if (nowType !== desired) toChange.push({ col: b.col, row: b.row, type: desired });
			  }
			}
			const litTrailers = component.filter(b => b.type === 'lit_trailer');
			if (toChange.length === 0 && litTrailers.length === 0 && !hasRealSource) {
			  continue;
			}
			for (const ch of toChange) {
			  const k = `${ch.col},${ch.row}`;
			  worldBlocks[k] = Object.assign(worldBlocks[k] || {}, { type: ch.type, mineProg: 0 });
			}
			const componentLitCoords = new Set();
			for (const b of component) {
			  const curType = getBlockType(b.col, b.row); 
			  if (curType === 'lit_trailer') componentLitCoords.add(`${b.col},${b.row}`);
			}
			const bombs = ['napalm_bomb','dynamite_bomb','octogen_bomb','weak_nuclear_bomb','subnuclear_bomb','nuclear_bomb', 'traps', 'trap_cs', 'trap_cps'];
			for (const lt of componentLitCoords) {
			  const [lc, lr] = lt.split(',').map(Number);
			  const neighbors = [
				{ c: lc, r: lr - 1 }, { c: lc, r: lr + 1 },
				{ c: lc - 1, r: lr }, { c: lc + 1, r: lr }
			  ];
			  for (const n of neighbors) {
				const nt = getBlockType(n.c, n.r);
				if (bombs.includes(nt)) bombsToDetonate.add(`${n.c},${n.r},${nt}`);
			  }
			}
		  } 
		  if (bombsToDetonate.size > 0) {
			setTimeout(() => {
			  for (const b of bombsToDetonate) {
				const [bc, br, btype] = b.split(',');
				if (getBlockType(Number(bc), Number(br)) === btype) {
				  detonateBomb(Number(bc), Number(br), btype);
				}
			  }
			}, 40);
		  }
		}
        function handleBlockPlacement() {
            if (!isGameActive || isGamePaused || !mouse.rightDown) return;
				const selectedItemObject = getSelectedItem();
				const selectedItemType = selectedItemObject ? selectedItemObject.type : null;
				if (
				  selectedItemObject &&
				  selectedItemObject.count > 0 &&
				  itemTypes[selectedItemType]?.isFood
				) {
				  const props = itemTypes[selectedItemType];
				  if (typeof props.addsMaxHealth === 'number' && props.addsMaxHealth !== 0) {
					player.maxHealth = (player.maxHealth || 100) + props.addsMaxHealth;
				  }
				  if (props.fullHeal) {
					player.health = player.maxHealth;
                    removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
				  } else {
					const healAmount = props.healAmount || 0;
					if (healAmount > 0) {
						if (player.health < player.maxHealth) {
							player.health += healAmount;
							if (player.health > player.maxHealth) player.health = player.maxHealth;
							removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						}
					} else {
						player.health += healAmount;
						if (player.health > player.maxHealth) player.health = player.maxHealth;
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						if (player.health <= 0) {
							respawnPlayer();
							return;
						}
					}
				  }
				  mouse.rightDown = false;
				  return;
				}
            const worldMouseX = mouse.x + camera.x;
            const worldMouseY = mouse.y + camera.y;
            const targetCol = Math.floor(worldMouseX / tileSize);
            const targetRow = Math.floor(worldMouseY / tileSize);
            const targetKey = `${targetCol},${targetRow}`;
            const blockAtTarget = getBlockData(targetCol, targetRow);
            if (blockAtTarget.type === 'chest' || blockAtTarget.type === 'dead_body_chest' || blockAtTarget.type === 'refrigerator' || blockAtTarget.type === 'magical_chest') {
                toggleChestMenu(targetCol, targetRow);
                mouse.rightDown = false;
                return;
            } else if (blockAtTarget.type === 'void_chest') {
				toggleVoidChestMenu();
				mouse.rightDown = false;
				return;
			} else if (blockAtTarget.type === 'oven' || blockAtTarget.type === 'magma_furnace') {
				toggleFurnaceMenu(targetCol, targetRow, blockAtTarget.type); 
				mouse.rightDown = false;
				return;
			} else if (blockAtTarget.type === 'item_frame') { 
                const selectedItemObject = getSelectedItem();
                if (selectedItemObject) {
					if (selectedItemType != 'item_frame') {
						worldBlocks[targetKey].item = { 
							type: selectedItemObject.type, 
							count: selectedItemObject.count
						}
                    };
                } else {
                    worldBlocks[targetKey].item = null;
                }
                mouse.rightDown = false;
                return; 
            } else if (blockAtTarget.type === 'world_mover') {
                const selectedItem = getSelectedItem();
                const moverData = worldBlocks[targetKey];
                if (selectedItem && selectedItem.type === 'pure_fuel') {
                    if (!moverData.inventory) {
                        moverData.inventory = new Array(1).fill(null);
                    }
                    const fuelSlot = moverData.inventory[0];
                    if (!fuelSlot) {
                        moverData.inventory[0] = { type: selectedItem.type, count: selectedItem.count };
                        removeItemFromInventory(hotbarIndices[selectedHotbarSlot], selectedItem.count);
                        showMessageBox(`Fueled World Mover with ${moverData.inventory[0].count} Pure Fuel.`, 'alert');
                    } else if (fuelSlot.type === 'pure_fuel' && fuelSlot.count < maxStackSize) {
                        const spaceAvailable = maxStackSize - fuelSlot.count;
                        const amountToAdd = Math.min(selectedItem.count, spaceAvailable);
                        fuelSlot.count += amountToAdd;
                        removeItemFromInventory(hotbarIndices[selectedHotbarSlot], amountToAdd);
                        showMessageBox(`Added ${amountToAdd} Pure Fuel. Total: ${fuelSlot.count}.`, 'alert');
                    } else {
                        showMessageBox(`World Mover fuel tank is full.`, 'alert');
                    }
                } else {
                    toggleWorldMoverMenu(targetCol, targetRow);
                }
                mouse.rightDown = false;
                return;
            } else if (blockAtTarget.type === 'trader') {
                toggleTraderMenu(targetCol, targetRow);
                mouse.rightDown = false;
                return; 
            } else if (blockAtTarget.type === 'bed') {
                player.bedSpawnPoint = { x: (targetCol - 1) * tileSize, y: (targetRow - playerHeightBlocks) * tileSize };
                showMessageBox("Bed point set! Press the ; key to teleport to bed as long as your health is above 50! It will cost you 10 health points though!", 'alert');
                mouse.rightDown = false;
                return;
            } else if (blockAtTarget.type === 'lever_off' || blockAtTarget.type === 'lever_on') {
                const newState = blockAtTarget.type === 'lever_off' ? 'lever_on' : 'lever_off';
                worldBlocks[targetKey].type = newState;
                scheduleMechUpdate(targetCol, targetRow);
                mouse.rightDown = false; 
                return;
            } else if (blockAtTarget.type === 'chest_lever_off' || blockAtTarget.type === 'chest_lever_on') {
                const newState = blockAtTarget.type === 'chest_lever_off' ? 'chest_lever_on' : 'chest_lever_off';
                worldBlocks[targetKey].type = newState;
                scheduleMechUpdate(targetCol, targetRow);
                mouse.rightDown = false; 
                return;
            }
            if (selectedItemObject && selectedItemObject.count > 0) {
                const selectedItemIsPlaceableBlock = selectedItemType && blockTypes[selectedItemType] && blockTypes[selectedItemType].solid;
                const selectedItemIsBed = selectedItemType === 'bed';
				const selectedItemIsTrader = selectedItemType === 'trader';
				const selectedItemIsGrassSeeds = selectedItemType === 'grass_seeds';
				const selectedItemIsMossSeeds = selectedItemType === 'moss_seeds';
                const selectedItemIsPest = selectedItemType === 'pest';
				const selectedItemIsCobweb = selectedItemType === 'cobweb';
                const selectedItemIsSeeds = selectedItemType === 'wheat_seeds' || selectedItemType === 'tomato_seeds' || selectedItemType === 'pumpkin_seeds' || selectedItemType === 'cotton_seeds' || selectedItemType === 'rice_seeds' || selectedItemType === 'hop_seeds' || selectedItemType === 'coffee_seeds' || selectedItemType === 'oat_seeds' || selectedItemType === 'corn_seeds' || selectedItemType === 'barley_seeds' || selectedItemType === 'onion_seeds' || selectedItemType === 'garlic_seeds' || selectedItemType === 'chili_pepper_seeds';
                const currentBlockAtTarget = getBlockType(targetCol, targetRow);
                const placementRect = { x: targetCol * tileSize, y: targetRow * tileSize, width: tileSize, height: tileSize };
                const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };
                if (rectIntersects(placementRect, playerRect)) {
                    mouse.rightDown = false;
                    return;
                }
                if (selectedItemIsBed) {
                    const canPlaceBed = isSolid(targetCol, targetRow + 1) && isSolid(targetCol - 1, targetRow + 1) && isSolid(targetCol + 1, targetRow + 1) &&
                                        getBlockType(targetCol, targetRow) === '' && getBlockType(targetCol - 1, targetRow) === '' && getBlockType(targetCol + 1, targetRow) === '';
                    if (canPlaceBed) {
                        worldBlocks[`${targetCol - 1},${targetRow}`] = { type: 'bed', part: 'left' };
                        worldBlocks[`${targetCol},${targetRow}`] = { type: 'bed', part: 'middle' };
                        worldBlocks[`${targetCol + 1},${targetRow}`] = { type: 'bed', part: 'right' };
                        removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
                    }
				} else if (selectedItemIsTrader) {
					const canPlaceTrader = getBlockType(targetCol, targetRow) === '' &&
										   getBlockType(targetCol, targetRow - 1) === '' &&
										   getBlockType(targetCol, targetRow - 2) === '' &&
										   isSolid(targetCol, targetRow + 1); 
					if (canPlaceTrader) {
						const placed = placeTraderAt(targetCol, targetRow);
						if (placed) removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
					}
				} else if (selectedItemIsGrassSeeds) {
					let seedUsed = false;
					const blockAtTarget = getBlockData(targetCol, targetRow);
					const blockAboveKey = `${targetCol},${targetRow - 1}`;
					const blockAboveType = getBlockType(targetCol, targetRow - 1);
					const placementRect = { x: targetCol * tileSize, y: targetRow * tileSize, width: tileSize, height: tileSize };
					const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };
					if (rectIntersects(placementRect, playerRect)) {
						mouse.rightDown = false;
						return;
					}
					if (blockAtTarget.type === 'd') {
						if (blockAboveType === 'iceb') {
							worldBlocks[targetKey] = { type: 'dark_grassd', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: '', mineProg: 0 }; 
							seedUsed = true;
						} else if (blockAboveType === 'packed_iceb') {
							worldBlocks[targetKey] = { type: 'dark_grassd', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: 'iceb', mineProg: 0 }; 
							seedUsed = true;
						} else {
							worldBlocks[targetKey] = { type: 'gd', mineProg: 0 }; 
							seedUsed = true;
						}
					} 
					else if (blockAtTarget.type === 'so') {
						if (blockAboveType === 'iceb') {
							worldBlocks[targetKey] = { type: 'dark_grasss', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: '', mineProg: 0 };
							seedUsed = true;
						} else if (blockAboveType === 'packed_iceb') {
							worldBlocks[targetKey] = { type: 'dark_grasss', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: 'iceb', mineProg: 0 };
							seedUsed = true;
						} else {
							worldBlocks[targetKey] = { type: 'gs', mineProg: 0 };
							seedUsed = true;
						}
					}
					else if (blockAtTarget.type === 'mud') {
						worldBlocks[targetKey] = { type: 'grass_mud', mineProg: 0 };
						seedUsed = true;
					}
					else if (blockAtTarget.type === 'sand') {
						if (blockAboveType === '') {
							worldBlocks[blockAboveKey] = { type: 'desert_brush', mineProg: 0 };
							seedUsed = true;
						} else if (blockAboveType === 'desert_brush') {
							worldBlocks[blockAboveKey] = { type: 'prickly_pear_cactus', mineProg: 0 };
							seedUsed = true;
						}
					} else if (blockAtTarget.type === 'red_sandb') {
						if (blockAboveType === '') {
							worldBlocks[blockAboveKey] = { type: 'desert_grass', mineProg: 0 };
							seedUsed = true;
						} if (blockAboveType === 'desert_grass') {
							worldBlocks[blockAboveKey] = { type: 'prickly_pear_cactus', mineProg: 0 };
							seedUsed = true;
						}
					}
					else if (['gd', 'gs', 'dark_grassd', 'dark_grasss'].includes(blockAtTarget.type)) {
						if (blockAboveType === '') {
							worldBlocks[blockAboveKey] = { type: 'grass_sprouts', mineProg: 0 };
							seedUsed = true;
						} else if (blockAboveType === 'grass_sprouts') {
							worldBlocks[blockAboveKey] = { type: 'grass', mineProg: 0 };
							seedUsed = true;
						} else if (blockAboveType === 'grass') {
							worldBlocks[blockAboveKey] = { type: 'tall_grass', mineProg: 0 };
							seedUsed = true;
						} else if (blockAboveType === 'tall_grass' || blockAboveType !== '') { 
							if (blockAtTarget.type === 'gd') {
								worldBlocks[targetKey] = { type: 'overgrown_grassd', mineProg: 0 };
							} else if (blockAtTarget.type === 'gs') {
								worldBlocks[targetKey] = { type: 'overgrown_grasss', mineProg: 0 };
							} else if (blockAtTarget.type === 'dark_grassd') {
								worldBlocks[targetKey] = { type: 'overgrown_dark_grassd', mineProg: 0 };
							} else if (blockAtTarget.type === 'dark_grasss') {
								worldBlocks[targetKey] = { type: 'overgrown_dark_grasss', mineProg: 0 };
							}
							seedUsed = true;
						}
					}
					else if (blockAtTarget.type === 'grass_mud') {
						if (blockAboveType === '') {
							worldBlocks[blockAboveKey] = { type: 'fern', mineProg: 0 };
						} else {
							worldBlocks[targetKey] = { type: 'overgrown_grass_mud', mineProg: 0 };
						}
						seedUsed = true;
					}
					if (seedUsed) {
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						mouse.rightDown = false; 
					}
                } else if (selectedItemIsMossSeeds) {
					let seedUsed = false;
					const blockAtTarget = getBlockData(targetCol, targetRow);
					const blockAboveKey = `${targetCol},${targetRow - 1}`;
					const blockAboveType = getBlockType(targetCol, targetRow - 1);
					const placementRect = { x: targetCol * tileSize, y: targetRow * tileSize, width: tileSize, height: tileSize };
					const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };
					if (rectIntersects(placementRect, playerRect)) {
						mouse.rightDown = false;
						return;
					}
					if (blockAtTarget.type === 'd') {
						if (blockAboveType === 'iceb') {
							worldBlocks[targetKey] = { type: 'dark_mossd', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: '', mineProg: 0 }; 
							seedUsed = true;
						} else if (blockAboveType === 'packed_iceb') {
							worldBlocks[targetKey] = { type: 'dark_mossd', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: 'iceb', mineProg: 0 }; 
							seedUsed = true;
						} else {
							worldBlocks[targetKey] = { type: 'mossd', mineProg: 0 }; 
							seedUsed = true;
						}
					}
					if (blockAtTarget.type === 'so') {
						if (blockAboveType === 'iceb') {
							worldBlocks[targetKey] = { type: 'dark_mosss', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: '', mineProg: 0 }; 
							seedUsed = true;
						} else if (blockAboveType === 'packed_iceb') {
							worldBlocks[targetKey] = { type: 'dark_mosss', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: 'iceb', mineProg: 0 }; 
							seedUsed = true;
						} else {
							worldBlocks[targetKey] = { type: 'mosss', mineProg: 0 }; 
							seedUsed = true;
						}
					}
					else if (blockAtTarget.type === 'stone_brickb') {
						if (blockAboveType === 'iceb') {
							worldBlocks[targetKey] = { type: 'dark_moss_stone_brickb', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: '', mineProg: 0 }; 
							seedUsed = true;
						} else if (blockAboveType === 'packed_iceb') {
							worldBlocks[targetKey] = { type: 'dark_moss_stone_brickb', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: 'iceb', mineProg: 0 }; 
							seedUsed = true;
						} else {
							worldBlocks[targetKey] = { type: 'moss_stone_brickb', mineProg: 0 }; 
							seedUsed = true;
						}
					}
					else if (['mossd', 'mosss', 'dark_mossd', 'dark_mosss'].includes(blockAtTarget.type)) {
						if (blockAboveType === '') {
							if (blockAtTarget.type === 'mossd' || blockAtTarget.type === 'mosss') {
								worldBlocks[blockAboveKey] = { type: 'moss', mineProg: 0 };
								seedUsed = true;
							} else if (blockAtTarget.type === 'dark_mossd' || blockAtTarget.type === 'dark_mosss') {
								worldBlocks[blockAboveKey] = { type: 'dark_moss', mineProg: 0 };
								seedUsed = true;
							}
						}
					}
					if (seedUsed) {
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						mouse.rightDown = false; 
					}
				} else if (selectedItemIsPest) {
					let seedUsed = false;
					const blockAtTarget = getBlockData(targetCol, targetRow);
					const blockAboveKey = `${targetCol},${targetRow - 1}`;
					const blockAboveType = getBlockType(targetCol, targetRow - 1);
					const placementRect = { x: targetCol * tileSize, y: targetRow * tileSize, width: tileSize, height: tileSize };
					const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };
					if (rectIntersects(placementRect, playerRect)) {
						mouse.rightDown = false;
						return;
					}
					if (blockAtTarget.type === 'gd') {
						worldBlocks[targetKey] = { type: 'weedd', mineProg: 0 };
						seedUsed = true;
					}
                    else if (blockAtTarget.type === 'weedd') {
						if (blockAboveType === '') {
							worldBlocks[blockAboveKey] = { type: 'weed', mineProg: 0 };
							seedUsed = true;
						}
					}
					else if (blockAtTarget.type === 'so') {
						worldBlocks[targetKey] = { type: 'pestd', mineProg: 0 };
						seedUsed = true;
					}
					else if (blockAtTarget.type === 's') {
						worldBlocks[targetKey] = { type: 'pest_stone_block_weak', mineProg: 0 };
						seedUsed = true;
					} else if (blockAtTarget.type === 'pest_stone_block_weak') {
                        if (blockAboveType === 'pest_stone_block_weak') {
						    worldBlocks[targetKey] = { type: 'pest_stone_block_strong', mineProg: 0 };
                            worldBlocks[blockAboveKey] = { type: '', mineProg: 0 };
						    seedUsed = true;
                        }
					}
					if (seedUsed) {
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						mouse.rightDown = false; 
					}
				} else if (selectedItemIsCobweb) {
					let seedUsed = false;
					const blockAtTarget = getBlockData(targetCol, targetRow);
					const blockAboveKey = `${targetCol},${targetRow - 1}`;
					const blockAboveType = getBlockType(targetCol, targetRow - 1);
					const placementRect = { x: targetCol * tileSize, y: targetRow * tileSize, width: tileSize, height: tileSize };
					const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };
					if (rectIntersects(placementRect, playerRect)) {
						mouse.rightDown = false;
						return;
					}
					else if (blockAtTarget.type === '') {
						worldBlocks[targetKey] = { type: 'cobweb', mineProg: 0 };
						seedUsed = true;
					}
					if (seedUsed) {
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						mouse.rightDown = false; 
					}
				} else if (selectedItemIsSeeds) {
                    if (['d', 'so', 'f'].includes(currentBlockAtTarget)) {
                        worldBlocks[targetKey] = { type: `planted_${selectedItemType}`, mineProg: 0, plantTime: gameTime, baseBlockType: currentBlockAtTarget };
                        activePlants.add(targetKey);
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
                    }
                } else if (selectedItemIsPlaceableBlock) {
					const replaceableBlocks = ['', 'grass', 'tall_grass', 'grass_sprouts', 'wheat', 'oak_bush', 'birch_bush', 'spruce_bush', 'snow', 'large_snow_pile', 'desert_brush', 'desert_grass', 'prickly_pear_cactus', 'tomato_bush', 'pumpkin', 'anthill_sand_mound', 'moss', 'dark_moss', 'weed', 'shroom', 'cotton', 'rice', 'hop', 'coffee', 'oat', 'corn', 'barley', 'pine_needle_pile', 'pinecone_pile', 'leaf_pile', 'leaf_plant', 'blue_flower', 'yellow_flower', 'red_flower', 'onion', 'garlic', 'chili_pepper_bush'];
                    if (replaceableBlocks.includes(currentBlockAtTarget)) {
                        if (currentBlockAtTarget !== '') {
                            const replacedBlockProps = blockTypes[currentBlockAtTarget];
                            handleMiningDrops(replacedBlockProps, targetKey);
                        }
                        if (selectedItemType === 'chest') {
							worldBlocks[targetKey] = { type: selectedItemType, mineProg: 0, inventory: new Array(chestInventorySize).fill(null), label: '' };
						} else if (selectedItemType === 'refrigerator') {
							worldBlocks[targetKey] = { type: selectedItemType, mineProg: 0, inventory: new Array(18).fill(null), label: '' };
						} else if (selectedItemType === 'magical_chest') {
							worldBlocks[targetKey] = { type: selectedItemType, mineProg: 0, inventory: new Array(50).fill(null), label: '' };
						} else if (selectedItemType === 'oven' || selectedItemType === 'magma_furnace') {
							worldBlocks[targetKey] = { type: selectedItemType, mineProg: 0, inventory: new Array(12).fill(null) };
						} else if (selectedItemType === 'item_frame') { 
                            worldBlocks[targetKey] = { 
                                type: selectedItemType, 
                                mineProg: 0, 
                                item: null 
                            };
                        } else {
							worldBlocks[targetKey] = { type: selectedItemType, mineProg: 0 };
                            const placedType = selectedItemType;
                            const neighbors = [
                                { col: targetCol, row: targetRow - 1 }, 
                                { col: targetCol, row: targetRow + 1 }, 
                                { col: targetCol - 1, row: targetRow }, 
                                { col: targetCol + 1, row: targetRow }  
                            ];
                            for (const neighbor of neighbors) {
                                const neighborType = getBlockType(neighbor.col, neighbor.row);
                                const neighborKey = `${neighbor.col},${neighbor.row}`;
                                if (placedType === 'iceb' && neighborType === 'magma_stoneb') {
                                    worldBlocks[neighborKey] = { type: 'obsidianb', mineProg: 0 };
                                }
                                if (placedType === 'magma_stoneb' && neighborType === 'iceb') {
                                    worldBlocks[targetKey] = { type: 'obsidianb', mineProg: 0 };
                                    break; 
                                }
                                if (placedType === 'packed_iceb' && neighborType === 'magma_stoneb') {
                                    worldBlocks[neighborKey] = { type: 'obsidianb', mineProg: 0 };
                                }
                                if (placedType === 'magma_stoneb' && neighborType === 'packed_iceb') {
                                    worldBlocks[targetKey] = { type: 'obsidianb', mineProg: 0 };
                                    break; 
                                }
                            }
						}
						const mechageezerComponents = ['lever_off', 'lever_on', 'chest_lever_off', 'chest_lever_on', 'reactant', 'trailer', 'lit_trailer', 'stone_trailer'];
                        if (mechageezerComponents.includes(selectedItemType)) {
                            scheduleMechUpdate(targetCol, targetRow);
                            const neighbors = [
                                { col: targetCol, row: targetRow - 1 }, 
                                { col: targetCol, row: targetRow + 1 }, 
                                { col: targetCol - 1, row: targetRow }, 
                                { col: targetCol + 1, row: targetRow }  
                            ];
                            for (const n of neighbors) {
                                if (mechageezerComponents.includes(getBlockType(n.col, n.row))) {
                                    scheduleMechUpdate(n.col, n.row);
                                }
                            }
                        }
                        removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
                        if (selectedItemType === 'heaven_gate_brickb') {
                            checkAndCreateHeavenPortal(targetCol, targetRow);
                        }
                    }
                }
            }
        }
		function _ensureAcquiredTimes(slot, now) {
			if (!slot) return;
			now = now ?? gameTime;
			if (!Array.isArray(slot.acquiredTimes)) {
				if (slot.acquiredTime !== undefined) {
					slot.acquiredTimes = Array(slot.count || 0).fill(slot.acquiredTime);
					delete slot.acquiredTime;
				} else {
					slot.acquiredTimes = Array(slot.count || 0).fill(now);
				}
			} else {
				while (slot.acquiredTimes.length < (slot.count || 0)) slot.acquiredTimes.push(now);
				while (slot.acquiredTimes.length > (slot.count || 0)) slot.acquiredTimes.shift();
			}
		}
		function _takeTimestamps(slot, takeCount) {
			if (!slot) return [];
			if (!Array.isArray(slot.acquiredTimes)) {
				const now = gameTime;
				slot.acquiredTimes = Array(slot.count || 0).fill(now);
			}
			const taken = slot.acquiredTimes.splice(0, takeCount);
			while (taken.length < takeCount) taken.push(gameTime);
			return taken;
		}
		function _pushTimestampsIntoSlot(slot, timestamps) {
			if (!slot) return;
			if (!Array.isArray(slot.acquiredTimes)) slot.acquiredTimes = [];
			slot.acquiredTimes.push(...timestamps);
			while (slot.acquiredTimes.length > slot.count) slot.acquiredTimes.shift();
		}
        function addToInventory(itemType, count = 1, durability = null, acquiredTimes = null, inventory = inventorySlots) {
			if (!itemTypes[itemType] && !blockTypes[itemType]) {
				console.warn(`Attempted to add unknown item type: ${itemType}`);
				return false;
			}
			const itemProps = itemTypes[itemType] || blockTypes[itemType];
			let remaining = count;
			const now = gameTime;
			function takeFromParam(n) {
				if (!acquiredTimes) return Array(n).fill(now);
				return acquiredTimes.splice(0, n).concat(Array(Math.max(0, n - (acquiredTimes ? acquiredTimes.length : 0))).fill(now));
			}
			if (itemProps?.isTool) {
				for (let i = 0; i < inventory.length && remaining > 0; i++) {
					if (!inventory[i]) {
						inventory[i] = { type: itemType, count: 1, durability: durability ?? itemProps.maxDurability, maxDurability: itemProps.maxDurability };
						if (i < hotbarSize && hotbarIndices[i] === null) {
							hotbarIndices[i] = i;
						}
						remaining--;
					}
				}
			} else {
				for (let i = 0; i < inventory.length && remaining > 0; i++) {
					const slot = inventory[i];
					if (slot && slot.type === itemType && slot.count < maxStackSize) {
						const amountToAdd = Math.min(remaining, maxStackSize - slot.count);
						const timestamps = takeFromParam(amountToAdd);
						slot.count += amountToAdd;
						if (itemProps?.spoilable) {
							if (!Array.isArray(slot.acquiredTimes)) _ensureAcquiredTimes(slot, now);
							_pushTimestampsIntoSlot(slot, timestamps);
						}
						remaining -= amountToAdd;
					}
				}
				for (let i = 0; i < inventory.length && remaining > 0; i++) {
					if (!inventory[i]) {
						const amountForNewStack = Math.min(remaining, maxStackSize);
						const timestamps = takeFromParam(amountForNewStack);
						inventory[i] = { type: itemType, count: amountForNewStack };
						if (itemProps?.isTool) {
							inventory[i].durability = durability ?? itemProps.maxDurability;
							inventory[i].maxDurability = itemProps.maxDurability;
						} else if (itemProps?.spoilable) {
							inventory[i].acquiredTimes = timestamps.slice(); 
						}
						if (i < hotbarSize && hotbarIndices[i] === null) {
							hotbarIndices[i] = i;
						}
						remaining -= amountForNewStack;
					}
				}
			}
			updateHotbar();
			if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
			if (chestOverlay.style.display === 'flex') updateChestMenu();
			if (remaining > 0) {
				addToVoidStorage(itemType, remaining, durability, itemProps?.maxDurability);
			}
			return true; 
		}
		function animateVoidCharacter() {
			if (!isVoidChestOpen) return; 
			const character = document.getElementById('voidCharacter');
			voidCharacterBob += 0.05 * voidCharacterBobDirection;
			if (Math.abs(voidCharacterBob) > 2) { 
				voidCharacterBobDirection *= -1;
			}
			character.style.transform = `translateY(${voidCharacterBob}px)`;
			requestAnimationFrame(animateVoidCharacter);
		}
		function generateVoidTradeOffer() {
			if (voidStorage.length === 0) {
				currentVoidTrade = null;
				return;
			}
			const itemToOffer = voidStorage[Math.floor(random() * voidStorage.length)];
			const itemProps = itemTypes[itemToOffer.type] || blockTypes[itemToOffer.type];
			let offerCount = 1;
			if (!itemProps.isTool) {
				offerCount = 1 + Math.floor(random() * 30); 
				if (offerCount > itemToOffer.count) {
					offerCount = itemToOffer.count; 
				}
			}
			const costPerItem = 1 + Math.floor(random() * 5); 
			const coinType = random() < 0.5 ? 'bronze_coin' : 'gold_coin';
			currentVoidTrade = {
				itemType: itemToOffer.type,
				count: offerCount,
				costPerItem: costPerItem,
				coinType: coinType,
				durability: itemToOffer.durability,
				maxDurability: itemToOffer.maxDurability
			};
		}
		function updateVoidTradeOfferUI() {
			const characterContainer = document.getElementById('voidCharacterContainer');
			const tradeOfferBubble = document.getElementById('voidTradeOffer'); 
			const dialogueText = document.getElementById('voidDialogue');
			characterContainer.style.display = 'flex';
			if (!currentVoidTrade) {
				tradeOfferBubble.style.display = 'none';
				dialogueText.textContent = "The void is quiet... for now.";
				return;
			}
			tradeOfferBubble.style.display = 'flex';
			dialogueText.textContent = "Care to make a deal for what's been lost?";
			const offerItemSlot = document.getElementById('voidOfferItem');
			offerItemSlot.innerHTML = '';
			const itemSlotContent = createInventorySlot({ type: currentVoidTrade.itemType, count: currentVoidTrade.count, durability: currentVoidTrade.durability, maxDurability: currentVoidTrade.maxDurability }, -1, 'trade');
			offerItemSlot.appendChild(itemSlotContent);
			const offerCostDiv = document.getElementById('voidOfferCost');
			const totalCost = currentVoidTrade.costPerItem * currentVoidTrade.count;
			const coinImgSrc = assets[currentVoidTrade.coinType]?.src || '';
			offerCostDiv.innerHTML = `<span>Cost: ${totalCost}</span> <img src="${coinImgSrc}" alt="${currentVoidTrade.coinType}">`;
			const acceptButton = document.getElementById('voidAcceptButton');
			let playerCoinCount = 0;
			inventorySlots.forEach(item => {
				if (item && item.type === currentVoidTrade.coinType) {
					playerCoinCount += item.count;
				}
			});
			acceptButton.disabled = playerCoinCount < totalCost;
		}
		function addToVoidStorage(itemType, count, durability = null, maxDurability = null) {
			if (!itemType || count <= 0) return;
			const isNewItemType = !voidStorage.some(item => item && item.type === itemType);
			const itemProps = itemTypes[itemType] || blockTypes[itemType];
			if (itemProps && itemProps.isTool) {
				for (let i = 0; i < count; i++) {
					voidStorage.push({
						type: itemType,
						count: 1,
						durability: durability ?? itemProps.maxDurability,
						maxDurability: maxDurability ?? itemProps.maxDurability
					});
				}
			} else {
				let existingStack = voidStorage.find(item => item && item.type === itemType);
				if (existingStack) {
					existingStack.count += count;
				} else {
					voidStorage.push({ type: itemType, count: count });
				}
			}
			if (itemType === 'gold_coin') {
				if (count >= 5) {
					generateVoidTradeOffer()
				}
			} else if (itemType === 'bronze_coin') {
				if (count >= 10) {
					generateVoidTradeOffer()
				}
			}
			if (isNewItemType && random() < 0.2) {
				generateVoidTradeOffer();
			}
		}
        function removeItemFromInventory(slotIndex, count = 1, inventory = inventorySlots) {
			if (slotIndex === null || slotIndex === undefined || !inventory[slotIndex]) {
				console.warn(`Attempted to remove item from empty or invalid slot: ${slotIndex}`);
				return;
			}
			const itemInSlot = inventory[slotIndex];
			const toRemove = Math.min(count, itemInSlot.count);
			if (itemTypes[itemInSlot.type]?.spoilable && Array.isArray(itemInSlot.acquiredTimes)) {
				itemInSlot.acquiredTimes.splice(0, toRemove);
			}
			itemInSlot.count -= toRemove;
			if (itemInSlot.count <= 0) {
				inventory[slotIndex] = null;
				const hotbarIdx = hotbarIndices.indexOf(slotIndex);
				if (hotbarIdx !== -1) hotbarIndices[hotbarIdx] = null;
			}
			updateHotbar();
			if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
			if (chestOverlay.style.display === 'flex') updateChestMenu();
		}
        function getSelectedItem() {
            const hotbarSlotIndex = hotbarIndices[selectedHotbarSlot];
            return (hotbarSlotIndex !== null && hotbarSlotIndex !== undefined) ? inventorySlots[hotbarSlotIndex] : null;
        }
		function tp(XPOS, YPOS) {
			player.y = -YPOS * tileSize;
			player.x = XPOS * tileSize
		}
        function updateHotbar() {
            hotbarDiv.innerHTML = '';
            for (let i = 0; i < hotbarSize; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.classList.add('hotbar-slot');
                if (i === selectedHotbarSlot) slotDiv.classList.add('selected');
                const inventorySlotIndex = hotbarIndices[i];
                const itemObject = (inventorySlotIndex !== null && inventorySlotIndex !== undefined) ? inventorySlots[inventorySlotIndex] : null;
                if (itemObject) {
                    const itemProps = itemTypes[itemObject.type] || blockTypes[itemObject.type];
                    const itemImg = assets[itemObject.type];
                    if (itemImg && !failedAssets[itemObject.type]) {
                        const imgElement = document.createElement('img');
                        imgElement.src = itemImg.src;
                        slotDiv.appendChild(imgElement);
                    } else if (itemProps?.color) {
                        const fallbackDiv = document.createElement('div');
                        fallbackDiv.classList.add('fallback');
                        fallbackDiv.style.backgroundColor = itemProps.color;
                        fallbackDiv.textContent = itemObject.type.substring(0, 3).toUpperCase();
                        slotDiv.appendChild(fallbackDiv);
                    }
                    const countSpan = document.createElement('span');
                    countSpan.textContent = itemObject.count;
                    slotDiv.appendChild(countSpan);
                    if (itemProps?.isTool && itemObject.durability !== null && itemObject.durability !== undefined) {
                        const durabilityBar = document.createElement('div');
                        durabilityBar.classList.add('durability-bar');
                        const durabilityFill = document.createElement('div');
                        durabilityFill.classList.add('durability-fill');
                        const durabilityRatio = itemObject.durability / itemObject.maxDurability;
                        durabilityFill.style.width = `${Math.max(0, durabilityRatio * 100)}%`;
                        durabilityFill.style.backgroundColor = durabilityRatio > 0.6 ? '#28a745' : (durabilityRatio > 0.3 ? '#ffc107' : '#dc3545');
                        durabilityBar.appendChild(durabilityFill);
                        slotDiv.appendChild(durabilityBar);
                    }
                }
                hotbarDiv.appendChild(slotDiv);
            }
		   const selectedToolObject = getSelectedItem();
            const selectedToolProps = selectedToolObject ? itemTypes[selectedToolObject.type] : null;
        }
        function generateOffscreenChunks() {
            const playerCol = Math.floor((player.x + playerWidth / 2) / tileSize);
            const playerRow = Math.floor((player.y + playerHeight / 2) / tileSize);
            const viewWidthInTiles = Math.ceil(canvas.width / tileSize);
            const viewHeightInTiles = Math.ceil(canvas.height / tileSize);
            const startCol = playerCol - Math.floor(viewWidthInTiles / 2) - generationBuffer;
            const endCol = playerCol + Math.ceil(viewWidthInTiles / 2) + generationBuffer;
            const startRow = playerRow - Math.floor(viewHeightInTiles / 2) - generationBuffer;
            const endRow = playerRow + Math.ceil(viewHeightInTiles / 2) + generationBuffer;
            for (let col = startCol; col < endCol; col++) {
                for (let row = startRow; row < endRow + 50; row++) {
                    getBlockData(col, row); 
                }
            }
        }
        function drawWorld() {
            const playerGridY = Math.floor(player.y / tileSize);
            if (playerGridY < -100000) { 
                document.body.style.backgroundColor = '#ff8700';
            } 
            else if (playerGridY < -265) { 
                document.body.style.backgroundColor = '#000000';
            } else if (playerGridY < -145) { 
                document.body.style.backgroundColor = '#d8d043';
            } else if (playerGridY > 605) { 
                document.body.style.backgroundColor = '#000000';
			} else if (playerGridY > 205) { 
                document.body.style.backgroundColor = '#4d0f0f';
            } else if (playerGridY > 20) { 
                document.body.style.backgroundColor = '#2e2e2e';
            } else if (playerGridY > 10) { 
                document.body.style.backgroundColor = '#4e626d';
            } else { 
                document.body.style.backgroundColor = '#d8fffe';
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const startCol = Math.floor(camera.x / tileSize) - 1;
            const endCol = Math.ceil((camera.x + canvas.width) / tileSize) + 1;
            const startRow = Math.floor(camera.y / tileSize) - 1;
            const endRow = Math.ceil((camera.y + canvas.height) / tileSize) + 1;
            for (let col = startCol; col < endCol; col++) {
                for (let row = startRow; row < endRow; row++) {
                    const key = `${col},${row}`;
					const blockData = worldBlocks[key];
					if (!blockData || blockData.type === '') continue; 
                    let blockType = blockData.type;
                    let blockProps = blockTypes[blockType];
                    const screenX = col * tileSize - camera.x;
                    const screenY = row * tileSize - camera.y;
                    if (blockData.type.startsWith('planted_')) {
                        const seedType = blockData.type.replace('planted_', '').replace('_seeds', '');
                        blockType = `${seedType}${blockData.baseBlockType}`;
                        blockProps = blockTypes[blockType];
                    }
                    if (blockType !== '' && blockProps) {
                        const blockImg = assets[blockType];
                        if (blockImg && !failedAssets[blockType]) {
                            if (blockType === 'trader' && blockData.part === 'bottom') {
								ctx.drawImage(blockImg, screenX, screenY - tileSize*2, tileSize, tileSize*3);
							} else if (blockType === 'bed' && blockData.part === 'left') {
                                ctx.drawImage(blockImg, screenX, screenY, tileSize * 3, tileSize);
                            } else if (blockType !== 'bed') { 
                                ctx.drawImage(blockImg, screenX, screenY, tileSize, tileSize);
                            }
                        } else if (blockProps.color) {
                             ctx.fillStyle = blockProps.color;
                             ctx.fillRect(screenX, screenY, tileSize, tileSize);
                        }
                        if (blockType === 'item_frame' && blockData.item) {
                            const itemToDraw = assets[blockData.item.type];
                            if (itemToDraw) {
                                const itemSize = tileSize * 0.80; 
                                const itemOffset = (tileSize - itemSize) / 2; 
                                const itemX = screenX + itemOffset;
                                const itemY = screenY + itemOffset;
                                ctx.drawImage(itemToDraw, itemX, itemY, itemSize, itemSize);
                            }
                        }
                        if (maintainBlockDurability && blockData.mineProg > 0) {
                            let effectiveMiningHardness = blockTypes[blockData.type].miningHardness;
                            const progressRatio = blockData.mineProg / effectiveMiningHardness;
                            let overlayImage = null;
                            if (progressRatio >= 0.75) overlayImage = assets['breaking_stage_3'];
                            else if (progressRatio >= 0.50) overlayImage = assets['breaking_stage_2'];
                            else if (progressRatio >= 0.25) overlayImage = assets['breaking_stage_1'];
                            if (overlayImage) ctx.drawImage(overlayImage, screenX, screenY, tileSize, tileSize);
                        }
                    }
                }
            }
        }
        function drawPlayer() {
			ctx.drawImage(
				playerImg,
				player.x - camera.x,
				player.y - camera.y,
				playerWidth,
				playerHeight
			);
		}
		function drawAnimatedDrops() {
			if (animatedDrops.length === 0) return;
			for (const drop of animatedDrops) {
				if (drop.img && !failedAssets[drop.type]) {
					const drawSize = tileSize * 0.5; 
					ctx.drawImage(
						drop.img,
						drop.x - (drawSize / 2) - camera.x,
						drop.y - (drawSize / 2) - camera.y,
						drawSize,
						drawSize
					);
				}
			}
		}
		function drawParticles() {
			for (let i = 0; i < particles.length; i++) {
				const p = particles[i];
				const opacity = p.life / p.maxLife;
				ctx.globalAlpha = Math.max(0, opacity); 
				ctx.drawImage(
					p.img,
					p.sourceX,           
					p.sourceY,           
					p.sourceSize,        
					p.sourceSize,        
					p.x - camera.x,      
					p.y - camera.y,      
					p.drawSize,          
					p.drawSize           
				);
			}
			ctx.globalAlpha = 1.0;
		}
		function drawHeldItem() {
			const heldItem = getSelectedItem();
			if (!heldItem) {
				return; 
			}
			const itemImg = assets[heldItem.type];
			if (!itemImg || failedAssets[heldItem.type]) {
				return; 
			}
			const pivotX = player.x - camera.x + playerWidth / 2;
			const pivotY = player.y - camera.y + playerHeight / 2 + 5; 
			ctx.save(); 
			ctx.translate(pivotX, pivotY);
			ctx.scale(player.facingDirection, 1);
			ctx.rotate(heldItemState.angle);
			ctx.drawImage(
				itemImg, 
				10 + heldItemState.offsetX,  
				-5 + heldItemState.offsetY, 
				tileSize * 0.8, 
				tileSize * 0.8
			);
			ctx.restore(); 
		}
        function drawmineProg() {
            if (miningTarget) {
                const progressRatio = miningTarget.progress / miningTarget.requiredProgress;
                const screenX = miningTarget.col * tileSize - camera.x;
                const screenY = miningTarget.row * tileSize - camera.y;
                let overlayImage = null;
                if (progressRatio >= 0.75) overlayImage = assets['breaking_stage_3'];
                else if (progressRatio >= 0.50) overlayImage = assets['breaking_stage_2'];
                else if (progressRatio >= 0.25) overlayImage = assets['breaking_stage_1'];
                if (overlayImage) ctx.drawImage(overlayImage, screenX, screenY, tileSize, tileSize);
            }
        }
        function drawHealth() {
            healthBarDiv.classList.remove('glow-yellow', 'flash-red', 'glow-green');
            if (player.health > player.lastHealth) {
                healthBarDiv.classList.add('glow-green');
            } else if (player.health < player.lastHealth) {
                healthBarDiv.classList.add('flash-red');
            } else if (player.health >= player.maxHealth) {
                healthBarDiv.classList.add('glow-yellow');
            }
            player.lastHealth = player.health;
            healthBarDiv.innerHTML = '';
            const totalHearts = player.maxHealth / 20;
            let health = player.health;
            for (let i = 0; i < totalHearts; i++) {
                const img = document.createElement('img');
                if (health >= 20) {
                    img.src = assets['full_heart'].src;
                    health -= 20;
                } else if (health > 0) {
                    img.src = assets['half_heart'].src;
                    health = 0; 
                } else {
                    img.src = assets['empty_heart'].src;
                }
                healthBarDiv.appendChild(img);
            }
        }
        window.addEventListener('keydown', (e) => {
			if (e.key === '/') {
				e.preventDefault(); 
				toggleDevConsole();
				return; 
			}
			if (isConsoleOpen && e.code !== 'Escape') {
				return;
			}
			if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
				keys[e.code] = true;
			} else if (e.code === 'Escape') {
				keys[e.code] = true;
			}
            if (e.code === 'Escape') {
				if (isConsoleOpen) {
					toggleDevConsole();
				} else if (isGamePaused && inventoryCraftingOverlay.style.display === 'flex') {
					toggleInventoryMenu();
				} else if (isGamePaused && chestOverlay.style.display === 'flex') {
					toggleChestMenu();
				} else if (isGamePaused && ovenOverlay.style.display === 'flex') {
                    toggleFurnaceMenu();
                } else if (isGamePaused && worldMoverConfigOverlay.style.display === 'flex') {
                    toggleWorldMoverMenu();
                } else if (isGamePaused && worldMoverTeleportOverlay.style.display === 'flex') {
                    toggleTeleportMenu();
                } else if (isGamePaused && voidChestOverlay.style.display === 'flex') {
					toggleVoidChestMenu();
				} else if (isGamePaused && isTraderMenuOpen === true) {
					toggleTraderMenu();
				} else if (isGamePaused && gameMenuOverlay.style.display === 'flex') {
					toggleGameMenu();
				} else {
					toggleGameMenu();
				}
			}
            if (e.code === 'KeyE') {
                if (isGamePaused && chestOverlay.style.display === 'flex') return; 
                if (!isGamePaused || (isGamePaused && inventoryCraftingOverlay.style.display === 'flex')) toggleInventoryMenu();
            }
            if (!isGamePaused) {
                if (e.key >= '1' && e.key <= '9') selectedHotbarSlot = parseInt(e.key) - 1;
                else if (e.key === '0') selectedHotbarSlot = 9;
                updateHotbar();
            }
			if (e.key === ';' && player.health > 50) {
				if (player.bedSpawnPoint) {
					player.health -= 10
					player.x = player.bedSpawnPoint.x;
					player.y = player.bedSpawnPoint.y;
				}
			}
            if (e.key === '?') {
				if (particleCount > 30) {
                    showMessageBox("Particle Effects Reduced To 30!");
                    particleCount = 30;
                } else if (particleCount > 15) {
                    showMessageBox("Particle Effects Reduced To 15!");
                    particleCount = 15;
                } else if (particleCount > 5) {
                    showMessageBox("Particle Effects Reduced To 5!");
                    particleCount = 5;
                } else if (particleCount > 3) {
                    showMessageBox("Particle Effects Reduced To 3!");
                    particleCount = 3;
                } else if (particleCount > 0) {
                    showMessageBox("Particle Effects Reduced To None!");
                    particleCount = 0;
                } else if (particleCount === 0) {
                    showMessageBox("Particle Effects Increased To 60!");
                    particleCount = 60;
                }
                let gameParticles = particleCount
                localStorage.setItem('gameParticles', String(particleCount));
                showMessageBox(`Particle Effects set to ${particleCount} (saved).`);
			}
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'Space'].includes(e.code)) e.preventDefault();
			if (e.key === '%') {
				showDebugStats = !showDebugStats; 
				debugStatsDiv.style.display = showDebugStats ? 'block' : 'none';
			}
        });
        window.addEventListener('keyup', (e) => { keys[e.code] = false; });
		document.addEventListener('mousemove', (e) => {
			itemTooltip.style.left = (e.clientX + 15) + 'px';
			itemTooltip.style.top = (e.clientY + 10) + 'px';
		});
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (!isGamePaused) {
                if (e.button === 0) mouse.down = true;
                else if (e.button === 2) mouse.rightDown = true;
            }
        });
        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            if (e.button === 0) mouse.down = false;
            else if (e.button === 2) mouse.rightDown = false;
        });
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.y;
        });
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        document.addEventListener('visibilitychange', () => {
            isGameActive = !document.hidden;
            if (isGameActive) lastTime = performance.now();
        });
        window.addEventListener('resize', resizeCanvas);
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            draw();
        }
        function showMessageBox(message, type = 'alert', callback = null) {
            messageBoxText.textContent = message;
            messageBoxButtons.innerHTML = '';
            return new Promise(resolve => {
                const okButton = document.createElement('button');
                okButton.textContent = 'OK';
                okButton.onclick = () => { customMessageBoxOverlay.style.display = 'none'; resolve(true); if (callback) callback(true); };
                messageBoxButtons.appendChild(okButton);
                if (type === 'confirm') {
                    const cancelButton = document.createElement('button');
                    cancelButton.textContent = 'Cancel';
                    cancelButton.onclick = () => { customMessageBoxOverlay.style.display = 'none'; resolve(false); if (callback) callback(false); };
                    messageBoxButtons.appendChild(cancelButton);
                }
                customMessageBoxOverlay.style.display = 'flex';
            });
        }
        const recipes = [
            { name: "Bed",
                input: { 0: { type: 'cotton_item', count: 1 }, 1: { type: 'cotton_item', count: 1 }, 2: { type: 'cotton_item', count: 1 }, 3: { type: 'cotton_item', count: 1 }, 4: { type: 'any_plank', count: 1 }, 5: { type: 'any_plank', count: 1 }, 6: { type: 'any_plank', count: 1 }, 7: { type: 'any_plank', count: 1 } },
                output: 'bed', outputCount: 1,
            },
            { name: "Chest", 
                input: { 0: { type: 'any_plank', count: 1 }, 1: { type: 'any_plank', count: 1 }, 2: { type: 'any_plank', count: 1 }, 3: { type: 'any_plank', count: 1 }, 4: { type: 'any_plank', count: 1 }, 5: { type: 'any_plank', count: 1 }, 6: { type: 'any_plank', count: 1 }, 7: { type: 'any_plank', count: 1 } },
                output: 'chest', outputCount: 1,
            },
			{ name: "Refrigerator",
				input: { 0: { type: 'chest', count: 1 }, 1: { type: 'packed_iceb', count: 1 } },
				output: 'refrigerator', outputCount: 1
			},
			{ name: "Magical Chest", 
                input: { 0: { type: 'chest', count: 1 }, 1: { type: 'goldn', count: 1 } },
                output: 'magical_chest', outputCount: 1,
            },
			{ name: "Void Chest", 
                input: { 0: { type: 'magical_chest', count: 1 }, 1: { type: 'void_crystal', count: 1 }, 2: { type: 'void_crystal', count: 1 }, 3: { type: 'void_crystal', count: 1 } },
                output: 'void_chest', outputCount: 1,
            },
			{ name: "Oven",
				input: { 0: { type: 's', count: 1 }, 1: { type: 's', count: 1 }, 2: { type: 's', count: 1 }, 3: { type: 's', count: 1 }, 4: { type: 'coal', count: 1 }, 5: { type: 'cs', count: 1 }, 6: { type: 'cs', count: 1 }, 7: { type: 'coal', count: 1 } },
				output: 'oven', outputCount: 1
			},
			{ name: "Magma Furnace",
				input: { 0: { type: 'cs', count: 1 }, 1: { type: 's', count: 1 }, 2: { type: 's', count: 1 }, 3: { type: 'cs', count: 1 }, 4: { type: 'coal', count: 1 }, 5: { type: 'cps', count: 1 }, 6: { type: 'cps', count: 1 }, 7: { type: 'coal', count: 1 }, 8: { type: 'magma_stoneb', count: 1 }, 9: { type: 'magma_stoneb', count: 1 }, 10: { type: 'magma_stoneb', count: 1 }, 11: { type: 'magma_stoneb', count: 1 } },
				output: 'magma_furnace', outputCount: 1
			},
			{ name: "Bronze Coins", 
                input: { 0: { type: 'bronzen', count: 1 } },
                output: 'bronze_coin', outputCount: 10,
            },
			{ name: "Gold Coins", 
                input: { 0: { type: 'goldn', count: 1 } },
                output: 'gold_coin', outputCount: 10,
            },
			{ name: "Pure Fuel",
				input: { 0: { type: 'coal', count: 1 } },
				output: 'pure_fuel', outputCount: 3
			},
			{ name: "Pure Fuel",
				input: { 0: { type: 'paper', count: 1 } },
				output: 'pure_fuel', outputCount: 1
			},
            { name: "Paper",
				input: { 0: { type: 'any_plank', count: 1 }, 3: { type: 'any_plank', count: 1 } },
				output: 'paper', outputCount: 1,
            },
			{ name: "Wooden Sticks", input: { 0: { type: 'any_plank', count: 1 } }, output: 'wooden_stick', outputCount: 3,
            },
			{ name: "Wield Wooden Stick", input: { 0: { type: 'wooden_stick', count: 1 }, 1: { type: 'gravel', count: 1 }, 2: { type: 'gravel', count: 1 }, 3: { type: 'gravel', count: 1 } }, output: 'wield_wooden_stick', outputCount: 1,
            },
			{ name: "Coffee Beans",
                input: { 0: { type: 'coffee', count: 1 } },
                output: 'coffee_bean', outputCount: 3
            },
			{ name: "Wooden Bowl",
                input: { 0: { type: 'any_plank', count: 1 }, 3: { type: 'any_plank', count: 1 }, 4: { type: 'any_plank', count: 1 }, 7: { type: 'any_plank', count: 1 }, 8: { type: 'any_plank', count: 1 }, 9: { type: 'any_plank', count: 1 }, 10: { type: 'any_plank', count: 1 }, 11: { type: 'any_plank', count: 1 } },
                output: 'wooden_bowl', outputCount: 3,
            },
			{ name: "Taco Salad",
                input: { 0: { type: 'wooden_bowl', count: 1 }, 1: { type: 'tomato', count: 1 }, 2: { type: 'corn_item', count: 1 }, 3: { type: 'rice_item', count: 1 } },
                output: 'taco_salad', outputCount: 1
            },
			{ name: "Mushroom Soup",
                input: { 0: { type: 'wooden_bowl', count: 1 }, 1: { type: 'shroom', count: 1 }, 2: { type: 'shroom', count: 1 }, 3: { type: 'shroom', count: 1 } },
                output: 'mushroom_soup', outputCount: 1
            },
			{ name: "3 Mushroom Soups",
                input: { 0: { type: 'wooden_bowl', count: 3 }, 1: { type: 'big_shroom', count: 1 }, 2: { type: 'big_shroom', count: 1 }, 3: { type: 'big_shroom', count: 1 } },
                output: 'mushroom_soup', outputCount: 3
            },
			{ name: "Tomato Soup",
                input: { 0: { type: 'wooden_bowl', count: 1 }, 1: { type: 'tomato', count: 1 }, 2: { type: 'tomato', count: 1 }, 3: { type: 'tomato', count: 1 } },
                output: 'tomato_soup', outputCount: 1
            },
			{ name: "Cup Of Beer",
                input: { 0: { type: 'cup_of_water', count: 1 }, 1: { type: 'barley_item', count: 1 }, 2: { type: 'corn_item', count: 1 }, 4: { type: 'hop_item', count: 1 }, 5: { type: 'hop_item', count: 1 }, 6: { type: 'hop_item', count: 1 } },
                output: 'cup_of_beer', outputCount: 1
            },
            { name: "Wooden Pickaxe",
                input: { 0: { type: 'any_plank', count: 1 }, 1: { type: 'any_plank', count: 1 }, 2: { type: 'any_plank', count: 1 }, 3: { type: 'any_plank', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'wooden_pickaxe', outputCount: 1
            },
			{ name: "Wooden Shovel",
                input: { 0: { type: 'any_plank', count: 1 }, 1: { type: 'any_plank', count: 1 }, 2: { type: 'any_plank', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'wooden_shovel', outputCount: 1
            },
            { name: "Wooden Axe",
                input: { 0: { type: 'any_plank', count: 1 }, 1: { type: 'any_plank', count: 1 }, 2: { type: 'any_plank', count: 1 }, 6: { type: 'any_plank', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'wooden_axe', outputCount: 1
            },
            { name: "Rock Pickaxe",
                input: { 0: { type: 'rockb', count: 1 }, 1: { type: 'rockb', count: 1 }, 2: { type: 'rockb', count: 1 }, 3: { type: 'rockb', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'rock_pickaxe', outputCount: 1
            },
			{ name: "Rock Shovel",
                input: { 0: { type: 'rockb', count: 1 }, 1: { type: 'rockb', count: 1 }, 2: { type: 'rockb', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'rock_shovel', outputCount: 1
            },
            { name: "Rock Axe",
                input: { 0: { type: 'rockb', count: 1 }, 1: { type: 'rockb', count: 1 }, 2: { type: 'rockb', count: 1 }, 6: { type: 'rockb', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'rock_axe', outputCount: 1
            },
			{ name: "Reinforced Rock Pickaxe",
                input: { 0: { type: 'rock_pickaxe', count: 1 }, 1: { type: 'ironn', count: 1 }, 4: { type: 'ironn', count: 1 } },
                output: 'reinforced_rock_pickaxe', outputCount: 1
            },
            { name: "Copper Pickaxe",
                input: { 0: { type: 'coppern', count: 1 }, 1: { type: 'coppern', count: 1 }, 2: { type: 'coppern', count: 1 }, 3: { type: 'coppern', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'copper_pickaxe', outputCount: 1
            },
			{ name: "Copper Shovel",
                input: { 0: { type: 'coppern', count: 1 }, 1: { type: 'coppern', count: 1 }, 2: { type: 'coppern', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'copper_shovel', outputCount: 1
            },
            { name: "Copper Axe",
                input: { 0: { type: 'coppern', count: 1 }, 1: { type: 'coppern', count: 1 }, 2: { type: 'coppern', count: 1 }, 6: { type: 'coppern', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'copper_axe', outputCount: 1
            },
            { name: "Tin Pickaxe",
                input: { 0: { type: 'tinn', count: 1 }, 1: { type: 'tinn', count: 1 }, 2: { type: 'tinn', count: 1 }, 3: { type: 'tinn', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'tin_pickaxe', outputCount: 1
            },
			{ name: "Tin Shovel",
                input: { 0: { type: 'tinn', count: 1 }, 1: { type: 'tinn', count: 1 }, 2: { type: 'tinn', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'tin_shovel', outputCount: 1
            },
            { name: "Tin Axe",
                input: { 0: { type: 'tinn', count: 1 }, 1: { type: 'tinn', count: 1 }, 2: { type: 'tinn', count: 1 }, 6: { type: 'tinn', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'tin_axe', outputCount: 1
            },
            { name: "Bronze Nugget", input: { 0: { type: 'tinn', count: 1 }, 1: { type: 'coppern', count: 1 } }, output: 'bronzen', outputCount: 1 },
            { name: "Bronze Pickaxe",
                input: { 0: { type: 'bronzen', count: 1 }, 1: { type: 'bronzen', count: 1 }, 2: { type: 'bronzen', count: 1 }, 3: { type: 'bronzen', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'bronze_pickaxe', outputCount: 1
            },
			{ name: "Bronze Shovel",
                input: { 0: { type: 'bronzen', count: 1 }, 1: { type: 'bronzen', count: 1 }, 2: { type: 'bronzen', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'bronze_shovel', outputCount: 1
            },
            { name: "Bronze Axe",
                input: { 0: { type: 'bronzen', count: 1 }, 1: { type: 'bronzen', count: 1 }, 2: { type: 'bronzen', count: 1 }, 6: { type: 'bronzen', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'bronze_axe', outputCount: 1
            },
			{ name: "Brass Nugget", input: { 0: { type: 'zincn', count: 1 }, 1: { type: 'coppern', count: 1 } }, output: 'brassn', outputCount: 1 },
            { name: "Iron Pickaxe",
                input: { 0: { type: 'ironn', count: 1 }, 1: { type: 'ironn', count: 1 }, 2: { type: 'ironn', count: 1 }, 3: { type: 'ironn', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'iron_pickaxe', outputCount: 1
            },
			{ name: "Iron Shovel",
                input: { 0: { type: 'ironn', count: 1 }, 1: { type: 'ironn', count: 1 }, 2: { type: 'ironn', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'iron_shovel', outputCount: 1
            },
            { name: "Iron Axe",
                input: { 0: { type: 'ironn', count: 1 }, 1: { type: 'ironn', count: 1 }, 2: { type: 'ironn', count: 1 }, 6: { type: 'ironn', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'iron_axe', outputCount: 1
            },
			{ name: "Tungsten Pickaxe",
                input: { 0: { type: 'tungstenn', count: 1 }, 1: { type: 'tungstenn', count: 1 }, 2: { type: 'tungstenn', count: 1 }, 3: { type: 'tungstenn', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'tungsten_pickaxe', outputCount: 1
            },
			{ name: "Tungsten Shovel",
                input: { 0: { type: 'tungstenn', count: 1 }, 1: { type: 'tungstenn', count: 1 }, 2: { type: 'tungstenn', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'tungsten_shovel', outputCount: 1
            },
            { name: "Tungsten Axe",
                input: { 0: { type: 'tungstenn', count: 1 }, 1: { type: 'tungstenn', count: 1 }, 2: { type: 'tungstenn', count: 1 }, 6: { type: 'tungstenn', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'tungsten_axe', outputCount: 1
            },
            { name: "Steel Nugget",
                input: { 1: { type: 'coal', count: 1 }, 4: { type: 'coal', count: 1 }, 5: { type: 'ironn', count: 1 }, 6: { type: 'coal', count: 1 }, 9: { type: 'coal', count: 1 }, 10: { type: 'coal', count: 1 } },
                output: 'steeln', outputCount: 1
            },
            { name: "Steel Pickaxe",
                input: { 0: { type: 'steeln', count: 1 }, 1: { type: 'steeln', count: 1 }, 2: { type: 'steeln', count: 1 }, 3: { type: 'steeln', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'steel_pickaxe', outputCount: 1
            },
			{ name: "Steel Shovel",
                input: { 0: { type: 'steeln', count: 1 }, 1: { type: 'steeln', count: 1 }, 2: { type: 'steeln', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'steel_shovel', outputCount: 1
            },
            { name: "Steel Axe",
                input: { 0: { type: 'steeln', count: 1 }, 1: { type: 'steeln', count: 1 }, 2: { type: 'steeln', count: 1 }, 6: { type: 'steeln', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'steel_axe', outputCount: 1
            },
            { name: "Ruby Plated Steel Pickaxe",
                input: { 0: { type: 'rubyn', count: 1 }, 1: { type: 'steel_pickaxe', count: 1 }, 2: { type: 'rubyn', count: 1 }, 5: { type: 'rubyn', count: 1 } },
                output: 'ruby_plated_steel_pickaxe', outputCount: 1
            },
            { name: "Diamond Plated Steel Pickaxe",
                input: { 0: { type: 'diamondn', count: 1 }, 1: { type: 'steel_pickaxe', count: 1 }, 2: { type: 'diamondn', count: 1 }, 5: { type: 'diamondn', count: 1 } },
                output: 'diamond_plated_steel_pickaxe', outputCount: 1
            },
			{ name: "Diviniron Pickaxe",
                input: { 0: { type: 'divinironn', count: 1 }, 1: { type: 'divinironn', count: 1 }, 2: { type: 'divinironn', count: 1 }, 3: { type: 'divinironn', count: 1 }, 5: { type: 'wield_wooden_stick', count: 1 }, 9: { type: 'wield_wooden_stick', count: 1 }, 13: { type: 'wield_wooden_stick', count: 1 } },
                output: 'diviniron_pickaxe', outputCount: 1
            },
			{ name: "Mighterrum Pickaxe",
                input: { 0: { type: 'mighterrumn', count: 1 }, 1: { type: 'mighterrumn', count: 1 }, 2: { type: 'mighterrumn', count: 1 }, 3: { type: 'mighterrumn', count: 1 }, 5: { type: 'wield_wooden_stick', count: 1 }, 9: { type: 'wield_wooden_stick', count: 1 }, 13: { type: 'wield_wooden_stick', count: 1 } },
                output: 'mighterrum_pickaxe', outputCount: 1
            },
			{ name: "Hellrock Pickaxe",
                input: { 0: { type: 'hellrock', count: 1 }, 1: { type: 'hellrock', count: 1 }, 2: { type: 'hellrock', count: 1 }, 3: { type: 'hellrock', count: 1 }, 5: { type: 'rock_pickaxe', count: 1 }, 9: { type: 'rock_pickaxe', count: 1 }, 13: { type: 'rock_pickaxe', count: 1 } },
                output: 'hellrock_pickaxe', outputCount: 1
            },
			{ name: "Hellsteel Pickaxe",
                input: { 0: { type: 'hellsteeln', count: 1 }, 1: { type: 'hellsteeln', count: 1 }, 2: { type: 'hellsteeln', count: 1 }, 3: { type: 'hellsteeln', count: 1 }, 5: { type: 'steel_pickaxe', count: 1 }, 9: { type: 'steel_pickaxe', count: 1 }, 13: { type: 'steel_pickaxe', count: 1 } },
                output: 'hellsteel_pickaxe', outputCount: 1
            },
			{ name: "Anthill Hellsteel Pickaxe",
                input: { 0: { type: 'hellsteel_pickaxe', count: 1 }, 1: { type: 'colony_heart', count: 1 }, 2: { type: 'colony_heart', count: 1 }, 3: { type: 'colony_heart', count: 1 } },
                output: 'anthill_hellsteel_pickaxe', outputCount: 1
            },
			{ name: "Void Hellsteel Pickaxe",
                input: { 0: { type: 'hellsteel_pickaxe', count: 1 }, 1: { type: 'void_crystal', count: 1 }, 2: { type: 'void_crystal', count: 1 }, 3: { type: 'void_crystal', count: 1 }, 4: { type: 'void_crystal', count: 1 }, 5: { type: 'void_crystal', count: 1 }, 6: { type: 'void_crystal', count: 1 }, 7: { type: 'void_crystal', count: 1 }, 8: { type: 'void_crystal', count: 1 }, 9: { type: 'void_crystal', count: 1 }, 10: { type: 'void_crystal', count: 1 }, 11: { type: 'void_crystal', count: 1 }, 12: { type: 'void_crystal', count: 1 }, 13: { type: 'void_crystal', count: 1 }, 14: { type: 'void_crystal', count: 1 }, 15: { type: 'void_crystal', count: 1 } },
                output: 'void_hellsteel_pickaxe', outputCount: 1
            },
			{ name: "Heavenrock Pickaxe",
                input: { 0: { type: 'cloud_rockb', count: 1 }, 1: { type: 'cloud_rockb', count: 1 }, 2: { type: 'cloud_rockb', count: 1 }, 3: { type: 'cloud_rockb', count: 1 }, 5: { type: 'rock_pickaxe', count: 1 }, 9: { type: 'rock_pickaxe', count: 1 }, 13: { type: 'rock_pickaxe', count: 1 } },
                output: 'heavenrock_pickaxe', outputCount: 1
            },
			{ name: "Heavensteel Pickaxe",
                input: { 0: { type: 'heavensteeln', count: 1 }, 1: { type: 'heavensteeln', count: 1 }, 2: { type: 'heavensteeln', count: 1 }, 3: { type: 'heavensteeln', count: 1 }, 5: { type: 'steel_pickaxe', count: 1 }, 9: { type: 'steel_pickaxe', count: 1 }, 13: { type: 'steel_pickaxe', count: 1 } },
                output: 'heavensteel_pickaxe', outputCount: 1
            },
			{ name: "Anthill Heavensteel Pickaxe",
                input: { 0: { type: 'heavensteel_pickaxe', count: 1 }, 1: { type: 'colony_heart', count: 1 }, 2: { type: 'colony_heart', count: 1 }, 3: { type: 'colony_heart', count: 1 } },
                output: 'anthill_heavensteel_pickaxe', outputCount: 1
            },
			{ name: "Void Heavensteel Pickaxe",
                input: { 0: { type: 'heavensteel_pickaxe', count: 1 }, 1: { type: 'void_crystal', count: 1 }, 2: { type: 'void_crystal', count: 1 }, 3: { type: 'void_crystal', count: 1 }, 4: { type: 'void_crystal', count: 1 }, 5: { type: 'void_crystal', count: 1 }, 6: { type: 'void_crystal', count: 1 }, 7: { type: 'void_crystal', count: 1 }, 8: { type: 'void_crystal', count: 1 }, 9: { type: 'void_crystal', count: 1 }, 10: { type: 'void_crystal', count: 1 }, 11: { type: 'void_crystal', count: 1 }, 12: { type: 'void_crystal', count: 1 }, 13: { type: 'void_crystal', count: 1 }, 14: { type: 'void_crystal', count: 1 }, 15: { type: 'void_crystal', count: 1 } },
                output: 'void_heavensteel_pickaxe', outputCount: 1
            },
			{ name: "Infinitungsten Pickaxe",
                input: { 0: { type: 'infinitungstenn', count: 1 }, 1: { type: 'infinitungstenn', count: 1 }, 2: { type: 'infinitungstenn', count: 1 }, 3: { type: 'infinitungstenn', count: 1 }, 5: { type: 'wield_wooden_stick', count: 1 }, 9: { type: 'wield_wooden_stick', count: 1 }, 13: { type: 'wield_wooden_stick', count: 1 } },
                output: 'infinitungsten_pickaxe', outputCount: 1
            },
            { name: "Anthill Infinitungsten Pickaxe",
                input: { 0: { type: 'infinitungsten_pickaxe', count: 1 }, 1: { type: 'colony_heart', count: 1 }, 2: { type: 'colony_heart', count: 1 }, 3: { type: 'colony_heart', count: 1 } },
                output: 'anthill_infinitungsten_pickaxe', outputCount: 1
            },
			{ name: "Void Infinitungsten Pickaxe",
                input: { 0: { type: 'infinitungsten_pickaxe', count: 1 }, 1: { type: 'void_crystal', count: 1 }, 2: { type: 'void_crystal', count: 1 }, 3: { type: 'void_crystal', count: 1 }, 4: { type: 'void_crystal', count: 1 }, 5: { type: 'void_crystal', count: 1 }, 6: { type: 'void_crystal', count: 1 }, 7: { type: 'void_crystal', count: 1 }, 8: { type: 'void_crystal', count: 1 }, 9: { type: 'void_crystal', count: 1 }, 10: { type: 'void_crystal', count: 1 }, 11: { type: 'void_crystal', count: 1 }, 12: { type: 'void_crystal', count: 1 }, 13: { type: 'void_crystal', count: 1 }, 14: { type: 'void_crystal', count: 1 }, 15: { type: 'void_crystal', count: 1 } },
                output: 'void_infinitungsten_pickaxe', outputCount: 1
            },
			{ name: "Mythicalithium Pickaxe",
                input: { 0: { type: 'mythicalithiumn', count: 1 }, 1: { type: 'mythicalithiumn', count: 1 }, 2: { type: 'mythicalithiumn', count: 1 }, 3: { type: 'mythicalithiumn', count: 1 }, 5: { type: 'diviniron_pickaxe', count: 1 }, 9: { type: 'diviniron_pickaxe', count: 1 }, 13: { type: 'diviniron_pickaxe', count: 1 } },
                output: 'mythicalithium_pickaxe', outputCount: 1
            },
            { name: "Snow Block",
                input: { 0: { type: 'snow_ball', count: 1 }, 1: { type: 'snow_ball', count: 1 }, 2: { type: 'snow_ball', count: 1 }, 4: { type: 'snow_ball', count: 1 }, 5: { type: 'snow_ball', count: 1 }, 6: { type: 'snow_ball', count: 1 }, 8: { type: 'snow_ball', count: 1 }, 9: { type: 'snow_ball', count: 1 }, 10: { type: 'snow_ball', count: 1 } },
                output: 'snowb', outputCount: 1
            },
            { name: "Oak Planks", input: { 0: { type: 'roak', count: 1 } }, output: 'poak', outputCount: 3 },
            { name: "Birch Planks", input: { 0: { type: 'rbirch', count: 1 } }, output: 'pbirch', outputCount: 3 },
            { name: "Spruce Planks", input: { 0: { type: 'rspruce', count: 1 } }, output: 'pspruce', outputCount: 3 },
			{ name: "Apple Planks", input: { 0: { type: 'rapple', count: 1 } }, output: 'papple', outputCount: 3 },
			{ name: "Rubber Planks", input: { 0: { type: 'rrubber', count: 1 } }, output: 'prubber', outputCount: 3 },
			{ name: "Mahogany Planks", input: { 0: { type: 'rmahogany', count: 1 } }, output: 'pmahogany', outputCount: 3 },
			{ name: "Cinnamon Planks", input: { 0: { type: 'rcinnamon', count: 1 } }, output: 'pcinnamon', outputCount: 3 },
			{ name: "Redwood Planks", input: { 0: { type: 'rredwood', count: 1 } }, output: 'predwood', outputCount: 3 },
			{ name: "Hell Wood Planks", input: { 0: { type: 'rhellw', count: 1 } }, output: 'phellw', outputCount: 3 },
            { name: "Darkwood Planks", input: { 0: { type: 'rdarkwood', count: 1 } }, output: 'pdarkwood', outputCount: 3 },
            { name: "Gilded Wood Planks", input: { 0: { type: 'rgildedw', count: 1 } }, output: 'pgildedw', outputCount: 3 },
			{ name: "Blueglow Wood Planks", input: { 0: { type: 'rbluegloww', count: 1 } }, output: 'pbluegloww', outputCount: 3 },
            { name: "Cinnamon", input: { 0: { type: 'rcinnamon', count: 1 }, 4: { type: 'rcinnamon', count: 1 }, 8: { type: 'rcinnamon', count: 1 }, 12: { type: 'rcinnamon', count: 1 } }, output: 'cinnamon', outputCount: 10 },
			{ name: "Hay Bale",
                input: { 0: { type: 'wheat_item', count: 1 }, 1: { type: 'barley_item', count: 1 }, 4: { type: 'barley_item', count: 1 }, 5: { type: 'wheat_item', count: 1 } },
                output: 'hay_bale', outputCount: 1
            },
			{ name: "Flour",
                input: { 0: { type: 'wheat_item', count: 1 } },
                output: 'flour', outputCount: 2
            },
			{ name: "Iodized Salt",
                input: { 0: { type: 'rock_salt', count: 1 } },
                output: 'iodized_salt', outputCount: 2
            },
            { name: "Tomato Sandwich",
                input: { 1: { type: 'wheat_bread', count: 1 }, 5: { type: 'tomato', count: 1 }, 6: { type: 'tomato', count: 1 }, 7: { type: 'tomato', count: 1 }, 9: { type: 'wheat_bread', count: 1 } },
                output: 'tomato_sandwich', outputCount: 1,
            },
			{ name: "Tomato Sandwich",
                input: { 1: { type: 'barley_bread', count: 1 }, 5: { type: 'tomato', count: 1 }, 6: { type: 'tomato', count: 1 }, 7: { type: 'tomato', count: 1 }, 9: { type: 'barley_bread', count: 1 } },
                output: 'tomato_sandwich', outputCount: 1,
            },
            { name: "Fertilizer",
                input: { 0: { type: 'so', count: 1 }, 1: { type: 'coal', count: 1 } },
                output: 'f', outputCount: 1
            },
			{ name: "Fertilizer",
                input: { 0: { type: 'plantations', count: 1 }, 1: { type: 'plantations', count: 1 }, 2: { type: 'plantations', count: 1 } },
                output: 'f', outputCount: 1
            },
			{ name: "Stone Stairs Right",
				input: { 3: { type: 's', count: 1 }, 6: { type: 's', count: 1 }, 7: { type: 's', count: 1 }, 9: { type: 's', count: 1 }, 10: { type: 's', count: 1 }, 11: { type: 's', count: 1 }, 12: { type: 's', count: 1 }, 13: { type: 's', count: 1 }, 14: { type: 's', count: 1 }, 15: { type: 's', count: 1 } },
				output: 'stone_stairs_right', outputCount: 10
			},
			{ name: "Stone Stairs Left",
				input: { 0: { type: 's', count: 1 }, 4: { type: 's', count: 1 }, 5: { type: 's', count: 1 }, 8: { type: 's', count: 1 }, 9: { type: 's', count: 1 }, 10: { type: 's', count: 1 }, 12: { type: 's', count: 1 }, 13: { type: 's', count: 1 }, 14: { type: 's', count: 1 }, 15: { type: 's', count: 1 } },
				output: 'stone_stairs_left', outputCount: 10
			},
			{ name: "Clay Brick Block",
                input: { 0: { type: 's', count: 1 }, 1: { type: 'sand', count: 1 }, 4: { type: 'sand', count: 1 }, 5: { type: 's', count: 1 } },
                output: 'clay_brickb', outputCount: 1
            },
			{ name: "Stone Brick Block",
                input: { 0: { type: 's', count: 1 }, 1: { type: 'cs', count: 1 }, 4: { type: 'cs', count: 1 }, 5: { type: 's', count: 1 } },
                output: 'stone_brickb', outputCount: 3
            },
			{ name: "Asphalt Block",
                input: { 0: { type: 's', count: 1 }, 1: { type: 'schist', count: 1 }, 2: { type: 'slate', count: 1 }, 3: { type: 'granite', count: 1 }, 5: { type: 'cs', count: 1 }, 6: { type: 'rockb', count: 1 } },
                output: 'asphalt', outputCount: 6
            },
			{ name: "Asphalt Block",
                input: { 0: { type: 'asphalt_fragment', count: 1 }, 1: { type: 'asphalt_fragment', count: 1 }, 2: { type: 'asphalt_fragment', count: 1 }, 3: { type: 'asphalt_fragment', count: 1 } },
                output: 'asphalt', outputCount: 1
            },
			{ name: "Bronze Brick Block",
                input: { 0: { type: 'bronzen', count: 1 }, 1: { type: 'bronzen', count: 1 }, 4: { type: 'bronzen', count: 1 }, 5: { type: 'bronzen', count: 1 } },
                output: 'bronze_brickb', outputCount: 1
            },
			{ name: "Brass Brick Block",
                input: { 0: { type: 'brassn', count: 1 }, 1: { type: 'brassn', count: 1 }, 4: { type: 'brassn', count: 1 }, 5: { type: 'brassn', count: 1 } },
                output: 'brass_brickb', outputCount: 1
            },
			{ name: "Steel Brick Block",
                input: { 0: { type: 'steeln', count: 1 }, 1: { type: 'steeln', count: 1 }, 4: { type: 'steeln', count: 1 }, 5: { type: 'steeln', count: 1 } },
                output: 'steel_brickb', outputCount: 1
            },
			{ name: "Iron Brick Block",
                input: { 0: { type: 'ironn', count: 1 }, 1: { type: 'ironn', count: 1 }, 4: { type: 'ironn', count: 1 }, 5: { type: 'ironn', count: 1 } },
                output: 'iron_brickb', outputCount: 1
            },
			{ name: "Tungsten Brick Block",
                input: { 0: { type: 'tungstenn', count: 1 }, 1: { type: 'tungstenn', count: 1 }, 4: { type: 'tungstenn', count: 1 }, 5: { type: 'tungstenn', count: 1 } },
                output: 'tungsten_brickb', outputCount: 1
            },
			{ name: "Tin Brick Block",
                input: { 0: { type: 'tinn', count: 1 }, 1: { type: 'tinn', count: 1 }, 4: { type: 'tinn', count: 1 }, 5: { type: 'tinn', count: 1 } },
                output: 'tin_brickb', outputCount: 1
            },
			{ name: "Zinc Brick Block",
                input: { 0: { type: 'zincn', count: 1 }, 1: { type: 'zincn', count: 1 }, 4: { type: 'zincn', count: 1 }, 5: { type: 'zincn', count: 1 } },
                output: 'zinc_brickb', outputCount: 1
            },
			{ name: "Copper Brick Block",
                input: { 0: { type: 'coppern', count: 1 }, 1: { type: 'coppern', count: 1 }, 4: { type: 'coppern', count: 1 }, 5: { type: 'coppern', count: 1 } },
                output: 'copper_brickb', outputCount: 1
            },
            { name: "Gold Brick Block",
                input: { 0: { type: 'goldn', count: 1 }, 1: { type: 'goldn', count: 1 }, 4: { type: 'goldn', count: 1 }, 5: { type: 'goldn', count: 1 } },
                output: 'gold_brickb', outputCount: 1
            },
			{ name: "Gold Power Brick Block",
                input: { 0: { type: 'gold_brickb', count: 1 }, 1: { type: 'cactusb', count: 1 }, 2: { type: 'cactusb', count: 1 }, 3: { type: 'gold_brickb', count: 1 }, 5: { type: 'coal', count: 1 }, 6: { type: 'coal', count: 1 } },
                output: 'gold_power_brickb', outputCount: 1
            },
			{ name: "Aluminum Brick Block",
                input: { 0: { type: 'aluminumn', count: 1 }, 1: { type: 'aluminumn', count: 1 }, 4: { type: 'aluminumn', count: 1 }, 5: { type: 'aluminumn', count: 1 } },
                output: 'aluminum_brickb', outputCount: 1
            },
            { name: "Palladium Brick Block",
                input: { 0: { type: 'palladiumn', count: 1 }, 1: { type: 'palladiumn', count: 1 }, 4: { type: 'palladiumn', count: 1 }, 5: { type: 'palladiumn', count: 1 } },
                output: 'palladium_brickb', outputCount: 1
            },
			{ name: "Nickel Brick Block",
                input: { 0: { type: 'nickeln', count: 1 }, 1: { type: 'nickeln', count: 1 }, 4: { type: 'nickeln', count: 1 }, 5: { type: 'nickeln', count: 1 } },
                output: 'nickel_brickb', outputCount: 1
            },
			{ name: "Lead Brick Block",
                input: { 0: { type: 'leadn', count: 1 }, 1: { type: 'leadn', count: 1 }, 4: { type: 'leadn', count: 1 }, 5: { type: 'leadn', count: 1 } },
                output: 'lead_brickb', outputCount: 1
            },
            { name: "Gold Nugget",
                input: { 0: { type: 'any_gilded', count: 1 }, 1: { type: 'any_gilded', count: 1 }, 2: { type: 'any_gilded', count: 1 }, 3: { type: 'any_gilded', count: 1 }, 4: { type: 'any_gilded', count: 1 }, 5: { type: 'any_gilded', count: 1 }, 6: { type: 'any_gilded', count: 1 }, 7: { type: 'any_gilded', count: 1 }, 8: { type: 'any_gilded', count: 1 }, 9: { type: 'any_gilded', count: 1 }, 10: { type: 'any_gilded', count: 1 }, 11: { type: 'any_gilded', count: 1 }, 12: { type: 'any_gilded', count: 1 }, 13: { type: 'any_gilded', count: 1 }, 14: { type: 'any_gilded', count: 1}, 15: { type: 'any_gilded', count: 1 } },
                output: 'goldn', outputCount: 1
            },
			{ name: "Glass Cup",
                input: { 0: { type: 'glassb', count: 1 }, 2: { type: 'glassb', count: 1 }, 4: { type: 'glassb', count: 1 }, 6: { type: 'glassb', count: 1 }, 8: { type: 'glassb', count: 1 }, 10: { type: 'glassb', count: 1 }, 12: { type: 'glassb', count: 1 }, 13: { type: 'glassb', count: 1 }, 14: { type: 'glassb', count: 1 } },
                output: 'glass_cup', outputCount: 4
            },
			{ name: "Void Dust Block",
                input: { 0: { type: 'void_dust', count: 1 }, 1: { type: 'void_dust', count: 1 }, 4: { type: 'void_dust', count: 1 }, 5: { type: 'void_dust', count: 1 } },
                output: 'void_dustb', outputCount: 1
            },
			{ name: "Red Void Crystal",
                input: { 0: { type: 'colony_heart', count: 1 }, 1: { type: 'void_crystal', count: 1 }, 4: { type: 'void_crystal', count: 1 }, 5: { type: 'void_crystal', count: 1 } },
                output: 'red_void_crystal', outputCount: 1
            },
			{ name: "Pure Heaven Debris Block",
                input: { 0: { type: 'corroded_heaven_debrisb', count: 1 }, 1: { type: 'ancient_heaven_debrisb', count: 1 }, 2: { type: 'ancient_heaven_debrisb', count: 1 }, 3: { type: 'corroded_heaven_debrisb', count: 1 }, 4: { type: 'ancient_heaven_debrisb', count: 1 }, 5: { type: 'strong_heaven_debrisb', count: 1 }, 6: { type: 'strong_heaven_debrisb', count: 1 }, 7: { type: 'ancient_heaven_debrisb', count: 1 }, 8: { type: 'ancient_heaven_debrisb', count: 1 }, 9: { type: 'strong_heaven_debrisb', count: 1 }, 10: { type: 'strong_heaven_debrisb', count: 1 }, 11: { type: 'ancient_heaven_debrisb', count: 1 }, 12: { type: 'corroded_heaven_debrisb', count: 1 }, 13: { type: 'ancient_heaven_debrisb', count: 1 }, 14: { type: 'ancient_heaven_debrisb', count: 1}, 15: { type: 'corroded_heaven_debrisb', count: 1 } },
                output: 'pure_heaven_debrisb', outputCount: 1
            },
			{ name: "Heaven Gate Brick Block",
                input: { 0: { type: 'pure_heaven_debrisb', count: 1 }, 1: { type: 'pure_heaven_debrisb', count: 1 }, 2: { type: 'pure_heaven_debrisb', count: 1 }, 3: { type: 'pure_heaven_debrisb', count: 1 }, 4: { type: 'pure_heaven_debrisb', count: 1 }, 5: { type: 'pure_heaven_debrisb', count: 1 }, 6: { type: 'pure_heaven_debrisb', count: 1 }, 7: { type: 'pure_heaven_debrisb', count: 1 }, 8: { type: 'pure_heaven_debrisb', count: 1 }, 9: { type: 'pure_heaven_debrisb', count: 1 }, 10: { type: 'pure_heaven_debrisb', count: 1 }, 11: { type: 'pure_heaven_debrisb', count: 1 }, 12: { type: 'pure_heaven_debrisb', count: 1 }, 13: { type: 'pure_heaven_debrisb', count: 1 }, 14: { type: 'pure_heaven_debrisb', count: 1}, 15: { type: 'pure_heaven_debrisb', count: 1 } },
                output: 'heaven_gate_brickb', outputCount: 1
            },
			{ name: "Impure Infinitungsten Nugget",
                input: { 0: { type: 'hellsteeln', count: 1 }, 1: { type: 'hellsteeln', count: 1 }, 2: { type: 'heavensteeln', count: 1 }, 3: { type: 'heavensteeln', count: 1 }, 4: { type: 'hellsteeln', count: 1 }, 5: { type: 'hellsteeln', count: 1 }, 6: { type: 'heavensteeln', count: 1 }, 7: { type: 'heavensteeln', count: 1 }, 8: { type: 'hellsteeln', count: 1 }, 9: { type: 'hellsteeln', count: 1 }, 10: { type: 'heavensteeln', count: 1 }, 11: { type: 'heavensteeln', count: 1 }, 12: { type: 'hellsteeln', count: 1 }, 13: { type: 'hellsteeln', count: 1 }, 14: { type: 'heavensteeln', count: 1}, 15: { type: 'heavensteeln', count: 1 } },
                output: 'impure_infinitungstenn', outputCount: 1
            },
			{ name: "Power Orb",
                input: { 0: { type: 'diamondn', count: 1 }, 1: { type: 'topazn', count: 1 }, 2: { type: 'sapphiren', count: 1 }, 3: { type: 'rubyn', count: 1 }, 4: { type: 'emeraldn', count: 1 }, 5: { type: 'opaln', count: 1 }, 6: { type: 'amethystn', count: 1 }, 7: { type: 'jaden', count: 1 }, 8: { type: 'goldn', count: 1 }, 9: { type: 'tinn', count: 1 }, 10: { type: 'aluminumn', count: 1 }, 11: { type: 'ironn', count: 1 }, 12: { type: 'coppern', count: 1 }, 13: { type: 'zincn', count: 1 }, 14: { type: 'palladiumn', count: 1}, 15: { type: 'tungstenn', count: 1 } },
                output: 'power_orb', outputCount: 1
            },
			{ name: "Power Soup",
                input: { 0: { type: 'wooden_bowl', count: 2 }, 1: { type: 'power_orb', count: 1 } },
                output: 'power_soup', outputCount: 2
            },
			{ name: "Powered Wooden Pickaxe",
                input: { 0: { type: 'wooden_pickaxe', count: 1 }, 1: { type: 'power_orb', count: 1 } },
                output: 'powered_wooden_pickaxe', outputCount: 1,
            },
			{ name: "World Mover",
                input: { 0: { type: 'red_sandb', count: 1 }, 3: { type: 'red_sandb', count: 1 }, 12: { type: 'red_sandb', count: 1 }, 15: { type: 'red_sandb', count: 1 }, 5: { type: 'infinitungstenn', count: 1 }, 6: { type: 'infinitungstenn', count: 1 }, 9: { type: 'infinitungstenn', count: 1 }, 10: { type: 'infinitungstenn', count: 1 } },
                output: 'world_mover', outputCount: 1
            },
            { name: "Mechageezer: Trailer",
                input: { 0: { type: 'coppern', count: 1 }, 1: { type: 'd', count: 1 } },
                output: 'trailer', outputCount: 12,
            },
			{ name: "Mechageezer: Stone Trailer",
                input: { 0: { type: 'trailer', count: 1 }, 1: { type: 's', count: 1 } },
                output: 'stone_trailer', outputCount: 1,
            },
            { name: "Mechageezer: Reactant",
                input: { 0: { type: 'coppern', count: 1 }, 1: { type: 'pure_fuel', count: 1 } },
                output: 'reactant', outputCount: 1,
            },
            { name: "Mechageezer: Lever",
                input: { 0: { type: 'poak', count: 1 }, 1: { type: 's', count: 1 }, 2: { type: 'cs', count: 1 }, 3: { type: 'coppern', count: 1 } },
                output: 'lever_off', outputCount: 1,
            },
			{ name: "Mechageezer: Chest Lever",
                input: { 0: { type: 'lever_off', count: 1 }, 1: { type: 'chest', count: 1 } },
                output: 'chest_lever_off', outputCount: 1,
            },
            { name: "Napalm Bomb",
                input: { 0: { type: 'paper', count: 1 }, 1: { type: 'paper', count: 1 }, 2: { type: 'paper', count: 1 }, 3: { type: 'paper', count: 1 }, 4: { type: 'paper', count: 1 }, 5: { type: 'coal', count: 1 }, 6: { type: 'coal', count: 1 }, 7: { type: 'paper', count: 1 }, 8: { type: 'paper', count: 1 }, 9: { type: 'coal', count: 1 }, 10: { type: 'coal', count: 1 }, 11: { type: 'paper', count: 1 }, 12: { type: 'paper', count: 1 }, 13: { type: 'paper', count: 1 }, 14: { type: 'paper', count: 1 }, 15: { type: 'paper', count: 1 } },
                output: 'napalm_bomb', outputCount: 1
            },
            { name: "Dynamite Bomb",
                input: { 0: { type: 'sand', count: 1 }, 1: { type: 'paper', count: 1 }, 2: { type: 'paper', count: 1 }, 3: { type: 'red_sandb', count: 1 }, 4: { type: 'paper', count: 1 }, 5: { type: 'coal', count: 1 }, 6: { type: 'coal', count: 1 }, 7: { type: 'paper', count: 1 }, 8: { type: 'paper', count: 1 }, 9: { type: 'coal', count: 1 }, 10: { type: 'coal', count: 1 }, 11: { type: 'paper', count: 1 }, 12: { type: 'red_sandb', count: 1 }, 13: { type: 'paper', count: 1 }, 14: { type: 'paper', count: 1 }, 15: { type: 'sand', count: 1 } },
                output: 'dynamite_bomb', outputCount: 1
            },
            { name: "Octogen Bomb",
                input: { 0: { type: 'void_dust', count: 1 }, 1: { type: 'paper', count: 1 }, 2: { type: 'paper', count: 1 }, 3: { type: 'void_dust', count: 1 }, 4: { type: 'paper', count: 1 }, 5: { type: 'coal', count: 1 }, 6: { type: 'coal', count: 1 }, 7: { type: 'paper', count: 1 }, 8: { type: 'paper', count: 1 }, 9: { type: 'coal', count: 1 }, 10: { type: 'coal', count: 1 }, 11: { type: 'paper', count: 1 }, 12: { type: 'void_dust', count: 1 }, 13: { type: 'paper', count: 1 }, 14: { type: 'paper', count: 1 }, 15: { type: 'void_dust', count: 1 } },
                output: 'octogen_bomb', outputCount: 1
            },
            { name: "Weak Nuclear Bomb",
                input: { 0: { type: 'nuclear_core', count: 1 }, 1: { type: 'copper_brickb', count: 1 }, 2: { type: 'copper_brickb', count: 1 }, 3: { type: 'copper_brickb', count: 1 } },
                output: 'weak_nuclear_bomb', outputCount: 1
            },
            { name: "Subnuclear Bomb",
                input: { 0: { type: 'weak_nuclear_bomb', count: 1 }, 1: { type: 'gold_brickb', count: 1 }, 2: { type: 'gold_brickb', count: 1 }, 3: { type: 'gold_brickb', count: 1 } },
                output: 'subnuclear_bomb', outputCount: 1
            },
            { name: "Nuclear Bomb",
                input: { 0: { type: 'subnuclear_bomb', count: 1 }, 1: { type: 'nuclear_core', count: 1 }, 2: { type: 'nuclear_core', count: 1 }, 3: { type: 'nuclear_core', count: 1 } },
                output: 'nuclear_bomb', outputCount: 1
            },
			{ name: "Trap Stone",
                input: { 0: { type: 'dynamite_bomb', count: 1 }, 1: { type: 's', count: 1 } },
                output: 'traps', outputCount: 1,
            },
			{ name: "Trap Compacted Stone",
                input: { 0: { type: 'octogen_bomb', count: 1 }, 1: { type: 'cs', count: 1 } },
                output: 'trap_cs', outputCount: 1,
            },
			{ name: "Trap Compressed Stone",
                input: { 0: { type: 'weak_nuclear_bomb', count: 1 }, 1: { type: 'cps', count: 1 } },
                output: 'trap_cps', outputCount: 1,
            },
        ];
		const ovenRecipes = [
            { name: "Wheat Bread",
                input: { 0: { type: 'wheat_item', count: 1 }, 1: { type: 'wheat_item', count: 1 }, 2: { type: 'wheat_item', count: 1 } },
				fuel: 1,
                output: 'wheat_bread', outputCount: 1,
            },
			{ name: "Barley Bread",
                input: { 0: { type: 'barley_item', count: 1 }, 1: { type: 'barley_item', count: 1 }, 2: { type: 'barley_item', count: 1 } },
				fuel: 1,
                output: 'barley_bread', outputCount: 1,
            },
			{ name: "Cooked Beef",
                input: { 0: { type: 'beef', count: 1 } },
				fuel: 1,
                output: 'cooked_beef', outputCount: 1,
            },
			{ name: "Cooked Pork",
                input: { 0: { type: 'pork', count: 1 } },
				fuel: 1,
                output: 'cooked_pork', outputCount: 1,
            },
			{ name: "Vulcanized Rubber Block",
                input: { 0: { type: 'rrubber', count: 1 } },
				fuel: 1,
                output: 'vulcanized_rubber', outputCount: 1,
            },
			{ name: "Dry Paper",
				input: { 0: { type: 'soggy_paper', count: 1 } },
				fuel: 1,
				output: 'paper', outputCount: 1,
			},
			{ name: "Bulk Dry Paper",
				input: { 0: { type: 'soggy_paper', count: 5 }, 1: { type: 'soggy_paper', count: 5 } },
				fuel: 1,
				output: 'paper', outputCount: 10,
			},
			{ name: "Raw Sugar",
                input: { 0: { type: 'sugarcane', count: 1 }  },
				fuel: 1,
                output: 'rsugar', outputCount: 3,
				byproduct: 'molasses', byproductCount: 1,
            },
			{ name: "Refined Sugar",
                input: { 0: { type: 'rsugar', count: 1 }, 1: { type: 'rsugar', count: 1 }, 3: { type: 'rsugar', count: 1 }, 4: { type: 'rsugar', count: 1 }  },
				fuel: 1,
                output: 'refined_sugar', outputCount: 3,
				byproduct: 'molasses', byproductCount: 1,
            },
			{ name: "Cup Of Purified Water",
                input: { 0: { type: 'glass_cup', count: 1 }, 1: {type: 'iceb', count: 1} },
                fuel: 1,
				output: 'cup_of_water', outputCount: 1,
            },
			{ name: "Cup Of Purified Water",
                input: { 0: { type: 'cup_of_urine', count: 1 } },
                fuel: 1,
				output: 'cup_of_water', outputCount: 1,
            },
			{ name: "Cup Of Coffee",
                input: { 0: { type: 'cup_of_water', count: 1 }, 1: { type: 'coffee_bean', count: 1 }, 2: { type: 'coffee_bean', count: 1 }, 3: { type: 'coffee_bean', count: 1 }, 4: { type: 'coffee_bean', count: 1 }, 5: { type: 'coffee_bean', count: 1 } },
                fuel: 1,
				output: 'cup_of_coffee', outputCount: 1,
            },
            { name: "Cup Of Pine Needle Tea",
                input: { 0: { type: 'cup_of_water', count: 1 }, 1: { type: 'pine_needle_living', count: 1 }, 2: { type: 'pine_needle_living', count: 1 }, 3: { type: 'pine_needle_living', count: 1 }, 4: { type: 'pine_needle_living', count: 1 }, 5: { type: 'pine_needle_living', count: 1 } },
                fuel: 1,
				output: 'cup_of_pine_needle_tea', outputCount: 1,
            },
			{ name: "Noodles",
                input: { 0: { type: 'cup_of_water', count: 1 }, 1: { type: 'flour', count: 1 }, 2: { type: 'flour', count: 1 }, 3: { type: 'iodized_salt', count: 1 } },
                fuel: 1,
				output: 'noodles', outputCount: 1,
            },
			{ name: "Ramen Noodles",
                input: { 0: { type: 'wooden_bowl', count: 1 }, 1: { type: 'cup_of_water', count: 1 }, 2: { type: 'iodized_salt', count: 1 }, 3: { type: 'chili_pepper', count: 1 }, 4: { type: 'garlic_item', count: 1 }, 5: { type: 'onion_item', count: 1 }, 6: { type: 'noodles', count: 1 }, 7: { type: 'egg', count: 1 }, 8: { type: 'noodles', count: 1 } },
                fuel: 1,
				output: 'ramen_noodles', outputCount: 1,
				byproduct: 'glass_cup', outputCount: 1,
            },
			{ name: "Spaghetti And Marinara",
                input: { 0: { type: 'wooden_bowl', count: 1 }, 1: { type: 'cup_of_water', count: 1 }, 2: { type: 'iodized_salt', count: 1 }, 3: { type: 'tomato', count: 1 }, 4: { type: 'garlic_item', count: 1 }, 5: { type: 'tomato', count: 1 }, 6: { type: 'noodles', count: 1 }, 7: { type: 'cooked_pork', count: 1 }, 8: { type: 'noodles', count: 1 } },
                fuel: 1,
				output: 'spaghetti', outputCount: 1,
				byproduct: 'glass_cup', outputCount: 1,
            },
			{ name: "Cake",
                input: { 0: { type: 'flour', count: 1 }, 1: { type: 'egg', count: 1 }, 2: { type: 'flour', count: 1 }, 3: { type: 'rsugar', count: 1 }, 4: { type: 'butter', count: 1 }, 5: { type: 'rsugar', count: 1 }, 7: { type: 'cup_of_milk', count: 1 } },
                fuel: 2,
				output: 'cake', outputCount: 1,
				byproduct: 'glass_cup', byproductCount: 1
            },
			{ name: "Pumpkin Pie",
                input: { 0: { type: 'cinnamon', count: 1 }, 1: { type: 'egg', count: 1 }, 2: { type: 'cinnamon', count: 1 }, 3: { type: 'refined_sugar', count: 1 }, 4: { type: 'butter', count: 1 }, 5: { type: 'refined_sugar', count: 1 }, 6: { type: 'pumpkin', count: 1 }, 7: { type: 'cup_of_milk', count: 1 }, 8: { type: 'pumpkin', count: 1 } },
                fuel: 2,
				output: 'pumpkin_pie', outputCount: 1,
				byproduct: 'glass_cup', byproductCount: 1
            },
		];
		const furnaceRecipes = [
            { name: "Glass Block",
                input: { 0: { type: 'sand', count: 1 } },
				fuel: 1,
                output: 'glassb', outputCount: 2,
            },
			{ name: "Concrete Block",
                input: { 0: { type: 'limestone', count: 1 }, 1: { type: 'gravel', count: 1 }, 2: { type: 'sand', count: 1 }, 3: { type: 'limestone', count: 1 }, 4: { type: 'gravel', count: 1 }, 5: { type: 'sand', count: 1 }, 6: { type: 'limestone', count: 1 }, 7: { type: 'gravel', count: 1 }, 8: { type: 'sand', count: 1 } },
				fuel: 1,
                output: 'concrete', outputCount: 6
            },
			{ name: "Infinitungsten Nugget",
                input: { 0: { type: 'impure_infinitungstenn', count: 1 }, 1: { type: 'tungstenn', count: 1 } },
				fuel: 3,
                output: 'infinitungstenn', outputCount: 1,
            },
            { name: "Nuclear Core",
                input: { 0: { type: 'stone_brickb', count: 1 }, 1: { type: 'stone_brickb', count: 1 }, 2: { type: 'stone_brickb', count: 1 }, 3: { type: 'stone_brickb', count: 1 }, 4: { type: 'infinitungstenn', count: 1 }, 5: { type: 'stone_brickb', count: 1 }, 6: { type: 'stone_brickb', count: 1 }, 7: { type: 'stone_brickb', count: 1 }, 8: { type: 'stone_brickb', count: 1 } },
				fuel: 5,
                output: 'nuclear_core', outputCount: 1
            },
			{ name: "Mythicalithium Nugget",
                input: { 0: { type: 'infinitungstenn', count: 1 }, 1: { type: 'mighterrumn', count: 1 }, 2: { type: 'infinitungstenn', count: 1 } },
				fuel: 3,
                output: 'mythicalithiumn', outputCount: 1,
            },
		];
		const traderTrades = [
            { input: { type: 'apple', count: 17 }, output: { type: 'bronze_coin', count: 15 } },
            { input: { type: 'wheat_item', count: 17 }, output: { type: 'gold_coin', count: 5 } },
            { input: { type: 'topazn', count: 2 }, output: { type: 'iron_pickaxe', count: 1 } },
            { input: { type: 'coal', count: 20 }, output: { type: 'rock_pickaxe', count: 1 } },
            { input: { type: 'poak', count: 35 }, output: { type: 'iron_axe', count: 1 } },
            { input: { type: 'hellrock', count: 30 }, output: { type: 'heavensteeln', count: 1 } },
			{ input: { type: 'cloud_rockb', count: 30 }, output: { type: 'hellsteeln', count: 1 } },
            { input: { type: 'refrigerator', count: 1 }, output: { type: 'chili_pepper_seeds', count: 8 } },
            { input: { type: 'oven', count: 1 }, output: { type: 'coffee_seeds', count: 8 } },
            { input: { type: 'bed', count: 1 }, output: { type: 'corn_seeds', count: 8 } },
            { input: { type: 'bronze_coin', count: 3 }, output: { type: 'prickly_pear_fruit', count: 5 } },
            { input: { type: 'gold_coin', count: 2 }, output: { type: 'tomato_sandwich', count: 1 } },
            { input: { type: 'bronze_coin', count: 1 }, output: { type: 'grass_seeds', count: 5 } },
            { input: { type: 'gold_coin', count: 2 }, output: { type: 'oak_bush', count: 40 } },
            { input: { type: 'bronze_coin', count: 4 }, output: { type: 'trailer', count: 25 } },
            { input: { type: 'gold_coin', count: 200 }, output: { type: 'nuclear_core', count: 1 } },
            { input: { type: 'bronze_coin', count: 25 }, output: { type: 'glass_cup', count: 5 } },
            { input: { type: 'divinironn', count: 13 }, output: { type: 'colony_heart', count: 1 } },
            { input: { type: 'cactusb', count: 25 }, output: { type: 'asphalt', count: 5 } },
			{ input: { type: 'pest', count: 20 }, output: { type: 'concrete', count: 5 } },
		];
        const farmerTraderTrades = [
			{ input: { type: 'bronze_coin', count: 5 }, output: { type: 'wheat_seeds', count: 10 } },
			{ input: { type: 'bronze_coin', count: 5 }, output: { type: 'cotton_seeds', count: 10 } },
			{ input: { type: 'gold_coin', count: 1 }, output: { type: 'pumpkin_seeds', count: 8 } },
			{ input: { type: 'apple', count: 15 }, output: { type: 'f', count: 5 } },
			{ input: { type: 'gold_coin', count: 10 }, output: { type: 'refrigerator', count: 1 } },
		];
		const minerTraderTrades = [
			{ input: { type: 'gold_coin', count: 2 }, output: { type: 'coal', count: 25 } },
			{ input: { type: 'ironn', count: 10 }, output: { type: 'rock_pickaxe', count: 1 } },
			{ input: { type: 'gold_coin', count: 8 }, output: { type: 'iron_pickaxe', count: 1 } },
			{ input: { type: 'diamondn', count: 6 }, output: { type: 'emeraldn', count: 3 } },
			{ input: { type: 'wooden_stick', count: 30 }, output: { type: 'poak', count: 9 } },
		];
		const traderTypes = [
			{ name: 'Trader', imgSrc: 'Trader.png', trades: traderTrades },
			{ name: 'Farmer', imgSrc: 'Farmer.png', trades: farmerTraderTrades },
			{ name: 'Miner', imgSrc: 'Miner.png', trades: minerTraderTrades },
		];
		function pickRandomTradesFromPool(count = 5) {
			if (!Array.isArray(traderTrades) || traderTrades.length === 0) return [];
			const pool = traderTrades.slice();
			const picks = [];
			for (let i = 0; i < Math.min(count, pool.length); i++) {
				const idx = Math.floor(random() * pool.length);
				picks.push(JSON.parse(JSON.stringify(pool[idx]))); 
				pool.splice(idx, 1);
			}
			return picks;
		}
		function placeTraderAt(col, row, presetTrades = null) {
			const replaceableBlocks = ['', 'grass', 'tall_grass', 'grass_sprouts', 'wheat', 'oak_bush', 'birch_bush', 'spruce_bush', 'snow', 'large_snow_pile', 'desert_brush', 'desert_grass', 'prickly_pear_cactus', 'tomato_bush', 'pumpkin', 'anthill_sand_mound', 'moss', 'dark_moss', 'weed', 'shroom', 'cotton', 'rice', 'hop', 'coffee', 'oat', 'corn', 'barley', 'pine_needle_pile', 'pinecone_pile', 'leaf_pile', 'leaf_plant', 'blue_flower', 'yellow_flower', 'red_flower', 'onion', 'garlic', 'chili_pepper_bush'];
			if (!replaceableBlocks.includes(getBlockType(col, row)) || 
                !replaceableBlocks.includes(getBlockType(col, row - 1)) || 
                !replaceableBlocks.includes(getBlockType(col, row - 2))) {
                return false;
            }
			const placementRect = { x: col * tileSize, y: row * tileSize - (tileSize * 2), width: tileSize, height: tileSize * 3 };
			const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };
			if (rectIntersects(playerRect, placementRect)) return false;
			const trades = presetTrades || pickRandomTradesFromPool(5);
			worldBlocks[`${col},${row}`]     = { type: 'trader', part: 'bottom', mineProg: 0, trades: trades };
			worldBlocks[`${col},${row-1}`]   = { type: 'trader', part: 'middle', mineProg: 0 };
			worldBlocks[`${col},${row-2}`]   = { type: 'trader', part: 'top', mineProg: 0 };
			return true;
		}
        let craftingGridSlots = new Array(16).fill(null);
        function toggleInventoryMenu() {
            if (gameMenuOverlay.style.display === 'flex' && !isGamePaused) return;
            isGamePaused = !isGamePaused;
            if (isGamePaused) {
                inventoryCraftingOverlay.style.display = 'flex';
                updateInventoryMenu();
                renderRecipes();
            } else {
                inventoryCraftingOverlay.style.display = 'none';
                for(let i = 0; i < craftingGridSlots.length; i++) {
                    const slot = craftingGridSlots[i];
                    if (slot && slot.type && slot.count > 0) {
                        addToInventory(slot.type, slot.count, slot.durability);
                        craftingGridSlots[i] = null;
                    }
                }
                if (heldItem) {
                    addToInventory(heldItem.type, heldItem.count, heldItem.durability);
                    heldItem = null;
                    heldItemSource = { type: null, index: -1 };
                }
                lastTime = performance.now();
            }
        }
        function updateInventoryMenu() {
            playerInventoryGrid.innerHTML = '';
            inventoryHotbarGrid.innerHTML = '';
            for (let i = 0; i < hotbarSize; i++) {
                const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
                slotDiv.classList.add('hotbar-slot');
                inventoryHotbarGrid.appendChild(slotDiv);
            }
            for (let i = hotbarSize; i < totalInventorySlots; i++) {
                const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
                playerInventoryGrid.appendChild(slotDiv);
            }
            craftingGridDiv.innerHTML = '';
            for (let i = 0; i < 16; i++) {
                const slotDiv = createInventorySlot(craftingGridSlots[i], i, 'crafting');
                craftingGridDiv.appendChild(slotDiv);
            }
            deleteSlot.addEventListener('mousedown', (e) => {
				e.stopPropagation();
				e.preventDefault();
				handleSlotClick(e);
			});
            checkCraftingRecipe();
        }
        function createInventorySlot(itemObject, slotIndex, sourceType) {
			const slot = document.createElement('div');
			slot.classList.add('inventory-slot');
			slot.dataset.slotIndex = slotIndex;
			slot.dataset.sourceType = sourceType;
			slot.addEventListener('mousedown', (e) => {
				e.stopPropagation();
				e.preventDefault();
				handleSlotClick(e);
			});
			slot.onmouseenter = (e) => {
                if (itemObject) {
                    let itemName = (itemObject.type.replace(/_/g, ' ')).replace(/\b\w/g, l => l.toUpperCase());
                    const itemProps = itemTypes[itemObject.type] || blockTypes[itemObject.type];
                    if (itemProps && itemProps.isTool && itemObject.durability !== undefined) {
                        itemName += ` (${Math.ceil(itemObject.durability)} / ${itemObject.maxDurability})`;
                    }
                    itemTooltip.textContent = itemName;
                    itemTooltip.style.display = 'block';
                }
            };
			slot.onmouseleave = (e) => {
				itemTooltip.style.display = 'none';
			};
            if (sourceType === 'delete') {
                slot.id = 'deleteSlot';
                slot.innerHTML = 'X';
                return slot;
            }
            if (heldItemSource.type === sourceType && heldItemSource.index === slotIndex) {
                slot.style.backgroundColor = '#888';
            }
            if (itemObject && itemObject.type && itemObject.count > 0) {
                const itemProps = itemTypes[itemObject.type] || blockTypes[itemObject.type];
                const itemImg = assets[itemObject.type];
                if (itemImg && !failedAssets[itemObject.type]) {
                    const imgElement = document.createElement('img');
                    imgElement.src = itemImg.src;
                    slot.appendChild(imgElement);
                } else if (itemProps?.color) {
                    const fallbackDiv = document.createElement('div');
                    fallbackDiv.classList.add('fallback');
                    fallbackDiv.style.backgroundColor = itemProps.color;
                    fallbackDiv.textContent = itemObject.type.substring(0, 3).toUpperCase();
                    slot.appendChild(fallbackDiv);
                }
                const countSpan = document.createElement('span');
                countSpan.classList.add('item-count');
                countSpan.textContent = itemObject.count;
                slot.appendChild(countSpan);
                if (itemProps?.isTool && itemObject.durability !== null && itemObject.durability !== undefined) {
                    const durabilityBar = document.createElement('div');
                    durabilityBar.classList.add('durability-bar');
                    const durabilityFill = document.createElement('div');
                    durabilityFill.classList.add('durability-fill');
                    const durabilityRatio = itemObject.durability / itemObject.maxDurability;
                    durabilityFill.style.width = `${Math.max(0, durabilityRatio * 100)}%`;
                    durabilityFill.style.backgroundColor = durabilityRatio > 0.6 ? '#28a745' : (durabilityRatio > 0.3 ? '#ffc107' : '#dc3545');
                    durabilityBar.appendChild(durabilityFill);
                    slot.appendChild(durabilityBar);
                }
            }
            return slot;
        }
        function handleSlotClick(event) {
			event.preventDefault();
			const slotDiv = event.currentTarget;
			const sourceType = slotDiv.dataset.sourceType;
			const slotIndex = parseInt(slotDiv.dataset.slotIndex);
            if (event.shiftKey) {
                let sourceArray, destinationArray, sourceItem;
                if (sourceType === 'inventory') {
                    sourceArray = inventorySlots;
                } else if (sourceType === 'chest') {
                    sourceArray = worldBlocks[`${currentlyOpenChest.col},${currentlyOpenChest.row}`]?.inventory;
                } else if (sourceType === 'oven' || sourceType === 'magma_furnace') {
                    sourceArray = worldBlocks[`${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`]?.inventory;
                }
                if (!sourceArray || !sourceArray[slotIndex]) return; 
                sourceItem = { ...sourceArray[slotIndex] }; 
                if (currentlyOpenChest) {
                    destinationArray = (sourceType === 'inventory') ? worldBlocks[`${currentlyOpenChest.col},${currentlyOpenChest.row}`].inventory : inventorySlots;
                } else if (currentlyOpenFurnace) {
                    destinationArray = (sourceType === 'inventory') ? worldBlocks[`${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`].inventory : inventorySlots;
                } else if (inventoryCraftingOverlay.style.display === 'flex') {
                    const targetIsHotbar = slotIndex >= hotbarSize;
                    let moved = false;
                    for (let i = 0; i < inventorySlots.length; i++) {
                        const destinationIndex = targetIsHotbar ? i : hotbarSize + i;
                        if (destinationIndex >= inventorySlots.length) break;
                        if (!inventorySlots[destinationIndex]) {
                            inventorySlots[destinationIndex] = sourceItem;
                            sourceArray[slotIndex] = null;
                            moved = true;
                            break;
                        }
                    }
                    if (!moved) return; 
                }
                if (destinationArray) {
                    if (sourceType === 'inventory' && currentlyOpenFurnace) {
                        let sourceSlot = sourceArray[slotIndex]; 
                        if (sourceSlot.type === 'pure_fuel') {
                            let fuelSlot = destinationArray[9];
                            if (!fuelSlot) { 
                                destinationArray[9] = sourceSlot;
                                sourceArray[slotIndex] = null;
                            } else if (fuelSlot.type === 'pure_fuel' && fuelSlot.count < maxStackSize) { 
                                const space = maxStackSize - fuelSlot.count;
                                const amountToMove = Math.min(sourceSlot.count, space);
                                fuelSlot.count += amountToMove;
                                sourceSlot.count -= amountToMove;
                                if (sourceSlot.count <= 0) {
                                    sourceArray[slotIndex] = null; 
                                }
                            }
                        } else { 
                            for (let i = 0; i < 9; i++) {
                                let inputSlot = destinationArray[i];
                                if (inputSlot && inputSlot.type === sourceSlot.type && inputSlot.count < maxStackSize) {
                                    const space = maxStackSize - inputSlot.count;
                                    const amountToMove = Math.min(sourceSlot.count, space);
                                    inputSlot.count += amountToMove;
                                    sourceSlot.count -= amountToMove;
                                    if (sourceSlot.count <= 0) {
                                        sourceArray[slotIndex] = null;
                                        break; 
                                    }
                                }
                            }
                            if (sourceArray[slotIndex]) {
                                 for (let i = 0; i < 9; i++) {
                                    if (!destinationArray[i]) {
                                        destinationArray[i] = sourceSlot;
                                        sourceArray[slotIndex] = null;
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        const originalCount = sourceItem.count;
                        const wasAdded = addToInventory(sourceItem.type, sourceItem.count, sourceItem.durability, sourceItem.acquiredTimes, destinationArray);
                        if (wasAdded) {
                            sourceArray[slotIndex] = null;
                        }
                    }
                }
                if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
                if (chestOverlay.style.display === 'flex') updateChestMenu();
                if (ovenOverlay.style.display === 'flex') updateFurnaceMenu();
				if (voidChestOverlay.style.display === 'flex') updateVoidChestMenu();
                syncHotbarIndices();
                return; 
            }
			if (sourceType === 'delete') {
				if (heldItem) {
					addToVoidStorage(heldItem.type, heldItem.count, heldItem.durability, heldItem.maxDurability);
					heldItem = null;
					heldItemSource = { type: null, index: -1 };
					if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
					if (chestOverlay.style.display === 'flex') updateChestMenu();
				}
				return;
			}
			let sourceArray;
			if (sourceType === 'inventory') sourceArray = inventorySlots;
			else if (sourceType === 'void') {
				const itemTypeIdentifier = slotIndex; 
				if (event.button === 0) { 
					if (heldItem) return; 
					for (let i = voidStorage.length - 1; i >= 0; i--) {
						if (voidStorage[i] && voidStorage[i].type === itemTypeIdentifier) {
							if (!heldItem) {
								heldItem = { ...voidStorage[i] }; 
							} else {
								heldItem.count += voidStorage[i].count; 
							}
							voidStorage.splice(i, 1); 
						}
					}
					heldItemSource = { type: 'void', index: itemTypeIdentifier };
				} else if (event.button === 2) { 
					if (heldItem) return; 
					let totalCount = 0;
					voidStorage.forEach(item => {
						if (item && item.type === itemTypeIdentifier) totalCount += item.count;
					});
					if (totalCount > 0) {
						const amountToTake = Math.ceil(totalCount / 2);
						heldItem = { type: itemTypeIdentifier, count: amountToTake };
						heldItemSource = { type: 'void', index: itemTypeIdentifier };
						let amountRemoved = 0;
						for (let i = voidStorage.length - 1; i >= 0; i--) {
							if (voidStorage[i] && voidStorage[i].type === itemTypeIdentifier) {
								const canRemove = Math.min(voidStorage[i].count, amountToTake - amountRemoved);
								voidStorage[i].count -= canRemove;
								amountRemoved += canRemove;
								if (voidStorage[i].count <= 0) {
									voidStorage.splice(i, 1);
								}
								if(amountRemoved >= amountToTake) break;
							}
						}
					}
				}
				updateVoidChestMenu(); 
				return; 
			}
			else if (sourceType === 'crafting') sourceArray = craftingGridSlots;
			else if (sourceType === 'oven' || sourceType === 'magma_furnace' || sourceType === 'world_mover_fuel') {
                let blockData;
                if (sourceType === 'world_mover_fuel') {
                    if (currentlyOpenWorldMover) {
                        blockData = worldBlocks[`${currentlyOpenWorldMover.col},${currentlyOpenWorldMover.row}`];
                    }
                } else { 
                    if (currentlyOpenFurnace) {
                        blockData = worldBlocks[`${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`];
                    }
                }
                if (blockData) sourceArray = blockData.inventory;
			}
			else if (sourceType === 'chest') {
				const chestData = worldBlocks[`${currentlyOpenChest.col},${currentlyOpenChest.row}`];
				if (chestData) sourceArray = chestData.inventory;
			}
			if (!sourceArray) return;
			const clickedSlotItem = sourceArray[slotIndex];
			if (event.button === 2) { 
				if (heldItem === null) {
					if (clickedSlotItem && clickedSlotItem.count > 1) {
						const halfCount = Math.ceil(clickedSlotItem.count / 2);
						const timestamps = itemTypes[clickedSlotItem.type]?.spoilable ? _takeTimestamps(clickedSlotItem, halfCount) : null;
						heldItem = {
							type: clickedSlotItem.type,
							count: halfCount,
							durability: clickedSlotItem.durability,
							maxDurability: clickedSlotItem.maxDurability,
							acquiredTimes: timestamps
						};
						clickedSlotItem.count -= halfCount;
						if (clickedSlotItem.count <= 0) sourceArray[slotIndex] = null;
						heldItemSource = { type: sourceType, index: slotIndex };
					}
				if (heldItem && sourceType === 'oven' && slotIndex === 9 && heldItem.type !== 'pure_fuel') {
					return; 
				}
				if (heldItem && sourceType === 'magma_furnace' && slotIndex === 9 && heldItem.type !== 'pure_fuel') {
					return; 
				}
				} else { 
					if (heldItem.count > 0) {
						if (!clickedSlotItem) {
							const timestamps = (itemTypes[heldItem.type]?.spoilable && Array.isArray(heldItem.acquiredTimes)) ? [heldItem.acquiredTimes.shift()] : (itemTypes[heldItem.type]?.spoilable ? [gameTime] : null);
							sourceArray[slotIndex] = { type: heldItem.type, count: 1 };
							if (itemTypes[heldItem.type]?.isTool) {
								sourceArray[slotIndex].durability = heldItem.durability ?? (itemTypes[heldItem.type]?.maxDurability ?? null);
								sourceArray[slotIndex].maxDurability = heldItem.maxDurability ?? (itemTypes[heldItem.type]?.maxDurability ?? null);
							} else if (timestamps) {
								sourceArray[slotIndex].acquiredTimes = timestamps.slice();
							}
							heldItem.count--;
						} else if (clickedSlotItem.type === heldItem.type && !(itemTypes[heldItem.type] || blockTypes[heldItem.type])?.isTool && clickedSlotItem.count < maxStackSize) {
							const ts = (itemTypes[heldItem.type]?.spoilable && Array.isArray(heldItem.acquiredTimes)) ? heldItem.acquiredTimes.shift() : (itemTypes[heldItem.type]?.spoilable ? gameTime : null);
							clickedSlotItem.count++;
							if (ts) {
								if (!Array.isArray(clickedSlotItem.acquiredTimes)) _ensureAcquiredTimes(clickedSlotItem, gameTime);
								clickedSlotItem.acquiredTimes.push(ts);
							}
							heldItem.count--;
						}
						if (heldItem.count <= 0) {
							heldItem = null; heldItemSource = { type: null, index: -1 };
						}
					}
				}
			} else { 
				if (heldItem === null) {
					if (clickedSlotItem) {
						heldItem = clickedSlotItem;
						sourceArray[slotIndex] = null;
						heldItemSource = { type: sourceType, index: slotIndex };
						if ((sourceType === 'chest' || sourceType === 'refrigerator' || sourceType === 'magical_chest') && itemTypes[heldItem.type]?.spoilable) {
							if (!Array.isArray(heldItem.acquiredTimes) || heldItem.acquiredTimes.length === 0) {
								heldItem.acquiredTimes = Array(heldItem.count).fill(gameTime);
							}
						}
					}
				} else { 
					if (!clickedSlotItem) {
						if (sourceType === 'void') {
							addToVoidStorage(heldItem.type, heldItem.count, heldItem.durability, heldItem.maxDurability);
						} else {
							sourceArray[slotIndex] = heldItem;
						}
						heldItem = null; heldItemSource = { type: null, index: -1 };
					} else if (clickedSlotItem.type === heldItem.type && !(itemTypes[heldItem.type] || blockTypes[heldItem.type])?.isTool) {
						const amountToTransfer = Math.min(heldItem.count, maxStackSize - clickedSlotItem.count);
						if (itemTypes[heldItem.type]?.spoilable) {
							if (!Array.isArray(clickedSlotItem.acquiredTimes)) _ensureAcquiredTimes(clickedSlotItem, gameTime);
							if (!Array.isArray(heldItem.acquiredTimes)) heldItem.acquiredTimes = Array(heldItem.count).fill(gameTime);
							const transferringTimestamps = [];
							for (let s = 0; s < amountToTransfer; s++) {
								transferringTimestamps.push(heldItem.acquiredTimes.shift() ?? gameTime);
							}
							clickedSlotItem.acquiredTimes.push(...transferringTimestamps);
						}
						clickedSlotItem.count += amountToTransfer;
						heldItem.count -= amountToTransfer;
						if (heldItem.count <= 0) {
							heldItem = null; heldItemSource = { type: null, index: -1 };
						}
					} else {
						[heldItem, sourceArray[slotIndex]] = [sourceArray[slotIndex], heldItem];
						heldItemSource = { type: sourceType, index: slotIndex };
					}
				}
			}
			if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
			if (chestOverlay.style.display === 'flex') updateChestMenu();
			if (ovenOverlay.style.display === 'flex') updateFurnaceMenu();
			if (voidChestOverlay.style.display === 'flex') updateVoidChestMenu();
			if (worldMoverConfigOverlay.style.display === 'flex') updateWorldMoverMenu();
			syncHotbarIndices();
		}
        function checkCraftingRecipe() {
            craftingOutputSlot.innerHTML = '';
            craftButton.disabled = true;
            craftButton.onclick = null;
            for (const recipe of recipes) {
                const requiredInput = recipe.input;
                const requiredKeys = Object.keys(requiredInput);
                const currentGridItems = {};
                let gridItemCount = 0;
                for(let i=0; i<16; i++) {
                    if(craftingGridSlots[i]) {
                        currentGridItems[i] = craftingGridSlots[i];
                        gridItemCount++;
                    }
                }
                if (requiredKeys.length !== gridItemCount) continue;
                let allMatch = true;
				for (const key of requiredKeys) {
					const required = requiredInput[key];
					const current = currentGridItems[key];
					if (!current || current.count < required.count) {
						allMatch = false;
						break;
					}
					if (required.type === 'any_plank') {
						if (!current.type.startsWith('p')) {
							allMatch = false;
							break;
						}
					} else if (required.type === 'any_gilded') {
						if (
							!current.type.startsWith('gilded_') &&
							!current.type.startsWith('rgilded_') &&
							!current.type.startsWith('pgilded_')
						) {
							allMatch = false;
							break;
						}
					} else if (current.type !== required.type) {
						allMatch = false;
						break;
					}
				}
                if (allMatch) {
                    const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
                    const outputSlotContent = createInventorySlot({ type: recipe.output, count: recipe.outputCount, durability: outputItemProps?.isTool ? outputItemProps.maxDurability : null, maxDurability: outputItemProps?.isTool ? outputItemProps.maxDurability : null }, -1, 'output');
                    craftingOutputSlot.appendChild(outputSlotContent);
                    craftButton.disabled = false;
                    craftButton.onclick = (event) => executeCraft(recipe, event.shiftKey);
                    return;
                }
            }
        }
        function executeCraft(recipe, isShiftClick = false) {
            let maxCrafts = 1;
            if (isShiftClick) {
                let maxFromMaterials = Infinity;
                for (const key in recipe.input) {
                    const required = recipe.input[key];
                    const current = craftingGridSlots[key];
                    const possible = Math.floor(current.count / required.count);
                    if (possible < maxFromMaterials) {
                        maxFromMaterials = possible;
                    }
                }
                let spaceAvailable = 0;
                const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
                if (outputItemProps.isTool) {
                     spaceAvailable = inventorySlots.filter(slot => !slot).length;
                } else {
                    inventorySlots.forEach(slot => {
                        if (!slot) {
                            spaceAvailable += maxStackSize;
                        } else if (slot.type === recipe.output) {
                            spaceAvailable += maxStackSize - slot.count;
                        }
                    });
                }
                const maxFromSpace = Math.floor(spaceAvailable / recipe.outputCount);
                maxCrafts = Math.min(maxFromMaterials, maxFromSpace);
            }
            if (maxCrafts <= 0) return;
            for (let i = 0; i < maxCrafts; i++) {
                for (const key in recipe.input) {
                    const required = recipe.input[key];
                    const current = craftingGridSlots[key];
                    if(current) { 
                         current.count -= required.count;
                         if (current.count <= 0) craftingGridSlots[key] = null;
                    } else {
                        updateInventoryMenu();
                        return;
                    }
                }
                const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
                addToInventory(recipe.output, recipe.outputCount, outputItemProps?.isTool ? outputItemProps.maxDurability : null);
            }
            updateInventoryMenu();
        }
        function renderRecipes() {
            recipeListDiv.innerHTML = '';
            for (const recipe of recipes) {
                const recipeItemDiv = document.createElement('div');
                recipeItemDiv.classList.add('recipe-item');
                const inputGridDiv = document.createElement('div');
                inputGridDiv.classList.add('recipe-input-grid');
                const displayInput = recipe.altInputs?.[0] ?? recipe.input;
                for (let i = 0; i < 16; i++) {
                    const inputItem = displayInput[i];
                    const slot = createInventorySlot(inputItem ? {type: inputItem.type, count: inputItem.count} : null, -1, 'recipe');
                    inputGridDiv.appendChild(slot);
                }
                recipeItemDiv.appendChild(inputGridDiv);
                const arrowSpan = document.createElement('span');
                arrowSpan.classList.add('crafting-arrow');
                arrowSpan.textContent = '';
                recipeItemDiv.appendChild(arrowSpan);
                const outputDiv = document.createElement('div');
                outputDiv.classList.add('recipe-output');
                const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
                const outputSlot = createInventorySlot({ type: recipe.output, count: recipe.outputCount, durability: outputItemProps?.isTool ? outputItemProps.maxDurability : null }, -1, 'recipe');
                outputDiv.appendChild(outputSlot);
                const outputNameSpan = document.createElement('span');
                outputNameSpan.textContent = recipe.name || recipe.output.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                outputDiv.appendChild(outputNameSpan);
                recipeItemDiv.appendChild(outputDiv);
                recipeListDiv.appendChild(recipeItemDiv);
				if (cheatItems === true) {
					recipeItemDiv.addEventListener('click', () => {
						craftingGridSlots.fill(null);
						for (const key in recipe.input) {
							const required = recipe.input[key];
							craftingGridSlots[key] = { type: required.type, count: required.count };
						}
						updateInventoryMenu();
					});
				}
            }
        }
        function updatePlantGrowth() {
			if (isGamePaused) return;
			const currentTime = gameTime;
			const plantsToRemove = new Set();
			for (const key of activePlants) {
				const blockData = worldBlocks[key];
				if (!blockData || !blockData.type.startsWith('planted_')) {
					plantsToRemove.add(key);
					continue;
				}
				let growthTimeRequired;
				if (blockData.baseBlockType === 'f') {
					growthTimeRequired = 45000; 
				} else if (blockData.baseBlockType === 'so') {
					growthTimeRequired = 90000; 
				} else { 
					growthTimeRequired = 180000; 
				}
				if (currentTime - blockData.plantTime >= growthTimeRequired) {
					const coords = key.split(',').map(Number);
					if (getBlockType(coords[0], coords[1] - 1) === '') {
						let cropType;
						if (blockData.type === 'planted_wheat_seeds') cropType = 'wheat';
						else if (blockData.type === 'planted_tomato_seeds') cropType = 'tomato_bush';
						else if (blockData.type === 'planted_pumpkin_seeds') cropType = 'pumpkin';
						else if (blockData.type === 'planted_cotton_seeds') cropType = 'cotton';
						else if (blockData.type === 'planted_rice_seeds') cropType = 'rice';
						else if (blockData.type === 'planted_hop_seeds') cropType = 'hop';
						else if (blockData.type === 'planted_coffee_seeds') cropType = 'coffee';
						else if (blockData.type === 'planted_oat_seeds') cropType = 'oat';
						else if (blockData.type === 'planted_corn_seeds') cropType = 'corn';
						else if (blockData.type === 'planted_barley_seeds') cropType = 'barley';
						else if (blockData.type === 'planted_onion_seeds') cropType = 'onion';
						else if (blockData.type === 'planted_garlic_seeds') cropType = 'garlic';
						else if (blockData.type === 'planted_chili_pepper_seeds') cropType = 'chili_pepper_bush';
						if (cropType) {
							worldBlocks[`${coords[0]},${coords[1] - 1}`] = { type: cropType, mineProg: 0 };
							worldBlocks[key] = { type: blockData.baseBlockType, mineProg: 0 }; 
							plantsToRemove.add(key); 
						}
					}
				}
			}
			for (const key of plantsToRemove) {
				activePlants.delete(key);
			}
		}
		function updateSpoilage() {
			if (isGamePaused) return;
			const currentTime = gameTime;
			function addSpoiledToInventoryArray(invArray, spoiledType, count) {
				let remaining = count;
				for (let i = 0; i < invArray.length && remaining > 0; i++) {
					const s = invArray[i];
					if (s && s.type === spoiledType && !(itemTypes[spoiledType] || blockTypes[spoiledType])?.isTool && s.count < maxStackSize) {
						const take = Math.min(remaining, maxStackSize - s.count);
						s.count += take;
						remaining -= take;
					}
				}
				for (let i = 0; i < invArray.length && remaining > 0; i++) {
					if (!invArray[i]) {
						const amount = Math.min(remaining, maxStackSize);
						invArray[i] = { type: spoiledType, count: amount };
						remaining -= amount;
					}
				}
				return remaining; 
			}
			const checkInventory = (inventory, isRefrigerator = false, isPlayerInventory = false) => {
				if (!inventory) return;
				for (let i = 0; i < inventory.length; i++) {
					const item = inventory[i];
					if (!item) continue;
					if (itemTypes[item.type]?.spoilable) {
						const spoilInfo = itemTypes[item.type].spoilable;
						if (isRefrigerator) {
							if (Array.isArray(item.acquiredTimes)) delete item.acquiredTimes;
							if (item.acquiredTime) delete item.acquiredTime;
							continue;
						}
						_ensureAcquiredTimes(item, currentTime);
						let expiredCount = 0;
						for (let t = 0; t < (item.acquiredTimes || []).length; t++) {
							if (currentTime - item.acquiredTimes[t] > spoilInfo.time) expiredCount++;
							else break; 
						}
						if (expiredCount > 0) {
							item.acquiredTimes.splice(0, expiredCount);
							item.count -= expiredCount;
							if (item.count <= 0) {
								inventory[i] = null;
							}
							const spoiledType = spoilInfo.into || 'spoiled'; 
							let leftover = 0;
							if (isPlayerInventory) {
								addToInventory(spoiledType, expiredCount, null, null, inventorySlots);
							} else {
								leftover = addSpoiledToInventoryArray(inventory, spoiledType, expiredCount);
								if (leftover > 0) {
									const stillLeft = (leftover > 0) ? (addToInventory(spoiledType, leftover) ? 0 : leftover) : 0;
									if (stillLeft > 0) {
										console.warn(`No space for ${stillLeft} spoiled ${spoiledType}. They were discarded.`);
									}
								}
							}
						}
					}
				}
			};
			checkInventory(inventorySlots, false, true);
			for (const key in worldBlocks) {
				const block = worldBlocks[key];
				if (block.inventory && (block.type === 'chest' || block.type === 'dead_body_chest' || block.type === 'magical_chest')) {
					checkInventory(block.inventory, false, false);
				} else if (block.inventory && block.type === 'refrigerator') {
					checkInventory(block.inventory, true, false);
				}
			}
		}
        function toggleGameMenu() {
            if (inventoryCraftingOverlay.style.display === 'flex' || chestOverlay.style.display === 'flex') return;
            isGamePaused = !isGamePaused;
            const tipDisplay = document.getElementById('gameMenuTipText'); 
            if (isGamePaused) {
                gameMenuOverlay.style.display = 'flex';
                seedInput.value = '';
                seedInput.placeholder = `Current: ${currentSeed}`;
                maintainDurabilityCheckbox.checked = maintainBlockDurability;
                animateDropsCheckbox.checked = animateDrops;
                const showNextTip = () => {
                    if (loadingTips.length === 0) return;
					const idx = Math.floor(Math.random() * loadingTips.length);
					tipDisplay.textContent = `Tip: ${loadingTips[idx]}`;
                };
                showNextTip();
                tipIntervalId = setInterval(showNextTip, 6500);
            } else {
                gameMenuOverlay.style.display = 'none';
                if (tipIntervalId) {
                    clearInterval(tipIntervalId);
                    tipIntervalId = null;
                }
                resolvePlayerVerticalCollision();
                lastTime = performance.now();
            }
        }
		function updateDebugStats() {
			if (!showDebugStats) return; 
			const loadedBlockCount = Object.keys(worldBlocks).length;
			debugStatsDiv.innerHTML = `
				FPS: ${currentFps}<br>
				Player Pos: (${player.x.toFixed(1)}, ${player.y.toFixed(1)})<br>
				Player Vel: (${player.dx.toFixed(1)}, ${player.dy.toFixed(1)})<br>
				Loaded Blocks: ${loadedBlockCount}<br>
				Particles: ${particles.length}<br>
				Item Drops: ${animatedDrops.length}<br>
				Game Time: ${(gameTime / 1000).toFixed(1)}s
			`;
		}
        function toggleWorldMoverMenu(col, row) {
            isGamePaused = !isGamePaused;
            if (isGamePaused) {
                currentlyOpenWorldMover = { col, row };
                worldMoverConfigOverlay.style.display = 'flex';
                updateWorldMoverMenu();
            } else {
                worldMoverConfigOverlay.style.display = 'none';
                currentlyOpenWorldMover = null;
                if (heldItem) { 
                    addToInventory(heldItem.type, heldItem.count, heldItem.durability);
                    heldItem = null;
                    heldItemSource = { type: null, index: -1 };
                }
                lastTime = performance.now();
            }
        }
        function updateWorldMoverMenu() {
            if (!currentlyOpenWorldMover) return;
            const moverKey = `${currentlyOpenWorldMover.col},${currentlyOpenWorldMover.row}`;
            const moverData = worldBlocks[moverKey];
            if (!moverData || moverData.type !== 'world_mover') {
                toggleWorldMoverMenu(); 
                return;
            }
            if (!moverData.inventory) {
                moverData.inventory = new Array(1).fill(null);
            }
            worldMoverCodeInput.value = moverData.code || '';
            worldMoverFuelSlot.innerHTML = '';
            const slotDiv = createInventorySlot(moverData.inventory[0], 0, 'world_mover_fuel');
            worldMoverFuelSlot.appendChild(slotDiv);
        }
        function saveWorldMoverConfig() {
            if (!currentlyOpenWorldMover) return;
            const code = worldMoverCodeInput.value.trim();
            if (!/^\d{3}$/.test(code)) {
                showMessageBox("Invalid Code. Must be exactly 3 digits.", 'alert');
                return;
            }
            if (!isWorldMoverCodeUnique(code, currentlyOpenWorldMover.col, currentlyOpenWorldMover.row)) {
                showMessageBox("This code is already in use by another World Mover.", 'alert');
                return;
            }
            const moverKey = `${currentlyOpenWorldMover.col},${currentlyOpenWorldMover.row}`;
            worldBlocks[moverKey].code = code;
            showMessageBox(`World Mover configured with code ${code}.`, 'alert');
            toggleWorldMoverMenu(); 
        }
        function isWorldMoverCodeUnique(code, currentCol, currentRow) {
            for (const key in worldBlocks) {
                const [col, row] = key.split(',').map(Number);
                if (col === currentCol && row === currentRow) continue; 
                const block = worldBlocks[key];
                if (block.type === 'world_mover' && block.code === code) {
                    return false; 
                }
            }
            return true;
        }
        function canOpenTeleportMenu() {
            for (const key in worldBlocks) {
                const block = worldBlocks[key];
                if (block.type === 'world_mover' && block.code && /^\d{3}$/.test(block.code)) {
                    return true; 
                }
            }
            return false;
        }
        function toggleTeleportMenu() {
            if (isGamePaused && !isTeleportMenuOpen) return; 
            isTeleportMenuOpen = !isTeleportMenuOpen;
            isGamePaused = isTeleportMenuOpen;
            if (isTeleportMenuOpen) {
                worldMoverTeleportOverlay.style.display = 'flex';
                teleportCodeInput.value = '';
                teleportCodeInput.focus();
            } else {
                worldMoverTeleportOverlay.style.display = 'none';
                lastTime = performance.now();
            }
        }
        function executeTeleport() {
            const code = teleportCodeInput.value.trim();
            if (!/^\d{3}$/.test(code)) return; 
            let targetMoverKey = null;
            let targetMoverData = null;
            for (const key in worldBlocks) {
                const block = worldBlocks[key];
                if (block.type === 'world_mover' && block.code === code) {
                    targetMoverKey = key;
                    targetMoverData = block;
                    break;
                }
            }
            if (!targetMoverData) {
                showMessageBox(`No World Mover found with code ${code}.`, 'alert');
                return;
            }
            const fuel = targetMoverData.inventory ? targetMoverData.inventory[0] : null;
            if (!fuel || fuel.type !== 'pure_fuel' || fuel.count < 20) {
                showMessageBox(`Destination Mover (Code: ${code}) lacks sufficient energy.`, 'alert');
                return;
            }
            const [col, row] = targetMoverKey.split(',').map(Number);
            for (let i = 1; i <= 3; i++) {
                const blockAboveType = getBlockType(col, row - i);
                if (blockAboveType !== '' && blockAboveType !== 'sky') {
                    showMessageBox(`Destination Mover (Code: ${code}) is obstructed.`, 'alert');
                    return;
                }
            }
            player.x = col * tileSize;
            player.y = (row - playerHeightBlocks) * tileSize;
            player.dy = 0; 
            fuel.count -= 20;
            if (fuel.count <= 0) {
                targetMoverData.inventory[0] = null;
            }
            showMessageBox(`Teleported to Mover ${code}!`, 'alert');
            toggleTeleportMenu(); 
        }
		function toggleVoidChestMenu() {
            const voidCharacterContainer = document.getElementById('voidCharacterContainer');
            isGamePaused = !isGamePaused;
            isVoidChestOpen = isGamePaused;
            if (isVoidChestOpen) {
                voidChestOverlay.style.display = 'flex';
                voidCharacterContainer.style.display = 'flex'; 
                if (!currentVoidTrade && voidStorage.length > 0) {
                    generateVoidTradeOffer();
                }
                updateVoidChestMenu();
                animateVoidCharacter();
            } else {
                voidCharacterContainer.style.display = 'none'; 
                voidChestOverlay.style.display = 'none';
                if (heldItem) { 
                    addToVoidStorage(heldItem.type, heldItem.count, heldItem.durability, heldItem.maxDurability);
                    heldItem = null;
                    heldItemSource = { type: null, index: -1 };
                }
                lastTime = performance.now();
            }
        }
		function updateVoidChestMenu() {
			if (!isVoidChestOpen) return;
			voidChestGrid.innerHTML = '';
			voidChestPlayerInventoryGrid.innerHTML = '';
			const aggregatedVoid = {};
			for (const item of voidStorage) {
				if (!item) continue;
				if (aggregatedVoid[item.type]) {
					aggregatedVoid[item.type].count += item.count;
				} else {
					aggregatedVoid[item.type] = { ...item }; 
				}
			}
			const displayableVoid = Object.values(aggregatedVoid);
			for (let i = 0; i < displayableVoid.length; i++) {
				const item = displayableVoid[i];
				const slotDiv = createInventorySlot(item, item.type, 'void');
				voidChestGrid.appendChild(slotDiv);
			}
			for (let i = 0; i < totalInventorySlots; i++) {
				const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
				voidChestPlayerInventoryGrid.appendChild(slotDiv);
			}
			updateVoidTradeOfferUI(); 
		}
        function toggleChestMenu(col, row) {
            isGamePaused = !isGamePaused;
            if (isGamePaused) {
                currentlyOpenChest = { col, row };
                chestOverlay.style.display = 'flex';
                updateChestMenu();
            } else {
                chestOverlay.style.display = 'none';
                currentlyOpenChest = null;
                if (heldItem) {
                    addToInventory(heldItem.type, heldItem.count, heldItem.durability);
                    heldItem = null;
                    heldItemSource = { type: null, index: -1 };
                }
                lastTime = performance.now();
            }
        }
		let isTraderMenuOpen = false;
		let traderBob = 0;
		let traderBobDirection = 1;
		let currentTraderRef = null; 
		function toggleTraderMenu(col, row) {
			isGamePaused = !isGamePaused;
			if (isGamePaused) {
				isTraderMenuOpen = true;
				currentTraderRef = { col, row };
				traderCharacterContainer.style.display = 'flex';
				updateTraderMenu();
				animateTraderCharacter(); 
			} else {
				isTraderMenuOpen = false;
				traderCharacterContainer.style.display = 'none';
				currentTraderRef = null;
				lastTime = performance.now();
			}
		}
		function updateTraderMenu() {
			if (!isTraderMenuOpen || !currentTraderRef) return;
			const { col, row } = currentTraderRef;
			let bottomRow = row;
			const middleBlock = worldBlocks[`${col},${row-1}`];
			const topBlock = worldBlocks[`${col},${row-2}`];
			if (middleBlock && middleBlock.type === 'trader' && middleBlock.part === 'bottom') bottomRow = row - 1;
			if (topBlock && topBlock.type === 'trader' && topBlock.part === 'bottom') bottomRow = row - 2;
			const bottomKey = `${col},${bottomRow}`;
			const bottomBlock = worldBlocks[bottomKey];
			if (!bottomBlock || bottomBlock.type !== 'trader' || bottomBlock.part !== 'bottom') {
				toggleTraderMenu(); 
				return;
			}
			const offerList = document.getElementById('traderOfferList');
			offerList.innerHTML = ''; 
			if (!bottomBlock.trades) {
				bottomBlock.trades = pickRandomTradesFromPool(5);
			}
			const trades = bottomBlock.trades;
			trades.forEach((trade, index) => {
				const tradeRow = document.createElement('div');
				tradeRow.className = 'trade-row';
				const inputSlot = createInventorySlot(trade.input, -1, 'trade_ui');
				const arrow = document.createElement('span');
				arrow.className = 'trade-arrow';
				arrow.innerHTML = '&rarr;'; 
				const outputSlot = createInventorySlot(trade.output, -1, 'trade_ui');
				const acceptButton = document.createElement('button');
				acceptButton.textContent = 'Trade';
				let playerHas = 0;
				inventorySlots.forEach(item => {
					if (item && item.type === trade.input.type) {
						playerHas += item.count;
					}
				});
				if (playerHas < trade.input.count) {
					acceptButton.disabled = true;
				}
				acceptButton.onclick = () => {
					let currentHas = 0;
					inventorySlots.forEach(item => { if (item && item.type === trade.input.type) currentHas += item.count; });
					if (currentHas >= trade.input.count) {
						let remainingCost = trade.input.count;
						for (let i = inventorySlots.length - 1; i >= 0; i--) {
							const item = inventorySlots[i];
							if (item && item.type === trade.input.type) {
								const toRemove = Math.min(remainingCost, item.count);
								item.count -= toRemove;
								remainingCost -= toRemove;
								if (item.count <= 0) inventorySlots[i] = null;
								if (remainingCost <= 0) break;
							}
						}
						addToInventory(trade.output.type, trade.output.count);
						updateTraderMenu();
						syncHotbarIndices();
					} else {
						showMessageBox("You can no longer afford that.", 'alert');
						acceptButton.disabled = true;
					}
				};
				tradeRow.appendChild(inputSlot);
				tradeRow.appendChild(arrow);
				tradeRow.appendChild(outputSlot);
				tradeRow.appendChild(acceptButton);
				offerList.appendChild(tradeRow);
			});
		}
		function animateTraderCharacter() {
			if (!isTraderMenuOpen) {
				traderBob = 0;
				traderBobDirection = 1;
				document.getElementById('traderCharacterContainer').style.bottom = '20px';
				return;
			}
			traderBob += 0.25 * traderBobDirection;
			if (traderBob > 6) traderBobDirection = -1;
			if (traderBob < -2) traderBobDirection = 1;
			document.getElementById('traderCharacterContainer').style.bottom = (20 + traderBob) + 'px';
			requestAnimationFrame(animateTraderCharacter);
		}
		document.getElementById('traderDeclineButton').onclick = () => { toggleTraderMenu(); };
        function updateChestMenu() {
			if (!currentlyOpenChest) return;
			const chestKey = `${currentlyOpenChest.col},${currentlyOpenChest.row}`;
			const chestData = worldBlocks[chestKey];
			if (!chestData || (chestData.type !== 'chest' && chestData.type !== 'dead_body_chest' && chestData.type !== 'refrigerator' && chestData.type !== 'magical_chest')) {
				toggleChestMenu();
				return;
			}
			const currentChestSize = chestData.inventory.length;
			const columns = (currentChestSize === 50) ? 10 : 9;
			chestGrid.style.gridTemplateColumns = `repeat(${columns}, minmax(45px, 1fr))`;
			chestTitle.textContent = chestData.label || 'Chest';
			if (chestData.type === 'magical_chest') {
				chestTitle.textContent = chestData.label || 'Magical Chest';
			}
			if (chestData.type === 'refrigerator') {
				chestTitle.textContent = chestData.label || 'Fridge';
			}
			chestLabelInput.value = chestData.label || '';
			if (chestData.type === 'dead_body_chest') {
				chestLabelInput.disabled = true; 
			} else {
				chestLabelInput.disabled = false;
			}
			chestGrid.innerHTML = '';
			chestPlayerInventoryGrid.innerHTML = '';
			for (let i = 0; i < currentChestSize; i++) {
				const slotDiv = createInventorySlot(chestData.inventory[i], i, 'chest');
				chestGrid.appendChild(slotDiv);
			}
			for (let i = 0; i < totalInventorySlots; i++) {
				const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
				chestPlayerInventoryGrid.appendChild(slotDiv);
			}
		}
		function transferAllFromChest() {
			if (!currentlyOpenChest) return;
			const chestKey = `${currentlyOpenChest.col},${currentlyOpenChest.row}`;
			const chestData = worldBlocks[chestKey];
			if (!chestData || !chestData.inventory) return;
			const chestInventory = chestData.inventory;
			const playerInventory = inventorySlots;
			for (let i = 0; i < chestInventory.length; i++) {
				let chestItem = chestInventory[i];
				if (!chestItem) continue;
				const itemProps = itemTypes[chestItem.type] || blockTypes[chestItem.type];
				const isSpoilable = itemProps?.spoilable;
				const isTool = itemProps?.isTool;
				if (!isTool) { 
					for (let j = 0; j < playerInventory.length; j++) {
						if (chestItem.count <= 0) break;
						let playerSlot = playerInventory[j];
						if (playerSlot && playerSlot.type === chestItem.type && playerSlot.count < maxStackSize) {
							const spaceAvailable = maxStackSize - playerSlot.count;
							const amountToMove = Math.min(chestItem.count, spaceAvailable);
							playerSlot.count += amountToMove;
							if (isSpoilable) {
								const timestampsToMove = _takeTimestamps(chestItem, amountToMove);
								_pushTimestampsIntoSlot(playerSlot, timestampsToMove);
							}
							chestItem.count -= amountToMove; 
						}
					}
				}
				while (chestItem.count > 0) {
					let foundEmptySlot = false;
					for (let j = 0; j < playerInventory.length; j++) {
						if (!playerInventory[j]) { 
							const amountToMove = isTool ? 1 : Math.min(chestItem.count, maxStackSize);
							const timestampsToMove = isSpoilable ? _takeTimestamps(chestItem, amountToMove) : null;
							playerInventory[j] = {
								type: chestItem.type,
								count: amountToMove,
								durability: chestItem.durability, 
								maxDurability: chestItem.maxDurability,
								acquiredTimes: timestampsToMove
							};
							chestItem.count -= amountToMove;
							foundEmptySlot = true;
							if (isTool || chestItem.count <= 0) break;
						}
					}
					if (!foundEmptySlot) break;
				}
				if (chestItem.count <= 0) {
					chestInventory[i] = null;
				}
			}
			updateChestMenu();
			syncHotbarIndices(); 
		}
        chestLabelInput.addEventListener('change', () => {
			if (currentlyOpenChest) {
				const chestKey = `${currentlyOpenChest.col},${currentlyOpenChest.row}`;
				const chestData = worldBlocks[chestKey];
				if (chestData && (chestData.type === 'chest' || chestData.type === 'refrigerator' || chestData.type === 'magical_chest')) {
					chestData.label = chestLabelInput.value;
					chestTitle.textContent = chestData.label || (chestData.type === 'refrigerator' ? 'Refrigerator' : 'Chest');
				}
			}
		});
		function toggleFurnaceMenu(col, row, type) { 
			isGamePaused = !isGamePaused;
			if (isGamePaused) {
				currentlyOpenFurnace = { col, row, type }; 
				ovenOverlay.style.display = 'flex';
				updateFurnaceMenu();
			} else {
				ovenOverlay.style.display = 'none';
				if (currentlyOpenFurnace) {
					const furnaceKey = `${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`;
					const furnaceData = worldBlocks[furnaceKey];
					if (furnaceData && furnaceData.inventory) {
						for (let i = 0; i < furnaceData.inventory.length; i++) {
							const item = furnaceData.inventory[i];
							if (item) {
								addToInventory(item.type, item.count, item.durability);
								furnaceData.inventory[i] = null;
							}
						}
					}
				}
				currentlyOpenFurnace = null;
				if (heldItem) {
					addToInventory(heldItem.type, heldItem.count, heldItem.durability);
					heldItem = null;
					heldItemSource = { type: null, index: -1 };
				}
				lastTime = performance.now();
			}
		}
        function updateFurnaceMenu() {
			if (!currentlyOpenFurnace) return;
			const furnaceKey = `${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`;
			const furnaceData = worldBlocks[furnaceKey];
			if (!furnaceData || (furnaceData.type !== 'oven' && furnaceData.type !== 'magma_furnace')) {
				toggleFurnaceMenu();
				return;
			}
			const titleElement = document.querySelector('#ovenMenu h2');
			if (currentlyOpenFurnace.type === 'magma_furnace') {
				titleElement.textContent = 'Magma Furnace';
			} else {
				titleElement.textContent = 'Oven';
			}
			ovenGrid.innerHTML = '';
			ovenFuelSlot.innerHTML = '';
			ovenOutputSlot.innerHTML = '';
			ovenPlayerInventoryGrid.innerHTML = '';
			for (let i = 0; i < 9; i++) {
				const slotDiv = createInventorySlot(furnaceData.inventory[i], i, currentlyOpenFurnace.type);
				ovenGrid.appendChild(slotDiv);
			}
			const fuelSlotDiv = createInventorySlot(furnaceData.inventory[9], 9, currentlyOpenFurnace.type);
			ovenFuelSlot.innerHTML = '';
			ovenFuelSlot.appendChild(fuelSlotDiv);
			const outputSlotDiv = createInventorySlot(furnaceData.inventory[10], 10, currentlyOpenFurnace.type);
			ovenOutputSlot.innerHTML = '';
			ovenOutputSlot.appendChild(outputSlotDiv);
            const byproductSlotDiv = createInventorySlot(furnaceData.inventory[11], 11, currentlyOpenFurnace.type);
            const ovenByproductSlot = document.getElementById('ovenByproductSlot'); 
            ovenByproductSlot.innerHTML = '';
            ovenByproductSlot.appendChild(byproductSlotDiv);
			for (let i = 0; i < totalInventorySlots; i++) {
				const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
				ovenPlayerInventoryGrid.appendChild(slotDiv);
			}
			renderFurnaceRecipes();
			checkFurnaceRecipe();
		}
        function checkFurnaceRecipe() {
			cookButton.disabled = true;
			cookButton.onclick = null;
			if (!currentlyOpenFurnace) return;
			const recipeList = currentlyOpenFurnace.type === 'magma_furnace' ? furnaceRecipes : ovenRecipes;
			const furnaceKey = `${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`;
			const furnaceData = worldBlocks[furnaceKey];
			if (!furnaceData) return;
			const currentGrid = furnaceData.inventory.slice(0, 9);
			const fuelItem = furnaceData.inventory[9];
			const outputItem = furnaceData.inventory[10];
			for (const recipe of recipeList) { 
				const requiredInput = recipe.input;
				const requiredKeys = Object.keys(requiredInput);
				let gridItemCount = 0;
				const currentGridItems = {};
				for (let i = 0; i < 9; i++) {
					if (currentGrid[i]) {
						currentGridItems[i] = currentGrid[i];
						gridItemCount++;
					}
				}
				if (requiredKeys.length !== gridItemCount) continue;
				let recipeMatch = true;
				for (const key of requiredKeys) {
					if (!currentGridItems[key] || currentGridItems[key].type !== requiredInput[key].type || currentGridItems[key].count < requiredInput[key].count) {
						recipeMatch = false;
						break;
					}
				}
				if (recipeMatch) {
					const hasEnoughFuel = fuelItem && fuelItem.type === 'pure_fuel' && fuelItem.count >= recipe.fuel;
					const outputItem = furnaceData.inventory[10];
                    const byproductItem = furnaceData.inventory[11]; 
                    const canOutput = !outputItem || (outputItem.type === recipe.output && outputItem.count + recipe.outputCount <= maxStackSize);
                    let canByproduct = true; 
                    if (recipe.byproduct) {
                        canByproduct = !byproductItem || (byproductItem.type === recipe.byproduct && byproductItem.count + recipe.byproductCount <= maxStackSize);
                    }
                    if (hasEnoughFuel && canOutput && canByproduct) { 
                        cookButton.disabled = false;
                        cookButton.onclick = () => executeCook(recipe);
                        return;
                    }
				}
			}
		}
        function executeCook(recipe) {
            if (!currentlyOpenFurnace) return;
            const ovenKey = `${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`;
            const furnaceData = worldBlocks[ovenKey];
            if (!furnaceData) return;
            for (const key in recipe.input) {
                const required = recipe.input[key];
                furnaceData.inventory[key].count -= required.count;
                if (furnaceData.inventory[key].count <= 0) {
                    furnaceData.inventory[key] = null;
                }
            }
            furnaceData.inventory[9].count -= recipe.fuel;
            if (furnaceData.inventory[9].count <= 0) {
                furnaceData.inventory[9] = null;
            }
            const outputSlot = furnaceData.inventory[10];
            if (!outputSlot) {
                furnaceData.inventory[10] = { type: recipe.output, count: recipe.outputCount };
            } else {
                outputSlot.count += recipe.outputCount;
            }
            if (recipe.byproduct && recipe.byproductCount > 0) {
                const byproductSlot = furnaceData.inventory[11];
                if (!byproductSlot) {
                    furnaceData.inventory[11] = { type: recipe.byproduct, count: recipe.byproductCount };
                } else {
                    byproductSlot.count += recipe.byproductCount;
                }
            }
            updateFurnaceMenu();
        }
        function renderFurnaceRecipes() {
			ovenRecipeList.innerHTML = '';
			const recipeList = currentlyOpenFurnace.type === 'magma_furnace' ? furnaceRecipes : ovenRecipes;
			for (const recipe of recipeList) {
                const recipeItemDiv = document.createElement('div');
                recipeItemDiv.classList.add('recipe-item');
                recipeItemDiv.style.justifyContent = 'center';
                recipeItemDiv.style.gap = '10px';
                const inputGridDiv = document.createElement('div');
                inputGridDiv.style.display = 'grid';
                inputGridDiv.style.gridTemplateColumns = 'repeat(3, 35px)'; 
                inputGridDiv.style.gap = '3px';
                for (let i = 0; i < 9; i++) {
                    const inputItem = recipe.input[i];
                    const slot = createInventorySlot(inputItem ? {type: inputItem.type, count: inputItem.count} : null, -1, 'recipe');
                    slot.style.width = '35px';
                    slot.style.height = '35px';
                    inputGridDiv.appendChild(slot);
                }
                recipeItemDiv.appendChild(inputGridDiv);
                const fuelInfo = document.createElement('div');
                fuelInfo.style.display = 'flex';
                fuelInfo.style.alignItems = 'center';
                fuelInfo.style.gap = '5px';
                fuelInfo.innerHTML = `<span>+</span>`;
                const fuelSlot = createInventorySlot({type: 'pure_fuel', count: recipe.fuel}, -1, 'recipe');
                fuelInfo.appendChild(fuelSlot);
                recipeItemDiv.appendChild(fuelInfo);
                const arrowSpan = document.createElement('span');
                arrowSpan.classList.add('crafting-arrow');
                arrowSpan.textContent = '';
                recipeItemDiv.appendChild(arrowSpan);
                const outputSlot = createInventorySlot({ type: recipe.output, count: recipe.outputCount }, -1, 'recipe');
                recipeItemDiv.appendChild(outputSlot);
                ovenRecipeList.appendChild(recipeItemDiv);
            }
        }
        maintainDurabilityCheckbox.addEventListener('change', () => { maintainBlockDurability = maintainDurabilityCheckbox.checked; });
		animateDropsCheckbox.addEventListener('change', () => { animateDrops = animateDropsCheckbox.checked; });
		const transferAllButton = document.getElementById('transferAllButton');
        transferAllButton.addEventListener('click', transferAllFromChest);
        newGameButton.addEventListener('click', async () => {
            if (await showMessageBox("Starting a new game will overwrite current progress. Are you sure?", 'confirm')) {
                toggleGameMenu();
                let newSeedValue = seedInput.value.trim();
                let seedToUse = newSeedValue === '' ? Date.now() : stringToHash(newSeedValue);
                setSeed(seedToUse);
                Object.keys(worldBlocks).forEach(key => delete worldBlocks[key]);
                Object.keys(columnSurfaceHeights).forEach(key => delete columnSurfaceHeights[key]);
                Object.keys(worldBiomes).forEach(key => delete worldBiomes[key]); 
                caveBlocks.clear(); 
                skyIslandColumns.clear();
                lastBiomeEndCol = -1; 
                firstBiomeStartCol = 0;
                player.x = 0 * tileSize; player.y = 0; player.dx = 0; player.dy = 0; player.onGround = false;
                player.health = player.maxHealth; player.bedSpawnPoint = null;
                inventorySlots.fill(null); hotbarIndices.fill(null); selectedHotbarSlot = 0; playerMiningPower = 0.1;
                craftingGridSlots.fill(null); heldItem = null; heldItemSource = { type: null, index: -1 };
                updateHotbar();
                init();
                toggleTraderMenu();
                traderColumns.clear();
                watchtowerColumns.clear();
                skyIslandColumns.clear();
		        mineChamberColumns.clear();
        		voidRealmColumns.clear();
    		    chasmColumns.clear();
                bunkerColumns.clear();
		        plantationColumns.clear();
		        redRockColumns.clear();
		        graniteMountainColumns.clear();
		        icyHillColumns.clear();
		        jungleTempleColumns.clear();
                showMessageBox(`New game started with seed: ${seedToUse}`);
            }
        });
        resumeButton.addEventListener('click', toggleGameMenu);
        function resolvePlayerVerticalCollision() {
            const playerCol = Math.floor(player.x / tileSize);
            const playerRow = Math.floor(player.y / tileSize);
            player.onGround = false;
            for (let r = playerRow; r < playerRow + playerHeightBlocks + 2; r++) {
                for (let c = playerCol; c < playerCol + playerWidthBlocks; c++) {
                    if (isSolid(c, r)) {
                        player.y = r * tileSize - playerHeight;
                        player.dy = 0;
                        player.onGround = true;
                        return;
                    }
                }
            }
        }
        let lastTime = performance.now();
        let accumulator = 0.0;
        const fixedDeltaTime = 1000 / 60; 
        function gameLoop(currentTime) {
            if (isGameActive && !isGamePaused) {
                accumulator += currentTime - lastTime;
                lastTime = currentTime;
                if (accumulator > 1000) {
                    accumulator = 1000;
                }
				frameCount++;
				if (currentTime - lastFpsUpdate >= 1000) {
					currentFps = frameCount;
					frameCount = 0;
					lastFpsUpdate = currentTime;
				}
                while (accumulator >= fixedDeltaTime) {
                    update(fixedDeltaTime); 
                    accumulator -= fixedDeltaTime;
                }
            } else {
                lastTime = currentTime;
            }
            draw(); 
            requestAnimationFrame(gameLoop);
        }
        let waiterGo = 0
        function update(dt) {
			gameTime += dt;
            updatePlayer(dt);
            updateCamera();
            updateMining(dt);
            handleBlockPlacement();
			updateAnimatedDrops(dt);
            plantSpoilageAccumulator += dt;
			if (plantSpoilageAccumulator >= PLANT_SPOILAGE_INTERVAL) {
			  updatePlantGrowth();
			  updateSpoilage();
			  plantSpoilageAccumulator = 0;
			}
            waiterGo += 1
            if (waiterGo === 3) {
                waiterGo = 0
                updateParticles(dt);
                updateDebugStats();
                updateHeldItemAnimation(dt); 
                updateHotbar();
                generateOffscreenChunks();
            }
            if (waiterGo === 1) {
                updateHeldItemAnimation(dt);
                updateParticles(dt);
            }
            const playerGridCoords = worldToGrid(player.x + playerWidth / 2, player.y + playerHeight / 2);
            coordsDisplay.textContent = `Coords: (${playerGridCoords.col}, ${playerGridCoords.row})`;
        }
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawWorld();
			drawAnimatedDrops();
			drawParticles();
            drawPlayer();
			drawHeldItem();
            drawmineProg();
            drawHealth();
        }
        function init() {
            resizeCanvas();
            setSeed(currentSeed);
            generateOffscreenChunks();
            const playerStartCol = Math.floor(player.x / tileSize);
            let actualSurfaceRowAtStart = baseSurfaceLevel;
            const maxSurfaceSevoidVoidArchDepth = 200;
            let sevoidVoidArchCount = 0;
            while(getBlockType(playerStartCol, actualSurfaceRowAtStart) === '' && sevoidVoidArchCount < maxSurfaceSevoidVoidArchDepth) {
                 actualSurfaceRowAtStart++;
                 sevoidVoidArchCount++;
            }
            if (sevoidVoidArchCount >= maxSurfaceSevoidVoidArchDepth) {
                console.warn("Could not find solid surface. Defaulting player Y.");
                actualSurfaceRowAtStart = baseSurfaceLevel + 10;
            }
            player.y = (actualSurfaceRowAtStart - playerHeightBlocks) * tileSize;
            player.spawnPoint = { x: player.x, y: player.y }; 
            resolvePlayerVerticalCollision();
            updateHotbar();
            lastTime = performance.now();
            if (!gameLoopId) {
                gameLoopId = requestAnimationFrame(gameLoop);
            }
        }
        let gameLoopId;
        function exportWorldData() {
            const sanitizedWorldBlocks = {};
            for (const key in worldBlocks) {
                const block = worldBlocks[key];
                const sanitizedBlock = { tp: block.type };
                if (block.mineProg) sanitizedBlock.mP = block.mineProg;
                if (block.inventory) sanitizedBlock.inv = block.inventory;
                if (block.label) sanitizedBlock.lbl = block.label;
                if (block.part) sanitizedBlock.prt = block.part;
                if (block.plantTime) sanitizedBlock.pT = block.plantTime;
                if (block.baseBlockType) sanitizedBlock.bBT = block.baseBlockType;
                if (block.code) sanitizedBlock.cd = block.code;
                if (block.item) sanitizedBlock.itm = block.item;
                sanitizedWorldBlocks[key] = sanitizedBlock;
            }
            const worldData = {
                seed: currentSeed,
                blocks: sanitizedWorldBlocks,
                heights: columnSurfaceHeights,
                heavenHeights: heavenColumnSurfaceHeights,
                biomes: worldBiomes,
                underworldBiomes: underworldBiomes,
                caves: Array.from(caveBlocks),
                islands: Array.from(skyIslandColumns),
                towers: Array.from(watchtowerColumns),
                player: {
                    x: player.x,
                    y: player.y,
                    h: player.health,
					mh: player.maxHealth,
                    bed: player.bedSpawnPoint
                },
                inventory: inventorySlots,
                hotbar: hotbarIndices,
				void: voidStorage,
				trade: currentVoidTrade,
            };
            const json = JSON.stringify(worldData);
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `world_${currentSeed}.bgu1`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessageBox("World Saved!");
        }
		document.addEventListener("keydown", (e) => {
			if (e.key === ']') {
				exportWorldData();
			}
		});
        document.addEventListener("keydown", (e) => {
			if (e.key === '*') {
				let newSeedValue = seedInput.value.trim();
                let seedToUse = newSeedValue === '' ? Date.now() : stringToHash(newSeedValue);
                setSeed(seedToUse);
                Object.keys(worldBlocks).forEach(key => delete worldBlocks[key]);
                Object.keys(columnSurfaceHeights).forEach(key => delete columnSurfaceHeights[key]);
                Object.keys(worldBiomes).forEach(key => delete worldBiomes[key]); 
                caveBlocks.clear(); 
                skyIslandColumns.clear();
                lastBiomeEndCol = -1; 
                firstBiomeStartCol = 0;
                player.x = 0 * tileSize; player.y = 0; player.dx = 0; player.dy = 0; player.onGround = false;
                player.health = player.maxHealth; player.bedSpawnPoint = null;
                inventorySlots.fill(null); hotbarIndices.fill(null); selectedHotbarSlot = 0; playerMiningPower = 0.1;
                craftingGridSlots.fill(null); heldItem = null; heldItemSource = { type: null, index: -1 };
                updateHotbar();
                init();
                toggleTraderMenu();
                traderColumns.clear();
                watchtowerColumns.clear();
                skyIslandColumns.clear();
		        mineChamberColumns.clear();
        		voidRealmColumns.clear();
    		    chasmColumns.clear();
                bunkerColumns.clear();
		        plantationColumns.clear();
		        redRockColumns.clear();
		        graniteMountainColumns.clear();
		        icyHillColumns.clear();
		        jungleTempleColumns.clear();
			}
		});
		document.getElementById("worldFileInput").addEventListener("change", function (event) {
			const file = event.target.files[0];
			if (!file) return;
			const reader = new FileReader();
			reader.onload = function (e) {
				try {
					const data = JSON.parse(e.target.result);
					importWorldData(data);
					showMessageBox("World data successfully imported!");
				} catch (err) {
					console.error("Error parsing world data:", err);
                    showMessageBox("Error: Could not load world file. It may be corrupted.");
				}
			};
			reader.readAsText(file);
		});
		function importWorldData(data) {
            Object.keys(worldBlocks).forEach(key => delete worldBlocks[key]);
            Object.keys(columnSurfaceHeights).forEach(key => delete columnSurfaceHeights[key]);
            Object.keys(heavenColumnSurfaceHeights).forEach(key => delete heavenColumnSurfaceHeights[key]);
            Object.keys(worldBiomes).forEach(key => delete worldBiomes[key]);
            Object.keys(underworldBiomes).forEach(key => delete underworldBiomes[key]);
            caveBlocks.clear();
            skyIslandColumns.clear();
            watchtowerColumns.clear();
            setSeed(data.seed || Date.now());
            const loadedBlocks = data.blocks || {};
            for (const key in loadedBlocks) {
                const sBlock = loadedBlocks[key];
                const newBlock = { 
                    type: sBlock.tp, 
                    mineProg: sBlock.mP || 0,
                    inventory: sBlock.inv,
                    label: sBlock.lbl,
                    part: sBlock.prt,
                    plantTime: sBlock.pT,
                    baseBlockType: sBlock.bBT,
                    code: sBlock.cd
                };
                if (sBlock.itm) newBlock.item = sBlock.itm;
                worldBlocks[key] = newBlock;
            }
            Object.assign(columnSurfaceHeights, data.heights || {});
            Object.assign(heavenColumnSurfaceHeights, data.heavenHeights || {});
            Object.assign(worldBiomes, data.biomes || {});
            Object.assign(underworldBiomes, data.underworldBiomes || {});
            (data.caves || []).forEach(key => caveBlocks.add(key));
            (data.islands || []).forEach(key => skyIslandColumns.add(key));
            (data.towers || []).forEach(key => watchtowerColumns.add(key));
			voidStorage = data.void || []; 
			currentVoidTrade = data.trade || null;
            if (data.player) {
                player.x = data.player.x;
                player.y = data.player.y;
                player.health = data.player.h;
				player.maxHealth = data.player.mh;
                player.bedSpawnPoint = data.player.bed;
            }
            inventorySlots.fill(null);
            if(data.inventory) {
                for(let i=0; i < data.inventory.length; i++) {
                    inventorySlots[i] = data.inventory[i];
                }
            }
            hotbarIndices.fill(null);
             if(data.hotbar) {
                for(let i=0; i < data.hotbar.length; i++) {
                    hotbarIndices[i] = data.hotbar[i];
                }
            }
            updateHotbar();
            if(gameMenuOverlay.style.display === 'flex') toggleGameMenu();
            lastTime = performance.now(); 
            console.log("World state updated from import.");
        }
		document.addEventListener("keydown", (e) => {
			if (e.key === "[") {
				document.getElementById("worldFileInput").click();
			}
		});
        function strToU8(s) {
          return new TextEncoder().encode(s);
        }
        function u8ToStr(u8) {
          return new TextDecoder().decode(u8);
        }
        function crc32(buf) {
          const table = (function() {
            let t = new Uint32Array(256);
            for (let i = 0; i < 256; i++) {
              let c = i;
              for (let k = 0; k < 8; k++) {
                c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
              }
              t[i] = c >>> 0;
            }
            return t;
          })();
          let crc = 0xffffffff;
          for (let i = 0; i < buf.length; i++) {
            crc = (crc >>> 8) ^ table[(crc ^ buf[i]) & 0xff];
          }
          return (crc ^ 0xffffffff) >>> 0;
        }
        function dosDateTime(ms = Date.now()) {
          const d = new Date(ms);
          const year = Math.max(1980, d.getFullYear()) - 1980;
          const month = d.getMonth() + 1;
          const day = d.getDate();
          const hours = d.getHours();
          const minutes = d.getMinutes();
          const seconds = Math.floor(d.getSeconds() / 2); 
          const dosTime = (hours << 11) | (minutes << 5) | seconds;
          const dosDate = (year << 9) | (month << 5) | day;
          return { dosTime, dosDate };
        }
        function writeLE(buffer, offset, value, bytes) {
          for (let i = 0; i < bytes; i++) {
            buffer[offset + i] = value & 0xff;
            value >>>= 8;
          }
        }
        function buildSingleEntryZip(filename, compressedBytes, uncompressedSize, crcVal, compressionMethod = 8) {
          const filenameU8 = strToU8(filename);
          const localHeaderSize = 30 + filenameU8.length;
          const cdHeaderSize = 46 + filenameU8.length;
          const compressedSize = compressedBytes.length;
          const localHeader = new Uint8Array(localHeaderSize);
          writeLE(localHeader, 0, 0x04034b50, 4);
          writeLE(localHeader, 4, 20, 2); 
          writeLE(localHeader, 6, 0, 2); 
          writeLE(localHeader, 8, compressionMethod, 2); 
          const dt = dosDateTime();
          writeLE(localHeader, 10, dt.dosTime, 2);
          writeLE(localHeader, 12, dt.dosDate, 2);
          writeLE(localHeader, 14, crcVal >>> 0, 4);
          writeLE(localHeader, 18, compressedSize >>> 0, 4);
          writeLE(localHeader, 22, uncompressedSize >>> 0, 4);
          writeLE(localHeader, 26, filenameU8.length, 2);
          writeLE(localHeader, 28, 0, 2); 
          localHeader.set(filenameU8, 30);
          const cdHeader = new Uint8Array(cdHeaderSize);
          writeLE(cdHeader, 0, 0x02014b50, 4); 
          writeLE(cdHeader, 4, 0x0314, 2); 
          writeLE(cdHeader, 6, 20, 2); 
          writeLE(cdHeader, 8, 0, 2); 
          writeLE(cdHeader,10, compressionMethod, 2);
          writeLE(cdHeader,12, dt.dosTime, 2);
          writeLE(cdHeader,14, dt.dosDate, 2);
          writeLE(cdHeader,16, crcVal >>> 0, 4);
          writeLE(cdHeader,20, compressedSize >>> 0, 4);
          writeLE(cdHeader,24, uncompressedSize >>> 0, 4);
          writeLE(cdHeader,28, filenameU8.length, 2);
          writeLE(cdHeader,30, 0, 2); 
          writeLE(cdHeader,32, 0, 2); 
          writeLE(cdHeader,34, 0, 2); 
          writeLE(cdHeader,36, 0, 2); 
          writeLE(cdHeader,38, 0, 4); 
          writeLE(cdHeader,42, localHeaderSize >>> 0, 4); 
          cdHeader.set(filenameU8, 46);
          const eocd = new Uint8Array(22);
          writeLE(eocd, 0, 0x06054b50, 4);
          writeLE(eocd, 4, 0, 2); 
          writeLE(eocd, 6, 0, 2); 
          writeLE(eocd, 8, 1, 2); 
          writeLE(eocd,10, 1, 2); 
          writeLE(eocd,12, cdHeaderSize >>> 0, 4); 
          writeLE(eocd,16, (localHeaderSize + compressedSize) >>> 0, 4); 
          writeLE(eocd,20, 0, 2); 
          const out = new Uint8Array(localHeaderSize + compressedSize + cdHeaderSize + eocd.length);
          let pos = 0;
          out.set(localHeader, pos); pos += localHeaderSize;
          out.set(compressedBytes, pos); pos += compressedSize;
          out.set(cdHeader, pos); pos += cdHeaderSize;
          out.set(eocd, pos);
          return out;
        }
        async function deflateRawUint8(inputU8) {
          if (typeof CompressionStream === 'function') {
            try {
              const cs = new CompressionStream('deflate-raw');
              const stream = new Response(new Blob([inputU8])).body.pipeThrough(cs);
              const deflated = await new Response(stream).arrayBuffer();
              return new Uint8Array(deflated);
            } catch (err) {
              console.warn('deflate-raw failed:', err);
              throw err;
            }
          } else {
            throw new Error('CompressionStream API (deflate-raw) not available in this browser.');
          }
        }
        async function inflateRawUint8(compressedU8) {
          if (typeof DecompressionStream === 'function') {
            try {
              const ds = new DecompressionStream('deflate-raw');
              const stream = new Response(new Blob([compressedU8])).body.pipeThrough(ds);
              const inflated = await new Response(stream).arrayBuffer();
              return new Uint8Array(inflated);
            } catch (err) {
              console.warn('inflate-raw failed:', err);
              throw err;
            }
          } else {
            throw new Error('DecompressionStream API (deflate-raw) not available in this browser.');
          }
        }
        async function exportWorldBGU2() {
          try {
            const sanitizedWorldBlocks = {};
            for (const key in worldBlocks) {
              const block = worldBlocks[key];
              const sanitizedBlock = { tp: block.type };
              if (block.mineProg) sanitizedBlock.mP = block.mineProg;
              if (block.inventory) sanitizedBlock.inv = block.inventory;
              if (block.label) sanitizedBlock.lbl = block.label;
              if (block.part) sanitizedBlock.prt = block.part;
              if (block.plantTime) sanitizedBlock.pT = block.plantTime;
              if (block.baseBlockType) sanitizedBlock.bBT = block.baseBlockType;
              if (block.code) sanitizedBlock.cd = block.code;
              if (block.item) sanitizedBlock.itm = block.item;
              sanitizedWorldBlocks[key] = sanitizedBlock;
            }
            const worldData = {
              seed: currentSeed,
              blocks: sanitizedWorldBlocks,
              heights: columnSurfaceHeights,
              heavenHeights: heavenColumnSurfaceHeights,
              biomes: worldBiomes,
              underworldBiomes: underworldBiomes,
              caves: Array.from(caveBlocks),
              islands: Array.from(skyIslandColumns),
              towers: Array.from(watchtowerColumns),
              player: {
                x: player.x,
                y: player.y,
                h: player.health,
                mh: player.maxHealth,
                bed: player.bedSpawnPoint
              },
              inventory: inventorySlots,
              hotbar: hotbarIndices,
			  void: voidStorage,
			  trade: currentVoidTrade,
            };
            const json = JSON.stringify(worldData);
            const jsonU8 = strToU8(json);
            const crc = crc32(jsonU8);
            let compressedU8;
            let compressionMethod = 8;
            try {
              compressedU8 = await deflateRawUint8(jsonU8);
            } catch (err) {
              console.warn('Deflate unavailable, creating stored ZIP entry (no compression).');
              compressionMethod = 0;
              compressedU8 = jsonU8;
            }
            const filename = `world_${currentSeed}.json`;
            const zipU8 = buildSingleEntryZip(filename, compressedU8, jsonU8.length, crc, compressionMethod);
            const blob = new Blob([zipU8], { type: 'application/octet-stream' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `world_${currentSeed}.bgu2`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
            showMessageBox("World saved as .bgu2 (compressed).");
          } catch (err) {
            console.error("BGU2 export failed:", err);
            showMessageBox("Error: Could not export .bgu2 file. Check console for details.");
          }
        }
        function parseSingleEntryZip(u8) {
          let offset = 0;
          const sig = (u8[0] | (u8[1] << 8) | (u8[2] << 16) | (u8[3] << 24)) >>> 0;
          if (sig !== 0x04034b50) throw new Error('Not a zip file (missing local header).');
          const compressionMethod = u8[8] | (u8[9] << 8);
          const crc = (u8[14] | (u8[15] << 8) | (u8[16] << 16) | (u8[17] << 24)) >>> 0;
          const compressedSize = (u8[18] | (u8[19] << 8) | (u8[20] << 16) | (u8[21] << 24)) >>> 0;
          const uncompressedSize = (u8[22] | (u8[23] << 8) | (u8[24] << 16) | (u8[25] << 24)) >>> 0;
          const fnameLen = u8[26] | (u8[27] << 8);
          const extraLen = u8[28] | (u8[29] << 8);
          const localHeaderSize = 30 + fnameLen + extraLen;
          const filenameBytes = u8.slice(30, 30 + fnameLen);
          const filename = u8ToStr(filenameBytes);
          const compressedStart = localHeaderSize;
          const compressedEnd = compressedStart + compressedSize;
          if (compressedEnd > u8.length) throw new Error('Truncated zip data.');
          const compressedU8 = u8.slice(compressedStart, compressedEnd);
          return { filename, compressedU8, compressionMethod, uncompressedSize, crc };
        }
        async function importBGU2File(file) {
          try {
            const ab = await file.arrayBuffer();
            const u8 = new Uint8Array(ab);
            if (u8[0] === 0x50 && u8[1] === 0x4b && u8[2] === 0x03 && u8[3] === 0x04) {
              const parsed = parseSingleEntryZip(u8);
              let jsonU8;
              if (parsed.compressionMethod === 8) {
                try {
                  jsonU8 = await inflateRawUint8(parsed.compressedU8);
                } catch (err) {
                  throw new Error('Decompression failed: ' + err.message);
                }
              } else if (parsed.compressionMethod === 0) {
                jsonU8 = parsed.compressedU8;
              } else {
                throw new Error('Unsupported compression method in .bgu2: ' + parsed.compressionMethod);
              }
              const calc = crc32(jsonU8);
              if (calc !== parsed.crc) {
                console.warn('Warning: CRC mismatch for imported .bgu2 (file may be corrupted).');
              }
              const jsonText = u8ToStr(jsonU8);
              let data;
              try {
                data = JSON.parse(jsonText);
              } catch (err) {
                throw new Error('JSON parse failed: ' + err.message);
              }
              importWorldData(data);
              showMessageBox("BGU2 world imported!");
              return;
            } else {
              const txt = u8ToStr(u8);
              try {
                const data = JSON.parse(txt);
                importWorldData(data);
                showMessageBox("Imported world (plain JSON).");
                return;
              } catch (err) {
                throw new Error('Unrecognized file format for import.');
              }
            }
          } catch (err) {
            console.error("BGU2 import error:", err);
            showMessageBox("Error: Could not import .bgu2 file. See console for details.");
          }
        }
        const bgu2Input = document.createElement('input');
        bgu2Input.type = 'file';
        bgu2Input.accept = '.bgu2';
        bgu2Input.style.display = 'none';
        bgu2Input.addEventListener('change', function (ev) {
          const file = ev.target.files[0];
          if (!file) return;
          importBGU2File(file);
          bgu2Input.value = '';
        });
        document.body.appendChild(bgu2Input);
        document.addEventListener('keydown', (e) => {
          if (isConsoleOpen && e.code !== 'Escape') return;
          if (e.key === '}') {
            e.preventDefault();
            exportWorldBGU2();
          } else if (e.key === '{') {
            e.preventDefault();
            bgu2Input.click();
          }
        });
        loadAssets();
    </script>
</body>
</html>