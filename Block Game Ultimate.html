<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Game Ultimate [HTML EDITION]</title>
	<link rel="icon" type="image/png" href="Grass Dirt Block.png">
	<input type="file" id="worldFileInput" accept=".bgu1" style="display: none;">
    <input type="file" id="texturePackInput" webkitdirectory directory multiple style="display: none;">
	<!-- Created By Bryant Reitzel 
	Ideas And Mechanics All From The Mind Of Bryant Reitzel -->
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #70b6d5; /* Set body background to sky blue */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: sans-serif;
            color: white;
            transition: background-color 1s ease; /* Smooth background transition */
        }
        canvas {
            border: 2px solid #555;
            display: block;
            width: 100%; /* Make canvas fill container width */
            height: 100%; /* Make canvas fill container height */
        }
        #gameContainer {
            position: relative;
            display: inline-block; /* To center the container */
            width: 100vw; /* Ensure game container takes full viewport width */
            height: 100vh; /* Ensure game container takes full viewport height */
            overflow: hidden; /* Hide overflow from canvas scaling */
        }
        #hotbar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 5px;
            z-index: 50;
        }
        .hotbar-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #aaa;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            cursor: pointer;
            position: relative;
            background-color: rgba(255, 255, 255, 0.2);
        }
        .hotbar-slot.selected {
            border-color: yellow;
        }
        .hotbar-slot span {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            color: white; /* Ensure count is visible */
            text-shadow: 1px 1px 2px black; /* Add shadow for readability */
        }
        .hotbar-slot img {
             /* Represents the block image */
            width: 30px;
            height: 30px;
             /* Optional: for pixel art style */
        }
         /* Style for fallback text/color in hotbar if image fails */
        .hotbar-slot .fallback {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            text-align: center;
            word-break: break-word; /* Prevent long names from overflowing */
            padding: 2px;
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
		#itemTooltip {
			display: none; /* Hidden by default */
			position: fixed; /* Stays in place on the screen */
			background-color: rgba(0, 0, 0, 0.8);
			color: white;
			padding: 5px 8px;
			border-radius: 4px;
			font-size: 14px;
			pointer-events: none; /* So it doesn't interfere with mouse clicks */
			z-index: 9999; /* Ensures it's on top of everything */
			white-space: nowrap; /* Prevents the name from wrapping to a new line */
		}
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            z-index: 100;
        }
        #coordsDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 50; /* Ensure it's above the canvas */
        }
		#hellfireIcon {
            position: absolute;
            top: 40px; /* Positioned below the coords display */
            right: 10px;
            width: 32px;
            height: 32px;
            
            z-index: 50;
            display: none; /* Hidden by default */
            transition: filter 0.5s linear; /* Smooths the saturation change */
        }
		#deathDisplay {
            margin-top: 3px; /* Add some space above the tip */
            padding: 2px;
            background-color: rgba(0, 0, 0, 0.2); /* A subtle background */
            border-radius: 2px;
            font-size: 0.9em; /* Slightly smaller text */
            font-style: italic;
            color: #CCC; /* Light gray color */
            text-align: center;
            min-height: 10px; /* Prevents the menu from resizing as tips change */
            transition: color 0.5s ease; /* Smoothly fade text color */
        }
        /* Player Health Bar */
        #healthBar {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 2px;
            z-index: 50;
        }
        #healthBar img {
            width: 18px;
            height: 18px;
            
        }
		
		/* Health Bar Effects */
        #healthBar.glow-yellow img {
            filter: drop-shadow(0 0 5px #ffee00) drop-shadow(0 0 10px #ffee00);
            transition: filter 0.2s;
        }

        #healthBar.flash-red img {
            animation: red-flash 1s ease-out; /* Changed from 0.5s to 1s */
        }

        #healthBar.glow-green img {
            animation: green-glow 1.5s ease-out; /* Changed from 1s to 1.5s */
        }

        @keyframes red-flash {
            0% {
                filter: drop-shadow(0 0 10px red) brightness(2.0);
            }
            50% {
                filter: drop-shadow(0 0 20px red) brightness(3.0); /* Increased brightness */
            }
            100% {
                filter: none;
            }
        }

        @keyframes green-glow {
            0% {
                filter: drop-shadow(0 0 10px limegreen) drop-shadow(0 0 20px limegreen) brightness(1.5); /* Increased brightness */
            }
            100% {
                filter: none;
            }
        }
		
        /* Game Menu Styles */
        #gameMenuOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85); /* Darker, more opaque overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* On top of everything */
            font-family: 'Inter', sans-serif; /* Use Inter font */
            color: #E0E0E0; /* Light gray text */
            flex-direction: column;
            gap: 20px;
            display: none; /* Hidden by default */
        }

        #gameMenu {
            background-color: #333; /* Darker background for the menu */
            padding: 30px;
            border-radius: 15px; /* More rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); /* Stronger shadow */
            width: 90%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            border: 2px solid #555; /* Subtle border */
            max-height: 90vh; /* Make the menu itself scrollable */
            overflow-y: auto; /* Enable vertical scrolling */
        }

        #gameMenu h2 {
            color: #00BFFF; /* Deep sky blue for headings */
            text-align: center;
            margin-bottom: 20px;
            font-size: 2em; /* Larger heading */
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }

        #seedInput {
            width: calc(100% - 24px); /* Adjust for padding */
            padding: 12px;
            margin-top: 10px;
            border: 1px solid #666;
            border-radius: 8px;
            background-color: #555;
            color: white;
            font-size: 1em;
            box-sizing: border-box; /* Include padding in width */
        }

        #seedInput::placeholder {
            color: #AAA;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .menu-buttons button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .menu-buttons button:hover {
            transform: translateY(-2px);
        }

        #resumeButton, #newGameButton {
            background-color: #6c757d; /* Gray */
            color: white;
        }
        #resumeButton:hover, #newGameButton:hover {
            background-color: #5a6268;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 600px) {
            #gameMenu {
                padding: 20px;
                width: 95%;
            }
            #gameMenu h2 {
                font-size: 1.5em;
            }
            .menu-buttons button {
                width: 100%;
            }
        }

        /* Add this new CSS rule anywhere in your <style> tag */
        #gameMenuTipText {
            margin-top: 3px; /* Add some space above the tip */
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2); /* A subtle background */
            border-radius: 8px;
            font-size: 0.9em; /* Slightly smaller text */
            font-style: italic;
            color: #CCC; /* Light gray color */
            text-align: center;
            min-height: 40px; /* Prevents the menu from resizing as tips change */
            transition: color 0.5s ease; /* Smoothly fade text color */
        }
        
        /* Custom Message Box Styles */
        #customMessageBoxOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Higher than game menu */
            font-family: 'Inter', sans-serif;
            color: white;
            display: none; /* Hidden by default */
        }

        #customMessageBox {
            background-color: #444;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            text-align: center;
            max-width: 400px;
            width: 80%;
            border: 1px solid #666;
        }

		/* In-Game Console Styles */
		#devConsoleOverlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background-color: rgba(0, 0, 0, 0.5);
			display: none; /* Hidden by default */
			justify-content: center;
			align-items: center;
			z-index: 3000; /* On top of everything */
			font-family: 'Courier New', monospace;
		}

		#devConsole {
			width: 80%;
			max-width: 800px;
			height: 60%;
			background-color: #1E1E1E;
			border: 2px solid #555;
			border-radius: 10px;
			display: flex;
			flex-direction: column;
			overflow: hidden;
		}

		#consoleOutput {
			flex-grow: 1;
			overflow-y: auto;
			padding: 10px;
			color: #D4D4D4;
			font-size: 14px;
			white-space: pre-wrap;
			word-break: break-all;
		}

		#consoleOutput .log-input {
			color: #9CDCFE; /* Light blue for commands */
		}

		#consoleOutput .log-output {
			color: #4EC9B0; /* Teal for results */
		}

		#consoleOutput .log-error {
			color: #F44747; /* Red for errors */
		}

		#consoleInputWrapper {
			display: flex;
			align-items: center;
			border-top: 1px solid #555;
			padding: 5px;
			background-color: #252526;
		}

		#consoleInputWrapper span {
			color: #D4D4D4;
			margin-right: 5px;
		}

		#consoleInput {
			flex-grow: 1;
			background-color: transparent;
			border: none;
			outline: none;
			color: #D4D4D4;
			font-family: 'Courier New', monospace;
			font-size: 14px;
		}

        #messageBoxText {
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        #messageBoxButtons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        #messageBoxButtons button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            transition: background-color 0.2s ease;
        }

        #messageBoxButtons button:hover {
            background-color: #0056b3;
        }

        #messageBoxCancelButton {
            background-color: #6c757d;
        }
        #messageBoxCancelButton:hover {
            background-color: #5a6268;
        }

        /* Inventory & Crafting Menu Styles */
        #inventoryCraftingOverlay, #chestOverlay, #voidChestOverlay, #anvilOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-family: 'Inter', sans-serif;
            color: #E0E0E0;
        }
		
		/* --- Void Character & Trade Offer CSS --- */
        #voidCharacterContainer {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: none; /* Hidden by default, shown when void chest is open */
            align-items: flex-end;
            gap: 15px;
            z-index: 1001; /* Above the chest grid */
        }

        #voidCharacter {
            width: 80px; /* Adjust size as needed */
            height: auto;
            
        }

        #voidTradeOffer {
            background-color: rgba(20, 0, 30, 0.9);
            border: 2px solid #8A2BE2;
            border-radius: 10px;
            padding: 15px;
            color: #E0E0E0;
            width: 250px;
            font-family: 'Inter', sans-serif;
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #voidDialogue {
            font-style: italic;
            text-align: center;
            margin: 0 0 10px 0;
            font-size: 0.9em;
        }
        
        #voidOfferItem {
            margin: 0 auto; /* Center the item slot */
        }

        #voidOfferCost {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
        }
        
        #voidOfferCost img {
            width: 20px;
            height: 20px;
            
        }

        #voidTradeButtons {
            display: flex;
            justify-content: center;
            gap: 10px;
            width: 100%;
        }

        #voidTradeButtons button {
            padding: 8px 12px;
            border: none;
            border-radius: 5px;
            font-size: 0.9em;
            cursor: pointer;
            flex-grow: 1;
        }
        
        #voidAcceptButton {
            background-color: #28a745;
            color: white;
        }
        #voidAcceptButton:disabled {
            background-color: #5a6268;
            cursor: not-allowed;
        }
        #voidDeclineButton {
            background-color: #dc3545;
            color: white;
        }

        /* --- Trader UI Improvements --- */
		.trade-row {
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 8px;
			margin-bottom: 8px;
			background-color: rgba(0, 0, 0, 0.2);
			border-radius: 6px;
			gap: 10px;
		}
		.trade-row .inventory-slot {
			width: 40px;
			height: 40px;
			cursor: default; /* Make slots non-interactive */
		}
		.trade-row .trade-arrow {
			font-size: 1.5em;
			font-weight: bold;
		}
		.trade-row button {
			padding: 6px 12px;
			font-size: 0.9em;
		}
		
		/* World Mover Config Menu Styles */
        #worldMoverConfigOverlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: rgba(0, 0, 0, 0.85); display: none;
            justify-content: center; align-items: center; z-index: 2000;
            font-family: 'Inter', sans-serif; color: #E0E0E0;
        }
        #worldMoverConfigMenu {
            background-color: #333; padding: 20px; border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); width: 90%;
            max-width: 400px; border: 2px solid #555; display: flex;
            flex-direction: column; gap: 15px; text-align: center;
        }
        #worldMoverConfigMenu h2 { color: #8A2BE2; margin: 0 0 10px 0; }
        .config-section { padding: 10px; background-color: #444; border-radius: 10px; }
        #worldMoverCodeInput {
            width: 50%; padding: 8px; border: 1px solid #666;
            border-radius: 5px; background-color: #555; color: white;
            font-size: 1.2em; text-align: center;
        }
        #saveWorldMoverButton {
            padding: 10px 20px; border: none; border-radius: 8px; font-size: 1.1em;
            cursor: pointer; background-color: #007bff; color: white;
            font-weight: bold; align-self: center; margin-top: 10px;
        }

        /* World Mover Teleport Menu Styles */
        #worldMoverTeleportOverlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: rgba(0, 0, 0, 0.85); display: none;
            justify-content: center; align-items: center; z-index: 2000;
            font-family: 'Inter', sans-serif; color: #E0E0E0;
        }
        #worldMoverTeleportMenu {
            background-color: #2a2a2a; padding: 30px; border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.6); text-align: center;
            border: 2px solid #8A2BE2;
        }
        #teleportCodeInput {
            display: block; margin: 10px auto; width: 100px; font-size: 2em;
            text-align: center; background-color: #444; color: white;
            border: 1px solid #666; border-radius: 5px;
        }

        #inventoryCraftingMenu, #chestMenu, #voidChestMenu, #anvilMenu {
            background-color: #333;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 600px;
            border: 2px solid #555;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 90vh; /* Make the menu itself scrollable */
            overflow-y: auto; /* Enable vertical scrolling */
        }

        #inventoryCraftingMenu h2, #chestMenu h2 {
            color: #00BFFF;
            text-align: center;
            margin: 0 0 10px 0;
        }
        
        .inventory-section {
            padding: 10px;
            background-color: #444;
            border-radius: 10px;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
            gap: 8px;
        }

        .inventory-slot {
            width: 45px;
            height: 45px;
            border: 2px solid #777;
            background-color: #555;
            border-radius: 5px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .inventory-slot:hover {
            background-color: #666;
        }
        .inventory-slot img {
            width: 32px;
            height: 32px;
            
        }
        .inventory-slot .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        /* New style for hotbar slots within the inventory menu */
        #inventoryHotbarGrid .hotbar-slot {
            border-color: yellow; /* Distinguish hotbar slots in inventory */
        }

        .crafting-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        #craftingGrid {
            display: grid;
            grid-template-columns: repeat(4, 45px); /* Changed to 4x4 */
            grid-template-rows: repeat(4, 45px); /* Changed to 4x4 */
            gap: 5px;
        }
        
        .crafting-arrow {
            font-size: 2em;
            color: #999;
        }

        #craftingOutput {
            width: 50px;
            height: 50px;
            border: 2px dashed #999;
        }
        
        #craftButton {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #28a745;
            color: white;
            font-weight: bold;
            align-self: center;
        }
        #craftButton:disabled {
            background-color: #5a6268;
            cursor: not-allowed;
        }

        /* Recipe Menu Styles */
        #recipeMenu {
            padding: 10px;
            background-color: #444;
            border-radius: 10px;
            margin-top: 20px;
        }

        #recipeMenu h3 {
            color: #00BFFF;
            margin-top: 0;
            margin-bottom: 10px;
        }

        .recipe-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            background-color: #555;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #666;
        }

        .recipe-input-grid {
            display: grid;
            grid-template-columns: repeat(4, 35px); /* Smaller grid for recipe display */
            grid-template-rows: repeat(4, 35px);
            gap: 3px;
            margin-right: 10px;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .recipe-input-grid .inventory-slot {
            width: 35px;
            height: 35px;
            border: 1px solid #777;
            background-color: #666;
        }

        .recipe-output {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: bold;
        }

        .recipe-output .inventory-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #777;
            background-color: #555;
            border-radius: 5px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .recipe-output .inventory-slot img {
            width: 28px;
            height: 28px;
        }
        .recipe-output .inventory-slot .item-count {
            font-size: 10px;
        }

        /* Durability Bar for Pickaxe */
        .durability-bar {
            position: absolute;
            bottom: 0px; /* Position at the bottom of the slot */
            left: 0;
            width: 100%;
            height: 4px; /* Thin bar */
            background-color: #555; /* Background for empty part */
            border-radius: 2px;
            overflow: hidden;
        }

        .durability-fill {
            height: 100%;
            background-color: #28a745; /* Green for full durability */
            width: 100%; /* Default to full width */
            transition: width 0.1s linear; /* Smooth transition for durability changes */
        }
        /* Chest Label Input */
        #chestLabelInput {
            width: calc(100% - 20px);
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #666;
            border-radius: 5px;
            background-color: #555;
            color: white;
            font-size: 0.9em;
        }

        /* Delete Slot */
        #deleteSlot {
            width: 45px;
            height: 45px;
            border: 2px dashed #dc3545;
            background-color: rgba(220, 53, 69, 0.2);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #dc3545;
            font-size: 24px;
            font-weight: bold;
            margin-top: 10px;
        }
        #deleteSlot:hover {
            background-color: rgba(220, 53, 69, 0.4);
        }
		
		#consoleInput {
			flex-grow: 1;
			background-color: transparent;
			border: none;
			outline: none;
			color: #D4D4D4;
			font-family: 'Courier New', monospace;
			font-size: 14px;
			resize: none; /* Disable manual resizing */
			overflow-y: auto; /* Add scrollbar if it gets too tall */
			max-height: 120px; /* Limit height to about 8 lines */
			line-height: 1.4;
			white-space: pre-wrap;
			word-break: break-all;
		}
		
		/* Oven Menu Styles */
        #ovenOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 2000;
            font-family: 'Inter', sans-serif;
            color: #E0E0E0;
			pointer-events: auto; /* ensure it receives pointer events */
        }

        #ovenMenu {
            background-color: #333;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 600px;
            border: 2px solid #555;
            display: flex;
            flex-direction: column;
            gap: 15px;
			max-height: 90vh;
            overflow-y: auto;
        }

        #ovenMenu h2 {
            color: #FFA500; /* Orange for oven title */
            text-align: center;
            margin: 0 0 10px 0;
        }

        .oven-ui-area {
            display: flex;
            justify-content: space-around;
            align-items: center;
            gap: 20px;
        }

        #ovenGrid {
            display: grid;
            grid-template-columns: repeat(3, 45px);
            grid-template-rows: repeat(3, 45px);
            gap: 5px;
        }
        
        .oven-fuel-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        #cookButton {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #28a745; /* Green */
            color: white;
            font-weight: bold;
            align-self: center;
            margin-top: 10px;
        }

        #cookButton:disabled {
            background-color: #5a6268;
            cursor: not-allowed;
        }
		
		// --- Vibrant Oven Menu Style Add For Fun If Wanted ---
		/* #ovenOverlay {
			/* Adds a very subtle, dark red transparent background */
			background-color: rgba(40, 10, 10, 0.85);
		}

		#ovenMenu {
			/* A fiery orange border */
			border: 2px solid #FF4500;
			/* Dark background with a radial gradient to simulate a "glow" */
			background: radial-gradient(circle, 
				rgba(60, 40, 30, 1) 0%, 
				rgba(40, 20, 15, 1) 100%
			);
		}

		#ovenMenu h2 {
			/* Brighter, more intense orange title */
			color: #FF6600;
			text-shadow: 0 0 8px rgba(255, 100, 0, 0.7);
		}

		#cookButton {
			/* Make the cook button a vibrant orange */
			background-color: #FF4500;
			border: 1px solid #FF8C00;
		}
		#cookButton:hover:not(:disabled) {
			background-color: #E03D00;
			box-shadow: 0 0 10px rgba(255, 100, 0, 0.5);
		}*/
		
		// --- Unique Anvil Menu Style For Fun If Wanted ---
		/*#anvilOverlay {
			/* A subtle, dark blue/purple overlay */
			background-color: rgba(20, 15, 40, 0.85);
		}

		#anvilMenu {
			/* A cool, magical purple border (like Mythicalithium) */
			border: 2px solid #8A2BE2;
			/* A metallic, dark blue-grey background */
			background: radial-gradient(circle, 
				rgba(50, 50, 65, 1) 0%, 
				rgba(30, 30, 45, 1) 100%
			);
		}

		#anvilMenu h2 {
			/* Match the purple border */
			color: #9A4BFF;
			text-shadow: 0 0 8px rgba(154, 75, 255, 0.7);
		}

		#anvilCraftButton {
			/* Make the craft button a matching purple */
			background-color: #8A2BE2;
			border: 1px solid #9A4BFF;
		}
		#anvilCraftButton:hover:not(:disabled) {
			background-color: #7022C0;
			box-shadow: 0 0 10px rgba(154, 75, 255, 0.5);
		}*/

		/* --- New "Skip Loading" Button Style --- */
		#skipLoadingButton {
			display: none; /* Hidden by default */
			margin-top: 15px;
			padding: 8px 12px;
			background-color: #555;
			border: 1px solid #888;
			color: white;
			border-radius: 5px;
			cursor: pointer;
			font-family: 'Inter', sans-serif;
			font-size: 14px;
			transition: background-color 0.2s;
		}
		#skipLoadingButton:hover {
			background-color: #777;
		}
		
		#debugStats {
			position: absolute;
			top: 35px; /* Position it below the health bar */
			left: 10px;
			background-color: rgba(0, 0, 0, 0.6);
			color: white;
			padding: 8px;
			border-radius: 5px;
			font-family: 'Courier New', monospace;
			font-size: 12px;
			line-height: 1.4;
			z-index: 50;
			pointer-events: none; /* Make it non-interactive */
		}

        #drunkVignette {
            display: none; /* Hidden by default */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Sits on top of the canvas (z-index: 0) */
            z-index: 10; 
            /* Your UI (health, hotbar) is z-index: 50, so it will be on top */
            pointer-events: none; /* Lets clicks pass through to the canvas */
            /* The radial gradient creates the vignette. We will control its opacity. */
            background-image: radial-gradient(circle, 
                rgba(0,0,0,0) 40%, 
                rgba(0,0,0,0.8) 100%
            );
            transition: opacity 0.5s linear;
        }

        /* Vibration animation */
        @keyframes vibrate {
            0% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 2px); }
            50% { transform: translate(2px, -2px); }
            75% { transform: translate(2px, 2px); }
            100% { transform: translate(0, 0); }
        }

        /* Class to apply the animation */
        .vibrating {
            animation: vibrate 0.1s linear infinite;
        }
		
		.recipe-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .recipe-controls input[type="text"] {
            flex: 1;
            padding: 8px;
            border: 1px solid #666;
            border-radius: 5px;
            background-color: #555;
            color: white;
            font-size: 0.9em;
        }

        .recipe-view-toggle {
            padding: 8px 12px;
            border: 1px solid #777;
            background-color: #555;
            color: #E0E0E0;
            cursor: pointer;
            border-radius: 5px;
            font-size: 0.9em;
        }
        
        .recipe-view-toggle:hover {
            background-color: #666;
        }

        .recipe-view-toggle.active {
            background-color: #007bff;
            border-color: #007bff;
            color: white;
            font-weight: bold;
        }

        #recipeIconContainer,
        #ovenRecipeIconContainer {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
            gap: 8px;
            max-height: 300px; /* Give the icon grid a max height */
            overflow-y: auto;   /* And make it scrollable */
            padding: 5px;
            background-color: rgba(0,0,0,0.1);
            border-radius: 5px;
        }

        .recipe-icon-slot {
            width: 45px;
            height: 45px;
        }
		
		.paper-doll-armor {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            
        }
		/* --- Book Menu Styles --- */
        #bookMenuOverlay, #publishMenuOverlay, #bookReaderOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 1500; /* Above other menus */
            font-family: 'Inter', sans-serif;
            color: #E0E0E0;
        }

        #bookEditor, #publishMenu, #bookReaderMenu {
            background-color: #333;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 700px;
            border: 2px solid #555;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 90vh;
        }

        #bookEditor h2, #publishMenu h2, #bookReaderMenu h2 {
            color: #00BFFF;
            text-align: center;
            margin: 0 0 10px 0;
        }

        #bookContentInput {
            width: calc(100% - 20px);
            height: 60vh;
            background-color: #222;
            color: #E0E0E0;
            border: 1px solid #666;
            border-radius: 8px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
        }

        .book-buttons {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
        }

        .book-buttons button, #publishMenu button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            transition: background-color 0.2s ease;
        }
        .book-buttons button:hover, #publishMenu button:hover {
            background-color: #0056b3;
        }
        
        #bookPublishButton { background-color: #28a745; }
        #bookPublishButton:hover { background-color: #218838; }

        #bookImportLabel {
            padding: 10px 15px;
            border-radius: 5px;
            background-color: #6c757d;
            color: white;
            cursor: pointer;
            text-align: center;
        }
        #bookImportLabel:hover { background-color: #5a6268; }
        #bookImportInput { display: none; }

        /* Publish Menu */
        #publishMenu {
            max-width: 500px;
        }
        #publishMenu input[type="text"] {
            width: calc(100% - 24px);
            padding: 12px;
            border: 1px solid #666;
            border-radius: 8px;
            background-color: #555;
            color: white;
            font-size: 1em;
        }
        #coverPreview {
            max-width: 100%;
            max-height: 200px;
            object-fit: contain;
            border: 1px dashed #777;
            background-color: #444;
            min-height: 50px;
            border-radius: 5px;
        }
        #bookCoverInput { display: none; }
        #bookCoverLabel {
            padding: 10px 15px;
            border-radius: 5px;
            background-color: #6c757d;
            color: white;
            cursor: pointer;
            text-align: center;
        }
        #bookFinalizeButton { background-color: #28a745; }
        #bookCancelPublishButton { background-color: #dc3545; }
        
        /* Reader Menu */
        #bookReaderMenu {
            max-width: 800px;
            text-align: center;
        }
        #bookReaderCover {
            max-width: 100%;
            max-height: 300px;
            object-fit: contain; /* FIX: This makes the image fit without stretching */
            border-radius: 5px;
            margin-bottom: 15px;
        }
        #bookReaderContent {
            height: 50vh; /* FIX: Set a defined height */
            background-color: #222;
            color: #E0E0E0;
            border: 1px solid #666;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Georgia', serif;
            font-size: 16px;
            overflow-y: auto; /* FIX: This adds the scrollbar when content overflows */
            text-align: left;
            white-space: pre-wrap; /* Preserve line breaks */
        }

        /* Skin Upload Menu */
        #skinUploadOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 2000;
            font-family: 'Inter', sans-serif;
            color: #E0E0E0;
        }
        #skinUploadMenu {
            background-color: #333;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 400px;
            border: 2px solid #555;
            display: flex;
            flex-direction: column;
            gap: 15px;
            text-align: center;
        }
        #skinUploadMenu h2 {
            color: #00BFFF;
            margin: 0 0 10px 0;
        }
        #skinUploadLabel {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #007bff;
            color: white;
        }
        #skinResetButton, #skinUploadCancelButton {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            background-color: #dc3545;
            color: white;
        }
        #skinUploadCancelButton {
             background-color: #6c757d;
        }
		/* --- Minimap Styles --- */
        #minimapContainer {
            position: absolute;
            top: 80px; /* Positioned below coords and hellfire */
            right: 10px;
            width: 150px;
            height: 150px;
            border: 2px solid #888;
            background-color: #000000; /* Dark, transparent background */
            z-index: 50; /* Same as other UI */
            display: none; /* Hidden by default */
            image-rendering: pixelated;
        }
        #minimapCanvas {
            width: 100%;
            height: 100%;
        }
        /* --- START OF MOBILE CONTROLS CSS --- */
        #mobileControlsOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 900; /* Above game, below menus */
            pointer-events: none; /* Pass clicks through overlay */
            display: none; /* Hidden by default */
        }

        #joystickContainer {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 140px;
            height: 140px;
            background-color: rgba(100, 100, 100, 0.4);
            border-radius: 50%;
            pointer-events: auto; /* This element is clickable */
        }

        #joystickKnob {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            top: 40px; /* (140 - 60) / 2 */
            left: 40px; /* (140 - 60) / 2 */
            transition: transform 0.05s linear; /* Smooth reset */
        }

        #mobileButtonContainer {
            position: absolute;
            bottom: 80px; /* MOVED from top */
            right: 10px;  /* MOVED from left */
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
            align-items: flex-end; /* ADDED: Aligns buttons to the right */
        }

        .mobile-button {
            width: 50px;
            height: 50px;
            background-color: rgba(100, 100, 100, 0.6);
            border: 2px solid white;
            border-radius: 10px;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 24px;
            user-select: none; /* Prevent text selection */
        }

        .mobile-close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background-color: #dc3545; /* Red */
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            font-size: 20px;
            font-weight: bold;
            z-index: 9999; /* On top of everything in the menu */
            display: none; /* Hidden by default */
            pointer-events: auto;
            user-select: none;
        }
        #mobileButtonContainer > .mobile-button {
            pointer-events: auto; /* Makes direct children (buttons) clickable */
        }

        #mobileSubMenu {
            display: none; /* Hidden by default */
            position: absolute;
            right: 100%; /* CHANGED from left */
            top: 0;
            padding-right: 10px; /* CHANGED from padding-left */
            flex-direction: column;
            gap: 10px;
            width: 100px; /* Give the sub-menu a fixed width */
        }

        #mobileSubMenu.show {
            display: flex; /* Show the menu */
        }

        .mobile-sub-button {
            height: 50px;
            background-color: rgba(100, 100, 100, 0.6);
            border: 2px solid white;
            border-radius: 10px;
            pointer-events: auto;
            color: white;
            font-size: 16px;
            font-weight: bold;
            user-select: none;
        }
        #fullscreenMapOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.95);
            z-index: 2500; /* Above most menus */
            display: none;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Hide canvas overflow */
        }
        #fullscreenMapCanvas {
            width: 100%;
            height: 100%;
            border: none;
            image-rendering: pixelated;
            cursor: grab;
        }
        #fullscreenMapCanvas:active {
            cursor: grabbing;
        }
        #fullscreenMapCloseButton {
            z-index: 2501; /* Above map canvas */
        }
		@media (max-width: 500px) {
            #hotbar {
                width: 98%; /* Make it almost full width */
                gap: 2px;
                padding: 3px;
                bottom: 5px; /* Move it closer to the bottom edge */
            }
            .hotbar-slot {
                /* Shrink slots to fit 10 on screen */
                width: 32px; 
                height: 32px;
                font-size: 10px; /* Smaller count text */
            }
            .hotbar-slot img {
                width: 24px; /* Shrink the item image */
                height: 24px;
            }
            .hotbar-slot span {
                /* Adjust count position for smaller slot */
                font-size: 9px;
                bottom: 1px;
                right: 1px;
            }
        }
		/* --- Achievement Toast (Pop-up) Styles --- */
		#achievementToastContainer {
			position: fixed;
			top: 20px;
			right: 20px;
			z-index: 9999;
			display: flex;
			flex-direction: column;
			gap: 10px;
			pointer-events: none; /* Let clicks pass through */
		}

		.achievement-toast {
			background-color: rgba(40, 40, 40, 0.9);
			border: 2px solid #DAA520;
			border-radius: 10px;
			padding: 15px;
			display: flex;
			align-items: center;
			gap: 15px;
			width: 300px;
			box-shadow: 0 4px 15px rgba(0,0,0,0.5);
			animation: toast-fade-in 0.5s ease-out forwards, toast-fade-out 0.5s ease-in 4.5s forwards;
		}

		@keyframes toast-fade-in {
			from {
				opacity: 0;
				transform: translateX(100%);
			}
			to {
				opacity: 1;
				transform: translateX(0);
			}
		}

		@keyframes toast-fade-out {
			from {
				opacity: 1;
				transform: translateX(0);
			}
			99.9% {
				opacity: 0;
				transform: translateX(0);
			}
			100% {
				opacity: 0;
				transform: translateX(100%);
				display: none; /* Hide it completely after animation */
			}
		}

		.achievement-toast-icon {
			width: 45px;
			height: 45px;
			
			border: 2px solid #777;
			background-color: #555;
			border-radius: 5px;
			flex-shrink: 0;
		}

		.achievement-toast-text {
			display: flex;
			flex-direction: column;
			gap: 2px;
			color: white;
		}

		.achievement-toast-text h4 {
			margin: 0;
			color: #FFD700;
			font-size: 1.1em;
		}

		.achievement-toast-text p {
			margin: 0;
			font-size: 0.9em;
			color: #E0E0E0;
		}

		.achievement-toast-text .xp-gain {
			margin-top: 4px;
			font-size: 0.9em;
			font-weight: bold;
			color: #4CAF50; /* Green */
		}
		
		/* Style for the description text */
		.achievement-slot-desc {
			font-size: 0.8em;
			color: #B0B0B0;
			margin-top: 4px;
			/* Allow text to wrap */
			white-space: normal;
			word-wrap: break-word;
		}

		/* --- XP & Achievements Menu Styles --- */
		#xpMenuOverlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background-color: rgba(0, 0, 0, 0.85);
			display: none; /* Hidden by default */
			justify-content: center;
			align-items: center;
			z-index: 1000;
			font-family: 'Inter', sans-serif;
			color: #E0E0E0;
		}

		#xpMenu {
			background-color: #333;
			padding: 20px;
			border-radius: 15px;
			box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
			width: 90%;
			max-width: 700px;
			border: 2px solid #DAA520;
			display: flex;
			flex-direction: column;
			gap: 15px;
			max-height: 90vh;
		}

		#xpMenu h2 {
			color: #DAA520;
			text-align: center;
			margin: 0 0 10px 0;
		}

		#xpHeader {
			display: flex;
			justify-content: space-between;
			align-items: center;
			background-color: #444;
			padding: 10px 15px;
			border-radius: 8px;
			font-size: 1.2em;
		}

		#xpTotalDisplay {
			font-weight: bold;
			color: #4CAF50;
			font-size: 1.3em;
		}

		#achievementGrid {
			display: grid;
			/* UPDATED: Make columns wider to fit text */
			grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); 
			gap: 10px;
			overflow-y: auto;
			padding: 10px;
			background-color: #2a2a2a;
			border-radius: 10px;
			min-height: 300px;
		}

		.achievement-slot {
			background-color: #444;
			border: 1px solid #666;
			border-radius: 8px;
			padding: 10px;
			display: flex;
			flex-direction: column;
			/* UPDATED: Align items to the start (left) */
			align-items: flex-start;
			text-align: left;
			gap: 8px; /* UPDATED: Increased gap */
			position: relative;
			cursor: default;
		}

		.achievement-slot-icon {
			width: 48px;
			height: 48px;
			
			border: 2px solid #777;
			background-color: #555;
			border-radius: 5px;
		}

		.achievement-slot-name {
			font-size: 0.9em;
			font-weight: bold;
			color: #FFD700;
		}

		.achievement-slot-xp {
			font-size: 0.8em;
			color: #4CAF50;
		}

		/* Tooltip for achievement description */
		.achievement-slot .tooltiptext {
			visibility: hidden;
			width: 200px;
			background-color: rgba(0, 0, 0, 0.9);
			color: #fff;
			text-align: center;
			border-radius: 6px;
			padding: 8px;
			position: absolute;
			z-index: 100;
			bottom: 110%; /* Position above the slot */
			left: 50%;
			margin-left: -100px; /* Use half of the width */
			opacity: 0;
			transition: opacity 0.3s;
			font-size: 0.85em;
			pointer-events: none;
		}

		.achievement-slot:hover .tooltiptext {
			visibility: visible;
			opacity: 1;
		}

		/* Grayed out for unearned */
		.achievement-slot.unearned {
			background-color: #383838;
		}

		.achievement-slot.unearned .achievement-slot-icon {
			filter: grayscale(1);
			opacity: 0.6;
		}

		.achievement-slot.unearned .achievement-slot-name {
			color: #999;
		}

		.achievement-slot.unearned .achievement-slot-xp {
			color: #777;
		}
		
		/* Grayed out for unearned */
		.achievement-slot.unearned .achievement-slot-desc {
			color: #777;
		}

		/* --- Mobile Specific Style Overrides --- */
		@media (max-width: 600px) {
			/* Move toast container to the top center */
			#achievementToastContainer {
				top: 10px;
				right: 50%;
				transform: translateX(50%);
				width: 95%;
				align-items: center;
			}

			.achievement-toast {
				width: 100%;
				box-sizing: border-box; /* Ensure padding doesn't break width */
			}

			/* Make XP menu grid columns smaller */
			#achievementGrid {
				grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
			}
			
			.achievement-slot-icon {
				width: 40px;
				height: 40px;
			}
		}

		/* --- Cinema Mode Overlays (Letterbox & Lighting) --- */
		#cinemaOverlayTop,
		#cinemaOverlayBottom {
			position: absolute;
			left: 0;
			width: 100%;
			height: 15vh; /* 15% of the screen height */
			background-color: #000;
			z-index: 950; /* Above game, below menus */
			pointer-events: none;
			display: none; /* Hidden by default */
			opacity: 0;
			transition: opacity 0.5s ease;
		}
		#cinemaOverlayTop { top: 0; }
		#cinemaOverlayBottom { bottom: 0; }

		#cinemaVignette {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			z-index: 949; /* Just behind the letterbox bars */
			pointer-events: none;
			display: none;
			opacity: 0;
			background-image: radial-gradient(circle, 
				rgba(0,0,0,0) 60%, 
				rgba(0,0,0,0.7) 100%
			);
			transition: opacity 0.5s ease;
		}

		/* --- Cinema Mode Active Class --- */

		/* This class will be toggled on #gameContainer */
		.cinema-mode #gameCanvas {
			/* This is the "HD" part: it enables browser anti-aliasing */
			image-rendering: auto !important; 
			
			/* This is the "Lighting" part: more contrast, richer color */
			filter: contrast(1.1) brightness(0.95) saturate(1.1);
		}

		.cinema-mode #cinemaOverlayTop,
		.cinema-mode #cinemaOverlayBottom,
		.cinema-mode #cinemaVignette {
			display: block;
			//opacity: 1;
		}

		/* This hides ALL UI elements when cinema mode is on */
		.cinema-mode #hotbar,
		.cinema-mode #healthBar,
		.cinema-mode #coordsDisplay,
		.cinema-mode #hellfireIcon,
		.cinema-mode #debugStats,
		.cinema-mode #minimapContainer,
		.cinema-mode #mobileControlsOverlay {
			display: none !important;
		}
    </style>
	<!-- Created By Bryant Reitzel 
	Ideas And Mechanics All From The Mind Of Bryant Reitzel -->
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="drunkVignette"></div>
        <div id="cinemaOverlayTop"></div>
        <div id="cinemaOverlayBottom"></div>
        <div id="cinemaVignette"></div>
        <div id="healthBar"></div>
        <div id="hotbar"></div>
        <div id="loadingScreen" style="display:flex;flex-direction:column;align-items:center;gap:8px;position:fixed;left:50%;top:40%;transform:translate(-50%,-50%);z-index:9999;padding:12px;background:rgba(0,0,0,0.75);border-radius:8px;">
          <div id="loadingText" style="color:white;font-size:16px;">Loading assets...</div>
          <div id="loadingBar" style="width:360px;height:18px;background:#333;border-radius:9px;overflow:hidden;border:2px solid #222;">
            <div id="loadingBarFill" style="width:0%;height:100%;background:#7bd389;transition:width 0.12s linear;"></div>
          </div>
          <div id="loadingPercent" style="color:#ddd;font-size:13px;">0%</div>
		  <div id="loadingTipText" style="margin-top: 15px; color: #bbb; font-size: 14px; font-style: italic; max-width: 360px; text-align: center;"></div>
		  <button id="skipLoadingButton">Skip To Game</button>
		  </div>
        </div>
        <div id="coordsDisplay">Coords: (0, 0)</div>
		<img id="hellfireIcon" src="Fire Icon.png" style="display: none;">
		<div id="debugStats" style="display: none;"></div>

        <div id="minimapContainer">
            <canvas id="minimapCanvas" width="150" height="150"></canvas>
        </div>
        <div id="mobileControlsOverlay">
        <div id="joystickContainer">
            <div id="joystickKnob"></div>
        </div>

        <div id="mobileButtonContainer">
            <button id="mobileInventoryButton" class="mobile-button"></button>
            <button id="mobileBedButton" class="mobile-button"></button>
            <button id="mobileMoverButton" class="mobile-button"></button>
                
            <button id="mobileMoreButton" class="mobile-button">...</button>
            <div id="mobileSubMenu">
                <button id="mobileConsoleButton" class="mobile-sub-button">Console</button>
                <button id="mobileMenuButton" class="mobile-sub-button">Menu</button>
                <button id="mobileMapButton" class="mobile-sub-button">Map</button>
                <button id="mobileImportButton" class="mobile-sub-button">Import</button>
                <button id="mobileExportButton" class="mobile-sub-button">Export</button>
            </div>
        </div>
    </div>

        <div id="fullscreenMapOverlay">
            <button id="fullscreenMapCloseButton" class="mobile-close-button" style="display: block; z-index: 10;">X</button>
            <canvas id="fullscreenMapCanvas"></canvas>
        </div>

    </div>
	
	
    <div id="achievementToastContainer"></div>

    <!-- Game Menu Overlay -->
    <div id="gameMenuOverlay" oncontextmenu="return false;">
        <div id="gameMenu">
            <h2>Game Menu</h2>
            <div class="menu-item" style="margin-bottom: 15px;">
                <label for="seedInput" style="display: block; margin-bottom: 5px; color: #CCC; text-align: center;">World Seed (optional):</label>
                <input type="text" id="seedInput" placeholder="Leave empty for random seed">
            </div>
			<button class="mobile-close-button">X</button>
            <div class="menu-buttons">
                <button id="newGameButton">New Game</button>
                <button id="resumeButton">Resume Game</button>
				<button id="achievementsButton" style="background-color: #DAA520; color: white;">Achievements</button>
            </div>
            <label style="margin-top: 10px; display: flex; align-items: center; justify-content: center;">
                <input type="checkbox" id="maintainDurabilityCheckbox" style="margin-right: 8px;"> Maintain Block Durability
            </label>
			<label style="margin-top: 10px; display: flex; align-items: center; justify-content: center;">
				<input type="checkbox" id="animateDropsCheckbox" style="margin-right: 8px;"> Animate Item Drops
			</label>
            <label style="margin-top: 10px; display: flex; align-items: center; justify-content: center;">
				<input type="checkbox" id="autosaveCheckbox" style="margin-right: 8px;"> Autosave World
			</label>
			<div id="deathDisplay">Coords: (0, 0)</div>
            <div id="gameMenuTipText"></div>
        </div>
    </div>

    <!-- Inventory & Crafting Menu Overlay -->
    <div id="inventoryCraftingOverlay" oncontextmenu="return false;">
        <div id="inventoryCraftingMenu">
            <h2>Inventory & Crafting</h2>
            <div class="inventory-section">
				<h3>Crafting</h3>
                <div class="crafting-area">
                    <button class="mobile-close-button">X</button>
                    <div id="craftingGrid">
                        <!-- Crafting grid slots will be dynamically generated here -->
                    </div>
                    <div class="crafting-arrow">&#10144;</div>
                    <div class="inventory-slot" id="craftingOutput"></div>
                </div>
                 <button id="craftButton" disabled>Craft</button>
            </div>
            
            <div class="inventory-section">
                <h3>Your Inventory</h3>
                <div id="playerInventoryGrid" class="inventory-grid">
                    </div>
            </div>
            <div class="inventory-section">
                <h3>Hotbar Slots</h3>
                <div id="inventoryHotbarGrid" class="inventory-grid">
                    </div>
            </div>
			<div class="inventory-section" style="text-align: center;">
                <h3>Delete Item</h3>
                <div id="deleteSlot" class="inventory-slot" data-source-type="delete" data-slot-index="0">X</div>
            </div>
			<div class="inventory-section" id="armorSection">
                <h3 style="margin-bottom: 5px;">Armor</h3>
                <div style="display: flex; justify-content: space-around; align-items: center; gap: 20px;">
                    <div id="paperDoll" style="width: 50px; height: 150px; background-image: url('Player.png'); background-size: contain; background-repeat: no-repeat; background-position: center;  opacity: 0.5; position: relative;">
                        </div>
                    
                    <div id="armorGrid" style="display: grid; grid-template-columns: 50px; grid-template-rows: repeat(4, 50px); gap: 8px; justify-content: center;">
                        </div>
                    
                    <div id="armorStats" style="text-align: center; min-width: 100px;">
                        <h4>Total Protection</h4>
                        <div id="totalProtectionDisplay" style="font-size: 1.5em; color: #4CAF50; font-weight: bold;">0%</div>
                    </div>
                </div>
            </div>
            <div id="recipeMenu" class="inventory-section">
                <h3>Recipes</h3>
                
                <div class="recipe-controls">
                    <input type="text" id="recipeSearchInput" placeholder="Search recipes...">
                    <button id="recipeViewToggleList" class="recipe-view-toggle active">List</button>
                    <button id="recipeViewToggleIcons" class="recipe-view-toggle">Icons</button>
                </div>

                <div id="recipeIconContainer" style="display: none;">
                    </div>

                <div id="recipeListContainer" style="display: block;">
                    </div>
            </div>
        </div>
    </div>
	
	<div id="devConsoleOverlay">
		<button class="mobile-close-button">X</button>
		<div id="devConsole">
			<div id="consoleOutput"></div>
			<div id="consoleInputWrapper">
				<span>&gt;</span>
				<textarea id="consoleInput" rows="1" autocomplete="off" spellcheck="false"></textarea>
			</div>
		</div>
	</div>

    <!-- Chest Menu Overlay -->
    <div id="chestOverlay" oncontextmenu="return false;">
        <div id="chestMenu">
            <h2 id="chestTitle">Chest (Esc to Exit)</h2>
            <button class="mobile-close-button">X</button>
            <div class="inventory-section">
                 <input type="text" id="chestLabelInput" placeholder="Chest Label..." maxlength="30">
                <div id="chestGrid" class="inventory-grid">
                    <!-- Chest inventory slots will be dynamically generated here -->
                </div>
            </div>
			
			<button id="transferAllButton" style="width: 100%; padding: 8px; margin-bottom: 10px; font-size: 1em;">
                &darr; Transfer Most Items &darr;
            </button>
			
            <div class="inventory-section">
                <h3>Your Inventory</h3>
                <div id="chestPlayerInventoryGrid" class="inventory-grid">
                    <!-- Player's inventory will be shown here -->
                </div>
            </div>
        </div>
    </div>
	
	<div id="voidChestOverlay" oncontextmenu="return false;">
		<div id="voidChestMenu" class="inventory-section"> <h2 id="voidChestTitle">The Void (Esc to Exit), Don't Leave Items Floating...</h2>
			<div id="voidChestGrid" class="inventory-grid">
				</div>
			<div class="inventory-section">
                <button class="mobile-close-button">X</button>
				<h3>Your Inventory</h3>
				<div id="voidChestPlayerInventoryGrid" class="inventory-grid">
					</div>
			</div>
		</div>
    	</div> <div id="voidCharacterContainer">
        <img id="voidCharacter" src="Dark Armored Player.png" alt="Void Dealer">
        <div id="voidTradeOffer">
            <p id="voidDialogue">Care to make a deal for what's been lost?</p>
            <div id="voidOfferItem" class="inventory-slot"></div>
            <div id="voidOfferCost"></div>
            <div id="voidTradeButtons">
                <button id="voidAcceptButton">Accept</button>
                <button id="voidDeclineButton">Decline</button>
            </div>
        </div>
    </div>
	
	<div id="traderCharacterContainer" oncontextmenu="return false;" style="display:none; position:absolute; bottom:20px; left:20px; z-index:1001; align-items:flex-end; gap:15px;">
	  <img id="traderCharacter" src="Trader.png" alt="Trader" style="width:80px; image-rendering:pixelated;">
	  <div id="traderTradeOffer" class="inventory-section" style="background-color:rgba(10,10,30,0.9); border-radius:10px; padding:10px; width:260px;">
		<p id="traderDialogue" style="font-style:italic; text-align:center; margin:0 0 8px 0;">Got goods if you've got coin.</p>
		<div id="traderOfferList"></div>
		<div id="traderOfferCost" style="margin-top:8px;"></div>
		<div id="traderTradeButtons" style="display:flex; justify-content:center; gap:8px; margin-top:8px;">
		  <button id="traderAcceptButton">Accept</button>
		  <button id="traderDeclineButton">Close</button>
            </div>
          </div>
		</div>
	  </div>
	</div>
	
	<div id="anvilOverlay" oncontextmenu="return false;">
        <div id="anvilMenu">
            <h2>Anvil</h2>
            <div class="inventory-section">
				<h3>Anvil Crafting</h3>
                <div class="crafting-area">
                    <button class="mobile-close-button">X</button>
                    <div id="anvilGrid" class="inventory-grid" style="grid-template-columns: repeat(4, 45px); grid-template-rows: repeat(4, 45px);">
                    </div>
                    <div class="crafting-arrow">&#10144;</div>
                    <div class="inventory-slot" id="anvilOutput"></div>
                </div>
                 <button id="anvilCraftButton" disabled>Craft</button>
            </div>
            
            <div class="inventory-section">
                <h3>Your Inventory</h3>
                <div id="anvilPlayerInventoryGrid" class="inventory-grid">
                </div>
            </div>
            <div class="inventory-section">
                <h3>Hotbar Slots</h3>
                <div id="anvilHotbarGrid" class="inventory-grid">
                </div>
            </div>
            <div id="anvilRecipeMenu" class="inventory-section">
                <h3>Recipes</h3>
                
                <div class="recipe-controls">
                    <input type="text" id="anvilRecipeSearchInput" placeholder="Search recipes...">
                    <button id="anvilRecipeViewToggleList" class="recipe-view-toggle active">List</button>
                    <button id="anvilRecipeViewToggleIcons" class="recipe-view-toggle">Icons</button>
                </div>

                <div id="anvilRecipeIconContainer" style="display: none;">
                </div>

                <div id="anvilRecipeListContainer" style="display: block;">
                </div>
            </div>
        </div>
    </div>
	<div id="worldMoverConfigOverlay" oncontextmenu="return false;">
        <div id="worldMoverConfigMenu">
            <h2>World Mover Configuration</h2>
            <button class="mobile-close-button">X</button>
            <div class="config-section">
                <label for="worldMoverCodeInput">3-Digit Code:</label>
                <input type="text" id="worldMoverCodeInput" placeholder="e.g., 123" maxlength="3">
            </div>
            <div class="config-section">
                <h3>Fuel (Pure Energy)</h3>
                <p style="font-size: 0.8em; color: #ccc;">Requires 20 Pure Fuel per use.</p>
                <div id="worldMoverFuelSlot" class="inventory-slot">
                    </div>
            </div>
            <button id="saveWorldMoverButton">Save & Close</button>
        </div>
    </div>

    <div id="worldMoverTeleportOverlay" oncontextmenu="return false;">
        <div id="worldMoverTeleportMenu">
            <h2>Teleport Network</h2>
            <button class="mobile-close-button">X</button>
            <label for="teleportCodeInput">Enter 3-Digit Code:</label>
            <input type="text" id="teleportCodeInput" placeholder="e.g., 123" maxlength="3">
            <p style="font-size: 0.8em; color: #ccc;">Press 'Enter' to teleport.</p>
        </div>
    </div>
	
	<div id="ovenOverlay" oncontextmenu="return false;">
        <div id="ovenMenu">
            <h2>Oven</h2>
            <button class="mobile-close-button">X</button>
            <div class="oven-ui-area">
                <div class="inventory-section">
                    <h3>Input</h3>
                    <div id="ovenGrid" class="inventory-grid">
                        </div>
                </div>

                <div class="oven-fuel-section">
                    <h3>Fuel</h3>
                    <div id="ovenFuelSlot" class="inventory-slot">
                        </div>
                </div>

                <div class="crafting-arrow" style="font-size: 2em;">&#10144;</div>

                <div class="inventory-section">
                    <div style="display: flex; justify-content: space-around; text-align: center;">
                        <div>
                            <h3>Output</h3>
                            <div id="ovenOutputSlot" class="inventory-slot">
                                </div>
                        </div>
                        <div>
                            <h3>Byproduct</h3>
                            <div id="ovenByproductSlot" class="inventory-slot">
                                </div>
                        </div>
                    </div>
                </div>
            </div>
            <button id="cookButton" disabled>Cook</button>
            <div class="inventory-section">
                <h3>Your Inventory</h3>
                <div id="ovenPlayerInventoryGrid" class="inventory-grid">
                    </div>
            </div>
            <div class="inventory-section" id="ovenRecipeMenu">
                <h3>Recipes</h3>

                <div class="recipe-controls">
                    <input type="text" id="ovenRecipeSearchInput" placeholder="Search recipes...">
                    <button id="ovenRecipeViewToggleList" class="recipe-view-toggle active">List</button>
                    <button id="ovenRecipeViewToggleIcons" class="recipe-view-toggle">Icons</button>
                </div>

                <div id="ovenRecipeIconContainer" style="display: none;">
                    </div>

                <div id="ovenRecipeListContainer" style="display: block;">
                    </div>
            </div>
        </div>
    </div>
	
	<div id="bookMenuOverlay" oncontextmenu="return false;">
        <div id="bookEditor">
            <h2>Edit Book</h2>
            <button class="mobile-close-button">X</button>
            <textarea id="bookContentInput" maxlength="1000000" placeholder="Write your story..."></textarea>
            <div class="book-buttons">
                <button id="bookSaveButton">Save & Close</button>
                <button id="bookPublishButton">Publish...</button>
                <button id="bookExportButton">Export (.txt)</button>
                <label for="bookImportInput" id="bookImportLabel">Import (.txt)</label>
                <input type="file" id="bookImportInput" accept=".txt">
            </div>
        </div>
    </div>

    <div id="publishMenuOverlay" oncontextmenu="return false;">
        <div id="publishMenu">
            <h2>Publish Book</h2>
            <button class="mobile-close-button">X</button>
            <label for="bookTitleInput">Book Title:</label>
            <input type="text" id="bookTitleInput" placeholder="Enter a title...">
            
            <label for="bookCoverInput" id="bookCoverLabel">Upload Cover (Optional, <5MB)</label>
            <input type="file" id="bookCoverInput" accept="image/png, image/jpeg, image/jpg">
            
            <img id="coverPreview" src="" alt="Cover preview">
            
            <div class="book-buttons">
                <button id="bookFinalizeButton">Finalize & Publish</button>
                <button id="bookCancelPublishButton">Cancel</button>
            </div>
        </div>
    </div>

    <div id="bookReaderOverlay" oncontextmenu="return false;">
        <div id="bookReaderMenu">
            <h2 id="bookReaderTitle">Book</h2>
            <button class="mobile-close-button">X</button>
            <img id="bookReaderCover" src="" alt="Book Cover">
            <div id="bookReaderContent">
                </div>
        </div>
    </div>
	
	<input type="file" id="skinUploadInput" accept="image/png, image/jpeg, image/jpg" style="display: none;">

    <div id="skinUploadOverlay" oncontextmenu="return false;">
        <div id="skinUploadMenu">
            <h2>Upload Custom Skin</h2>
            <button class="mobile-close-button">X</button>
            <p style="font-size: 0.9em; color: #ccc;">Image must have a 1:3 aspect ratio (e.g., 50px wide, 150px tall).</p>
            <label for="skinUploadInput" id="skinUploadLabel">Choose Image...</label>
            <button id="skinResetButton">Reset to Default</button>
            <button id="skinUploadCancelButton">Cancel</button>
        </div>
    </div>
	
	<div id="xpMenuOverlay" oncontextmenu="return false;">
		<div id="xpMenu">
			<h2>Achievements & Progression</h2>
			<button class="mobile-close-button">X</button>

			<div id="xpHeader">
				<span>Total XP:</span>
				<span id="xpTotalDisplay">0 XP</span>
			</div>

			<div id="achievementGrid">
				</div>
		</div>
	</div>
	
    <!-- Custom Message Box Overlay -->
    <div id="customMessageBoxOverlay" oncontextmenu="return false;">
        <div id="customMessageBox">
            <p id="messageBoxText"></p>
            <div id="messageBoxButtons">
                <!-- Buttons will be dynamically added here -->
            </div>
        </div>
    </div>
	<!-- Item Name Tooltip -->
<div id="itemTooltip"></div>
    <script>
		// Created By Bryant Reitzel 
		// Ideas And Mechanics All From The Mind Of Bryant Reitzel
		const itemTooltip = document.getElementById('itemTooltip');
        const loadingTipText = document.getElementById('loadingTipText');
		
		let showBlockOutline = false; // Toggle block outline on/off
		
		let hotbarTooltipTimer = null;
        function showHotbarSwitchTooltip(itemObject) {
            if (hotbarTooltipTimer) {
                clearTimeout(hotbarTooltipTimer); // Clear any old timer
            }
            if (!itemObject) {
                itemTooltip.style.display = 'none'; // Hide if slot is empty
                return;
            }

            // Get item name (like in createInventorySlot)
            const itemProps = itemTypes[itemObject.type] || blockTypes[itemObject.type];
            let itemName;
            if (itemProps && itemProps.isBook) {
                itemName = itemObject.published && itemObject.title ? itemObject.title : "Book (Editable)";
            } else {
                itemName = (itemObject.type.replace(/_/g, ' ')).replace(/\b\w/g, l => l.toUpperCase());
                if (itemProps && itemProps.isTool && itemObject.durability !== undefined) {
                    itemName += ` (${Math.ceil(itemObject.durability)} / ${itemObject.maxDurability})`;
                }
            }

            // Position and show the tooltip
            itemTooltip.textContent = itemName;
            itemTooltip.style.bottom = '70px'; // Position just above the hotbar
            itemTooltip.style.left = '50%';
            itemTooltip.style.transform = 'translateX(-50%)';
            itemTooltip.style.top = 'auto'; // Override mouse-following style
            itemTooltip.style.display = 'block';

            // Set a timer to hide it
            hotbarTooltipTimer = setTimeout(() => {
                itemTooltip.style.display = 'none';
                // Reset styles for normal mouse-following
                itemTooltip.style.bottom = 'auto';
                itemTooltip.style.left = '0px';
                itemTooltip.style.transform = 'none';
                hotbarTooltipTimer = null;
            }, 1000); // Show for 1 second
        }

		let cheatItems = false

        let textureOverrides = {}; // Stores filename -> Blob URL mappings
        let isLoadingAssets = true; // Flags if we are on the loading screen
        let currentLoadID = null; // Tracks the active loading process

        const loadingTips = [
            "Don't Eat Any Food When You Are At Full Health, You Dum Dum!!!",
            "Having A Bed Is Almost Like A Hack! You Can Press The ';' Key And You Will Teleport To Your Bed But At The Cost Of A Little Health. Farm Cotton First Though!",
            "When You Use Tools To Make New Tools, The Durability Resets. If You Ever Get A Steel Pickaxe, For Example, Save It At A Very Low Durability To Use It Later To Craft A Better Tool!",
            "Before You Go Underground, Stock Up On A High Supply Of Wood Planks And Sticks. If Possible, Craft A Rock Pickaxe Due To Their Superiority Over Wood. There's No Such Thing As Too Many Rock Pickaxes.",
            "Craft A Refrigerator For Any Crops Or Meat You Collect, And Store Them Carefully. They Will Otherwise Spoil In Your Inventory! Spoilables Are Often Quite Useful.",
            "Coal Is Most Common In The Stone Layer, So It Is Wise To Stock Up On Coal Before Entering The Underground Depths, Even Though Coal Thrives There Too!",
            "Press The '[' Button To Load Your World And The ']' Button To Save Your World. This Exports Your World As A .bgu1 (Block Game Ultimate) File You Can Use To Load Up Later!",
            "Press The '{' Button To Load Your World With Reduced File Size And The '}' Button To Save Your World With Reduced File Size (Up To 10x Smaller!). This Exports Your World As A .bgu2 (Block Game Ultimate) File You Can Use To Load Up Later!",
            "If You Get A Power Orb, Don't Waste It! Make A Powered Tool, Which NEVER BREAKS! Or Make Power Soup To PERMANENTLY Increase Health And Fully Heal.",
            "Pickaxes Are Best Used On Hard Blocks Like Stone, Otherwise Their Mining Power Makes No Difference And You Should Find Another Tool!",
            "Axes Are Best Used On Wood Blocks And Cactuses, Otherwise They Are Practically Useless And You Should Find A Better Tool Or Use Your Hands!",
            "Shovels Are Best Used On Softer Blocks Like Dirt And Sand, So Don't Waste Your Shovel Trying To Break Hard Stuff And Find A Better Tool!",
            "To Optimize Your Game's Loading Speeds, Use '?' Button To Set The Particle Count And Reduce The Lag!",
            "Do You Have Any World Movers Placed? Use The ':' Button To Teleport To Any Of Them, But Make Sure They Have Codes And Are All Loaded With Fuel!",
			"Go Play Terraria. Go Play Minecraft. Just Don't Try To Convince Me Any Of These Games Are The Same...",
			"Use A Void Chest To Look Into The Void... That's What Happens When An Item Has No Where To Go. Deletion!",
			"Brick Blocks Look Nice.",
			// Bonus Tips
			"The world is divided into extreme-hardness layers. The Compressed Stone Layer (around depth 1,000) features blocks with a hardness of 10,000, while the Core Molten Stone layer reaches 250,000 hardness.",
			"Prioritize mining Compacted Stone (hardness 1,000) once you can break it easily, as this layer is the primary source of valuable gem veins like Ruby, Sapphire, Diamond, and Emerald.",
			"Build paths from Asphalt Blocks to increase your walking speed by 50% (1.5x) when on the ground. Use them for quick travel around your base or mining routes.",
			"Do not stand on Magma Stone Blocks. They apply a rapid 50 health damage per second to the player, making them extremely dangerous even in short bursts.",
			"If you get caught in a Cobweb block, your movement speed, jump strength, and gravity are all reduced by 80% or more, effectively halting all movement. Use a tool to quickly cut yourself free.",
			// Vital Tip
			"This Game And Mechanics Were Made By BPR! Also, THIS GAME IS NOT JUST '2D MINECRAFT,' So Don't Call It That!"
        ];
        // Near the top of your script, with other variable declarations
        let currentTipIndex = 0;
        let tipIntervalId = null; // This will hold the ID of our timer
		console.log('This is the monitor and cheat console! Try using this command: addToInventory("sky", 120)');
		const playerImg = new Image();
		playerImg.src = 'Player.png'; //Non constant to enable console cheats
		const originalPlayerImgSrc = 'Player.png';
		const targetSkinSequence = "SKIN!";
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let inventorySize = 40 //Non constant to enable console cheats
		const hotbarSize = 10;
        let totalInventorySlots = hotbarSize + (inventorySize); // 10 + 40 = 50 slots
        let chestInventorySize = 27; // 2.7 rows of 10
        let maxStackSize = 120; // Max stack size for non-tool items, non constant to enable console cheats
		let handMiningPower = 0.1 //Non constant to enable console cheats
		let cloakingEnabled = true //Non constant to enable console cheats
		let displayType = 'stone';
		// START ACHIEVEMENT VARIABLES
        let deathCount = 0;
        let insomnia = 0;
        let guanoMined = 0;
        // END ACHIEVEMENT VARIABLES
		const foliageTypes = ['grass', 'tall_grass', 'grass_sprouts', 'wheat', 'snow', 'large_snow_pile', 'desert_brush', 'desert_grass', 'prickly_pear_cactus', 'tomato_bush', 'pumpkin', 'anthill_sand_mound', 'guano', 'moss', 'dark_moss', 'weed', 'shroom', 'cotton', 'rice', 'hop', 'coffee', 'oat', 'corn', 'barley', 'pinecone_pile', 'pine_needle_pile', 'leaf_pile', 'mossy_root', 'fern', 'leaf_plant', 'blue_flower', 'yellow_flower', 'red_flower', 'orange_flower', 'green_flower', 'purple_flower', 'onion', 'garlic', 'chili_pepper_bush', 'potato_stem', 'fern_stalk', 'sugarcane', 'sunflower_stem', 'sunflower_top', 'milkweed', 'pine_needle_pile'];
		const replaceableBlocks = ['', 'grass', 'tall_grass', 'grass_sprouts', 'wheat', 'snow', 'large_snow_pile', 'desert_brush', 'desert_grass', 'prickly_pear_cactus', 'tomato_bush', 'pumpkin', 'anthill_sand_mound', 'moss', 'dark_moss', 'weed', 'shroom', 'cotton', 'rice', 'hop', 'coffee', 'oat', 'corn', 'barley', 'pine_needle_pile', 'pinecone_pile', 'leaf_pile', 'leaf_plant', 'blue_flower', 'yellow_flower', 'red_flower', 'orange_flower', 'green_flower', 'purple_flower', 'onion', 'garlic', 'chili_pepper_bush', 'potato_stem', 'milkweed'];
		
		const SUPER_HEAVEN_Y_OFFSET = -100000; // Y-coords below this are Super Heaven
		let portals = []; // Will store all portal locations and links
		
		let gameTime = 0; // Tracks total elapsed time
		const DAY_CYCLE_DURATION = 600000; // 10 minutes in milliseconds for a full day-night cycle
		let plantSpoilageAccumulator = 0;
		const PLANT_SPOILAGE_INTERVAL = 1000; // ms (once per second)

        const hotbarDiv = document.getElementById('hotbar');
        const loadingScreen = document.getElementById('loadingScreen');
        const coordsDisplay = document.getElementById('coordsDisplay');
		const deathDisplay = document.getElementById('deathDisplay');
        const healthBarDiv = document.getElementById('healthBar');
        
		const moonColumns = new Set(); // Tracks vertical chunks checked for moon spawns
        const moonRegions = []; // Stores bounding boxes of generated moons to prevent overlap
        const moonProbability = 0.03; // 3% chance to attempt spawning a moon per vertical chunk
		
        // Game Menu
        const gameMenuOverlay = document.getElementById('gameMenuOverlay');
        const gameMenu = document.getElementById('gameMenu');
        const seedInput = document.getElementById('seedInput');
        const newGameButton = document.getElementById('newGameButton');
        const resumeButton = document.getElementById('resumeButton');
        const maintainDurabilityCheckbox = document.getElementById('maintainDurabilityCheckbox');
        const autosaveCheckbox = document.getElementById('autosaveCheckbox');

        // Inventory/Crafting Menu
        const inventoryCraftingOverlay = document.getElementById('inventoryCraftingOverlay');
        const playerInventoryGrid = document.getElementById('playerInventoryGrid');
        const inventoryHotbarGrid = document.getElementById('inventoryHotbarGrid');
        const craftingGridDiv = document.getElementById('craftingGrid'); // Reference to the 4x4 crafting grid container
        const craftingOutputSlot = document.getElementById('craftingOutput');
        const craftButton = document.getElementById('craftButton');
        const recipeListDiv = document.getElementById('recipeList'); // New: Recipe list container
        const deleteSlot = document.getElementById('deleteSlot');
		
		deleteSlot.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            e.preventDefault();
            handleSlotClick(e);
        });
		
		// Oven Menu
        const ovenOverlay = document.getElementById('ovenOverlay');
        const ovenGrid = document.getElementById('ovenGrid');
        const ovenFuelSlot = document.getElementById('ovenFuelSlot');
        const ovenOutputSlot = document.getElementById('ovenOutputSlot');
        const cookButton = document.getElementById('cookButton');
        const ovenPlayerInventoryGrid = document.getElementById('ovenPlayerInventoryGrid');
        const ovenRecipeList = document.getElementById('ovenRecipeList');
        let currentlyOpenFurnace = null; // Will store {col, row} of the open oven
		
		const anvilOverlay = document.getElementById('anvilOverlay');
        const anvilGridDiv = document.getElementById('anvilGrid');
        const anvilOutputSlot = document.getElementById('anvilOutput');
        const anvilCraftButton = document.getElementById('anvilCraftButton');
        const anvilPlayerInventoryGrid = document.getElementById('anvilPlayerInventoryGrid');
        const anvilHotbarGrid = document.getElementById('anvilHotbarGrid');
        let anvilGridSlots = new Array(16).fill(null);
        let currentlyOpenAnvil = null;
		
		const worldMoverConfigOverlay = document.getElementById('worldMoverConfigOverlay');
        const worldMoverCodeInput = document.getElementById('worldMoverCodeInput');
        const worldMoverFuelSlot = document.getElementById('worldMoverFuelSlot');
        const saveWorldMoverButton = document.getElementById('saveWorldMoverButton');
        let currentlyOpenWorldMover = null; // Stores {col, row} of the mover being configured

        const worldMoverTeleportOverlay = document.getElementById('worldMoverTeleportOverlay');
        const teleportCodeInput = document.getElementById('teleportCodeInput');
        let isTeleportMenuOpen = false;
		
		let voidStorage = []; // This will hold all items sent to the void
		const voidChestOverlay = document.getElementById('voidChestOverlay');
		const voidChestGrid = document.getElementById('voidChestGrid');
		const voidChestPlayerInventoryGrid = document.getElementById('voidChestPlayerInventoryGrid');
		let isVoidChestOpen = false;
		
		let currentVoidTrade = null; // To store the active trade offer
		let voidCharacterBob = 0; // For animation
		let voidCharacterBobDirection = 1;
		
		let hellfireOn = true;
		let hellfireLevel = 1.0; // 1.0 = saturated, 0.0 = desaturated
		const HELLFIRE_DURATION_MS = 120000; // 120 seconds
		let isPlayerInHellfireZone = false;
		let isPlayerOnHellfire = false; // The permanent fire state
		
		let showDebugStats = false;
		const debugStatsDiv = document.getElementById('debugStats');
		let frameCount = 0;
		let lastFpsUpdate = 0;
		let currentFps = 0;
	
        let isCreativeMode = 0;
        const CREATIVE_FLIGHT_SPEED = 5; // How fast the player flies in creative mode (adjust as needed)

        let showMinimap = false;
        let exploredMap = {}; // This will cache explored pixels
        let mmCanvas = null; // Cache canvas element
        let mmCtx = null; // Cache canvas context
		
		let isFullscreenMapOpen = false;
        const fullscreenMapOverlay = document.getElementById('fullscreenMapOverlay');
        const fsMapCanvas = document.getElementById('fullscreenMapCanvas');
        const fsMapCtx = fsMapCanvas.getContext('2d');
        const fullscreenMapDrag = {
            active: false,
            lastX: 0,
            lastY: 0,
            mapCol: 0, // Center of the map view in grid coords
            mapRow: 0,
            zoom: 2, // 2x zoom
        };
		
		const bullets = [];
        let gunCooldown = 0;
        let BULLET_SPEED = 20; // Speed of the bullet (pixels per frame)
        let BULLET_SIZE = 10;   // Size of the bullet (pixels)
		let lastAmmoTypeFired = null;
		
		const traderCharacterContainer = document.getElementById('traderCharacterContainer');
		
        // Chest Menu
        const chestOverlay = document.getElementById('chestOverlay');
        const chestGrid = document.getElementById('chestGrid');
        const chestPlayerInventoryGrid = document.getElementById('chestPlayerInventoryGrid');
        const chestTitle = document.getElementById('chestTitle');
        const chestLabelInput = document.getElementById('chestLabelInput');
        let currentlyOpenChest = null; // Will store {col, row} of the open chest
		
		const particles = [];
		const activePlants = new Set();
		const activeSpoilage = new Set();
        const particleGravity = 0.3;
		
		// World border
		let worldLimitEnabled = false; // Set to true to enable limits
		let worldMinX = -5000;
		let worldMaxX = 5000;
		let worldMinY = -1000; // Remember Y is negative going up
		let worldMaxY = 1500;
		
		seedInput.onkeydown = (e) => e.stopPropagation();
		chestLabelInput.onkeydown = (e) => e.stopPropagation();
		worldMoverCodeInput.onkeydown = (e) => e.stopPropagation();
		
		const heldItemState = {
            angle: 0,          // Current rotation in radians
            offsetX: 0,        // Horizontal offset from the player's hand
            offsetY: 0,        // Vertical offset
            bobTimer: 0,       // Timer for the walking bob animation
            swingTimer: 0,     // Timer for the swinging animation
            isSwinging: false, // Is the swing animation active?
            lastSwingTime: 0,   // To make the swing animation snappy
			gunAngle: 0 // FIRE!!! PEW PEW PEW, KABLOOM!!!
        };

        // Custom Message Box elements
        const customMessageBoxOverlay = document.getElementById('customMessageBoxOverlay');
        const messageBoxText = document.getElementById('messageBoxText');
        const messageBoxButtons = document.getElementById('messageBoxButtons');
		
		// Book UI elements
        const bookMenuOverlay = document.getElementById('bookMenuOverlay');
        const bookContentInput = document.getElementById('bookContentInput');
        const bookSaveButton = document.getElementById('bookSaveButton');
        const bookPublishButton = document.getElementById('bookPublishButton');
        const bookExportButton = document.getElementById('bookExportButton');
        const bookImportInput = document.getElementById('bookImportInput');

        const publishMenuOverlay = document.getElementById('publishMenuOverlay');
        const bookTitleInput = document.getElementById('bookTitleInput');
        const bookCoverInput = document.getElementById('bookCoverInput');
        const bookCoverLabel = document.getElementById('bookCoverLabel');
        const coverPreview = document.getElementById('coverPreview');
        const bookFinalizeButton = document.getElementById('bookFinalizeButton');
        const bookCancelPublishButton = document.getElementById('bookCancelPublishButton');

        const bookReaderOverlay = document.getElementById('bookReaderOverlay');
        const bookReaderTitle = document.getElementById('bookReaderTitle');
        const bookReaderCover = document.getElementById('bookReaderCover');
        const bookReaderContent = document.getElementById('bookReaderContent');

        let currentlyEditingBook = { slotIndex: -1, inventory: null };
		
		// Skin UI elements
        const skinUploadOverlay = document.getElementById('skinUploadOverlay');
        const skinUploadInput = document.getElementById('skinUploadInput');
        const skinUploadLabel = document.getElementById('skinUploadLabel');
        const skinResetButton = document.getElementById('skinResetButton');
        const skinUploadCancelButton = document.getElementById('skinUploadCancelButton');
		
		// --- Achievement & XP System ---
		let playerXP = 0;
		let earnedAchievements = []; // This will be an array of achievement IDs

		const achievements = {
			'DEATH_CATALYST': {
				id: 'DEATH_CATALYST',
				name: 'Death Catalyst',
				desc: 'Reach the underworld and face the hellfire.',
				icon: 'Hellstone Block.png',
				xp: 10
			},
			'SKY_CHASER': {
				id: 'SKY_CHASER',
				name: 'Sky Chaser',
				desc: 'Reach heaven and the clouds above.',
				icon: 'Cloud Block.png',
				xp: 10
			},
			'TIMBER': {
				id: 'TIMBER',
				name: 'TIMBER!',
				desc: 'Use an axe to hover over an axe-suited block.',
				icon: 'Wooden Axe.png',
				xp: 5
			},
			'POOP_SCOOP': {
				id: 'POOP_SCOOP',
				name: 'Poop Scoop!',
				desc: 'Use a shovel to hover over a shovel-suited block.',
				icon: 'Wooden Shovel.png',
				xp: 5
			},
			'TERRAFORMER': {
				id: 'TERRAFORMER',
				name: 'Terraformer!',
				desc: 'Use a pickaxe to hover over a pickaxe-suited block.',
				icon: 'Wooden Pickaxe.png',
				xp: 5
			},
			'PEW_PEW': {
				id: 'PEW_PEW',
				name: 'PEW PEW PEW!',
				desc: 'Use a gun to hit any block.',
				icon: 'Machine Gun.png',
				xp: 5
			},
			'DEDICATED_ONE': {
				id: 'DEDICATED_ONE',
				name: 'Dedicated One',
				desc: 'Waste your steel to make a steel brick block.',
				icon: 'Steel Brick Block.png',
				xp: 5
			},
			'FRANTIC_FARMER': {
				id: 'FRANTIC_FARMER',
				name: 'Frantic Farmer',
				desc: 'Plant any seed inside of fertilizer.',
				icon: 'Fertilizer Block.png',
				xp: 5
			},
			'REALM_NOTHINGNESS': {
				id: 'REALM_NOTHINGNESS',
				name: 'Realm of Nothingness',
				desc: 'Mine void crystal in the void.',
				icon: 'Void Crystal Block.png',
				xp: 10
			},
			'TRAGIC_BARGAIN': {
				id: 'TRAGIC_BARGAIN',
				name: 'Tragic Bargain',
				desc: 'Trade with the void trader.',
				icon: 'Void Chest.png',
				xp: 5
			},
			'BARTERIN_TIME': {
				id: 'BARTERIN_TIME',
				name: "Barterin' Time",
				desc: 'Trade with a trader.',
				icon: 'Gold Coin.png',
				xp: 5
			},
			'IT_BURNS': {
				id: 'IT_BURNS',
				name: 'It Burns!',
				desc: 'Eat a spicy Chili Pepper.',
				icon: 'Chili Pepper.png',
				xp: 5
			},
            'HELLFIRE_FORGED': {
                id: 'HELLFIRE_FORGED',
                name: 'Hellfire Forged',
                desc: 'Craft a tool from Hellsteel.',
                icon: 'Hellsteel Pickaxe.png',
                xp: 10
            },
            'HEAVEN_SENT': {
                id: 'HEAVEN_SENT',
                name: 'Heaven Sent',
                desc: 'Craft a tool from Heavensteel.',
                icon: 'Heavensteel Pickaxe.png',
                xp: 10
            },
            'MYTHICAL_MINER': {
                id: 'MYTHICAL_MINER',
                name: 'Mythical Miner',
                desc: 'Craft a tool from Mythicalithium.',
                icon: 'Mythicalithium Pickaxe.png',
                xp: 15
            },
            'SPELUNKER': {
                id: 'SPELUNKER',
                name: 'Spelunker',
                desc: 'Collect 25 Guano from caves underground.',
                icon: 'Guano.png',
                xp: 10
            },
            'ALCHEMIST': {
                id: 'ALCHEMIST',
                name: 'Alchemist',
                desc: 'Craft a Power Orb.',
                icon: 'Power Orb.png',
                xp: 10
            },
            'MAD_SCIENTIST': {
                id: 'MAD_SCIENTIST',
                name: 'Mad Scientist',
                desc: 'Craft an Impotent Orb.',
                icon: 'Impotent Orb.png',
                xp: 10
            },
            'ROCK_BOTTOM': {
				id: 'ROCK_BOTTOM',
				name: 'Rock Bottom',
				desc: 'Drink a nice, refreshing glass of your own pee.', // It's sterile and I like the taste
				icon: 'Cup Of Urine.png',
				xp: 5
			},
            'IS_THIS_ME': {
                id: 'IS_THIS_ME',
                name: 'Is This Me!?',
                desc: 'Gag and take a slimy bite of raw human flesh.',
                icon: 'Human Flesh.png',
                xp: 5
            },
            'HOME_SWEET_HOME': {
                id: 'HOME_SWEET_HOME',
                name: 'Home Sweet Home',
                desc: 'Place a bed.',
                icon: 'Bed.png',
                xp: 5
            },
            'KABOOM': {
                id: 'KABOOM',
                name: 'KABOOM!',
                desc: 'Detonate a Nuclear Bomb.',
                icon: 'Nuclear Bomb.png',
                xp: 10
            },
            'GLOBETROTTER': {
                id: 'GLOBETROTTER',
                name: 'Globetrotter',
                desc: 'Use a World Mover to teleport.',
                icon: 'World Mover.png',
                xp: 10
            },
            'BOOKWORM': {
                id: 'BOOKWORM',
                name: 'Bookworm',
                desc: 'Write and publish a book.',
                icon: 'Book.png',
                xp: 5
            },
            'CHEERS': {
                id: 'CHEERS',
                name: 'Cheers!',
                desc: 'Drink a Cup of Beer.',
                icon: 'Cup Of Beer.png',
                xp: 5
            },
            'INSOMNIAC': {
                id: 'INSOMNIAC',
                name: 'Insomniac',
                desc: 'Drink 10 Cups of Coffee.',
                icon: 'Cup Of Coffee.png',
                xp: 5
            },
            'COOL_IT': {
                id: 'COOL_IT',
                name: 'Cool It On The Drinks',
                desc: 'Get your Blood Alcohol level over 100.',
                icon: 'Drunk Mask Icon.png',
                xp: 10
            },
            'PERSISTENT': {
                id: 'PERSISTENT',
                name: 'Persistent',
                desc: 'Die 100 times. Ouch.',
                icon: 'Dead Body Chest.png',
                xp: 5
            }
		};

		const xpMenuOverlay = document.getElementById('xpMenuOverlay');
		const achievementsButton = document.getElementById('achievementsButton');
		
        let heldItem = null; // Stores the item object being dragged by the cursor {type, count, durability}
		
		
		// --- IN-GAME DEV CONSOLE CODE START ---

		// Get references to the console elements
		const devConsoleOverlay = document.getElementById('devConsoleOverlay');
		const consoleOutput = document.getElementById('consoleOutput');
		const consoleInput = document.getElementById('consoleInput');
		let isConsoleOpen = false;
		let commandHistory = [];
		let historyIndex = -1;
		const consoleAutocompleteSuggestions = [
			'addToInventory("",1)', 'player', 'tp(', 'killMyself()', 'npcs', 'particles', 'animatedDrops', 'gameTime', 'isGamePaused', 'inventorySize', 'maxStackSize', 'handMiningPower', 'playerHeight', 'playerWidth', 'maxSurfaceVariation', 'exportWorldData()', 'importWorldData(', 'showMessageBox(', 'toggleDevConsole()', 'worldBlocks', 'itemTypes', 'blockTypes', 'player.health', 'player.speed', 'player.jumpStrength', 'player.gravity', 'getOp("")', 'showBlockOutline = true',
		];
		
		function getOp(opMax) {
			player.health = 1000000;
			handMiningPower = 1000000;
			if (opMax === 'hell') {
				tp(0,-300)
			} else if (opMax === 'heaven') {
				tp(0,150)
			} else if (opMax === 'dungeon') {
				dungeonProbability = 0.005
			} else if (opMax === 'watchtower') {
				watchtowerProbability = 0.01
			}
		}
		
		function getConcrete() {
			addToInventory('concrete',120);
			addToInventory('light_concrete',120);
			addToInventory('dark_concrete',120);
			addToInventory('blue_concrete',120);
			addToInventory('blue_dark_concrete',120);
			addToInventory('blue_light_concrete',120);
			addToInventory('purple_concrete',120);
			addToInventory('purple_dark_concrete',120);
			addToInventory('purple_light_concrete',120);
			addToInventory('pink_concrete',120);
			addToInventory('pink_dark_concrete',120);
			addToInventory('pink_light_concrete',120);
			addToInventory('red_concrete',120);
			addToInventory('red_dark_concrete',120);
			addToInventory('red_light_concrete',120);
			addToInventory('orange_concrete',120);
			addToInventory('orange_dark_concrete',120);
			addToInventory('orange_light_concrete',120);
			addToInventory('yellow_concrete',120);
			addToInventory('yellow_dark_concrete',120);
			addToInventory('yellow_light_concrete',120);
			addToInventory('green_concrete',120);
			addToInventory('green_dark_concrete',120);
			addToInventory('green_light_concrete',120);
			addToInventory('cyan_concrete',120);
			addToInventory('cyan_dark_concrete',120);
			addToInventory('cyan_light_concrete',120);
		}
		
		function clearInventory() {
			inventorySlots.fill(null); 
            hotbarIndices.fill(null); 
            selectedHotbarSlot = 0;
            craftingGridSlots.fill(null); 
            heldItem = null; 
            heldItemSource = { type: null, index: -1 };
		}

        /**
         * A hack function to find the nearest instance of a block to the player.
         * @param {string} findType - The block type to search for (e.g., 'diamond_compacted_stone').
         */
        function find(findType) {
            let minDistSq = Infinity;
            let nearestKey = null;
            
            // Get player's current grid position
            const pCol = Math.floor(player.x / tileSize);
            const pRow = Math.floor(player.y / tileSize);

            // Iterate through all loaded blocks
            for (const key in worldBlocks) {
                const block = worldBlocks[key];
                
                // Check if it's the block we want
                if (block && block.type === findType) {
                    const [bCol, bRow] = key.split(',').map(Number);
                    
                    // Use squared distance to avoid slow Math.sqrt()
                    const distSq = (pCol - bCol)**2 + (pRow - bRow)**2;
                    
                    if (distSq < minDistSq) {
                        minDistSq = distSq;
                        nearestKey = key;
                    }
                }
            }

            let message;
            if (nearestKey === null) {
                message = `NONE FOUND for type '${findType}'.`;
            } else {
                // Get coords from the nearest key found
                const [bCol, bRow] = nearestKey.split(',').map(Number);
                message = `LOCATED NEAREST '${findType}' AT (${bCol}, ${bRow}).`;
            }
            
            logToConsole(message, 'log-output'); // Log to in-game console
            return message; // Return the message for the JS console
        }

        /**
         * A hack function to find and replace blocks in the world.
         * Can replace 'all' blocks or a specific 'findType'.
         * Includes exceptions and a safe zone around the player.
         * @param {string} findType - The block type to search for (e.g., 'dirt') or 'all'.
         * @param {string} replaceType - The block type to replace with (e.g., 'mud').
         * @param {...string} exceptions - A list of block types to NOT replace.
         */
        function findAndReplace(findType, replaceType, ...exceptions) {
            let replaceCount = 0;
            if (!findType && findType !== '' || !replaceType && replaceType !== '') {
                const msg = "Error: findAndReplace requires at least a findType and replaceType.";
                logToConsole(msg, 'log-error');
                return msg;
            }

            // 1. Create the exception set for fast lookup
            const exceptionSet = new Set(exceptions);
            exceptionSet.add(replaceType); // Always avoid replacing the block with itself
            exceptionSet.add('invisible_barrier'); // Protect world borders
            //exceptionSet.add(''); // Always ignore air
            //exceptionSet.add('sky'); // Always ignore sky

            // 2. Define the "safe zone" around the player (3 wide x 5 tall)
            const playerCol = Math.floor(player.x / tileSize);
            const playerRowMin = Math.floor(player.y / tileSize);
            const playerRowMax = Math.floor((player.y + playerHeight) / tileSize);
            const safeRadius = 1; // 1-block buffer on each side (total 3 wide)
            
            const safeZone = new Set();
            for (let c = playerCol - safeRadius; c <= playerCol + safeRadius; c++) {
                // 2 blocks above player's head, 2 blocks below player's feet
                for (let r = playerRowMin - 2; r <= playerRowMax + 2; r++) {
                    safeZone.add(`${c},${r}`);
                }
            }

            // 3. Iterate through all loaded blocks
            for (const key in worldBlocks) {
                const block = worldBlocks[key];
                if (!block) continue; // Skip if block is null/undefined

                const currentType = block.type;

                // 4. Check if this block should be replaced
                const isMatch = (findType === 'all') || (currentType === findType);
                if (!isMatch) {
                    continue;
                }

                // 5. Check if it's in the exception list or safe zone
                if (exceptionSet.has(currentType) || safeZone.has(key)) {
                    continue;
                }

                // 6. Create the new block, respecting special container properties
                const newBlock = { type: replaceType, mineProg: 0 };

                if (replaceType === 'chest') {
                    newBlock.inventory = new Array(chestInventorySize).fill(null);
                    newBlock.label = 'Replaced Chest';
                } else if (replaceType === 'magical_chest') {
                    newBlock.inventory = new Array(50).fill(null);
                    newBlock.label = 'Replaced M-Chest';
                } else if (replaceType === 'dead_body_chest') {
                    newBlock.inventory = new Array(50).fill(null);
                    newBlock.label = 'Replaced Body';
                } else if (replaceType === 'refrigerator') {
                    newBlock.inventory = new Array(18).fill(null);
                    newBlock.label = 'Replaced Fridge';
                } else if (replaceType === 'oven' || replaceType === 'magma_furnace' || replaceType === 'power_forge') {
                    newBlock.inventory = new Array(12).fill(null); // 9 input, 1 fuel, 1 output, 1 byproduct
                } else if (replaceType === 'world_mover') {
                    newBlock.inventory = new Array(1).fill(null); // 1 fuel slot
                }
                // (Add other special container types like anvils if they get inventories)

                // 7. Perform the replacement
                worldBlocks[key] = newBlock;
                replaceCount++;
            }

            const message = `Replaced ${replaceCount} blocks.`;
            logToConsole(message, 'log-output');
            return message;
        }

		function syncHotbarIndices() {
			// Ensure hotbarIndices always points to the inventorySlots that should appear in the hotbar
			for (let h = 0; h < hotbarSize; h++) {
				hotbarIndices[h] = (inventorySlots[h] ? h : null);
			}
			updateHotbar();
		}

		// Function to log messages to our custom console
		function logToConsole(message, type = 'log-output') {
			const logEntry = document.createElement('div');
			logEntry.textContent = message;
			logEntry.className = type;
			consoleOutput.appendChild(logEntry);
			// Scroll to the bottom
			consoleOutput.scrollTop = consoleOutput.scrollHeight;
		}
		
		// Function to toggle the console's visibility
		function toggleDevConsole() {
			isConsoleOpen = !isConsoleOpen;
			if (isConsoleOpen) {
				devConsoleOverlay.style.display = 'flex';
				isGamePaused = true; // Pause the game
				consoleInput.focus(); // Automatically focus the input field
			} else {
				devConsoleOverlay.style.display = 'none'; // <-- TYPO IS FIXED HERE
				// Only unpause if another menu isn't also open
				if (gameMenuOverlay.style.display !== 'flex' && inventoryCraftingOverlay.style.display !== 'flex' && chestOverlay.style.display !== 'flex') {
					isGamePaused = false;
					lastTime = performance.now(); // Reset game loop timer
				}
			}
		}
		
		function cinemaMode() {
			isCinemaMode = !isCinemaMode; // Toggle the state

			if (isCinemaMode) {
				gameContainer.classList.add('cinema-mode');
				logToConsole('Cinema Mode: ON', 'log-output');
			} else {
				gameContainer.classList.remove('cinema-mode');
				logToConsole('Cinema Mode: OFF', 'log-output');
			}
			
			// We must call draw() once manually to update the smoothing
			draw(); 
			return `Cinema Mode is now ${isCinemaMode ? 'ON' : 'OFF'}.`;
		}

		// Event listener for the input field
		consoleInput.addEventListener('keydown', (e) => {
			// This stops the event from bubbling up to the game's key listener
			e.stopPropagation(); 

			if (e.key === '#') {
                e.preventDefault();
                isCreativeMode = 1;
                if (isCreativeMode === 1) {
                    showMessageBox("Creative Mode ON: No clip, no gravity. Use W/S or Up/Down arrows to fly.", 'info');
                    // Reset player velocity when entering flight
                    player.dy = 0;
                    player.onGround = true; 
                } else {
                    showMessageBox("Creative Mode OFF: Gravity and collisions restored.", 'info');
                }
            } else if (e.key === 'Enter' && !e.shiftKey) { // Check that Shift is NOT pressed
				e.preventDefault(); // Prevent adding a newline when executing
				const command = consoleInput.value.trim();
				if (command) {
					logToConsole(`> ${command}`, 'log-input');

					// Add to history if it's not a duplicate of the last one
					if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== command) {
						commandHistory.push(command);
					}
					historyIndex = commandHistory.length; // Reset index to the end

					try {
						const result = eval.call(window, command);
						logToConsole(result !== undefined ? JSON.stringify(result, null, 2) : 'undefined', 'log-output');
					} catch (error) {
						logToConsole(error, 'log-error');
					}

					consoleInput.value = '';
					setTimeout(() => consoleInput.style.height = 'auto', 0);
					consoleOutput.scrollTop = consoleOutput.scrollHeight;
				}
			} else if (e.key === 'ArrowUp') {
				e.preventDefault();
				if (historyIndex > 0) {
					historyIndex--;
					consoleInput.value = commandHistory[historyIndex];
					// Move cursor to the end of the line
					setTimeout(() => consoleInput.selectionStart = consoleInput.selectionEnd = consoleInput.value.length, 0);
				}
			} else if (e.key === 'ArrowDown') {
				e.preventDefault();
				if (historyIndex < commandHistory.length - 1) {
					historyIndex++;
					consoleInput.value = commandHistory[historyIndex];
					// Move cursor to the end of the line
					setTimeout(() => consoleInput.selectionStart = consoleInput.selectionEnd = consoleInput.value.length, 0);
				} else {
					// If at the end of history, clear the input
					historyIndex = commandHistory.length;
					consoleInput.value = '';
				}
			} else if (e.key === 'Tab') {
				e.preventDefault();
				const currentInput = consoleInput.value;
				if (currentInput.trim() === '') return;

				const matches = consoleAutocompleteSuggestions.filter(suggestion =>
					suggestion.toLowerCase().startsWith(currentInput.toLowerCase())
				);

				if (matches.length === 1) {
					// If there's one match, autocomplete it
					consoleInput.value = matches[0];
				} else if (matches.length > 1) {
					// If multiple matches, show them in the console
					logToConsole(`Suggestions: ${matches.join('  ')}`, 'log-output');
				}
			}
		});
		
		// Auto-resizing for the new textarea console input
		consoleInput.addEventListener('input', () => {
			consoleInput.style.height = 'auto'; // Reset height to calculate new scrollHeight
			consoleInput.style.height = (consoleInput.scrollHeight) + 'px'; // Set to new height
		});
		
		saveWorldMoverButton.addEventListener('click', saveWorldMoverConfig);

        teleportCodeInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                executeTeleport();
            }
        });
		
		document.getElementById('voidAcceptButton').addEventListener('click', () => {
			if (!currentVoidTrade || !isVoidChestOpen) return;

			const totalCost = currentVoidTrade.costPerItem * currentVoidTrade.count;
			let coinsToRemove = totalCost;

			// Remove coins from player inventory
			for (let i = inventorySlots.length - 1; i >= 0; i--) {
				const item = inventorySlots[i];
				if (item && item.type === currentVoidTrade.coinType) {
					const amountToRemove = Math.min(coinsToRemove, item.count);
					item.count -= amountToRemove;
					coinsToRemove -= amountToRemove;
					if (item.count <= 0) {
						inventorySlots[i] = null;
					}
					if (coinsToRemove <= 0) break;
				}
			}

			// Remove item from void storage
			let itemsToFind = currentVoidTrade.count;
			for (let i = voidStorage.length - 1; i >= 0; i--) {
				const item = voidStorage[i];
				if (item && item.type === currentVoidTrade.itemType) {
					const amountToRemove = Math.min(itemsToFind, item.count);
					item.count -= amountToRemove;
					itemsToFind -= amountToRemove;
					if (item.count <= 0) {
						voidStorage.splice(i, 1);
					}
					if (itemsToFind <= 0) break;
				}
			}

			// Add bought item to player inventory
			addToInventory(currentVoidTrade.itemType, currentVoidTrade.count, currentVoidTrade.durability);
			
			unlockAchievement('TRAGIC_BARGAIN');

			// Clear the trade and update UI
			currentVoidTrade = null;
			updateVoidChestMenu();
			syncHotbarIndices(); // Important to update hotbar display
		});

		document.getElementById('voidDeclineButton').addEventListener('click', () => {
			if (isVoidChestOpen) {
				toggleVoidChestMenu(); // Simply close the menu
			}
		});

        window.addEventListener('keydown', (e) => {
            // ... (your existing keydown logic)

            // ADD THIS LOGIC for the ':' key
            if (e.key === ':') { // Shift + ;
                e.preventDefault();
                if (canOpenTeleportMenu()) {
                    toggleTeleportMenu();
                } else {
                    showMessageBox("You haven't configured any World Movers yet.", 'alert');
                }
            }
        });

		// --- IN-GAME DEV CONSOLE CODE END ---
        let heldItemSource = { type: null, index: -1 }; // type: 'inventory', 'crafting', 'chest'

        let tileSize = 40;
		// --- particle count persisted in localStorage ---
        // put this before any code that uses `particleCount`
        const DEFAULT_PARTICLE_COUNT = 15; // change default as you like
        
        function loadSavedParticleCount() {
          const saved = localStorage.getItem('gameParticles');
          if (saved === null) return DEFAULT_PARTICLE_COUNT;
          const n = parseInt(saved, 10);
          return Number.isFinite(n) && n >= 0 ? n : DEFAULT_PARTICLE_COUNT;
        }
        
        let particleCount = loadSavedParticleCount();
        const playerHeightBlocks = 3;
        const playerWidthBlocks = 1;
        playerHeight = playerHeightBlocks * tileSize; //Non constant to enable console cheats
        playerWidth = playerWidthBlocks * tileSize; //Non constant to enable console cheats

        // World generation parameters
        let generationBuffer = 60; // How many blocks to render off-screen
        const baseSurfaceLevel = 0;
        let minSurfaceVariation = 0;
        let maxSurfaceVariation = 10; //Non constant to enable console cheats, used to be 8
        const surfaceLevelRange = 0;
        
        // --- Vein & Structure Probabilities ---
        // Ore Probabilities
        const coalVeinProbability = 0.025;
		const stumpStoneVeinProbability = 0.05;
		const limestoneVeinProbability = 0.25;
		const surfaceIronVeinProbability = 0.002;
		const deepCoalVeinProbability = 0.003;
		const amethystVeinProbability = 0.004;
		const zincVeinProbability = 0.003;
        const copperVeinProbability = 0.0025;
		const tinVeinProbability = 0.0015;
        const ironVeinProbability = 0.001;
		const tungstenVeinProbability = 0.0005;
		const rareMineralProbability = 0.0008
        const goldVeinProbability = 0.0001; 
        const topazVeinProbability = rareMineralProbability / 10;
		const diamondVeinProbability = rareMineralProbability / 12;
		const jadeVeinProbability = rareMineralProbability / 12;
		const opalVeinProbability = rareMineralProbability / 13;
		const sapphireVeinProbability = rareMineralProbability / 13;
		const emeraldVeinProbability = rareMineralProbability / 14;
		const rubyVeinProbability = rareMineralProbability / 16; 
		const hellsteelVeinProbability = 0.005;
		const mighterrumVeinProbability = 0.0007;
        const obsidianVeinProbability = 0.008;

        // Stone & Gravel Vein Probabilities
        const gravelVeinProbability = 0.03;
		const graniteVeinProbability = 0.004;
        const slateVeinProbability = 0.003;
        const schistVeinProbability = 0.002;
		const saltVeinProbability = 0.0005;
		const rockVeinProbability = 0.0003;
		const crudeOilVeinProbability = 0.0003;
		const nitroVeinProbability = 0.0002;
        const antLarvaVeinProbability = 0.015;
        const boneSpineProbability = 0.001;

        // Structure Probabilities
        let caveProbability = 0.0004; //Non constant to enable console cheats
        let mineshaftProbability = 0.00005; //Non constant to enable console cheats
        let dungeonProbability = 0.00003; //Non constant to enable console cheats
        let skyIslandProbability = 0.0075; //Non constant to enable console cheats
        let watchtowerProbability = 0.0005; //Non constant to enable console cheats
		let chasmProbability = 0.0007;
		let powertowerProbability = 0.00015; //Non constant to enable console cheats
		let plantationProbability = 0.007; // Non constant to enable console cheats
		let mineChamberProbability = 0.002; // Non constant to enable console cheats
		let jungleTempleProbability = 0.005; // Non constant to enable console cheats
        let lavaCaveProbability = caveProbability / 2; // Non constant to enable console cheats
        let bunkerProbability = 0.00005; // Non constant to enable console cheats
		const doomShackColumns = new Set();
		let doomShackProbability = 0.0003; // "somewhat common"
        
        // Foliage Probabilities
		const cowProbability = 0.02; // ADD THIS - 2% chance to spawn on a grass block
        const grassProbability = 0.4;
        const tallGrassProbability = 0.1;
        const cactusProbability = 0.1;
        const anthillMoundProbability = 0.5;

        // Biome generation variables
        const worldBiomes = {};
        let lastBiomeEndCol = -1; 
        let firstBiomeStartCol = 0;
        const underworldBiomes = {};
        let lastUnderworldBiomeEndCol = -1;
        let firstUnderworldBiomeStartCol = 0;
		const heavenBiomes = {};
        let lastHeavenBiomeEndCol = -1;
        let firstHeavenBiomeStartCol = 0;

        const columnSurfaceHeights = {};
        const heavenColumnSurfaceHeights = {}; // NEW: For super heaven variation
		const superHeavenColumnSurfaceHeights = {}; // NEW: For heaven variation
        worldBlocks = {}; // Stores block data for generated and modified blocks
		const fireBlocks = {}; // NEW: Stores blocks that are on fire
        const caveBlocks = new Set(); // Stores 'x,y' strings for cave locations
        const skyIslandColumns = new Set(); // Stores column indices where islands have been generated
		const mineChamberColumns = new Set(); // OLD: To prevent mine chamber overlap
		const voidRealmColumns = new Set();
        const watchtowerColumns = new Set(); // OLD: To prevent tower overlap
        const traderProbability = 0.04; // 4% chance for a trader to spawn on a valid block
		let traderColumns = new Set(); // Prevents traders from spawning on top of each other
		const chasmColumns = new Set();
        const bunkerColumns = new Set();
		const sandstoneTempleColumns = new Set();
		const plantationColumns = new Set(); // ADD THIS
		const redRockColumns = new Set(); // prevent spire/arch overlap in red_rocks biomes
		const graniteMountainColumns = new Set();
		const icyHillColumns = new Set();
		const jungleTempleColumns = new Set();
		let ruinedPortalProbability = 0.005; // 0.5% chance per column
		const ruinedPortalColumns = new Set(); // Tracks where portals have spawned

        // --- OG Seeded PRNG Implementation ---
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        // 64-bit PRNG (splitmix64) using BigInt
        function mulberry64_bigint(seed) {
            // Initialize the 64-bit state from the seed
            let x = BigInt(seed) & 0xFFFFFFFFFFFFFFFFn;
            const MASK = 0xFFFFFFFFFFFFFFFFn;
            // 2**64 as a float for division
            const SHIFT_DIV = 18446744073709551616.0; 

            return function() {
                // Algorithm for splitmix64
                x = (x + 0x9E3779B97F4A7C15n) & MASK;
                let z = x;
                z = ((z ^ (z >> 30n)) * 0xBF58476D1CE4E5B9n) & MASK;
                z = ((z ^ (z >> 27n)) * 0x94D049BB133111EBn) & MASK;
                z = z ^ (z >> 31n);
                
                // Get the final 64-bit positive integer
                const result = (z >> 0n) & MASK;
                
                // Convert to a float between 0.0 and 1.0
                return Number(result) / SHIFT_DIV;
            }
        }

        // Simple string hashing function to convert text seeds to numbers
        function stringToHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0; // Convert to 32bit integer
            }
            return Math.abs(hash); // Ensure positive hash
        }

        let currentSeed = Date.now(); // Default seed
        //let random = mulberry32(currentSeed); // Initialize PRNG Old
        let random = mulberry64_bigint(currentSeed); // Initialize PRNG

        /*// Sets the seed for the PRNG Old
        function setSeed(seed) {
            currentSeed = seed;
            random = mulberry32(seed);
        }*/

        // Sets the seed for the PRNG
        function setSeed(seed) {
            currentSeed = seed;
            random = mulberry64_bigint(seed);
        }

		// THINGS COMING SOON: AAAASDfdfh

        // Block types and their properties (imgSrc, solid, mining hardness, drops, color - for fallback)
        let blockTypes = {
            // Grass Tops Add 10 Durability, Overgrown Grass Adds 20
            'sky': { imgSrc: null, solid: false, miningHardness: 0, drops: [], color: '#87ceeb' },
			'': { imgSrc: null, solid: false, miningHardness: 0, drops: [], color: '#87ceeb' }, // New replacement for sky, even faster loading!
            'cobweb': { imgSrc: 'Cobweb.png', solid: false, miningHardness: 50, drops: [], color: '#EEEEEE', wallPlace: true },
            'bed': { imgSrc: 'Bed.png', solid: true, miningHardness: 100, drops: [{item: 'bed', chance: 1, min: 1, max: 1}], color: '#FF0000' },
			'trader': { imgSrc: 'Trader.png', solid: true, miningHardness: 100, drops: null, color: '#8B4513' },
			'full_trader': { imgSrc: 'Full Trader.png', solid: true, miningHardness: 120, drops: null, color: '#8B4513' },
            'chest': { imgSrc: 'Chest.png', solid: true, miningHardness: 150, drops: [{item: 'chest', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'magical_chest': { imgSrc: 'Magical Chest.png', solid: true, miningHardness: 150, drops: [{item: 'magical_chest', chance: 1, min: 1, max: 1}], color: '#9400D3' },
            'void_chest': { imgSrc: 'Void Chest.png', solid: true, miningHardness: 150, drops: [{item: 'chest', chance: 1, min: 1, max: 1}], color: '#483D8B' },
			'refrigerator': { imgSrc: 'Refrigerator.png', solid: true, miningHardness: 150, drops: [{item: 'refrigerator', chance: 1, min: 1, max: 1}], color: '#E6E8FA' },
			'enchanter': { imgSrc: 'Enchanter.png', solid: true, miningHardness: 300, drops: [{item: 'enchanter', chance: 1, min: 1, max: 1}], color: '#696969', isEnchanter: true, shovelBlock: true },
			'rock_anvil': { imgSrc: 'Rock Anvil.png', solid: true, miningHardness: 1000, drops: [{item: 'rock_anvil', chance: 1, min: 1, max: 1}], color: '#696969', anvilPower: 1 },
			'iron_anvil': { imgSrc: 'Iron Anvil.png', solid: true, miningHardness: 2000, drops: [{item: 'iron_anvil', chance: 1, min: 1, max: 1}], color: '#696969', anvilPower: 2 },
			'tungsten_anvil': { imgSrc: 'Tungsten Anvil.png', solid: true, miningHardness: 2000, drops: [{item: 'tungsten_anvil', chance: 1, min: 1, max: 1}], color: '#696969', anvilPower: 2 },
			'brass_anvil': { imgSrc: 'Brass Anvil.png', solid: true, miningHardness: 2000, drops: [{item: 'brass_anvil', chance: 1, min: 1, max: 1}], color: '#696969', anvilPower: 2 },
			'oven': { imgSrc: 'Oven.png', solid: true, miningHardness: 750, drops: [{item: 'oven', chance: 1, min: 1, max: 1}], color: '#696969' },
			'magma_furnace': { imgSrc: 'Magma Furnace.png', solid: true, miningHardness: 750, drops: [{item: 'magma_furnace', chance: 1, min: 1, max: 1}], color: '#FF4500' },
            'power_forge': { imgSrc: 'Power Forge.png', solid: true, miningHardness: 750, drops: [{item: 'power_forge', chance: 1, min: 1, max: 1}], color: '#FFD700' },
			'item_frame': { imgSrc: 'Item Frame.png', solid: true, miningHardness: 50, drops: [{item: 'item_frame', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'world_mover': { imgSrc: 'World Mover.png', solid: true, miningHardness: 250, drops: [{item: 'world_mover', chance: 1, min: 1, max: 1}], color: '#8A2BE2' },
			'napalm_bomb': { imgSrc: 'Napalm Bomb.png', solid: true, miningHardness: 80, drops: [], color: '#FF4500', bombDamage: 3, bombRadius: 9, playerDamageMin: 10, playerDamageMax: 90 },
			'dynamite_bomb': { imgSrc: 'Dynamite Bomb.png', solid: true, miningHardness: 80, drops: [], color: '#DC143C', bombDamage: 15, bombRadius: 9, playerDamageMin: 10, playerDamageMax: 220 },
			'octogen_bomb': { imgSrc: 'Octogen Bomb.png', solid: true, miningHardness: 80, drops: [], color: '#FFD700', bombDamage: 45, bombRadius: 9, playerDamageMin: 10, playerDamageMax: 180 },
			'weak_nuclear_bomb': { imgSrc: 'Weak Nuclear Bomb.png', solid: true, miningHardness: 80, drops: [], color: '#ADFF2F', bombDamage: 100, bombRadius: 15, playerDamageMin: 10, playerDamageMax: 500 },
			'subnuclear_bomb': { imgSrc: 'Subnuclear Bomb.png', solid: true, miningHardness: 80, drops: [], color: '#7FFF00', bombDamage: 300, bombRadius: 25, playerDamageMin: 10, playerDamageMax: 1000 },
            'nuclear_bomb': { imgSrc: 'Nuclear Bomb.png', solid: true, miningHardness: 80, drops: [], color: '#FFFFFF', bombDamage: 500, bombRadius: 60, playerDamageMin: 10, playerDamageMax: 10000 },
			'trap_stone': { imgSrc: 'Trap Stone Block.png', solid: true, miningHardness: 500, drops: [{item: 'stone', chance: 1, min: 1, max: 1}], color: '#808080', bombDamage: 15, bombRadius: 9, playerDamageMin: 10, playerDamageMax: 180 },
			'trap_compacted_stone': { imgSrc: 'Trap Compacted Stone Block.png', solid: true, miningHardness: 1000, drops: [{item: 'compacted_stone', chance: 1, min: 1, max: 1}], color: '#708090', bombDamage: 45, bombRadius: 9, playerDamageMin: 10, playerDamageMax: 220 },
			'trap_compressed_stone': { imgSrc: 'Trap Compressed Stone Block.png', solid: true, miningHardness: 10000, drops: [{item: 'compressed_stone', chance: 1, min: 1, max: 1}], color: '#708090', bombDamage: 100, bombRadius: 15, playerDamageMin: 10, playerDamageMax: 500 },
			// Mechageezer section
			'lever_on': { imgSrc: 'Lever On.png', solid: true, miningHardness: 80, drops: [], color: '#00FF00' },
			'lever_off': { imgSrc: 'Lever Off.png', solid: true, miningHardness: 80, drops: [], color: '#FF0000' },
			'chest_lever_on': { imgSrc: 'Chest Lever On.png', solid: true, miningHardness: 3000, drops: [], color: '#00FF00' },
			'chest_lever_off': { imgSrc: 'Chest Lever Off.png', solid: true, miningHardness: 3000, drops: [], color: '#FF0000' },
			'reactant': { imgSrc: 'Reactant.png', solid: true, miningHardness: 80, drops: [], color: '#FFFF00' },
			'trailer': { imgSrc: 'Trailer.png', solid: true, miningHardness: 5, drops: [], color: '#FFA500' },
			'lit_trailer': { imgSrc: 'Lit Trailer.png', solid: true, miningHardness: 5, drops: [], color: '#FF4500' },
			'stone_trailer': { imgSrc: 'Trailer Stone Block.png', solid: true, miningHardness: 500, drops: [{item: 'stone', chance: 1, min: 1, max: 1}], color: '#999999' },
			'stone_stairs_right': { imgSrc: 'Stone Stairs Right.png', solid: true, miningHardness: 500, drops: [{item: 'stone_stairs_right', chance: 1, min: 1, max: 1}], color: '#999999' },
			'stone_stairs_left': { imgSrc: 'Stone Stairs Left.png', solid: true, miningHardness: 500, drops: [{item: 'stone_stairs_left', chance: 1, min: 1, max: 1}], color: '#999999' },
			'dead_body_chest': { imgSrc: 'Dead Body Chest.png', solid: true, miningHardness: 150, drops: [{item: 'dead_body_block', chance: 1, min: 1, max: 1}], color: '#BC8F8F' },
			'dead_body_block': { imgSrc: 'Dead Body Chest.png', solid: true, miningHardness: 150, drops: [{item: 'dead_body_block', chance: 1, min: 1, max: 1}], color: '#BC8F8F' },
            'seed_dirt_block': { imgSrc: 'Seed Dirt Block.png', solid: true, miningHardness: 50, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'hop_seeds', chance: 1, min: 1, max: 3}], color: '#8B4513', shovelBlock: true },
			'grass_dirt': { imgSrc: 'Grass Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#228B22', shovelBlock: true },
			'overgrown_grass_dirt': { imgSrc: 'Overgrown Grass Dirt Block.png', solid: true, miningHardness: 80, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#006400', shovelBlock: true },
			'dark_grass_dirt': { imgSrc: 'Dark Grass Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#556B2F', shovelBlock: true },
			'overgrown_dark_grass_dirt': { imgSrc: 'Overgrown Dark Grass Dirt Block.png', solid: true, miningHardness: 70, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#6B8E23', shovelBlock: true },
			'dark_grass_soil': { imgSrc: 'Dark Grass Soil Block.png', solid: true, miningHardness: 80, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#556B2F', shovelBlock: true },
			'overgrown_dark_grass_soil': { imgSrc: 'Overgrown Dark Grass Soil Block.png', solid: true, miningHardness: 90, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#6B8E23', shovelBlock: true },
            'dirt': { imgSrc: 'Dirt Block.png', solid: true, miningHardness: 50, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#A0522D', shovelBlock: true },
			'grass_soil': { imgSrc: 'Grass Soil Block.png', solid: true, miningHardness: 80, drops: [{item: 'soil', chance: 1, min: 1, max: 1}], color: '#90EE90', shovelBlock: true },
			'overgrown_grass_soil': { imgSrc: 'Overgrown Grass Soil Block.png', solid: true, miningHardness: 90, drops: [{item: 'soil', chance: 1, min: 1, max: 1}], color: '#32CD32', shovelBlock: true },
            'soil': { imgSrc: 'Soil Block.png', solid: true, miningHardness: 70, drops: [{item: 'soil', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'plantation_soil': { imgSrc: 'Plantation Soil Block.png', solid: true, miningHardness: 70, drops: [{item: 'plantation_soil', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
            'fertilizer': { imgSrc: 'Fertilizer Block.png', solid: true, miningHardness: 80, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
            'stone': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 500, drops: [{item: 'stone', chance: 1, min: 1, max: 1}], color: '#999999' },
			'soft_stone': { imgSrc: 'Soft Stone Block.png', solid: true, miningHardness: 500, drops: [{item: 'soft_stone', chance: 1, min: 1, max: 1}], color: '#999999' },
			'outer_mantle_molten_stone': { imgSrc: 'Outer Mantle Molten Stone Block.png', solid: true, miningHardness: 50000, drops: [{item: 'iron_nugget', chance: 0.15, min: 1, max: 3}, {item: 'nickel_nugget', chance: 0.1, min: 1, max: 3}], color: '#FF8C00', requiredMiningPower: 2.5 },
			'inner_mantle_molten_stone': { imgSrc: 'Inner Mantle Molten Stone Block.png', solid: true, miningHardness: 150000, drops: [{item: 'iron_nugget', chance: 0.3, min: 1, max: 3}, {item: 'nickel_nugget', chance: 0.2, min: 1, max: 3}], color: '#FF4500', requiredMiningPower: 5 },
			'core_molten_stone': { imgSrc: 'Core Molten Stone Block.png', solid: true, miningHardness: 250000, drops: [{item: 'iron_nugget', chance: 0.6, min: 1, max: 3}, {item: 'nickel_nugget', chance: 0.4, min: 1, max: 3}], color: '#FF0000', requiredMiningPower: 10 },
			'stump_stone': { imgSrc: 'Stump Stone Block.png', solid: true, miningHardness: 500, drops: [{item: 'stump_stone', chance: 1, min: 1, max: 1}], color: '#778899' },
			'taiga_dirt': { imgSrc: 'Taiga Dirt Block.png', solid: true, miningHardness: 50, drops: [{item: 'taiga_dirt', chance: 1, min: 1, max: 1}], color: '#8B4513', shovelBlock: true },
			'taiga_grass_dirt_block_1': { imgSrc: 'Taiga Grass Dirt Block 1.png', solid: true, miningHardness: 60, drops: [{item: 'taiga_dirt', chance: 1, min: 1, max: 1}], color: '#2E8B57', shovelBlock: true },
			'taiga_grass_dirt_block_2': { imgSrc: 'Taiga Grass Dirt Block 2.png', solid: true, miningHardness: 60, drops: [{item: 'taiga_dirt', chance: 1, min: 1, max: 1}], color: '#2E8B57', shovelBlock: true },
			'watchtower_stone_block': { imgSrc: 'Watchtower Stone Block.png', solid: true, miningHardness: 800, drops: [{item: 'watchtower_stone_block', chance: 1, min: 1, max: 1}], color: '#686868' },
			'powertower_stone_block': { imgSrc: 'Powertower Stone Block.png', solid: true, miningHardness: 800, drops: [{item: 'powertower_stone_block', chance: 1, min: 1, max: 1}], color: '#686868' },
            'rock_block': { imgSrc: 'Rock Block.png', solid: true, miningHardness: 500, drops: [{item: 'rock_block', chance: 1, min: 1, max: 1}], color: '#A9A9A9' },
			'salt_rock_block': { imgSrc: 'Salt Rock Block.png', solid: true, miningHardness: 500, drops: [{item: 'salt_rock_block', chance: 0.8, min: 1, max: 1}, {item: 'rock_salt', chance: 0.08, min: 1, max: 2}], color: '#FDF5E6' },
			'limestone': { imgSrc: 'Limestone Block.png', solid: true, miningHardness: 300, drops: [{item: 'limestone', chance: 1, min: 1, max: 1}], color: '#F5F5DC' },
            'sand': { imgSrc: 'Sand Block.png', solid: true, miningHardness: 40, drops: [{item: 'sand', chance: 1, min: 1, max: 1}], color: '#F4A460', shovelBlock: true },
			'red_sand_block': { imgSrc: 'Red Sand Block.png', solid: true, miningHardness: 40, drops: [{item: 'red_sand_block', chance: 1, min: 1, max: 1}], color: '#47433e', shovelBlock: true },
            'sandstone': { imgSrc: 'Sandstone Block.png', solid: true, miningHardness: 450, drops: [{item: 'sandstone', chance: 1, min: 1, max: 1}], color: '#47433e' },
			'red_sandstone_block': { imgSrc: 'Red Sandstone Block.png', solid: true, miningHardness: 450, drops: [{item: 'red_sandstone_block', chance: 1, min: 1, max: 1}], color: '#851500' },
            'compacting_stone': { imgSrc: 'Compacting Stone Block.png', solid: true, miningHardness: 750, drops: [{item: 'compacted_stone', chance: 1, min: 1, max: 1}], color: '#696969' },
            'glass_block': { imgSrc: 'Glass Block.png', solid: true, miningHardness: 40, drops: [{item: 'glass_block', chance: 1, min: 1, max: 1}], color: '#AFEEEE' },
			'compacted_stone': { imgSrc: 'Compacted Stone Block.png', solid: true, miningHardness: 1000, drops: [{item: 'compacted_stone', chance: 1, min: 1, max: 1}], color: '#565656', requiredMiningPower: 0.2 },
			'compressed_stone': { imgSrc: 'Compressed Stone Block.png', solid: true, miningHardness: 10000, drops: [{item: 'compressed_stone', chance: 1, min: 1, max: 1}], color: '#262626', requiredMiningPower: 0.3 },
			'void_stone': { imgSrc: 'Void Stone Block.png', solid: true, miningHardness: 1000, drops: [{item: 'void_stone', chance: 1, min: 1, max: 1}], color: '#5b6160', requiredMiningPower: 0.3 },
			'void_dust_block': { imgSrc: 'Void Dust Block.png', solid: true, miningHardness: 100, drops: [{item: 'void_dust', chance: 1, min: 1, max: 4}], color: '#6b8683' },
			'void_crystal': { imgSrc: 'Void Crystal Block.png', solid: true, miningHardness: 1000, drops: [{item: 'void_crystal', chance: 1, min: 1, max: 1}], color: '#de65b7', requiredMiningPower: 0.2 },
			'red_void_crystal': { imgSrc: 'Red Void Crystal Block.png', solid: true, miningHardness: 1000, drops: [{item: 'red_void_crystal', chance: 1, min: 1, max: 1}], color: '#DC143C', requiredMiningPower: 0.2 },
			'bedrock_stone': { imgSrc: 'Bedrock Stone Block.png', solid: true, miningHardness: 50000, drops: [{item: 'bedrock_stone', chance: 1, min: 1, max: 1}], color: '#191919', requiredMiningPower: 2.5 },
			'hellstone': { imgSrc: 'Hellstone Block.png', solid: true, miningHardness: 500, drops: [{item: 'hellstone', chance: 1, min: 1, max: 1}], color: '#451b1b' },
			'hellrock': { imgSrc: 'Hellrock Block.png', solid: true, miningHardness: 500, drops: [{item: 'hellrock', chance: 1, min: 1, max: 1}], color: '#8B0000' },
			'magma_stone_block': { imgSrc: 'Magma Stone Block.png', solid: true, miningHardness: 500, drops: [{item: 'magma_stone_block', chance: 1, min: 1, max: 1}], color: '#ff8700' },
			'chasm_magma_stone_block': { imgSrc: 'Chasm Magma Stone Block.png', solid: true, miningHardness: 500, drops: [{item: 'chasm_magma_stone_block', chance: 1, min: 1, max: 1}], color: '#ff00af' },
			'heaven_magma_stone_block': { imgSrc: 'Heaven Magma Stone Block.png', solid: true, miningHardness: -1, drops: [], color: '#ff8700' },
			'meteorite': { imgSrc: 'Meteorite.png', solid: true, miningHardness: 500, drops: [{item: 'gold_nugget', chance: 0.3, min: 1, max: 3}, {item: 'palladium_nugget', chance: 0.2, min: 1, max: 3}, {item: 'iron_nugget', chance: 0.6, min: 1, max: 3}, {item: 'nickel_nugget', chance: 0.6, min: 1, max: 3}], color: '#696969' },
			'hellsteel_hellstone': { imgSrc: 'Hellsteel Hellstone Block.png', solid: true, miningHardness: 750, drops: [{item: 'hellsteel_nugget', chance: 1, min: 1, max: 3}], color: '#E62020' },
			'mighterrum_hellstone': { imgSrc: 'Mighterrum Hellstone Block.png', solid: true, miningHardness: 750, drops: [{item: 'mighterrum_nugget', chance: 1, min: 1, max: 1}], color: '#B22222' },
			'coal_block': { imgSrc: 'Coal Block.png', solid: true, miningHardness: 500, drops: [{item: 'coal', chance: 1, min: 1, max: 9}], color: '#343434' },
			'stone_brick_block': { imgSrc: 'Stone Brick Block.png', solid: true, miningHardness: 500, drops: [{item: 'stone_brick_block', chance: 1, min: 1, max: 1}], color: '#808080' },
			'clay_brick_block': { imgSrc: 'Clay Brick Block.png', solid: true, miningHardness: 400, drops: [{item: 'clay_brick_block', chance: 1, min: 1, max: 1}], color: '#B22222' },
            'steel_brick_block': { imgSrc: 'Steel Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'steel_brick_block', chance: 1, min: 1, max: 1}], color: '#A9A9A9' },
			'bronze_brick_block': { imgSrc: 'Bronze Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'bronze_brick_block', chance: 1, min: 1, max: 1}], color: '#CD7F32' },
			'brass_brick_block': { imgSrc: 'Brass Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'brass_brick_block', chance: 1, min: 1, max: 1}], color: '#B5A642' },
			'gold_brick_block': { imgSrc: 'Gold Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'gold_brick_block', chance: 1, min: 1, max: 1}], color: '#FFD700' },
			'gold_power_brick_block': { imgSrc: 'Gold Power Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'gold_power_brick_block', chance: 1, min: 1, max: 1}], color: '#FFD700' },
			'iron_brick_block': { imgSrc: 'Iron Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'iron_brick_block', chance: 1, min: 1, max: 1}], color: '#A19D94' },
			'tungsten_brick_block': { imgSrc: 'Tungsten Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'tungsten_brick_block', chance: 1, min: 1, max: 1}], color: '#8B8B83' },
			'tin_brick_block': { imgSrc: 'Tin Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'tin_brick_block', chance: 1, min: 1, max: 1}], color: '#C0C0C0' },
			'zinc_brick_block': { imgSrc: 'Zinc Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'zinc_brick_block', chance: 1, min: 1, max: 1}], color: '#B0C4DE' },
			'lead_brick_block': { imgSrc: 'Lead Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'lead_brick_block', chance: 1, min: 1, max: 1}], color: '#778899' },
			'nickel_brick_block': { imgSrc: 'Nickel Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'nickel_brick_block', chance: 1, min: 1, max: 1}], color: '#BEBEBE' },
			'copper_brick_block': { imgSrc: 'Copper Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'copper_brick_block', chance: 1, min: 1, max: 1}], color: '#B87333' },
			'slightly_oxidizing_copper_brick_block': { imgSrc: 'Slightly Oxidizing Copper Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'slightly_oxidizing_copper_brick_block', chance: 1, min: 1, max: 1}], color: '#A07A5A' },
			'oxidizing_copper_brick_block': { imgSrc: 'Oxidizing Copper Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'oxidizing_copper_brick_block', chance: 1, min: 1, max: 1}], color: '#66A083' },
			'highly_oxidizing_copper_brick_block': { imgSrc: 'Highly Oxidizing Copper Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'highly_oxidizing_copper_brick_block', chance: 1, min: 1, max: 1}], color: '#4E9C7B' },
			'oxidized_copper_brick_block': { imgSrc: 'Oxidized Copper Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'oxidized_copper_brick_block', chance: 1, min: 1, max: 1}], color: '#3A8060' },
			'aluminum_brick_block': { imgSrc: 'Aluminum Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'aluminum_brick_block', chance: 1, min: 1, max: 1}], color: '#D3D3D3' },
			'palladium_brick_block': { imgSrc: 'Palladium Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'palladium_brick_block', chance: 1, min: 1, max: 1}], color: '#E6E8FA' },
            'heaven_brick_block': { imgSrc: 'Heaven Brick Block.png', solid: true, miningHardness: 1200, drops: [{item: 'heaven_brick_block', chance: 1, min: 1, max: 1}], color: '#F0EAD6' },
            // Ores And Minerals
			'coal_stone': { imgSrc: 'Coal Stone Block.png', solid: true, miningHardness: 750, drops: [{item: 'coal', chance: 1, min: 1, max: 1}], color: '#36454F' },
			'coal_compacted_stone': { imgSrc: 'Coal Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'coal', chance: 1, min: 1, max: 1}], color: '#36454F', requiredMiningPower: 0.2 },
            'coal_compressed_stone': { imgSrc: 'Coal Compressed Stone Block.png', solid: true, miningHardness: 15000, drops: [{item: 'coal', chance: 1, min: 1, max: 1}], color: '#36454F', requiredMiningPower: 0.5 },
			'copper_compacted_stone': { imgSrc: 'Copper Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'copper_nugget', chance: 1, min: 1, max: 1}], color: '#B87333', requiredMiningPower: 0.2 },
            'tin_compacted_stone': { imgSrc: 'Tin Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'tin_nugget', chance: 1, min: 1, max: 1}], color: '#C0C0C0', requiredMiningPower: 0.2 },
			'zinc_compacted_stone': { imgSrc: 'Zinc Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'zinc_nugget', chance: 1, min: 1, max: 1}], color: '#B0C4DE', requiredMiningPower: 0.2 },
			'iron_stone': { imgSrc: 'Iron Stone Block.png', solid: true, miningHardness: 750, drops: [{item: 'iron_nugget', chance: 1, min: 1, max: 1}], color: '#A19D94' },
            'iron_compacted_stone': { imgSrc: 'Iron Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'iron_nugget', chance: 1, min: 1, max: 1}], color: '#A19D94', requiredMiningPower: 0.2 },
			'iron_granite': { imgSrc: 'Iron Granite Block.png', solid: true, miningHardness: 1050, drops: [{item: 'iron_nugget', chance: 1, min: 1, max: 1}], color: '#A19D94', requiredMiningPower: 0.8 },
			'iron_compressed_stone': { imgSrc: 'Iron Compressed Stone Block.png', solid: true, miningHardness: 15000, drops: [{item: 'iron_nugget', chance: 1, min: 1, max: 1}], color: '#A19D94', requiredMiningPower: 0.5 },
			'tungsten_compacted_stone': { imgSrc: 'Tungsten Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'tungsten_nugget', chance: 1, min: 1, max: 1}], color: '#8B8B83', requiredMiningPower: 0.2 },
            'gold_compacted_stone': { imgSrc: 'Gold Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'gold_nugget', chance: 1, min: 1, max: 1}], color: '#FFD700', requiredMiningPower: 0.2 },
            'ruby_compacted_stone': { imgSrc: 'Ruby Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'ruby_nugget', chance: 1, min: 1, max: 1}], color: '#E0115F', requiredMiningPower: 0.2 },
            'diamond_compacted_stone': { imgSrc: 'Diamond Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'diamond_nugget', chance: 1, min: 1, max: 1}], color: '#B9F2FF', requiredMiningPower: 0.2 },
			'topaz_compacted_stone': { imgSrc: 'Topaz Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'topaz_nugget', chance: 1, min: 1, max: 1}], color: '#FFC87C', requiredMiningPower: 0.2 },
            'sapphire_compacted_stone': { imgSrc: 'Sapphire Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'sapphire_nugget', chance: 1, min: 1, max: 1}], color: '#0F52BA', requiredMiningPower: 0.2 },
            'emerald_compacted_stone': { imgSrc: 'Emerald Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'emerald_nugget', chance: 1, min: 1, max: 1}], color: '#50C878', requiredMiningPower: 0.2 },
            'amethyst_compacted_stone': { imgSrc: 'Amethyst Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'amethyst_nugget', chance: 1, min: 1, max: 1}], color: '#9966CC', requiredMiningPower: 0.2 },
            'opal_compacted_stone': { imgSrc: 'Opal Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'opal_nugget', chance: 1, min: 1, max: 1}], color: '#E0E9E7', requiredMiningPower: 0.2 },
			'jade_compacted_stone': { imgSrc: 'Jade Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'jade_nugget', chance: 1, min: 1, max: 1}], color: '#00A86B', requiredMiningPower: 0.2 },
            'aluminum_granite': { imgSrc: 'Aluminum Granite Block.png', solid: true, miningHardness: 1050, drops: [{item: 'aluminum_nugget', chance: 1, min: 1, max: 1}], color: '#D3D3D3' },
			'aluminum_compressed_stone': { imgSrc: 'Aluminum Compressed Stone Block.png', solid: true, miningHardness: 15000, drops: [{item: 'aluminum_nugget', chance: 1, min: 1, max: 1}], color: '#D3D3D3', requiredMiningPower: 0.5 },
			'palladium_compressed_stone': { imgSrc: 'Palladium Compressed Stone Block.png', solid: true, miningHardness: 15000, drops: [{item: 'palladium_nugget', chance: 1, min: 1, max: 1}], color: '#E6E8FA', requiredMiningPower: 0.5 },
			'nitro_compacted_stone': { imgSrc: 'Nitro Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'nitro_powder', chance: 1, min: 1, max: 5}], color: '#FFFF00', requiredMiningPower: 0.2 },
			'crude_oil_compacted_stone': { imgSrc: 'Crude Oil Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'crude_oil_chunk', chance: 1, min: 1, max: 1}], color: '#000000', requiredMiningPower: 0.2 },
			'any_plank': { imgSrc: 'Any Plank.png', solid: false, miningHardness: 0, drops: [], color: '#654321' },
			'any_gilded': { imgSrc: 'Any Gilded.png', solid: false, miningHardness: 0, drops: [], color: '#FFD700' },
			'raw_deadwood': { imgSrc: 'Raw Deadwood Block.png', solid: true, miningHardness: 100, drops: [{item: 'raw_deadwood', chance: 1, min: 1, max: 1}], color: '#654321' },
			'planked_deadwood': { imgSrc: 'Planked Deadwood Block.png', solid: true, miningHardness: 100, drops: [{item: 'planked_deadwood', chance: 1, min: 1, max: 1}], color: '#654321' },
			'raw_oak': { imgSrc: 'Raw Oak Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_oak', chance: 1, min: 1, max: 1}], color: '#654321' },
            'oak_bush': { imgSrc: 'Oak Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'oak_bush', chance: 0.05, min: 1, max: 1}], color: '#228B22' },
            'planked_oak': { imgSrc: 'Planked Oak Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_oak', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'raw_apple': { imgSrc: 'Raw Apple Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_apple', chance: 1, min: 1, max: 1}], color: '#654321' },
            'apple_bush': { imgSrc: 'Apple Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'apple_bush', chance: 0.05, min: 1, max: 1}], color: '#228B22' },
			'apple_bush_fruit': { imgSrc: 'Apple Bush Block Fruit.png', solid: true, miningHardness: 20, drops: [{item: 'apple_bush', chance: 0.05, min: 1, max: 1}, {item: 'apple', chance: 1, min: 1, max: 3}], color: '#FF0000' },
            'planked_apple': { imgSrc: 'Planked Apple Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_apple', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
            'raw_birch': { imgSrc: 'Raw Birch Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_birch', chance: 1, min: 1, max: 1}], color: '#F5F5DC' },
            'birch_bush': { imgSrc: 'Birch Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'birch_bush', chance: 0.05, min: 1, max: 1}], color: '#6B8E23' },
            'planked_birch': { imgSrc: 'Planked Birch Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_birch', chance: 1, min: 1, max: 1}], color: '#F5DEB3' },
            'raw_spruce': { imgSrc: 'Raw Spruce Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_spruce', chance: 1, min: 1, max: 1}], color: '#4A3B2F' },
            'spruce_bush': { imgSrc: 'Spruce Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'spruce_bush', chance: 0.05, min: 1, max: 1}, {item: 'pine_needle_living', chance: 0.2, min: 1, max: 1}, {item: 'pinecone', chance: 0.1, min: 1, max: 1}], color: '#0A4A2A' },
			'planked_spruce': { imgSrc: 'Planked Spruce Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_spruce', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'raw_orange': { imgSrc: 'Raw Orange Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_orange', chance: 1, min: 1, max: 1}], color: '#654321' },
            'orange_bush': { imgSrc: 'Orange Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'orange_bush', chance: 0.05, min: 1, max: 1}], color: '#228B22' },
			'orange_bush_fruit': { imgSrc: 'Orange Bush Block Fruit.png', solid: true, miningHardness: 20, drops: [{item: 'orange_bush', chance: 0.05, min: 1, max: 1}, {item: 'orange', chance: 1, min: 1, max: 3}], color: '#FFA500' },
            'planked_orange': { imgSrc: 'Planked Orange Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_orange', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'raw_redwood': { imgSrc: 'Raw Redwood Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_redwood', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'redwood_bush': { imgSrc: 'Redwood Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'redwood_bush', chance: 0.05, min: 1, max: 1}, {item: 'pine_needle_living', chance: 0.2, min: 1, max: 1}, {item: 'pinecone', chance: 0.1, min: 1, max: 1}], color: '#0A4A2A' },
			'planked_redwood': { imgSrc: 'Planked Redwood Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_redwood', chance: 1, min: 1, max: 1}], color: '#A0522D' },
			'raw_rubber': { imgSrc: 'Raw Rubber Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_rubber', chance: 1, min: 1, max: 1}], color: '#F5F5DC' },
            'rubber_bush': { imgSrc: 'Rubber Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'rubber_bush', chance: 0.05, min: 1, max: 1}], color: '#6B8E23' },
            'planked_rubber': { imgSrc: 'Planked Rubber Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_rubber', chance: 1, min: 1, max: 1}], color: '#F5DEB3' },
			'raw_mahogany': { imgSrc: 'Raw Mahogany Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_mahogany', chance: 1, min: 1, max: 1}], color: '#C04000' },
            'mahogany_bush': { imgSrc: 'Mahogany Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'mahogany_bush', chance: 0.05, min: 1, max: 1}], color: '#6B8E23' },
            'planked_mahogany': { imgSrc: 'Planked Mahogany Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_mahogany', chance: 1, min: 1, max: 1}], color: '#C04000' },
			'raw_cinnamon': { imgSrc: 'Raw Cinnamon Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_cinnamon', chance: 1, min: 1, max: 1}], color: '#D2691E' },
            'cinnamon_bush': { imgSrc: 'Cinnamon Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'cinnamon_bush', chance: 0.05, min: 1, max: 1}], color: '#6B8E23' },
            'planked_cinnamon': { imgSrc: 'Planked Cinnamon Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_cinnamon', chance: 1, min: 1, max: 1}], color: '#D2691E' },
			'raw_blueglow_wood': { imgSrc: 'Raw Blueglow Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_blueglow_wood', chance: 1, min: 1, max: 1}], color: '#00BFFF' },
            'blueglow_bush': { imgSrc: 'Blueglow Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'blueglow_bush', chance: 0.05, min: 1, max: 1}], color: '#00BFFF' },
            'planked_blueglow_wood': { imgSrc: 'Planked Blueglow Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_blueglow_wood', chance: 1, min: 1, max: 1}], color: '#00BFFF' },
			'meat_wood': { imgSrc: 'Meat Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'meat_wood', chance: 0.1, min: 1, max: 1}, {item: 'beef', chance: 0.3, min: 1, max: 3}, {item: 'pork', chance: 0.3, min: 1, max: 3}, {item: 'human_flesh', chance: 0.2, min: 1, max: 3}], color: '#DC143C' },
			'spoiled_meat_wood': { imgSrc: 'Spoiled Meat Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'spoiled_meat_wood', chance: 0.1, min: 1, max: 1}, {item: 'spoiled_beef', chance: 0.3, min: 1, max: 3}, {item: 'spoiled_pork', chance: 0.3, min: 1, max: 3}, {item: 'human_flesh', chance: 0.2, min: 1, max: 3}], color: '#556B2F' },
			'raw_hell_wood': { imgSrc: 'Raw Hell Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_hell_wood', chance: 1, min: 1, max: 1}], color: '#8B0000' },
            'hell_wood_bush': { imgSrc: 'Hell Wood Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'hell_wood_bush', chance: 0.05, min: 1, max: 1}], color: '#B22222' },
			'planked_hell_wood': { imgSrc: 'Planked Hell Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_hell_wood', chance: 1, min: 1, max: 1}], color: '#8B0000' },
			'leaf_plant': { imgSrc: 'Leaf Plant.png', solid: false, miningHardness: 15, drops: [{item: 'onion_seeds', chance: 0.1, min: 1, max: 2}, {item: 'garlic_seeds', chance: 0.1, min: 1, max: 2}], color: '#7CFC00' },
			'grass_sprouts': { imgSrc: 'Grass Sprouts.png', solid: false, miningHardness: 5, drops: [{item: 'grass_seeds', chance: 0.3, min: 1, max: 2}, {item: 'pumpkin_seeds', chance: 0.2, min: 1, max: 2}], color: '#7CFC00' },
            'grass': { imgSrc: 'Grass.png', solid: false, miningHardness: 10, drops: [{item: 'grass_seeds', chance: 0.4, min: 1, max: 3}, {item: 'wheat_seeds', chance: 0.2, min: 1, max: 2}, {item: 'barley_seeds', chance: 0.2, min: 1, max: 2}], color: '#7CFC00' },
			'tall_grass': { imgSrc: 'Tall Grass.png', solid: false, miningHardness: 20, drops: [{item: 'grass_seeds', chance: 0.5, min: 1, max: 5}, {item: 'wheat_seeds', chance: 0.3, min: 1, max: 3}, {item: 'cotton_seeds', chance: 0.1, min: 1, max: 2}], color: '#6B8E23' },
			'yellow_flower': { imgSrc: 'Yellow Flower.png', solid: false, miningHardness: 10, drops: [{item: 'yellow_flower', chance: 1, min: 1, max: 1}], color: '#FFFF00' },
			'red_flower': { imgSrc: 'Red Flower.png', solid: false, miningHardness: 10, drops: [{item: 'red_flower', chance: 1, min: 1, max: 1}], color: '#FF0000' },
			'blue_flower': { imgSrc: 'Blue Flower.png', solid: false, miningHardness: 10, drops: [{item: 'blue_flower', chance: 1, min: 1, max: 1}], color: '#0000FF' },
			'orange_flower': { imgSrc: 'Orange Flower.png', solid: false, miningHardness: 10, drops: [{item: 'orange_flower', chance: 1, min: 1, max: 1}], color: '#FFA500' },
			'purple_flower': { imgSrc: 'Purple Flower.png', solid: false, miningHardness: 10, drops: [{item: 'purple_flower', chance: 1, min: 1, max: 1}], color: '#800080' },
			'green_flower': { imgSrc: 'Green Flower.png', solid: false, miningHardness: 10, drops: [{item: 'green_flower', chance: 1, min: 1, max: 1}], color: '#7CFC00' },
			'pinecone_pile': { imgSrc: 'Pinecone Pile.png', solid: false, miningHardness: 10, drops: [{item: 'pinecone', chance: 1, min: 1, max: 3}], color: '#8B4513' },
			'pine_needle_pile': { imgSrc: 'Pine Needle Pile.png', solid: false, miningHardness: 10, drops: [{item: 'pine_needle_living', chance: 0.5, min: 1, max: 2}, {item: 'pine_needle_dying', chance: 0.5, min: 1, max: 2}, {item: 'pine_needle_dead', chance: 0.5, min: 1, max: 2}], color: '#2E8B57' },
            'sunflower_top': { imgSrc: 'Sunflower Top.png', solid: false, miningHardness: 10, drops: [], color: '#FFFF00' },
			'sunflower_stem': { imgSrc: 'Sunflower Stem.png', solid: false, miningHardness: 10, drops: [], color: '#FFFF00' },
			'milkweed': { imgSrc: 'Milkweed.png', solid: false, miningHardness: 10, drops: [{item: 'milkweed', chance: 1, min: 1, max: 1}], color: '#FFFF00' },
			'mossy_root': { imgSrc: 'Mossy Root.png', solid: false, miningHardness: 10, drops: [{item: 'mossy_root', chance: 1, min: 1, max: 1}], color: '#6B8E23' },
			'leaf_pile': { imgSrc: 'Leaf Pile.png', solid: false, miningHardness: 10, drops: [{item: 'leaf', chance: 1, min: 1, max: 5}], color: '#228B22' },
			'fern': { imgSrc: 'Fern.png', solid: false, miningHardness: 10, drops: [{item: 'chili_pepper_seeds', chance: 0.2, min: 1, max: 2}], color: '#7CFC00' },
			'fern_stalk': { imgSrc: 'Fern Stalk.png', solid: false, miningHardness: 10, drops: [{item: 'chili_pepper_seeds', chance: 0.2, min: 1, max: 2}], color: '#7CFC00' },
			'sugarcane': { imgSrc: 'Sugar Cane.png', solid: false, miningHardness: 10, drops: [{item: 'sugarcane', chance: 1, min: 1, max: 1}], color: '#90EE90' },
			'snow': { imgSrc: 'Snow Pile.png', solid: false, miningHardness: 5, drops: [{item: 'snow_ball', chance: 1, min: 1, max: 1}], color: '#FFFAFA' },
            'large_snow_pile': { imgSrc: 'Large Snow Pile.png', solid: false, miningHardness: 10, drops: [{item: 'snow_ball', chance: 1, min: 2, max: 2}], color: '#F0FFFF' },
            'snow_block': { imgSrc: 'Snow Block.png', solid: true, miningHardness: 25, drops: [{item: 'snow_block', chance: 1, min: 1, max: 1}], color: '#F0FFFF' },
            'desert_brush': { imgSrc: 'Desert Brush.png', solid: false, miningHardness: 5, drops: [{item: 'tomato_seeds', chance: 0.2, min: 1, max: 2}], color: '#D2B48C' },
			'desert_grass': { imgSrc: 'Desert Grass.png', solid: false, miningHardness: 5, drops: [{item: 'coffee_seeds', chance: 0.2, min: 1, max: 2}], color: '#D2B48C' },
            'prickly_pear_cactus': { imgSrc: 'Prickly Pear Cactus.png', solid: false, miningHardness: 5, drops: [{item: 'prickly_pear_fruit', chance: 0.6, min: 1, max: 1}], color: '#93C572' },
            'cactus_block': { imgSrc: 'Cactus Block.png', solid: true, miningHardness: 80, drops: [{item: 'cactus_block', chance: 1, min: 1, max: 1}], color: '#556B2F', shovelBlock: true },
            'anthill_sand_block': { imgSrc: 'Anthill Sand Block.png', solid: true, miningHardness: 45, drops: [{item: 'anthill_sand_block', chance: 1, min: 1, max: 1}], color: '#C19A6B' },
            'colony_heart_sand_block': { imgSrc: 'Colony Heart Sand Block.png', solid: true, miningHardness: 500, drops: [{item: 'colony_heart', chance: 1, min: 1, max: 1}], color: '#FF4444' },
            'anthill_sand_mound': { imgSrc: 'Anthill Sand Mound.png', solid: false, miningHardness: 10, drops: [], color: '#D2B48C' },
			'guano': { imgSrc: 'Guano.png', solid: false, miningHardness: 10, drops: [{item: 'guano', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
            'slate': { imgSrc: 'Slate Block.png', solid: true, miningHardness: 600, drops: [{item: 'slate', chance: 1, min: 1, max: 1}], color: '#708090' },
            'schist': { imgSrc: 'Schist Block.png', solid: true, miningHardness: 600, drops: [{item: 'schist', chance: 1, min: 1, max: 1}], color: '#848482' },
            'granite': { imgSrc: 'Granite Block.png', solid: true, miningHardness: 700, drops: [{item: 'granite', chance: 1, min: 1, max: 1}], color: '#D3B8B1' },
			'asphalt': { imgSrc: 'Asphalt Block.png', solid: true, miningHardness: 600, drops: [{item: 'asphalt_fragment', chance: 1, min: 1, max: 4}], color: '#36454F' },
			'concrete': { imgSrc: 'Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'concrete', chance: 1, min: 1, max: 1}], color: '#BEBEBE' },
			'light_concrete': { imgSrc: 'Light Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'light_concrete', chance: 1, min: 1, max: 1}], color: '#BEBEBE' },
			'dark_concrete': { imgSrc: 'Dark Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'dark_concrete', chance: 1, min: 1, max: 1}], color: '#BEBEBE' },
			'blue_concrete': { imgSrc: 'Blue Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'blue_concrete', chance: 1, min: 1, max: 1}], color: '#0000FF' },
			'purple_concrete': { imgSrc: 'Purple Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'purple_concrete', chance: 1, min: 1, max: 1}], color: '#800080' },
			'pink_concrete': { imgSrc: 'Pink Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'pink_concrete', chance: 1, min: 1, max: 1}], color: '#FFC0CB' },
			'red_concrete': { imgSrc: 'Red Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'red_concrete', chance: 1, min: 1, max: 1}], color: '#FF0000' },
			'orange_concrete': { imgSrc: 'Orange Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'orange_concrete', chance: 1, min: 1, max: 1}], color: '#FFA500' },
			'yellow_concrete': { imgSrc: 'Yellow Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'yellow_concrete', chance: 1, min: 1, max: 1}], color: '#FFFF00' },
			'green_concrete': { imgSrc: 'Green Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'green_concrete', chance: 1, min: 1, max: 1}], color: '#008000' },
			'cyan_concrete': { imgSrc: 'Cyan Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'cyan_concrete', chance: 1, min: 1, max: 1}], color: '#00FFFF' },
			'blue_dark_concrete': { imgSrc: 'Dark Blue Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'blue_dark_concrete', chance: 1, min: 1, max: 1}], color: '#0000FF' },
			'purple_dark_concrete': { imgSrc: 'Dark Purple Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'purple_dark_concrete', chance: 1, min: 1, max: 1}], color: '#800080' },
			'pink_dark_concrete': { imgSrc: 'Dark Pink Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'pink_dark_concrete', chance: 1, min: 1, max: 1}], color: '#FFC0CB' },
			'red_dark_concrete': { imgSrc: 'Dark Red Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'red_dark_concrete', chance: 1, min: 1, max: 1}], color: '#FF0000' },
			'orange_dark_concrete': { imgSrc: 'Dark Orange Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'orange_dark_concrete', chance: 1, min: 1, max: 1}], color: '#FFA500' },
			'yellow_dark_concrete': { imgSrc: 'Dark Yellow Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'yellow_dark_concrete', chance: 1, min: 1, max: 1}], color: '#FFFF00' },
			'green_dark_concrete': { imgSrc: 'Dark Green Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'green_dark_concrete', chance: 1, min: 1, max: 1}], color: '#008000' },
			'cyan_dark_concrete': { imgSrc: 'Dark Cyan Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'cyan_dark_concrete', chance: 1, min: 1, max: 1}], color: '#00FFFF' },
			'blue_light_concrete': { imgSrc: 'Light Blue Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'blue_light_concrete', chance: 1, min: 1, max: 1}], color: '#0000FF' },
			'purple_light_concrete': { imgSrc: 'Light Purple Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'purple_light_concrete', chance: 1, min: 1, max: 1}], color: '#800080' },
			'pink_light_concrete': { imgSrc: 'Light Pink Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'pink_light_concrete', chance: 1, min: 1, max: 1}], color: '#FFC0CB' },
			'red_light_concrete': { imgSrc: 'Light Red Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'red_light_concrete', chance: 1, min: 1, max: 1}], color: '#FF0000' },
			'orange_light_concrete': { imgSrc: 'Light Orange Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'orange_light_concrete', chance: 1, min: 1, max: 1}], color: '#FFA500' },
			'yellow_light_concrete': { imgSrc: 'Light Yellow Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'yellow_light_concrete', chance: 1, min: 1, max: 1}], color: '#FFFF00' },
			'green_light_concrete': { imgSrc: 'Light Green Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'green_light_concrete', chance: 1, min: 1, max: 1}], color: '#008000' },
			'cyan_light_concrete': { imgSrc: 'Light Cyan Concrete Block.png', solid: true, miningHardness: 600, drops: [{item: 'cyan_light_concrete', chance: 1, min: 1, max: 1}], color: '#00FFFF' },
			'vulcanized_rubber': { imgSrc: 'Vulcanized Rubber Block.png', solid: true, miningHardness: 200, drops: [{item: 'vulcanized_rubber', chance: 1, min: 1, max: 1}], color: '#3A3B3C' },
            'vine_stone': { imgSrc: 'Vine Stone Block.png', solid: true, miningHardness: 550, drops: [{item: 'stone', chance: 1, min: 1, max: 1}], color: '#556B2F' },
            'packed_ice': { imgSrc: 'Packed Ice Block.png', solid: true, miningHardness: 80, drops: [{item: 'packed_ice', chance: 1, min: 1, max: 1}], color: '#ADD8E6' },
			'ice': { imgSrc: 'Ice Block.png', solid: true, miningHardness: 50, drops: [{item: 'ice', chance: 1, min: 1, max: 1}], color: '#ADD8E6' },
            'hell_ice': { imgSrc: 'Hell Ice Block.png', solid: true, miningHardness: 110, drops: [{item: 'hell_ice', chance: 1, min: 1, max: 1}], color: '#4878e6' },
			'gravel': { imgSrc: 'Gravel Block.png', solid: true, miningHardness: 160, drops: [{item: 'gravel', chance: 1, min: 1, max: 1}], color: '#A9A9A9', shovelBlock: true }, // Used to be 60 hardness
            // Overgrown Forest Blocks
            'moss_dirt': { imgSrc: 'Moss Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#556B2F', shovelBlock: true },
			'dark_moss_dirt': { imgSrc: 'Dark Moss Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#4A442A', shovelBlock: true },
			'moss_soil': { imgSrc: 'Moss Soil Block.png', solid: true, miningHardness: 60, drops: [{item: 'soil', chance: 1, min: 1, max: 1}], color: '#556B2F', shovelBlock: true },
			'dark_moss_soil': { imgSrc: 'Dark Moss Soil Block.png', solid: true, miningHardness: 60, drops: [{item: 'soil', chance: 1, min: 1, max: 1}], color: '#4A442A', shovelBlock: true },
            'moss_stone_brick_block': { imgSrc: 'Moss Stone Brick Block.png', solid: true, miningHardness: 510, drops: [{item: 'stone_brick_block', chance: 1, min: 1, max: 1}], color: '#556B2F', shovelBlock: true },
			'dark_moss_stone_brick_block': { imgSrc: 'Dark Moss Stone Brick Block.png', solid: true, miningHardness: 510, drops: [{item: 'stone_brick_block', chance: 1, min: 1, max: 1}], color: '#4A442A', shovelBlock: true },
			'weed_dirt': { imgSrc: 'Weed Dirt Block.png', solid: true, miningHardness: 65, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#5A5030', shovelBlock: true },
            'mud': { imgSrc: 'Mud Block.png', solid: true, miningHardness: 100, drops: [{item: 'mud', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'thick_mud': { imgSrc: 'Thick Mud Block.png', solid: true, miningHardness: 150, drops: [{item: 'thick_mud', chance: 1, min: 1, max: 1}], color: '#5C4033', shovelBlock: true },
			'clay': { imgSrc: 'Clay Block.png', solid: true, miningHardness: 280, drops: [{item: 'clay', chance: 1, min: 1, max: 1}], color: '#47433e', shovelBlock: true },
			'surface_mud': { imgSrc: 'Surface Mud Block.png', solid: true, miningHardness: 110, drops: [{item: 'mud', chance: 1, min: 1, max: 1}, {item: 'leaf', chance: 1, min: 1, max: 3}], color: '#5C4033', shovelBlock: true },
			'grass_mud': { imgSrc: 'Grass Mud Block.png', solid: true, miningHardness: 110, drops: [{item: 'mud', chance: 1, min: 1, max: 1}], color: '#228B22', shovelBlock: true },
			'overgrown_grass_mud': { imgSrc: 'Overgrown Grass Mud Block.png', solid: true, miningHardness: 120, drops: [{item: 'mud', chance: 1, min: 1, max: 1}], color: '#006400', shovelBlock: true },
            'pest_dirt': { imgSrc: 'Pest Dirt Block.png', solid: true, miningHardness: 80, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'pest', chance: 1, min: 1, max: 3}], color: '#6B4226', shovelBlock: true },
            'raw_darkwood': { imgSrc: 'Raw Darkwood Block.png', solid: true, miningHardness: 160, drops: [{item: 'raw_darkwood', chance: 1, min: 1, max: 1}], color: '#2F271B' },
            'darkwood_bush': { imgSrc: 'Darkwood Bush Block.png', solid: true, miningHardness: 25, drops: [{item: 'darkwood_bush', chance: 0.05, min: 1, max: 1}], color: '#3A3125' },
            'planked_darkwood': { imgSrc: 'Planked Darkwood Block.png', solid: true, miningHardness: 160, drops: [{item: 'planked_darkwood', chance: 1, min: 1, max: 1}], color: '#4A3B2F' },
            'pest_stone_block_weak': { imgSrc: 'Pest Stone Block (Weak).png', solid: true, miningHardness: 400, drops: [{item: 'stone', chance: 1, min: 1, max: 1}, {item: 'pest', chance: 1, min: 1, max: 1}], color: '#6A675A', shovelBlock: true },
            'pest_stone_block_strong': { imgSrc: 'Pest Stone Block (Strong).png', solid: true, miningHardness: 600, drops: [{item: 'stone', chance: 1, min: 1, max: 1}, {item: 'pest', chance: 1, min: 1, max: 5}], color: '#5A574A', shovelBlock: true },
            'moss': { imgSrc: 'Moss.png', solid: false, miningHardness: 5, drops: [{item: 'moss_seeds', chance: 0.4, min: 1, max: 3}], color: '#4A5D23' },
            'dark_moss': { imgSrc: 'Dark Moss.png', solid: false, miningHardness: 5, drops: [{item: 'moss_seeds', chance: 0.4, min: 1, max: 3}], color: '#3B4A1C' },
            'weed': { imgSrc: 'Weed.png', solid: false, miningHardness: 5, drops: [{item: 'pest', chance: 0.5, min: 1, max: 1}], color: '#6B8E23' },
            'shroom': { imgSrc: 'Shroom.png', solid: false, miningHardness: 10, drops: [{item: 'shroom', chance: 1, min: 1, max: 1}], color: '#8B0000' },
			'big_shroom': { imgSrc: 'Big Shroom.png', solid: true, miningHardness: 50, drops: [{item: 'big_shroom', chance: 1, min: 1, max: 1}], color: '#8B0000' },
			'devil_shroom': { imgSrc: 'Devil Shroom.png', solid: true, miningHardness: 2500, drops: [{item: 'devil_shroom', chance: 1, min: 1, max: 1}], color: '#4B0082' },
            // ---FARMING SECTION---
            'hay_bale': { imgSrc: 'Hay Bale Block.png', solid: true, miningHardness: 100, drops: [{item: 'hat_bale', chance: 1, min: 1, max: 2}], color: '#E6BF83' },
		    'cotton': { imgSrc: 'Cotton.png', solid: false, miningHardness: 10, drops: [{item: 'cotton_item', chance: 1, min: 1, max: 1}, {item: 'cotton_seeds', chance: 0.5, min: 0, max: 2}], color: '#F0F0F0' },
			'cotton_dirt': { imgSrc: 'Cotton Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'cotton_seeds', chance: 1, min: 1, max: 1}], color: '#F0F0F0', shovelBlock: true },
            'cotton_soil': { imgSrc: 'Cotton Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'cotton_seeds', chance: 1, min: 1, max: 1}], color: '#F0F0F0', shovelBlock: true },
			'cotton_fertilizer': { imgSrc: 'Cotton Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'cotton_seeds', chance: 1, min: 1, max: 1}], color: '#F0F0F0', shovelBlock: true },
			'planted_cotton_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#F0F0F0' },
			'rice': { imgSrc: 'Rice.png', solid: false, miningHardness: 10, drops: [{item: 'rice_item', chance: 1, min: 1, max: 2}, {item: 'rice_seeds', chance: 0.5, min: 0, max: 2}], color: '#FFFFFF' },
            'rice_dirt': { imgSrc: 'Rice Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'rice_seeds', chance: 1, min: 1, max: 1}], color: '#F5F5DC', shovelBlock: true },
            'rice_soil': { imgSrc: 'Rice Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'rice_seeds', chance: 1, min: 1, max: 1}], color: '#F5F5DC', shovelBlock: true },
            'rice_fertilizer': { imgSrc: 'Rice Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'rice_seeds', chance: 1, min: 1, max: 1}], color: '#F5F5DC', shovelBlock: true },
            'planted_rice_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#F5F5DC' },
            'wheat': { imgSrc: 'Wheat.png', solid: false, miningHardness: 10, drops: [{item: 'wheat_item', chance: 1, min: 1, max: 2}, {item: 'wheat_seeds', chance: 0.5, min: 0, max: 3}], color: '#F5DEB3' },
            'wheat_dirt': { imgSrc: 'Wheat Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#F5DEB3', shovelBlock: true },
            'wheat_soil': { imgSrc: 'Wheat Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#F5DEB3', shovelBlock: true },
            'wheat_fertilizer': { imgSrc: 'Wheat Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#F5DEB3', shovelBlock: true },
			'planted_wheat_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#F5DEB3' },
			'barley': { imgSrc: 'Barley.png', solid: false, miningHardness: 10, drops: [{item: 'barley_item', chance: 1, min: 1, max: 2}, {item: 'barley_seeds', chance: 0.5, min: 0, max: 3}], color: '#E6BF83' },
            'barley_dirt': { imgSrc: 'Barley Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#E6BF83', shovelBlock: true },
            'barley_soil': { imgSrc: 'Barley Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#E6BF83', shovelBlock: true },
            'barley_fertilizer': { imgSrc: 'Barley Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#E6BF83', shovelBlock: true },
			'planted_barley_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#E6BF83' },
			'pumpkin': { imgSrc: 'Pumpkin.png', solid: false, miningHardness: 10, drops: [{item: 'pumpkin', chance: 1, min: 1, max: 3}, {item: 'pumpkin_seeds', chance: 0.5, min: 0, max: 3}], color: '#FFA500', spoilable: { into: 'plant_mush', time: 300000 } },
            'pumpkin_dirt': { imgSrc: 'Pumpkin Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'pumpkin_seeds', chance: 1, min: 1, max: 1}], color: '#FFA500', shovelBlock: true },
            'pumpkin_soil': { imgSrc: 'Pumpkin Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'pumpkin_seeds', chance: 1, min: 1, max: 1}], color: '#FFA500', shovelBlock: true },
            'pumpkin_fertilizer': { imgSrc: 'Pumpkin Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'pumpkin_seeds', chance: 1, min: 1, max: 1}], color: '#FFA500', shovelBlock: true },
			'planted_pumpkin_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#FFA500' },
			'tomato_bush': { imgSrc: 'Tomato Bush.png', solid: false, miningHardness: 10, drops: [{item: 'tomato', chance: 1, min: 1, max: 3}, {item: 'tomato_seeds', chance: 0.5, min: 0, max: 3}], color: '#FF0000' },
            'tomato_dirt': { imgSrc: 'Tomato Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'tomato_seeds', chance: 1, min: 1, max: 1}], color: '#FF0000', shovelBlock: true },
            'tomato_soil': { imgSrc: 'Tomato Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'tomato_seeds', chance: 1, min: 1, max: 1}], color: '#FF0000', shovelBlock: true },
            'tomato_fertilizer': { imgSrc: 'Tomato Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'tomato_seeds', chance: 1, min: 1, max: 1}], color: '#FF0000', shovelBlock: true },
			'planted_tomato_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#FF0000' },
			'hop': { imgSrc: 'Hop Plant.png', solid: false, miningHardness: 10, drops: [{item: 'hop_item', chance: 1, min: 1, max: 4}, {item: 'hop_seeds', chance: 0.5, min: 0, max: 3}], color: '#90EE90' },
            'hop_dirt': { imgSrc: 'Hop Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'hop_seeds', chance: 1, min: 1, max: 1}], color: '#90EE90', shovelBlock: true },
            'hop_soil': { imgSrc: 'Hop Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'hop_seeds', chance: 1, min: 1, max: 1}], color: '#90EE90', shovelBlock: true },
            'hop_fertilizer': { imgSrc: 'Hop Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'hop_seeds', chance: 1, min: 1, max: 1}], color: '#90EE90', shovelBlock: true },
			'planted_hop_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#90EE90' },
			'coffee': { imgSrc: 'Coffee.png', solid: false, miningHardness: 10, drops: [{item: 'coffee', chance: 1, min: 1, max: 1}, {item: 'coffee_seeds', chance: 0.5, min: 0, max: 3}], color: '#6F4E37' },
            'coffee_dirt': { imgSrc: 'Coffee Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'coffee_seeds', chance: 1, min: 1, max: 1}], color: '#6F4E37', shovelBlock: true },
            'coffee_soil': { imgSrc: 'Coffee Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'coffee_seeds', chance: 1, min: 1, max: 1}], color: '#6F4E37', shovelBlock: true },
            'coffee_fertilizer': { imgSrc: 'Coffee Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'coffee_seeds', chance: 1, min: 1, max: 1}], color: '#6F4E37', shovelBlock: true },
			'planted_coffee_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#6F4E37' },
			'oat': { imgSrc: 'Oat.png', solid: false, miningHardness: 10, drops: [{item: 'oat_item', chance: 1, min: 1, max: 2}, {item: 'oat_seeds', chance: 0.5, min: 0, max: 3}], color: '#D2B48C' },
            'oat_dirt': { imgSrc: 'Oat Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'oat_seeds', chance: 1, min: 1, max: 1}], color: '#D2B48C', shovelBlock: true },
            'oat_soil': { imgSrc: 'Oat Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'oat_seeds', chance: 1, min: 1, max: 1}], color: '#D2B48C', shovelBlock: true },
            'oat_fertilizer': { imgSrc: 'Oat Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'oat_seeds', chance: 1, min: 1, max: 1}], color: '#D2B48C', shovelBlock: true },
			'planted_oat_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'corn': { imgSrc: 'Corn.png', solid: false, miningHardness: 10, drops: [{item: 'corn_item', chance: 1, min: 1, max: 2}, {item: 'corn_seeds', chance: 0.5, min: 0, max: 3}], color: '#FFD700' },
            'corn_dirt': { imgSrc: 'Corn Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'corn_seeds', chance: 1, min: 1, max: 1}], color: '#FFD700', shovelBlock: true },
            'corn_soil': { imgSrc: 'Corn Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'corn_seeds', chance: 1, min: 1, max: 1}], color: '#FFD700', shovelBlock: true },
            'corn_fertilizer': { imgSrc: 'Corn Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'corn_seeds', chance: 1, min: 1, max: 1}], color: '#FFD700', shovelBlock: true },
			'planted_corn_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#FFD700' },
			'onion': { imgSrc: 'Onion Plant.png', solid: false, miningHardness: 10, drops: [{item: 'onion_item', chance: 1, min: 1, max: 2}, {item: 'onion_seeds', chance: 0.5, min: 0, max: 3}], color: '#F5F5DC' },
            'onion_dirt': { imgSrc: 'Onion Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'onion_seeds', chance: 1, min: 1, max: 1}], color: '#F5F5DC', shovelBlock: true },
            'onion_soil': { imgSrc: 'Onion Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'onion_seeds', chance: 1, min: 1, max: 1}], color: '#F5F5DC', shovelBlock: true },
            'onion_fertilizer': { imgSrc: 'Onion Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'onion_seeds', chance: 1, min: 1, max: 1}], color: '#F5F5DC', shovelBlock: true },
			'planted_onion_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#F5F5DC' },
			'garlic': { imgSrc: 'Garlic Plant.png', solid: false, miningHardness: 10, drops: [{item: 'garlic_item', chance: 1, min: 1, max: 3}, {item: 'garlic_seeds', chance: 0.5, min: 0, max: 3}], color: '#FDF5E6' },
            'garlic_dirt': { imgSrc: 'Garlic Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'garlic_seeds', chance: 1, min: 1, max: 1}], color: '#FDF5E6', shovelBlock: true },
            'garlic_soil': { imgSrc: 'Garlic Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'garlic_seeds', chance: 1, min: 1, max: 1}], color: '#FDF5E6', shovelBlock: true },
            'garlic_fertilizer': { imgSrc: 'Garlic Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'garlic_seeds', chance: 1, min: 1, max: 1}], color: '#FDF5E6', shovelBlock: true },
			'planted_garlic_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#FDF5E6' },
			'chili_pepper_bush': { imgSrc: 'Chili Pepper Bush.png', solid: false, miningHardness: 10, drops: [{item: 'chili_pepper', chance: 1, min: 1, max: 4}, {item: 'chili_pepper_seeds', chance: 0.5, min: 0, max: 3}], color: '#FF0000' },
            'chili_pepper_dirt': { imgSrc: 'Chili Pepper Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'chili_pepper_seeds', chance: 1, min: 1, max: 1}], color: '#FF0000', shovelBlock: true },
            'chili_pepper_soil': { imgSrc: 'Chili Pepper Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'chili_pepper_seeds', chance: 1, min: 1, max: 1}], color: '#FF0000', shovelBlock: true },
            'chili_pepper_fertilizer': { imgSrc: 'Chili Pepper Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'chili_pepper_seeds', chance: 1, min: 1, max: 1}], color: '#FF0000', shovelBlock: true },
			'planted_chili_pepper_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#FF0000' },
			'potato_stem': { imgSrc: 'Potato Stem.png', solid: false, miningHardness: 10, drops: [{item: 'potato', chance: 1, min: 1, max: 2}, {item: 'potato_seeds', chance: 0.5, min: 0, max: 3}], color: '#D2B48C' },
            'potato_dirt': { imgSrc: 'Potato Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'potato_seeds', chance: 1, min: 1, max: 1}], color: '#D2B48C', shovelBlock: true },
            'potato_soil': { imgSrc: 'Potato Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'potato_seeds', chance: 1, min: 1, max: 1}], color: '#D2B48C', shovelBlock: true },
            'potato_fertilizer': { imgSrc: 'Potato Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'potato_seeds', chance: 1, min: 1, max: 1}], color: '#D2B48C', shovelBlock: true },
			'planted_potato_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
            // Golden City/Gilded Forest & Sky Island Blocks
            'gilded_grass_dirt_block': { imgSrc: 'Gilded Grass Dirt Block.png', solid: true, miningHardness: 80, drops: [{item: 'gilded_dirt_block', chance: 1, min: 1, max: 1}], color: '#F0E68C', shovelBlock: true },
            'gilded_dirt_block': { imgSrc: 'Gilded Dirt Block.png', solid: true, miningHardness: 70, drops: [{item: 'gilded_dirt_block', chance: 1, min: 1, max: 1}], color: '#DAA520', shovelBlock: true },
            'raw_gilded_wood': { imgSrc: 'Raw Gilded Wood Block.png', solid: true, miningHardness: 180, drops: [{item: 'raw_gilded_wood', chance: 1, min: 1, max: 1}], color: '#BDB76B' },
            'planked_gilded_wood': { imgSrc: 'Planked Gilded Wood Block.png', solid: true, miningHardness: 180, drops: [{item: 'planked_gilded_wood', chance: 1, min: 1, max: 1}], color: '#CFB53B' },
            'gilded_tree_bush': { imgSrc: 'Gilded Tree Bush Block.png', solid: true, miningHardness: 30, drops: [{item: 'gilded_tree_bush', chance: 0.05, min: 1, max: 1}], color: '#FFD700' },
            'cloud_block': { imgSrc: 'Cloud Block.png', solid: true, miningHardness: 10, drops: [], color: '#F0F8FF', shovelBlock: true },
			'cloud_rock_block': { imgSrc: 'Cloud Rock Block.png', solid: true, miningHardness: 500, drops: [{item: 'cloud_rock_block', chance: 1, min: 1, max: 1}], color: '#D3D3D3' },
			'diviniron_cloud_block': { imgSrc: 'Diviniron Cloud Block.png', solid: true, miningHardness: 15, drops: [{item: 'diviniron_nugget', chance: 1, min: 1, max: 1}], color: '#E6E8FA' },
			'heavensteel_cloud_block': { imgSrc: 'Heavensteel Cloud Block.png', solid: true, miningHardness: 15, drops: [{item: 'heavensteel_nugget', chance: 1, min: 1, max: 3}], color: '#F0EAD6' },
			'corroded_heaven_debris_block': { imgSrc: 'Corroded Heaven Debris Block.png', solid: true, miningHardness: 500, drops: [{item: 'corroded_heaven_debris_block', chance: 1, min: 1, max: 1}], color: '#BC8F8F' },
			'ancient_heaven_debris_block': { imgSrc: 'Ancient Heaven Debris Block.png', solid: true, miningHardness: 2000, drops: [{item: 'ancient_heaven_debris_block', chance: 1, min: 1, max: 1}], color: '#A9A9A9' },
			'strong_heaven_debris_block': { imgSrc: 'Strong Heaven Debris Block.png', solid: true, miningHardness: 8000, drops: [{item: 'strong_heaven_debris_block', chance: 1, min: 1, max: 1}], color: '#778899' },
			'pure_heaven_debris_block': { imgSrc: 'Pure Heaven Debris Block.png', solid: true, miningHardness: 25000, drops: [{item: 'pure_heaven_debris_block', chance: 1, min: 1, max: 1}], color: '#FDF5E6' },
			'heaven_gate_brick_block': { imgSrc: 'Heaven Gate Brick Block.png', solid: true, miningHardness: 75000, drops: [{item: 'heaven_gate_brick_block', chance: 1, min: 1, max: 1}], color: '#FFD700' },
			'ruin_heaven_gate_brick_block': { imgSrc: 'Ruin Heaven Gate Brick Block.png', solid: true, miningHardness: 75000, drops: [{item: 'ruin_heaven_gate_brick_block', chance: 0.9, min: 1, max: 1}, {item: 'corroded_heaven_debris_block', chance: 0.1, min: 1, max: 1}], color: '#FFD700' },
			'heaven_portal': { imgSrc: 'Heaven Portal.png', solid: false, miningHardness: 75000, drops: [], color: '#00BFFF' },
			'meat_block': { imgSrc: 'Meat Block.png', solid: true, miningHardness: 200, drops: [{item: 'meat_block', chance: 0.1, min: 1, max: 1}, {item: 'beef', chance: 0.3, min: 1, max: 3}, {item: 'pork', chance: 0.3, min: 1, max: 3}, {item: 'human_flesh', chance: 0.2, min: 1, max: 3}], color: '#9e6655', shovelBlock: true },
			'spoiled_meat_block': { imgSrc: 'Spoiled Meat Block.png', solid: true, miningHardness: 200, drops: [{item: 'spoiled_meat_block', chance: 0.1, min: 1, max: 1}, {item: 'spoiled_beef', chance: 0.3, min: 1, max: 3}, {item: 'spoiled_pork', chance: 0.3, min: 1, max: 3}, {item: 'human_flesh', chance: 0.2, min: 1, max: 3}], color: '#cfd99f', shovelBlock: true },
			'flesh_block': { imgSrc: 'Flesh Block.png', solid: true, miningHardness: 300, drops: [{item: 'flesh_block', chance: 1, min: 1, max: 1}], color: '#FFC0CB', shovelBlock: true },
			// Super Heaven
			'super_mineral': { imgSrc: 'Super Mineral Block.png', solid: true, miningHardness: 1000, drops: [{item: 'super_mineral', chance: 1, min: 1, max: 1}], color: '#D3D3D3', shovelBlock: true },
			'infinitungsten_super_mineral': { imgSrc: 'Infinitungsten Super Mineral Block.png', solid: true, miningHardness: 1500, drops: [{item: 'impure_infinitungsten_nugget', chance: 0.3, min: 1, max: 3}], color: '#D3D3D3', shovelBlock: true },
			// IMPLEMENTED
			'bone_block': { imgSrc: 'Bone Block.png', solid: true, miningHardness: 500, drops: [{item: 'bone_block', chance: 1, min: 1, max: 1}], color: '#F5F5DC' },
			'obsidian_block': { imgSrc: 'Obsidian Block.png', solid: true, miningHardness: 300, drops: [{item: 'obsidian_block', chance: 1, min: 1, max: 1}], color: '#3C2A4D' },
			'ash_block': { imgSrc: 'Ash Block.png', solid: true, miningHardness: 40, drops: [{item: 'ash_block', chance: 1, min: 1, max: 1}], color: '#A9A9A9', shovelBlock: true },
			'ant_larva_block': { imgSrc: 'Ant Larva Block.png', solid: true, miningHardness: 30, drops: [/*ADD_DROPS*/], color: '#F5F5DC', shovelBlock: true },
			'blueglow_grass_dirt_block': { imgSrc: 'Blueglow Grass Dirt Block.png', solid: true, miningHardness: 80, drops: [{item: 'blueglow_dirt_block', chance: 1, min: 1, max: 1}], color: '#00BFFF', shovelBlock: true },
            'blueglow_dirt_block': { imgSrc: 'Blueglow Dirt Block.png', solid: true, miningHardness: 70, drops: [{item: 'blueglow_dirt_block', chance: 1, min: 1, max: 1}], color: '#00BFFF', shovelBlock: true },
			'blueglow_grass_soil_block': { imgSrc: 'Blueglow Grass Soil Block.png', solid: true, miningHardness: 80, drops: [{item: 'blueglow_soil_block', chance: 1, min: 1, max: 1}], color: '#00BFFF', shovelBlock: true },
            'blueglow_soil_block': { imgSrc: 'Blueglow Soil Block.png', solid: true, miningHardness: 70, drops: [{item: 'blueglow_soil_block', chance: 1, min: 1, max: 1}], color: '#00BFFF', shovelBlock: true },
			// To Be Implemented Into Future Biomes
			// Experimental And In Waiting
			'flesh_grass_dirt_block': { imgSrc: 'Flesh Grass Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#FFC0CB', shovelBlock: true },
			'flesh_grass_soil_block': { imgSrc: 'Flesh Grass Soil Block.png', solid: true, miningHardness: 60, drops: [{item: 'soil', chance: 1, min: 1, max: 1}], color: '#FFC0CB', shovelBlock: true },
			'flesh_hellstone': { imgSrc: 'Flesh Hellstone Block.png', solid: true, miningHardness: 510, drops: [{item: 'hellstone', chance: 1, min: 1, max: 1}], color: '#FFC0CB' },
			'doom_grass_dirt_block': { imgSrc: 'Doom Grass Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#4B0082', shovelBlock: true },
			'doom_grass_soil_block': { imgSrc: 'Doom Grass Soil Block.png', solid: true, miningHardness: 60, drops: [{item: 'soil', chance: 1, min: 1, max: 1}], color: '#4B0082', shovelBlock: true },
			'doom_hellstone': { imgSrc: 'Doom Hellstone Block.png', solid: true, miningHardness: 510, drops: [{item: 'hellstone', chance: 1, min: 1, max: 1}], color: '#4B0082' },
			// World Creator Blocks
			'invisible_barrier': { imgSrc: 'Barrier Invisible.png', solid: true, miningHardness: 50, drops: [], color: 'transparent', requiredTool: 'test_axe' },
			'visible_barrier': { imgSrc: 'Barrier Visible.png', solid: true, miningHardness: 50, drops: [], color: '#FF0000', requiredTool: 'test_axe' },
			'master_block': { imgSrc: 'Stone Block.png', solid: true, miningHardness: -1, drops: [{item: 'stone', chance: 1, min: 240, max: 240}], color: '#999999' },
			'test_block_mine_power': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 100, drops: [{item: 'stone', chance: 1, min: 1, max: 1}], color: '#999999', requiredMiningPower: 0.5 },
			'test_block_test_axe': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 100, drops: [{item: 'stone', chance: 1, min: 1, max: 1}], color: '#999999', requiredTool: 'test_axe' },
            'test_block_shovel': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 100, drops: [{item: 'stone', chance: 1, min: 1, max: 1}], color: '#999999', shovelBlock: true },
            'raw_test_block_axe': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 100, drops: [{item: 'stone', chance: 1, min: 1, max: 1}], color: '#999999' },
			// Walls
            'stone_wall': { imgSrc: 'Stone Wall.png', solid: false, miningHardness: 250, drops: [{item: 'stone_wall', chance: 1, min: 1, max: 1}], color: '#808080' },
            'compacted_stone_wall': { imgSrc: 'Compacted Stone Wall.png', solid: false, miningHardness: 250, drops: [{item: 'compacted_stone_wall', chance: 1, min: 1, max: 1}], color: '#708090' },
            'compressed_stone_wall': { imgSrc: 'Compressed Stone Wall.png', solid: false, miningHardness: 250, drops: [{item: 'compressed_stone_wall', chance: 1, min: 1, max: 1}], color: '#5A6A78' },
            'sandstone_wall': { imgSrc: 'Sandstone Wall.png', solid: false, miningHardness: 225, drops: [{item: 'sandstone_wall', chance: 1, min: 1, max: 1}], color: '#E3B48E' },
            'iron_brick_wall': { imgSrc: 'Iron Brick Wall.png', solid: false, miningHardness: 250, drops: [{item: 'iron_brick_wall', chance: 1, min: 1, max: 1}], color: '#A19D94' },
			'planked_oak_wall': { imgSrc: 'Planked Oak Wall.png', solid: false, miningHardness: 75, drops: [{item: 'planked_oak_wall', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'planked_birch_wall': { imgSrc: 'Planked Birch Wall.png', solid: false, miningHardness: 75, drops: [{item: 'planked_birch_wall', chance: 1, min: 1, max: 1}], color: '#F5DEB3' },
			'planked_spruce_wall': { imgSrc: 'Planked Spruce Wall.png', solid: false, miningHardness: 75, drops: [{item: 'planked_spruce_wall', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'hellstone_wall': { imgSrc: 'Hellstone Wall.png', solid: false, miningHardness: 250, drops: [{item: 'hellstone_wall', chance: 1, min: 1, max: 1}], color: '#B22222' },
			// Special Versions:
			// Viking Block Ship Prototype
			'viking_wood': { imgSrc: 'Viking Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'viking_wood', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'warped_viking_wood': { imgSrc: 'Warped Viking Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'warped_viking_wood', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'viking_wood_wall': { imgSrc: 'Viking Wood Wall.png', solid: false, miningHardness: 75, drops: [{item: 'viking_wood_wall', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'warped_viking_wood_wall': { imgSrc: 'Warped Viking Wood Wall.png', solid: false, miningHardness: 75, drops: [{item: 'warped_viking_wood_wall', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'viking_wood_pole': { imgSrc: 'Viking Wood Pole.png', solid: false, miningHardness: 50, drops: [{item: 'viking_wood_pole', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			// The Brickening (2025)
			'industrial_brick_block': { imgSrc: 'Industrial Brick Block.png', solid: true, miningHardness: 400, drops: [{item: 'industrial_brick_block', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'industrial_block': { imgSrc: 'Industrial Block.png', solid: true, miningHardness: 600, drops: [{item: 'industrial_block', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'industrial_rubber_block': { imgSrc: 'Industrial Rubber Block.png', solid: true, miningHardness: 200, drops: [{item: 'industrial_rubber_block', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'industrial_top_rubber_block': { imgSrc: 'Industrial Top Rubber Block.png', solid: true, miningHardness: 400, drops: [{item: 'industrial_top_rubber_block', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'industrial_bottom_rubber_block': { imgSrc: 'Industrial Bottom Rubber Block.png', solid: true, miningHardness: 400, drops: [{item: 'industrial_bottom_rubber_block', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'mechanical_brick_block': { imgSrc: 'Mechanical Brick Block.png', solid: true, miningHardness: 400, drops: [{item: 'mechanical_brick_block', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'mechanical_block': { imgSrc: 'Mechanical Block.png', solid: true, miningHardness: 600, drops: [{item: 'mechanical_block', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'mechanical_rubber_block': { imgSrc: 'Mechanical Rubber Block.png', solid: true, miningHardness: 200, drops: [{item: 'mechanical_rubber_block', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'mechanical_top_rubber_block': { imgSrc: 'Mechanical Top Rubber Block.png', solid: true, miningHardness: 400, drops: [{item: 'mechanical_top_rubber_block', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'mechanical_bottom_rubber_block': { imgSrc: 'Mechanical Bottom Rubber Block.png', solid: true, miningHardness: 400, drops: [{item: 'mechanical_bottom_rubber_block', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'saw_brick_block': { imgSrc: 'Saw Brick Block.png', solid: true, miningHardness: 400, drops: [{item: 'saw_brick_block', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'drone_brick_block': { imgSrc: 'Drone Brick Block.png', solid: true, miningHardness: 400, drops: [{item: 'drone_brick_block', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
			'rover_brick_block': { imgSrc: 'Rover Brick Block.png', solid: true, miningHardness: 400, drops: [{item: 'rover_brick_block', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
		};

        // Item types and their properties (imgSrc, isTool, miningPower, maxDurability, color - for fallback)
        let itemTypes = {
			 'cooked_beef': { imgSrc: 'Cooked Beef.png', color: '#802600', isFood: true, healAmount: 12 },
			 'cooked_pork': { imgSrc: 'Cooked Pork.png', color: '#D2B48C', isFood: true, healAmount: 10 },
			 'wooden_bowl': { imgSrc: 'Wooden Bowl.png', color: '#8B4513' },
			 'glass_cup': { imgSrc: 'Glass Cup.png', color: '#AFEEEE' },
             'asphalt_fragment': { imgSrc: 'Asphalt Fragment.png', color: '#36454F' },
			 'void_dust': { imgSrc: 'Void Dust.png', color: '#6b8683' },
			 'nitro_powder': { imgSrc: 'Nitro Powder.png', color: '#FFFF00' },
			 'saltpeter': { imgSrc: 'Saltpeter.png', color: '#FFFF00' },
			 'crude_oil_chunk': { imgSrc: 'Crude Oil Chunk.png', color: '#000000' },
             'snow_ball': { imgSrc: 'Snow Ball.png', color: '#FFFAFA' },
             'prickly_pear_fruit': { imgSrc: 'Prickly Pear Fruit.png', color: '#FF00FF', isFood: true, healAmount: 3 },
             'wooden_stick': { imgSrc: 'Wooden Stick.png', color: '#8B4513' },
			 'wield_wooden_stick': { imgSrc: 'Wield Wooden Stick.png', color: '#8B4513' },
             'colony_heart': { imgSrc: 'Colony Heart.png', color: '#FF0000' },
			 'paper': { imgSrc: 'Paper.png', color: '#FFFFFF' },
			 'soggy_paper': { imgSrc: 'Paper.png', color: '#D3D3D3' },
			 'book': { imgSrc: 'Book.png', color: '#8B4513', isBook: true, isTool: true, miningPower: 0.1, maxDurability: 1000 },
			 'cinnamon': { imgSrc: 'Cinnamon.png', color: '#D2691E' },
			 'bronze_coin': { imgSrc: 'Bronze Coin.png', color: '#CD7F32' },
			 'gold_coin': { imgSrc: 'Gold Coin.png', color: '#FFD700' },
			 // ---NUGGETS---
             'coal': { imgSrc: 'Coal Nugget.png', color: '#36454F' },
			 'pure_fuel': { imgSrc: 'Pure Fuel.png', color: '#FFFF00' },
			 // Metals
			 'copper_nugget': { imgSrc: 'Copper Nugget.png', color: '#B87333' },
			 'tin_nugget': { imgSrc: 'Tin Nugget.png', color: '#C0C0C0' },
			 'zinc_nugget': { imgSrc: 'Zinc Nugget.png', color: '#B0C4DE' },
             'bronze_nugget': { imgSrc: 'Bronze Nugget.png', color: '#CD7F32' },
			 'brass_nugget': { imgSrc: 'Brass Nugget.png', color: '#B5A642' },
             'iron_nugget': { imgSrc: 'Iron Nugget.png', color: '#A19D94' },
			 'tungsten_nugget': { imgSrc: 'Tungsten Nugget.png', color: '#8B8B83' },
			 'steel_nugget': { imgSrc: 'Steel Nugget.png', color: '#43464B' },
             'gold_nugget': { imgSrc: 'Gold Nugget.png', color: '#FFD700' },
			 'hellsteel_nugget': { imgSrc: 'Hellsteel Nugget.png', color: '#FF4500' },
			 'diviniron_nugget': { imgSrc: 'Diviniron Nugget.png', color: '#E6E8FA' },
			 'mighterrum_nugget': { imgSrc: 'Mighterrum Nugget.png', color: '#FFFF00' },
			 'heavensteel_nugget': { imgSrc: 'Heavensteel Nugget.png', color: '#F0EAD6' },
			 'impure_infinitungsten_nugget': { imgSrc: 'Impure Infinitungsten Nugget.png', color: '#8B8B83' },
			 'infinitungsten_nugget': { imgSrc: 'Infinitungsten Nugget.png', color: '#8B8B83' },
			 'mythicalithium_nugget': { imgSrc: 'Mythicalithium Nugget.png', color: '#8A2BE2' },
             'nuclear_core': { imgSrc: 'Nuclear Core.png', color: '#ADFF2F' },
			 'power_orb': { imgSrc: 'Power Orb.png', color: '#00BFFF' },
             'impotent_orb': { imgSrc: 'Impotent Orb.png', color: '#00BFFF' },
			 'nickel_nugget': { imgSrc: 'Nickel Nugget.png', color: '#BEBEBE' },
			 'lead_nugget': { imgSrc: 'Lead Nugget.png', color: '#778899' },
			 'aluminum_nugget': { imgSrc: 'Aluminum Nugget.png', color: '#D3D3D3' },
			 'palladium_nugget': { imgSrc: 'Palladium Nugget.png', color: '#E6E8FA' },
			 // 'tungsten_nugget': { imgSrc: 'Tungsten Nugget.png', color: '#FFD700' }, // Duplicate, already defined
			 // Coming Soon
			 'titanium_nugget': { imgSrc: 'Titanium Nugget.png', color: '#C0C0C0' }, // High Durability and Iron-Level Strength
			 // Gemstones
             'diamond_nugget': { imgSrc: 'Diamond Nugget.png', color: '#B9F2FF' },
			 'ruby_nugget': { imgSrc: 'Ruby Nugget.png', color: '#E0115F' },
			 'topaz_nugget': { imgSrc: 'Topaz Nugget.png', color: '#FFC87C' },
             'sapphire_nugget': { imgSrc: 'Sapphire Nugget.png', color: '#0F52BA' },
             'emerald_nugget': { imgSrc: 'Emerald Nugget.png', color: '#50C878' },
             'amethyst_nugget': { imgSrc: 'Amethyst Nugget.png', color: '#9966CC' },
             'opal_nugget': { imgSrc: 'Opal Nugget.png', color: '#E0E9E7' },
			 'jade_nugget': { imgSrc: 'Jade Nugget.png', color: '#00A86B' },
			 // ---FARMING SECTION---
			 'plant_mush': { imgSrc: 'Plant Mush.png', color: '#556B2F', isFood: true, healAmount: 1 },
			 'grass_seeds': { imgSrc: 'Grass Seeds.png', color: '#32CD32' },
			 'moss_seeds': { imgSrc: 'Moss Seeds.png', color: '#4A5D23' },
			 'tomato_seeds': { imgSrc: 'Tomato Seeds.png', color: '#FF6347' },
             'tomato': { imgSrc: 'Tomato.png', color: '#FF0000', isFood: true, healAmount: 2, spoilable: { into: 'plant_mush', time: 300000 } },
			 'wheat_seeds': { imgSrc: 'Wheat Seeds.png', color: '#F5DEB3' },
			 'wheat_item': { imgSrc: 'Wheat.png', color: '#F5DEB3', spoilable: { into: 'plant_mush', time: 300000 } },
			 'pumpkin_seeds': { imgSrc: 'Pumpkin Seeds.png', color: '#FFA500' },
			 'barley_seeds': { imgSrc: 'Barley Seeds.png', color: '#E6BF83' },
			 'barley_item': { imgSrc: 'Barley.png', color: '#E6BF83', spoilable: { into: 'plant_mush', time: 300000 } },
			 'cotton_seeds': { imgSrc: 'Cotton Seeds.png', color: '#F0F0F0' },
             'cotton_item': { imgSrc: 'Cotton.png', color: '#F5F5F5', spoilable: { into: 'plant_mush', time: 300000 } },
             'rice_seeds': { imgSrc: 'Rice Seeds.png', color: '#F5F5DC' },
             'rice_item': { imgSrc: 'Rice.png', color: '#FFFFFF', spoilable: { into: 'plant_mush', time: 300000 } },
			 'hop_seeds': { imgSrc: 'Hop Seeds.png', color: '#90EE90' },
             'hop_item': { imgSrc: 'Hop.png', color: '#90EE90', spoilable: { into: 'plant_mush', time: 300000 } },
			 'coffee_seeds': { imgSrc: 'Coffee Seeds.png', color: '#6F4E37' },
			 'oat_seeds': { imgSrc: 'Oat Seeds.png', color: '#D2B48C' },
             'oat_item': { imgSrc: 'Oat.png', color: '#D2B48C', spoilable: { into: 'plant_mush', time: 300000 } },
			 'corn_seeds': { imgSrc: 'Corn Seeds.png', color: '#FFD700' },
             'corn_item': { imgSrc: 'Corn.png', color: '#FFD700', isFood: true, healAmount: 3, spoilable: { into: 'plant_mush', time: 300000 } },
			 'garlic_seeds': { imgSrc: 'Garlic Seeds.png', color: '#FDF5E6' },
			 'garlic_item': { imgSrc: 'Garlic.png', color: '#FDF5E6', isFood: true, healAmount: 1, spoilable: { into: 'plant_mush', time: 300000 } },
			 'onion_seeds': { imgSrc: 'Onion Seeds.png', color: '#F5F5DC' },
			 'onion_item': { imgSrc: 'Onion.png', color: '#F5F5DC', isFood: true, healAmount: 1, spoilable: { into: 'plant_mush', time: 300000 } },
			 'chili_pepper_seeds': { imgSrc: 'Chili Pepper Seeds.png', color: '#FF0000' },
			 'chili_pepper': { imgSrc: 'Chili Pepper.png', color: '#FF0000', isFood: true, healAmount: 1, spoilable: { into: 'plant_mush', time: 300000 } },
			 'potato_seeds': { imgSrc: 'Potato Seeds.png', color: '#D2B48C' },
			 'potato': { imgSrc: 'Potato.png', color: '#D2B48C', isFood: true, healAmount: 3, spoilable: { into: 'moldy_potato', time: 300000 } },
			 'moldy_potato': { imgSrc: 'Moldy Potato.png', color: '#556B2F', isFood: true, healAmount: -4, spoilable: { into: 'plant_mush', time: 300000 } },
			 // ---(CRAFTED) FOOD/DRINK SECTION---
			 'taco_salad': { imgSrc: 'Taco Salad.png', color: '#FFFFFF', isFood: true, healAmount: 12 },
			 'mushroom_soup': { imgSrc: 'Mushroom Soup.png', color: '#8B4513', isFood: true, healAmount: 4 },
			 'tomato_soup': { imgSrc: 'Tomato Soup.png', color: '#FF6347', isFood: true, healAmount: 7 },
			 'power_soup': { imgSrc: 'Power Soup.png', color: '#00BFFF', isFood: true, healAmount: 100, addsMaxHealth: 10, fullHeal: true },
			 'tomato_sandwich': { imgSrc: 'Tomato Sandwich.png', color: '#FF6347', isFood: true, healAmount: 20 },
			 'coffee_bean': { imgSrc: 'Coffee Bean.png', color: '#6F4E37' },
			 'apple': { imgSrc: 'Apple.png', color: '#FF0000', isFood: true, healAmount: 4, spoilable: { into: 'plant_mush', time: 300000 } },
			 'orange': { imgSrc: 'Orange.png', color: '#FFA500', isFood: true, healAmount: 3, spoilable: { into: 'plant_mush', time: 300000 } },
			 'beef': { imgSrc: 'Beef.png', color: '#C04040', isFood: true, healAmount: 8, spoilable: { into: 'spoiled_beef', time: 300000 } },
			 'spoiled_beef': { imgSrc: 'Spoiled Beef.png', color: '#556B2F', isFood: true, healAmount: -5 },
			 'pork': { imgSrc: 'Pork.png', color: '#FFC0CB', isFood: true, healAmount: 6, spoilable: { into: 'spoiled_pork', time: 300000 } },
			 'spoiled_pork': { imgSrc: 'Spoiled Pork.png', color: '#556B2F', isFood: true, healAmount: -5 },
			 'human_flesh': { imgSrc: 'Human Flesh.png', color: '#FFC0CB', isFood: true, healAmount: 1 },
			 'cup_of_water': { imgSrc: 'Cup Of Water.png', color: '#ADD8E6', isFood: true, healAmount: 0 },
			 'cup_of_coffee': { imgSrc: 'Cup Of Coffee.png', color: '#6F4E37', isFood: true, healAmount: 3 },
             'cup_of_pine_needle_tea': { imgSrc: 'Cup Of Pine Needle Tea.png', color: '#2E8B57', isFood: true, healAmount: 1 },
			 'cup_of_beer': { imgSrc: 'Cup Of Beer.png', color: '#FFA500', isFood: true, healAmount: 8, alcoholicPower: 10 },
             'cup_of_vodka': { imgSrc: 'Cup Of Vodka.png', color: '#F0F8FF', isFood: true, healAmount: 3, alcoholicPower: 65 },
			 'cup_of_urine': { imgSrc: 'Cup Of Urine.png', color: '#FFFF00', isFood: true, healAmount: 0 },
			 'cup_of_crude_oil': { imgSrc: 'Cup Of Crude Oil.png', color: '#000000' },
			 'cup_of_gasoline': { imgSrc: 'Cup Of Gasoline.png', color: '#F0E68C' },
			 'pinecone': { imgSrc: 'Pinecone.png', color: '#8B4513' },
			 'pine_needle_living': { imgSrc: 'Pine Needle Living.png', color: '#2E8B57', spoilable: { into: 'pine_needle_dying', time: 50000 } },
			 'pine_needle_dying': { imgSrc: 'Pine Needle Dying.png', color: '#DAA520', spoilable: { into: 'pine_needle_dead', time: 50000 } },
			 'pine_needle_dead': { imgSrc: 'Pine Needle Dead.png', color: '#8B4513' },
             'leaf': { imgSrc: 'Leaf.png', color: '#228B22' },
			 'wheat_bread': { imgSrc: 'Wheat Bread.png', color: '#E6BF83', isFood: true, healAmount: 7 },
			 'barley_bread': { imgSrc: 'Barley Bread.png', color: '#E6BF83', isFood: true, healAmount: 7 },
			 'noodles': { imgSrc: 'Noodles.png', color: '#E6BF83', isFood: true, healAmount: 1 },
			 'cake': { imgSrc: 'Cake.png', color: '#E6BF83', isFood: true, healAmount: 36 },
			 'pumpkin_pie': { imgSrc: 'Pumpkin Pie.png', color: '#E6BF83', isFood: true, healAmount: 36 },
			 'ramen_noodles': { imgSrc: 'Ramen Noodles.png', color: '#E6BF83', isFood: true, healAmount: 30 },
			 'spaghetti': { imgSrc: 'Spaghetti.png', color: '#E6BF83', isFood: true, healAmount: 24 },
			 // Excellent For Cooking!
			 'raw_sugar': { imgSrc: 'Raw Sugar.png', color: '#FFFFFF' },
			 'refined_sugar': { imgSrc: 'Refined Sugar.png', color: '#FFFFFF' },
			 'molasses': { imgSrc: 'Molasses.png', color: '#3A1F04' },
			 'egg': { imgSrc: 'Egg.png', color: '#F0EAD6' },
			 'flour': { imgSrc: 'Flour.png', color: '#F5F5DC' },
			 'rock_salt': { imgSrc: 'Rock Salt.png', color: '#FDF5E6' },
			 'iodized_salt': { imgSrc: 'Iodized Salt.png', color: '#FFFFFF' },
			 'butter': { imgSrc: 'Butter.png', color: '#FFFFE0' },
			 'cup_of_milk': { imgSrc: 'Cup Of Milk.png', color: '#FFFFFF', isFood: true, healAmount: 3 },
			 // ---RUSTED TOOLS---
			 'rusted_iron_pickaxe': { imgSrc: 'Rusted Iron Pickaxe.png', color: '#D2691E', isTool: true, miningPower: 0.1, maxDurability: 5000 },
			 'rusted_steel_pickaxe': { imgSrc: 'Rusted Iron Pickaxe.png', color: '#D2691E', isTool: true, miningPower: 0.15, maxDurability: 15000 },
			 'rusted_ruby_plated_steel_pickaxe': { imgSrc: 'Rusted Ruby Plated Steel Pickaxe.png', color: '#D2691E', isTool: true, miningPower: 0.18, maxDurability: 19000 },
			 'rusted_diamond_plated_steel_pickaxe': { imgSrc: 'Rusted Diamond Plated Steel Pickaxe.png', color: '#D2691E', isTool: true, miningPower: 0.21, maxDurability: 19000 },
			 'rusted_diviniron_pickaxe': { imgSrc: 'Rusted Diviniron Pickaxe.png', color: '#D2691E', isTool: true, miningPower: 0.5, maxDurability: 2000 },
			 // ---PICKAXE SECTION---
			 // Anthill Enchantment Increases Power By x2, But Drops Durability By 20%
			 // Void Enchantment Increases Durability By 50%, But Drops Power By 20%
			 'wooden_pickaxe': { imgSrc: 'Wooden Pickaxe.png', color: '#A0522D', isTool: true, miningPower: 0.2, maxDurability: 7500 },
			 'powered_wooden_pickaxe': { imgSrc: 'Wooden Pickaxe.png', color: '#D2B48C', isTool: true, miningPower: 0.2, maxDurability: 9999999999999 }, // Powered, Durability is 9,999,999,999,999
             'rock_pickaxe': { imgSrc: 'Rock Pickaxe.png', color: '#888888', isTool: true, miningPower: 0.3, maxDurability: 12000 },//
			 'reinforced_rock_pickaxe': { imgSrc: 'Reinforced Rock Pickaxe.png', color: '#888888', isTool: true, miningPower: 0.3, maxDurability: 36000 },
             'copper_pickaxe': { imgSrc: 'Copper Pickaxe.png', color: '#B87333', isTool: true, miningPower: 0.6, maxDurability: 20000 },
             'tin_pickaxe': { imgSrc: 'Tin Pickaxe.png', color: '#C0C0C0', isTool: true, miningPower: 0.5, maxDurability: 8000 },
             'bronze_pickaxe': { imgSrc: 'Bronze Pickaxe.png', color: '#CD7F32', isTool: true, miningPower: 0.8, maxDurability: 35000 },
             'iron_pickaxe': { imgSrc: 'Iron Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 1.0, maxDurability: 38000 },
			 'tungsten_pickaxe': { imgSrc: 'Tungsten Pickaxe.png', color: '#8B8B83', isTool: true, miningPower: 1.5, maxDurability: 32000 },
             'steel_pickaxe': { imgSrc: 'Steel Pickaxe.png', color: '#43464B', isTool: true, miningPower: 1.5, maxDurability: 100000 },//
			 'ruby_plated_steel_pickaxe': { imgSrc: 'Ruby Plated Steel Pickaxe.png', color: '#E0115F', isTool: true, miningPower: 1.8, maxDurability: 120000 },
             'diamond_plated_steel_pickaxe': { imgSrc: 'Diamond Plated Steel Pickaxe.png', color: '#B9F2FF', isTool: true, miningPower: 2.1, maxDurability: 120000 },
			 'mighterrum_pickaxe': { imgSrc: 'Mighterrum Pickaxe.png', color: '#FFFF00', isTool: true, miningPower: 1.0, maxDurability: 30000 },
			 'diviniron_pickaxe': { imgSrc: 'Diviniron Pickaxe.png', color: '#E6E8FA', isTool: true, miningPower: 5.0, maxDurability: 20000 },
			 'hellrock_pickaxe': { imgSrc: 'Hellrock Pickaxe.png', color: '#8B0000', isTool: true, miningPower: 0.5, maxDurability: 16000 }, // +33% Durability, +66% Mining Power
			 'hellsteel_pickaxe': { imgSrc: 'Hellsteel Pickaxe.png', color: '#FF4500', isTool: true, miningPower: 2.5, maxDurability: 133333 }, // +33% Durability, +66% Mining Power
			 'anthill_hellsteel_pickaxe': { imgSrc: 'Anthill Hellsteel Pickaxe.png', color: '#FF0000', isTool: true, miningPower: 5, maxDurability: 106666 },
			 'void_hellsteel_pickaxe': { imgSrc: 'Void Hellsteel Pickaxe.png', color: '#8A2BE2', isTool: true, miningPower: 2, maxDurability: 199999 },
			 'heavenrock_pickaxe': { imgSrc: 'Heavenrock Pickaxe.png', color: '#F0EAD6', isTool: true, miningPower: 0.6, maxDurability: 12000 }, // Same Durability, +100% Mining Power
			 'heavensteel_pickaxe': { imgSrc: 'Heavensteel Pickaxe.png', color: '#F0EAD6', isTool: true, miningPower: 3, maxDurability: 100000 }, // Same Durability, +100% Mining Power
			 'anthill_heavensteel_pickaxe': { imgSrc: 'Anthill Heavensteel Pickaxe.png', color: '#F0EAD6', isTool: true, miningPower: 6, maxDurability: 80000 },
			 'void_heavensteel_pickaxe': { imgSrc: 'Void Heavensteel Pickaxe.png', color: '#8A2BE2', isTool: true, miningPower: 2.4, maxDurability: 150000 },
			 'infinitungsten_pickaxe': { imgSrc: 'Infinitungsten Pickaxe.png', color: '#8B8B83', isTool: true, miningPower: 10.0, maxDurability: 400000 },
             'anthill_infinitungsten_pickaxe': { imgSrc: 'Anthill Infinitungsten Pickaxe.png', color: '#8B8B83', isTool: true, miningPower: 20.0, maxDurability: 320000 },
             'void_infinitungsten_pickaxe': { imgSrc: 'Void Infinitungsten Pickaxe.png', color: '#8B8B83', isTool: true, miningPower: 8.0, maxDurability: 600000 },
			 'mythicalithium_pickaxe': { imgSrc: 'Mythicalithium Pickaxe.png', color: '#8A2BE2', isTool: true, miningPower: 22.0, maxDurability: 700000 },
			 'pest': { imgSrc: 'Pest.png', color: '#6B8E23' },
			 // ---SHOVEL SECTION---
			 'wooden_shovel': { imgSrc: 'Wooden Shovel.png', color: '#A0522D', isTool: true, miningPower: 0.1, shovelPower: 0.2, maxDurability: 7500 },
			 'rock_shovel': { imgSrc: 'Rock Shovel.png', color: '#888888', isTool: true, miningPower: 0.1, shovelPower: 0.3, maxDurability: 12000 },
			 'copper_shovel': { imgSrc: 'Copper Shovel.png', color: '#B87333', isTool: true, miningPower: 0.1, shovelPower: 0.6, maxDurability: 20000 },
			 'tin_shovel': { imgSrc: 'Tin Shovel.png', color: '#C0C0C0', isTool: true, miningPower: 0.1, shovelPower: 0.5, maxDurability: 8000 },
             'iron_shovel': { imgSrc: 'Iron Shovel.png', color: '#A19D94', isTool: true, miningPower: 0.1, shovelPower: 0.8, maxDurability: 38000 },
			 'tungsten_shovel': { imgSrc: 'Tungsten Shovel.png', color: '#8B8B83', isTool: true, miningPower: 0.1, shovelPower: 1.5, maxDurability: 32000 },
			 'bronze_shovel': { imgSrc: 'Bronze Shovel.png', color: '#CD7F32', isTool: true, miningPower: 0.1, shovelPower: 0.8, maxDurability: 35000 },
			 'steel_shovel': { imgSrc: 'Steel Shovel.png', color: '#43464B', isTool: true, miningPower: 0.1, shovelPower: 1.5, maxDurability: 100000 },
			 'infinitungsten_shovel': { imgSrc: 'Infinitungsten Shovel.png', color: '#8B8B83', isTool: true, miningPower: 0.1, shovelPower: 10.0, maxDurability: 400000 },
			 // ---AXE SECTION---
			 'wooden_axe': { imgSrc: 'Wooden Axe.png', color: '#A0522D', isTool: true, miningPower: 0.1, axePower: 0.2, maxDurability: 7500 },
             'rock_axe': { imgSrc: 'Rock Axe.png', color: '#888888', isTool: true, miningPower: 0.1, axePower: 0.3, maxDurability: 12000 },
			 'copper_axe': { imgSrc: 'Copper Axe.png', color: '#B87333', isTool: true, miningPower: 0.1, axePower: 0.6, maxDurability: 20000 },
			 'tin_axe': { imgSrc: 'Tin Axe.png', color: '#C0C0C0', isTool: true, miningPower: 0.1, axePower: 0.5, maxDurability: 8000 },
             'iron_axe': { imgSrc: 'Iron Axe.png', color: '#A19D94', isTool: true, miningPower: 0.1, axePower: 0.8, maxDurability: 38000 },
			 'tungsten_axe': { imgSrc: 'Tungsten Axe.png', color: '#8B8B83', isTool: true, miningPower: 0.1, axePower: 1.5, maxDurability: 32000 },
			 'bronze_axe': { imgSrc: 'Bronze Axe.png', color: '#CD7F32', isTool: true, miningPower: 0.1, axePower: 0.8, maxDurability: 35000 },
			 'steel_axe': { imgSrc: 'Steel Axe.png', color: '#43464B', isTool: true, miningPower: 0.1, axePower: 1.5, maxDurability: 100000 },
			 'infinitungsten_axe': { imgSrc: 'Infinitungsten Axe.png', color: '#8B8B83', isTool: true, miningPower: 0.1, axePower: 10.0, maxDurability: 400000 },
			 // ---GUN SECTION---
			 'wood_bullet': { imgSrc: 'Wood Bullet.png', color: '#43464B', isAmmo: true, ammoPower: 1 },
             'brass_bullet': { imgSrc: 'Brass Bullet.png', color: '#43464B', isAmmo: true, ammoPower: 5 },
             'steel_bullet': { imgSrc: 'Steel Bullet.png', color: '#43464B', isAmmo: true, ammoPower: 12 },
             'mythicalithium_bullet': { imgSrc: 'Mythicalithium Bullet.png', color: '#43464B', isAmmo: true, ammoPower: 235 },
			 'pistol': { imgSrc: 'Pistol.png', color: '#43464B', isTool: true, isGun: true, gunPower: 15, fireRate: 0.6, fireLoss: {min: 30, max: 50}, maxDurability: 20000 },
			 'machine_gun': { imgSrc: 'Machine Gun.png', color: '#43464B', isTool: true, isGun: true, gunPower: 21, fireRate: 0.1, fireLoss: {min: 30, max: 80}, maxDurability: 30000 },
			 'minigun': { imgSrc: 'Minigun.png', color: '#43464B', isTool: true, isGun: true, gunPower: 66, fireRate: 0.05, fireLoss: {min: 30, max: 150}, maxDurability: 35000 },
			 // Currently Useless Item
			 'bucket': { imgSrc: 'Bucket.png', color: '#A9A9A9' },
			 'test_axe': { imgSrc: 'Wooden Pickaxe.png', color: '#A0522D', isTool: true, miningPower: 0.5, maxDurability: 10000 },
			 'hammer_of_infinity': { imgSrc: 'Wooden Pickaxe.png', color: '#A0522D', isTool: true, miningPower: 0.01, maxDurability: 9999999999999 },
			 'hammer_of_eternity': { imgSrc: 'Wooden Pickaxe.png', color: '#A0522D', isTool: true, miningPower: 0.003, maxDurability: 9999999999999 },
			 // Especial
			 'gravity_curd': { color: '#483D8B', isFood: true, healAmount: 0, effectLength: 10, effect: {duration: 5, changes: [ { prop: 'gravity', type: 'set', value: -0.05 } ] } },
			 'speed_snack': { color: '#ADFF2F', isFood: true, healAmount: 0, effectLength: 10, effect: {duration: 15, changes: [ { prop: 'speed', type: 'add', value: 3 } ] } },
			 'jump_juice': { color: '#00BFFF', isFood: true, healAmount: 0, effectLength: 10, effect: {duration: 15, changes: [ { prop: 'jumpStrength', type: 'add', value: -5 } ] } },
			 // Armor
			 'happy_face': { imgSrc: 'Happy Face Icon.png', equippedImgSrc: 'Happy Face.png', color: '#FFFF00', isTool: true, miningPower: 0, armorType: 'helmet', protectionFactor: 0, maxDurability: 1 },
			 'farmer_trader_mask': { imgSrc: 'Farmer Trader Mask Icon.png', equippedImgSrc: 'Farmer Trader Mask.png', color: '#F5DEB3', isTool: true, miningPower: 0, armorType: 'helmet', protectionFactor: 0.02, maxDurability: 8 },
			 'miner_trader_mask': { imgSrc: 'Miner Trader Mask Icon.png', equippedImgSrc: 'Miner Trader Mask.png', color: '#696969', isTool: true, miningPower: 0, armorType: 'helmet', protectionFactor: 0.02, maxDurability: 8 },
			 'trader_mask': { imgSrc: 'Trader Mask Icon.png', equippedImgSrc: 'Trader Mask.png', color: '#8B4513', isTool: true, miningPower: 0, armorType: 'helmet', protectionFactor: 0.02, maxDurability: 8 },
			 'trader_cloak': { imgSrc: 'Trader Cloak Icon.png', equippedImgSrc: 'Trader Cloak.png', color: '#8B4513', isTool: true, miningPower: 0, armorType: 'chestGear', protectionFactor: 0.03, maxDurability: 14 },
			 'trader_pants': { imgSrc: 'Trader Pants Icon.png', equippedImgSrc: 'Trader Pants.png', color: '#00008B', isTool: true, miningPower: 0, armorType: 'legGear', protectionFactor: 0.02, maxDurability: 11 },
			 'trader_shoes': { imgSrc: 'Trader Shoes Icon.png', equippedImgSrc: 'Trader Shoes.png', color: '#4A3B2F', isTool: true, miningPower: 0, armorType: 'boots', protectionFactor: 0.02, maxDurability: 8 },
			 'dark_helmet': { imgSrc: 'Dark Helmet Icon.png', equippedImgSrc: 'Dark Helmet.png', color: '#36454F', isTool: true, miningPower: 0, armorType: 'helmet', protectionFactor: 0.08, maxDurability: 40 },
			 'dark_chestplate': { imgSrc: 'Dark Chestplate Icon.png', equippedImgSrc: 'Dark Chestplate.png', color: '#36454F', isTool: true, miningPower: 0, armorType: 'chestGear', protectionFactor: 0.15, maxDurability: 70 },
			 'dark_pants': { imgSrc: 'Dark Pants Icon.png', equippedImgSrc: 'Dark Pants.png', color: '#36454F', isTool: true, miningPower: 0, armorType: 'legGear', protectionFactor: 0.12, maxDurability: 55 },
			 'dark_boots': { imgSrc: 'Dark Boots Icon.png', equippedImgSrc: 'Dark Boots.png', color: '#36454F', isTool: true, miningPower: 0, armorType: 'boots', protectionFactor: 0.08, maxDurability: 40 },
			 'light_helmet': { imgSrc: 'Light Helmet Icon.png', equippedImgSrc: 'Light Helmet.png', color: '#F0EAD6', isTool: true, miningPower: 0, armorType: 'helmet', protectionFactor: 0.08, maxDurability: 40 },
			 'light_chestplate': { imgSrc: 'Light Chestplate Icon.png', equippedImgSrc: 'Light Chestplate.png', color: '#F0EAD6', isTool: true, miningPower: 0, armorType: 'chestGear', protectionFactor: 0.15, maxDurability: 70 },
			 'light_pants': { imgSrc: 'Light Pants Icon.png', equippedImgSrc: 'Light Pants.png', color: '#F0EAD6', isTool: true, miningPower: 0, armorType: 'legGear', protectionFactor: 0.12, maxDurability: 55 },
			 'light_boots': { imgSrc: 'Light Boots Icon.png', equippedImgSrc: 'Light Boots.png', color: '#F0EAD6', isTool: true, miningPower: 0, armorType: 'boots', protectionFactor: 0.08, maxDurability: 40 },
			 'steel_helmet': { imgSrc: 'Steel Helmet Icon.png', equippedImgSrc: 'Steel Helmet.png', color: '#43464B', isTool: true, miningPower: 0, armorType: 'helmet', protectionFactor: 0.06, maxDurability: 30 },
			 'steel_chestplate': { imgSrc: 'Steel Chestplate Icon.png', equippedImgSrc: 'Steel Chestplate.png', color: '#43464B', isTool: true, miningPower: 0, armorType: 'chestGear', protectionFactor: 0.11, maxDurability: 62 },
			 'steel_pants': { imgSrc: 'Steel Pants Icon.png', equippedImgSrc: 'Steel Pants.png', color: '#43464B', isTool: true, miningPower: 0, armorType: 'legGear', protectionFactor: 0.09, maxDurability: 42 },
			 'steel_boots': { imgSrc: 'Steel Boots Icon.png', equippedImgSrc: 'Steel Boots.png', color: '#43464B', isTool: true, miningPower: 0, armorType: 'boots', protectionFactor: 0.06, maxDurability: 30 },
			 'evil_helmet': { imgSrc: 'Evil Helmet Icon.png', equippedImgSrc: 'Evil Helmet.png', color: '#8B0000', isTool: true, miningPower: 0, armorType: 'helmet', protectionFactor: 0.15, maxDurability: 50 },
			 'diviniron_helmet': { imgSrc: 'Diviniron Helmet Icon.png', equippedImgSrc: 'Diviniron Helmet.png', color: '#E6E8FA', isTool: true, miningPower: 0, armorType: 'helmet', protectionFactor: 0.25, maxDurability: 25 },
             'diviniron_chestplate': { imgSrc: 'Diviniron Chestplate Icon.png', equippedImgSrc: 'Diviniron Chestplate.png', color: '#E6E8FA', isTool: true, miningPower: 0, armorType: 'chestGear', protectionFactor: 0.25, maxDurability: 45 },
			 'diviniron_pants': { imgSrc: 'Diviniron Pants Icon.png', equippedImgSrc: 'Diviniron Pants.png', color: '#E6E8FA', isTool: true, miningPower: 0, armorType: 'legGear', protectionFactor: 0.25, maxDurability: 35 },
             'diviniron_boots': { imgSrc: 'Diviniron Boots Icon.png', equippedImgSrc: 'Diviniron Boots.png', color: '#E6E8FA', isTool: true, miningPower: 0, armorType: 'boots', protectionFactor: 0.25, maxDurability: 25 },
             'sober_mask': { imgSrc: 'Sober Mask Icon.png', equippedImgSrc: 'Sober Mask.png', color: '#D4F0F0', isTool: true, miningPower: 0, armorType: 'helmet', protectionFactor: 0.01, maxDurability: 7 },
             'drunk_mask': { imgSrc: 'Drunk Mask Icon.png', equippedImgSrc: 'Drunk Mask.png', color: '#E0B0D0', isTool: true, miningPower: 0, armorType: 'helmet', protectionFactor: 0.01, maxDurability: 7 },
             'feather_boots': { imgSrc: 'Feather Boots Icon.png', equippedImgSrc: 'Feather Boots.png', color: '#FFFFFF', isTool: true, miningPower: 0, armorType: 'boots', protectionFactor: 0.02, maxDurability: 15, gravityMultiplier: 0.75 },
			 // Armor Construction
             'armor_tile': { imgSrc: 'Armor Tile.png', color: '#A9A9A9' },
			 'dark_armor_tile': { imgSrc: 'Dark Armor Tile.png', color: '#36454F' },
             'light_armor_tile': { imgSrc: 'Light Armor Tile.png', color: '#F0EAD6' },
             'forge_hammer': { imgSrc: 'Forge Hammer.png', color: '#A9A9A9', isTool: true, miningPower: 0.25, maxDurability: 1000 },
			 // Misc 
             'lighter': { imgSrc: 'Lighter.png', color: '#c0c0c0', isTool: true, miningPower: 0, maxDurability: 10 },
		};

        // Breaking stage assets for visual feedback during mining
        const breakingStageAssets = {
            'breaking_stage_1': { imgSrc: 'Breaking Stage 1.png' },
            'breaking_stage_2': { imgSrc: 'Breaking Stage 2.png' },
            'breaking_stage_3': { imgSrc: 'Breaking Stage 3.png' }
        };
		
		const fireAssets = {
			'fire_1': { imgSrc: 'Fire 1.png' },
			'fire_2': { imgSrc: 'Fire 2.png' },
			'fire_3': { imgSrc: 'Fire 3.png' }
		};

        // Health icon assets
        const healthAssets = {
            'full_heart': { imgSrc: 'Full Heart Icon.png' },
            'half_heart': { imgSrc: 'Half Heart Icon.png' },
            'empty_heart': { imgSrc: 'Empty Heart Icon.png' }
        };

        // Combine all assets to load
        const assetsToLoadList = { ...blockTypes, ...itemTypes, ...breakingStageAssets, ...healthAssets, ...fireAssets };
        const assets = {};            // will store loaded Image objects keyed by type name (e.g. assets['dirt'])
		let failedAssets = {};      // track failures
		let assetsToLoad = 0;
		let assetsLoaded = 0;

        // --- Texture Pack Functions ---
        function triggerTextureUpload() {
            const input = document.getElementById('texturePackInput');
            input.value = ''; // Reset to allow re-uploading same folder if needed
            input.click();
        }

        document.getElementById('texturePackInput').addEventListener('change', function(e) {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            const loadingText = document.getElementById('loadingText');
            loadingText.textContent = "Processing Texture Pack...";

            // Group files by name to handle duplicates
            const filesByName = {};
            
            files.forEach(file => {
                // We only care about image files
                if (file.type.startsWith('image/')) {
                    if (!filesByName[file.name]) {
                        filesByName[file.name] = [];
                    }
                    filesByName[file.name].push(file);
                }
            });

            let replacedCount = 0;

            // Iterate keys and pick random if duplicates exist
            Object.keys(filesByName).forEach(filename => {
                const candidates = filesByName[filename];
                const selectedFile = candidates[Math.floor(Math.random() * candidates.length)];
                
                // Create a local URL for the file
                if (textureOverrides[filename]) {
                    URL.revokeObjectURL(textureOverrides[filename]); // Clean up old one
                }
                textureOverrides[filename] = URL.createObjectURL(selectedFile);
                replacedCount++;
            });

            console.log(`Texture Pack: Loaded ${replacedCount} textures.`);
            showMessageBox(`Texture Pack loaded! ${replacedCount} textures replaced. Reloading assets...`, 'alert', () => {
                // --- FIX: Clear all previously loaded assets to force a fresh reload ---
                const groups = getAssetGroups();
                for (const group of groups) {
                    if (!group) continue;
                    for (const key in group) {
                        if (assets[key]) {
                            delete assets[key]; // Remove from our loaded assets cache
                        }
                        // Also delete the equipped asset variants
                        if (group[key]?.equippedImgSrc) {
                             delete assets[`${key}_equipped`];
                        }
                    }
                }
                // --- END FIX ---
            
                // Restart asset loading
                assetsLoaded = 0;
                failedAssets = {}; // Reset failures
                loadAssets(); // This will now generate a new currentLoadID and abort the old one
            });
        });
        
		function getAssetGroups() {
			// Add any other asset maps you use here
			return [blockTypes, itemTypes, breakingStageAssets, healthAssets, fireAssets]; // NEW: Added fireAssets
		}

		function loadAssets() {
			// --- NEW: Create a unique ID for this specific loading process ---
			const thisLoadID = Date.now();
			currentLoadID = thisLoadID;
			// --- END NEW ---

			const loadingText = document.getElementById('loadingText');
			const loadingBarFill = document.getElementById('loadingBarFill');
			const loadingPercent = document.getElementById('loadingPercent');
			
			// --- NEW: Skip Button Logic ---
			const skipButton = document.getElementById('skipLoadingButton');
			let gameStartedManually = false; // Flag to track if "Skip" was clicked
			let tipInterval;

			// "Skip" button click listener
			skipButton.addEventListener('click', () => {
				if (gameStartedManually) return; // Prevent double-clicks
				gameStartedManually = true;
				isLoadingAssets = false; // <<< CRITICAL: This tells the game it's "ready"
				loadingScreen.style.display = 'none';
				skipButton.style.display = 'none';
				if (tipInterval) clearInterval(tipInterval); // Stop tips
				init(); // Start the game!
				// The loadNext() loop will continue running in the background,
				// populating assets as they arrive.
			});
			// --- END NEW Skip Button Logic ---

			function showRandomTip() {
				const randomIndex = Math.floor(Math.random() * loadingTips.length);
				loadingTipText.textContent = `Tip: ${loadingTips[randomIndex]}`;
			}

			showRandomTip(); // Show a tip immediately
			tipInterval = setInterval(showRandomTip, 4000); // Change the tip every 4 seconds

			// Build a map: src -> [typeKey1, typeKey2, ...]
			const srcToKeys = {};
			const groups = getAssetGroups();
			for (const group of groups) {
				if (!group) continue;
				for (const key in group) {
					const src = group[key]?.imgSrc;
					if (!src) continue;
					if (!srcToKeys[src]) srcToKeys[src] = [];
					srcToKeys[src].push(key);

					const equippedSrc = group[key]?.equippedImgSrc;
					if (equippedSrc) {
						const equippedKey = `${key}_equipped`;
						if (!srcToKeys[equippedSrc]) srcToKeys[equippedSrc] = [];
						srcToKeys[equippedSrc].push(equippedKey);
					}
				}
			}

			const srcs = Object.keys(srcToKeys);
			assetsToLoad = srcs.length;
			assetsLoaded = 0;

			if (assetsToLoad === 0) {
				loadingScreen.style.display = 'none';
				init();
				return;
			}

			let idx = 0;
			function updateUI() {
				if (thisLoadID !== currentLoadID) return; // Abort if this is an old load
				const pct = Math.round((assetsLoaded / Math.max(1, assetsToLoad)) * 100);
				
				// --- NEW: Show Skip Button at 20% ---
				if (pct >= 20 && !gameStartedManually) {
					skipButton.style.display = 'block';
				}
				// --- END NEW ---
				
				loadingBarFill.style.width = pct + '%';
				loadingPercent.textContent = pct + '%';
			}

			function finishLoading() {
				if (thisLoadID !== currentLoadID) return; // Abort if old load
				
				// --- NEW: Check if game was already skipped ---
				if (gameStartedManually) {
					console.log("Background asset loading finished.");
					isLoadingAssets = false; // Ensure this is false
					return; // Don't hide screen or call init() again
				}
				// --- END NEW ---

				// This is the normal path (no skip)
				isLoadingAssets = false;
				clearInterval(tipInterval);
				updateUI();
				setTimeout(() => {
					if (thisLoadID !== currentLoadID) return;
					if (gameStartedManually) return; // Final check
					loadingScreen.style.display = 'none';
					skipButton.style.display = 'none'; // Hide button
					init();
				}, 120);
			}

			function loadNext() {
				if (thisLoadID !== currentLoadID) return; // Abort if old load

				if (idx >= srcs.length) {
					finishLoading();
					return;
				}
				const src = srcs[idx];
				
				const filename = src.split('/').pop(); 
				const finalSrc = textureOverrides[filename] || src;
				
				// Update text only if loading screen is still visible
				if (!gameStartedManually) {
					loadingText.textContent = `Loading: ${filename}` + (textureOverrides[filename] ? " (Custom)" : "");
				}

				const img = new Image();
				img.onload = () => {
					if (thisLoadID !== currentLoadID) return; 

					(srcToKeys[src] || []).forEach(typeKey => {
						assets[typeKey] = img;
					});
					assetsLoaded++;
					idx++;
					if (!gameStartedManually) updateUI(); // Only update UI if loading screen is active
					loadNext();
				};
				img.onerror = () => {
					if (thisLoadID !== currentLoadID) return; 

					if (textureOverrides[filename]) {
						console.warn(`Custom texture failed for ${filename}, reverting to default.`);
						delete textureOverrides[filename]; 
						loadNext(); // Retry this index
						return;
					}

					console.error('Failed to load asset:', src);
					failedAssets[src] = true;
					(srcToKeys[src] || []).forEach(typeKey => {
						assets[typeKey] = null;
					});
					assetsLoaded++;
					if (!gameStartedManually) {
						loadingText.textContent = `Failed: ${filename}`;
						updateUI();
					}
					idx++;
					loadNext();
				};
				img.src = finalSrc;
			}

			// kick off
			loadNext();
		}
		
		let skinTriggerSequence = "";
		
		const playerReach = 5 * tileSize; // For example, 5 tiles

        const player = {
            x: 0 * tileSize, y: 0, dx: 0, dy: 0,
			targetDx: 0,
            speed: 5, jumpStrength: -15, onGround: false, gravity: 0.8,
            health: 100, maxHealth: 100,
			bloodAlcohol: 0,
            activeEffects: [],
            fallStartY: 0, // Y-position where a fall started
            spawnPoint: { x: 0 * tileSize, y: -10 },
            bedSpawnPoint: null,
			portalCooldown: 0,
			facingDirection: 1,
			lastHealth: 100,
			onFire: false, // NEW: Is the player currently burning?
			fireDuration: 0, // NEW: How much time is left on the burn?
			fireDamageTimer: 0, // NEW: Timer for the 200ms damage tick
            // NEW: Armor slots now hold the full item object, not an index.
            armor: {
                helmet: null,
                chestGear: null,
                legGear: null,
                boots: null
            }
        };
		
		const PLAYER_FIRE_DURATION = 3000; // 10 cycles * 200ms = 2 seconds
		const PLAYER_FIRE_DAMAGE_TICK = 200; // Same as fire animation speed
		const PLAYER_FIRE_DAMAGE = 2; // Damage per tick
		const FIRE_SPREAD_CHANCE = 0.2; // 20% chance to spread per tick
        let playerMiningPower = 0.1; // Base mining power
        const camera = { x: 0, y: 0 };
        const keys = {}; // Tracks pressed keys
		const npcs = [];
		const animatedDrops = [];
        const mouse = { x: 0, y: 0, down: false, rightDown: false }; // Tracks mouse state
        let miningTarget = null; // Stores information about the block currently being mined
        
        const inventorySlots = new Array(totalInventorySlots).fill(null);
        const hotbarIndices = new Array(hotbarSize).fill(null);

        let selectedHotbarSlot = 0;
        let isGameActive = true; 
        let isGamePaused = false;
		let isCinemaMode = false;
		const gameContainer = document.getElementById('gameContainer'); // Cache this
        let maintainBlockDurability = true;
        let autosave = false;
		let animateDrops = false;

        // REVISED: Dedicated function for generating cacti
        function generateCactus(col, surfaceRow) {
            const height = 2 + Math.floor(random() * 4); // Generates a height of 2, 3, 4, or 5
            for (let i = 0; i < height; i++) {
                const key = `${col},${surfaceRow - 1 - i}`;
                // Check if the space is available before placing
                if (getBlockType(col, surfaceRow - 1 - i) === '') {
                    worldBlocks[key] = { type: 'cactus_block', mineProg: 0 };
                } else {
                    // Stop if we hit an obstacle
                    break; 
                }
            }
        }

        function generateTree(col, surfaceRow, treeType) {
			let trunkBlockType, bushBlockType, minTrunkHeight, maxTrunkHeight, trunkHeight, minCanopyRadius, maxCanopyRadius, horizontalSpreadFactorMin, horizontalSpreadFactorMax;

			// Tree type definitions (no changes here)
			if (treeType === 'oak') {
				trunkBlockType = 'raw_oak'; bushBlockType = 'oak_bush'; minTrunkHeight = 6; maxTrunkHeight = 10;
				minCanopyRadius = 3; maxCanopyRadius = 4; horizontalSpreadFactorMin = 0.5; horizontalSpreadFactorMax = 1.5;
			} else if (treeType === 'birch') {
				trunkBlockType = 'raw_birch'; bushBlockType = 'birch_bush'; minTrunkHeight = 4; maxTrunkHeight = 8;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.7; horizontalSpreadFactorMax = 0.9;
			} else if (treeType === 'spruce') {
				trunkBlockType = 'raw_spruce'; bushBlockType = 'spruce_bush'; minTrunkHeight = 8; maxTrunkHeight = 12;
				const canopyBaseWidth = 5; minCanopyRadius = 1; maxCanopyRadius = 2.5;
			} else if (treeType === 'rubber') {
				trunkBlockType = 'raw_rubber'; bushBlockType = 'rubber_bush'; minTrunkHeight = 5; maxTrunkHeight = 7;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.6; horizontalSpreadFactorMax = 0.9;
			} else if (treeType === 'mahogany') {
				trunkBlockType = 'raw_mahogany'; bushBlockType = 'mahogany_bush'; minTrunkHeight = 9; maxTrunkHeight = 13;
				minCanopyRadius = 3; maxCanopyRadius = 4; horizontalSpreadFactorMin = 0.9; horizontalSpreadFactorMax = 1.1;
			} else if (treeType === 'cinnamon') {
				trunkBlockType = 'raw_cinnamon'; bushBlockType = 'cinnamon_bush'; minTrunkHeight = 5; maxTrunkHeight = 7;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.8; horizontalSpreadFactorMax = 0.9;
			} else if (treeType === 'redwood') {
				trunkBlockType = 'raw_redwood'; bushBlockType = 'redwood_bush'; minTrunkHeight = 32; maxTrunkHeight = 46;
				const canopyBaseWidth = 5; minCanopyRadius = 1; maxCanopyRadius = 2.5; horizontalSpreadFactorMin = 1.8; horizontalSpreadFactorMax = 2;
			} else if (treeType === 'darkwood') {
				trunkBlockType = 'raw_darkwood'; bushBlockType = 'darkwood_bush'; minTrunkHeight = 9; maxTrunkHeight = 15;
				minCanopyRadius = 4; maxCanopyRadius = 6; horizontalSpreadFactorMin = 0.8; horizontalSpreadFactorMax = 1.2;
			} else if (treeType === 'fern') {
				trunkBlockType = 'fern_stalk'; minTrunkHeight = 3; maxTrunkHeight = 8;
				minCanopyRadius = 3; maxCanopyRadius = 4; horizontalSpreadFactorMin = 1; horizontalSpreadFactorMax = 1;
			} else if (treeType === 'sugarcane') {
				trunkBlockType = 'sugarcane'; minTrunkHeight = 1; maxTrunkHeight = 4;
				minCanopyRadius = 3; maxCanopyRadius = 4; horizontalSpreadFactorMin = 1; horizontalSpreadFactorMax = 1;
			} else if (treeType === 'hell') {
				trunkBlockType = 'raw_hell_wood'; bushBlockType = 'hell_wood_bush'; minTrunkHeight = 6; maxTrunkHeight = 8;
				minCanopyRadius = 2; maxCanopyRadius = 4; horizontalSpreadFactorMin = 0.6; horizontalSpreadFactorMax = 1;
			} else if (treeType === 'dead_tree') {
				trunkBlockType = 'raw_deadwood'; bushBlockType = 'raw_deadwood'; minTrunkHeight = 5; maxTrunkHeight = 8;
				minCanopyRadius = 0.5; maxCanopyRadius = 1; horizontalSpreadFactorMin = 0.3; horizontalSpreadFactorMax = 0.8;
			} else if (treeType === 'gilded') {
				trunkBlockType = 'raw_gilded_wood'; bushBlockType = 'gilded_tree_bush'; minTrunkHeight = 6; maxTrunkHeight = 8;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.7; horizontalSpreadFactorMax = 1;
			} else if (treeType === 'blueglow') {
				trunkBlockType = 'raw_blueglow_wood'; bushBlockType = 'blueglow_bush'; minTrunkHeight = 6; maxTrunkHeight = 8;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.7; horizontalSpreadFactorMax = 1.1;
			} else if (treeType === 'ash') {
				trunkBlockType = 'ash_block'; bushBlockType = 'ash_block'; minTrunkHeight = 5; maxTrunkHeight = 80;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.7; horizontalSpreadFactorMax = 1;
			} else if (treeType === 'magma') {
				trunkBlockType = 'magma_stone_block'; minTrunkHeight = 1; maxTrunkHeight = 5;
			} else if (treeType === 'granite') {
				trunkBlockType = 'granite'; minTrunkHeight = 1; maxTrunkHeight = 3;
			} else if (treeType === 'meat') {
				trunkBlockType = 'meat_wood'; bushBlockType = 'meat_block'; minTrunkHeight = 25; maxTrunkHeight = 30;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.7; horizontalSpreadFactorMax = 1.2;
			} else if (treeType === 'spoiled_meat') {
				trunkBlockType = 'spoiled_meat_wood'; bushBlockType = 'spoiled_meat_block'; minTrunkHeight = 20; maxTrunkHeight = 25;
				minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.7; horizontalSpreadFactorMax = 1.2;
			} else if (treeType === 'dirt_column') {
				trunkBlockType = 'dirt'; minTrunkHeight = 45; maxTrunkHeight = 47;
			}
			else if (treeType === 'apple' || treeType === 'orange') {
				if (treeType === 'apple') {
					baseBushBlockType = 'apple_bush';
					fruitBushBlockType = 'apple_bush_fruit';
					trunkBlockType = 'raw_apple';
					minTrunkHeight = 7; maxTrunkHeight = 9;
					minCanopyRadius = 3; maxCanopyRadius = 4; horizontalSpreadFactorMin = 0.5; horizontalSpreadFactorMax = 1.5;
				} else if (treeType === 'orange') {
					baseBushBlockType = 'orange_bush';
					fruitBushBlockType = 'orange_bush_fruit';
					trunkBlockType = 'raw_orange';
					minTrunkHeight = 5; maxTrunkHeight = 7;
					minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.5; horizontalSpreadFactorMax = 0.9;
				}
				
				trunkHeight = minTrunkHeight + Math.floor(random() * (maxTrunkHeight - minTrunkHeight + 1));
				const trunkBaseWidth = (random() < 0.3) ? 2 : 1;

				for (let i = 0; i < trunkHeight; i++) {
					let currentTrunkWidth = (i < 2 && trunkBaseWidth === 2) ? 2 : 1;
					for (let w = 0; w < currentTrunkWidth; w++) {
						const trunkCol = col - Math.floor((currentTrunkWidth - 1) / 2) + w;
						const key = `${trunkCol},${surfaceRow - 1 - i}`;
						if (getBlockType(trunkCol, surfaceRow - 1 - i) === '') {
							worldBlocks[key] = { type: trunkBlockType, mineProg: 0 };
						}
					}
				}

				const topOfTrunkRow = surfaceRow - trunkHeight;

				const canopyRadius = minCanopyRadius + Math.floor(random() * (maxCanopyRadius - minCanopyRadius + 1));
				for (let yOffset = 0; yOffset <= canopyRadius + 2; yOffset++) {
					let currentLayerRadius = Math.max(0, canopyRadius - Math.floor(yOffset / 1.5));
					const horizontalSpread = horizontalSpreadFactorMin + random() * (horizontalSpreadFactorMax - horizontalSpreadFactorMin);
					const effectiveRadius = currentLayerRadius * horizontalSpread;
					for (let x = -Math.ceil(effectiveRadius); x <= Math.ceil(effectiveRadius); x++) {
						if (random() < 0.85) {
							const leafCol = col + Math.round(x);
							const leafRow = topOfTrunkRow - yOffset;
							const key = `${leafCol},${leafRow}`;
							if (getBlockType(leafCol, leafRow) === '' && (!worldBlocks[key] || worldBlocks[key].type !== trunkBlockType)) {
								const chosenBushType = random() < 0.3 ? fruitBushBlockType : baseBushBlockType;
								worldBlocks[key] = { type: chosenBushType, mineProg: 0 };
							}
						}
					}
				}
				
				const branchCount = Math.floor(random() * 3);
				for(let i = 0; i < branchCount; i++) {
					const branchY = topOfTrunkRow + 1 - Math.floor(random() * 4);
					const branchDir = random() < 0.5 ? -1 : 1;
					const branchLength = 1 + Math.floor(random() * 2);
					for(let l = 1; l <= branchLength; l++) {
						const branchCol = col + (l * branchDir);
						const branchKey = `${branchCol},${branchY}`;
						if(getBlockType(branchCol, branchY) === '') {
							 worldBlocks[branchKey] = { type: trunkBlockType, mineProg: 0 };
						}
					}
					const leafClusterRadius = 1 + Math.floor(random() * 1.5);
					for (let lx = -leafClusterRadius; lx <= leafClusterRadius; lx++) {
						for (let ly = -leafClusterRadius; ly <= leafClusterRadius; ly++) {
							const leafCol = col + (branchLength * branchDir) + lx;
							if (lx*lx + ly*ly <= leafClusterRadius*leafClusterRadius && random() < 0.9) {
								const leafKey = `${leafCol},${branchY - 1 + ly}`;
								if(getBlockType(leafCol, branchY - 1 + ly) === '' && (!worldBlocks[leafKey] || worldBlocks[leafKey].type !== trunkBlockType)) {
									const chosenBushType = random() < 0.2 ? fruitBushBlockType : baseBushBlockType;
									worldBlocks[leafKey] = { type: chosenBushType, mineProg: 0 };
								}
							}
						}
					}
				}
				return;
			}
			
			trunkHeight = minTrunkHeight + Math.floor(random() * (maxTrunkHeight - minTrunkHeight + 1));
			const trunkBaseWidth = (random() < 0.4 && (treeType === 'oak' || treeType === 'darkwood')) ? 2 : 1;

			// --- START: REDWOOD TRUNK FIX ---
			// Redwoods need special logic to handle the 3-wide trunk on uneven ground.
			if (treeType === 'redwood') {
				const topOfTrunkRow = surfaceRow - trunkHeight;

				// Iterate through each of the 3 trunk columns individually
				for (let w = 0; w < 3; w++) {
					const trunkCol = col - 1 + w; // This will be col-1, col, and col+1
					// IMPORTANT: Get the surface height for THIS specific column
					const trunkSurfaceRow = columnSurfaceHeights[trunkCol] || surfaceRow;

					// Build this part of the trunk from its top down to its own ground level
					for (let row = topOfTrunkRow; row < trunkSurfaceRow; row++) {
						const key = `${trunkCol},${row}`;
						// Only place a block if the spot is empty (sky)
						if (getBlockType(trunkCol, row) === '') {
							worldBlocks[key] = { type: trunkBlockType, mineProg: 0 };
						}
					}
				}
			} else { // --- This is the original logic for all other trees ---
				for (let i = 0; i < trunkHeight; i++) {
					const currentTrunkWidth = (i < 2 && trunkBaseWidth === 2) ? 2 : 1;
					for (let w = 0; w < currentTrunkWidth; w++) {
						const trunkCol = col - Math.floor((currentTrunkWidth - 1) / 2) + w;
						const key = `${trunkCol},${surfaceRow - 1 - i}`;
						const biome = getBiome(trunkCol);
						const validBaseBlock = biome === 'overgrown_forest' ? 'dark_moss_dirt' : (biome === 'deciduous_forest' ? 'grass_dirt' : 'grass_soil');
						if (getBlockType(trunkCol, surfaceRow - 1 - i) === '' || (i === 0 && getBlockType(trunkCol, surfaceRow) === validBaseBlock)) {
							worldBlocks[key] = { type: trunkBlockType, mineProg: 0 };
						}
					}
				}
			}
			// --- END: REDWOOD TRUNK FIX ---

			const topOfTrunkRow = surfaceRow - trunkHeight;

			if (treeType === 'oak' || treeType === 'birch' || treeType === 'darkwood' || treeType === 'mahogany' || treeType === 'cinnamon' || treeType === 'rubber' || treeType === 'hell' || treeType === 'meat' || treeType === 'spoiled_meat' || treeType === 'gilded' || treeType === 'blueglow' || treeType === 'meat' || treeType === 'spoiled meat'|| treeType === 'ash' || treeType === 'dead_tree') {
				const canopyRadius = minCanopyRadius + Math.floor(random() * (maxCanopyRadius - minCanopyRadius + 1));
				for (let yOffset = 0; yOffset <= canopyRadius + 2; yOffset++) {
					let currentLayerRadius = Math.max(0, canopyRadius - Math.floor(yOffset / 1.5));
					const horizontalSpread = horizontalSpreadFactorMin + random() * (horizontalSpreadFactorMax - horizontalSpreadFactorMin);
					const effectiveRadius = currentLayerRadius * horizontalSpread;
					for (let x = -Math.ceil(effectiveRadius); x <= Math.ceil(effectiveRadius); x++) {
						if (random() < 0.85) {
							const leafCol = col + Math.round(x);
							const leafRow = topOfTrunkRow - yOffset;
							const key = `${leafCol},${leafRow}`;
							if (getBlockType(leafCol, leafRow) === '' && (!worldBlocks[key] || worldBlocks[key].type !== trunkBlockType)) {
								worldBlocks[key] = { type: bushBlockType, mineProg: 0 };
							}
						}
					}
				}
				if (treeType === 'oak' || treeType === 'darkwood') {
					const branchCount = Math.floor(random() * (treeType === 'darkwood' ? 5 : 3));
					for(let i = 0; i < branchCount; i++) {
						const branchY = topOfTrunkRow + 1 - Math.floor(random() * 4);
						const branchDir = random() < 0.5 ? -1 : 1;
						const branchLength = 1 + Math.floor(random() * (treeType === 'darkwood' ? 4 : 2));
						for(let l = 1; l <= branchLength; l++) {
							const branchCol = col + (l * branchDir);
							const branchKey = `${branchCol},${branchY}`;
							if(getBlockType(branchCol, branchY) === '') {
								 worldBlocks[branchKey] = { type: trunkBlockType, mineProg: 0 };
							}
						}
						const leafClusterRadius = 1 + Math.floor(random() * 1.5);
						for (let lx = -leafClusterRadius; lx <= leafClusterRadius; lx++) {
							for (let ly = -leafClusterRadius; ly <= leafClusterRadius; ly++) {
								const leafCol = col + (branchLength * branchDir) + lx;
								if (lx*lx + ly*ly <= leafClusterRadius*leafClusterRadius && random() < 0.9) {
									const leafKey = `${leafCol},${branchY - 1 + ly}`;
									if(getBlockType(leafCol, branchY - 1 + ly) === '' && (!worldBlocks[leafKey] || worldBlocks[leafKey].type !== trunkBlockType)) {
										worldBlocks[leafKey] = { type: bushBlockType, mineProg: 0 };
									}
								}
							}
						}
					}
				}
			} else if (treeType === 'spruce') {
				// ... (original spruce canopy logic, no changes needed) ...
				const canopyBottomRow = topOfTrunkRow + Math.floor(trunkHeight * 0.3);
				for (let r = canopyBottomRow; r >= topOfTrunkRow - 3; r--) {
					let currentCanopyRadius = Math.max(0, Math.floor(maxCanopyRadius - (canopyBottomRow - r) / 1.5));
					for (let x = -currentCanopyRadius; x <= currentCanopyRadius; x++) {
						const leafCol = col + x;
						const key = `${leafCol},${r}`;
						if (getBlockType(leafCol, r) === '' && (!worldBlocks[key] || worldBlocks[key].type !== trunkBlockType)) {
							if (random() < 0.95) {
								worldBlocks[key] = { type: bushBlockType, mineProg: 0 };
							}
						}
					}
				}
			} else if (treeType === 'redwood') {
				// --- START: REDWOOD CANOPY FIX ---
				// We increase the base width to better match the 3-block thick trunk.
				const canopyBaseWidth = 8; // CHANGED FROM 6 to 8
				const taperFactor = 2.2;
				// --- END: REDWOOD CANOPY FIX ---

				const canopyBottomRow = topOfTrunkRow + Math.floor(trunkHeight * 0.4);
				
				for (let r = canopyBottomRow; r >= topOfTrunkRow - 3; r--) {
					let currentCanopyRadius = Math.max(0, Math.floor(canopyBaseWidth - (canopyBottomRow - r) / taperFactor));
					
					for (let x = -currentCanopyRadius; x <= currentCanopyRadius; x++) {
						const leafCol = col + x;
						const key = `${leafCol},${r}`;
						
						if (getBlockType(leafCol, r) === '' && (!worldBlocks[key] || worldBlocks[key].type !== trunkBlockType)) {
							if (random() < 0.95) {
								worldBlocks[key] = { type: bushBlockType, mineProg: 0 };
							}
						}
					}
				}
			}
		}

        /**
         * Generates tall, multi-block foliage like sunflowers.
         * Checks for obstructions before placing.
         * @param {number} col - The column to plant the foliage on.
         * @param {number} surfaceRow - The row of the ground block (e.g., grass_dirt).
         * @param {string} foliageType - The type of foliage to generate (e.g., "sunflower").
         */
        function generateTallFoliage(col, surfaceRow, foliageType) {
            
            if (foliageType === 'sunflower') {
                const stemHeight = 2 + Math.floor(random() * 2); // 2 or 3 blocks tall
                const topRow = surfaceRow - stemHeight - 1; // Row for the flower top
                
                // 1. Check if there is enough empty space for the whole plant
                for (let i = 1; i <= stemHeight + 1; i++) {
                    if (getBlockType(col, surfaceRow - i) !== '') {
                        return; // Obstructed, cannot plant here
                    }
                }
                
                // 2. Place the stem blocks
                for (let i = 1; i <= stemHeight; i++) {
                    const stemRow = surfaceRow - i;
                    worldBlocks[`${col},${stemRow}`] = { type: 'sunflower_stem', mineProg: 0 };
                }
                
                // 3. Place the top block
                worldBlocks[`${col},${topRow}`] = { type: 'sunflower_top', mineProg: 0 };
            }
            
            // You can add more foliage types here in the future
            // else if (foliageType === 'corn_stalk') { ... }
        }
		
		// --- VOID REALM ISLAND GENERATION ---

        // Generates a small, floating platform of Void Dust
        function generateDustPad(startX, startY) {
            const padSize = 30 + Math.floor(random() * 31); // 30-60 blocks
            let blocksPlaced = 0;
            const toPlace = new Set([`${startX},${startY}`]);
            const placed = new Set();

            while (blocksPlaced < padSize && toPlace.size > 0) {
                const currentKey = Array.from(toPlace)[Math.floor(random() * toPlace.size)];
                toPlace.delete(currentKey);

                if (placed.has(currentKey) || worldBlocks[currentKey]) continue;

                worldBlocks[currentKey] = { type: 'void_dust_block', mineProg: 0 };
                placed.add(currentKey);
                blocksPlaced++;

                // Add neighbors to the list of potential blocks to place
                const [x, y] = currentKey.split(',').map(Number);
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        // Use a chance to create a more blob-like, less square shape
                        if (random() < 0.6) {
                            const nextKey = `${x + dx},${y + dy}`;
                            if (!placed.has(nextKey)) {
                                toPlace.add(nextKey);
                            }
                        }
                    }
                }
            }
        }

		// VERY RARE: generate a solid void-crystal geode (circle-ish, ~20-30 blocks)
		function generateGeode(cx, cy) {
			// prefer radius 3 (area ~28) but allow 2..4 for variety
			const radius = 2 + Math.floor(random() * 3); // 2,3,4
			const bboxRadius = radius + 1;

			// check area is mostly empty (don't stomp existing content). Try a few small offsets.
			let placed = false;
			const tries = 5;
			for (let t = 0; t < tries && !placed; t++) {
				const offX = Math.floor((random() - 0.5) * 6); // shift -3..+2
				const offY = Math.floor((random() - 0.5) * 6);
				const baseX = cx + offX;
				const baseY = cy + offY;

				// quick bounding-box emptiness check
				let ok = true;
				for (let dx = -bboxRadius; dx <= bboxRadius && ok; dx++) {
					for (let dy = -bboxRadius; dy <= bboxRadius; dy++) {
						const k = `${baseX + dx},${baseY + dy}`;
						// allow sky (empty) only; if anything else exists, abort this try
						if (worldBlocks[k]) { ok = false; break; }
					}
				}
				if (!ok) continue;

				// place filled circle of void_crystal
				for (let dx = -radius; dx <= radius; dx++) {
					for (let dy = -radius; dy <= radius; dy++) {
						// circle-ish mask (soft edge)
						if (Math.hypot(dx, dy) <= radius + 0.2) {
							const px = baseX + dx;
							const py = baseY + dy;
							const k = `${px},${py}`;
							// double-check safety
							if (!worldBlocks[k]) {
								worldBlocks[k] = { type: 'void_crystal', mineProg: 0 };
							}
						}
					}
				}

				// optional: add a tiny halo of void_stone around it so it reads as a geode clump
				for (let dx = -radius-1; dx <= radius+1; dx++) {
					for (let dy = -radius-1; dy <= radius+1; dy++) {
						const dist = Math.hypot(dx, dy);
						if (dist > radius + 0.9 && dist <= radius + 1.2 && random() < 0.5) {
							const hx = baseX + dx;
							const hy = baseY + dy;
							const hk = `${hx},${hy}`;
							if (!worldBlocks[hk]) worldBlocks[hk] = { type: 'void_stone', mineProg: 0 };
						}
					}
				}

				placed = true;
			}
			// if not placed after tries, skip (keeps them rare and non-destructive)
		}

        // -------------------------------------------------
		// Red Rock: imperfect arches and spires
		// -------------------------------------------------

		function generateRockArch(startCol, surfaceRow) {
			// Creates an imperfect arch of red_sandstone_block that rises from ground then returns
			const archLength = 12 + Math.floor(random() * 24); // length 12..35
			const peakIndex = Math.floor(archLength * (0.35 + random() * 0.3)); // where arch peaks
			let cx = startCol;
			// start one block above the surface so arch lifts off the ground
			let cy = surfaceRow - 1;
			const dirX = (random() < 0.5 ? 1 : -1); // consistent horizontal direction

			// subtle wobble parameters
			const verticalWobbleChance = 0.12;
			const extraThicknessChance = 0.25;

			for (let i = 0; i < archLength; i++) {
				// vertical trend: go up until peak, then down
				if (i < peakIndex) cy -= 1;
				else cy += 1;

				// small random vertical wobble
				if (random() < verticalWobbleChance) cy += (random() < 0.5 ? -1 : 1);

				// advance horizontally
				cx += dirX;

				// cross-section thickness (tappering & imperfections)
				let thickness = 1 + (random() < extraThicknessChance ? 1 : 0);

				// place roughly circular cross-section, but only into empty/air slots
				for (let dx = -thickness; dx <= thickness; dx++) {
					for (let dy = -thickness; dy <= thickness; dy++) {
						if (Math.hypot(dx, dy) > thickness + 0.25) continue;
						const px = cx + dx;
						const py = cy + dy;
						const key = `${px},${py}`;
						// only write into empty space (respect other structures)
						if (!worldBlocks[key] || getBlockType(px, py) === '') {
							// Keep arches in red sandstone
							worldBlocks[key] = { type: 'red_sandstone_block', mineProg: 0 };
						}
					}
				}
			}

			// anchor the ends down to the surface a bit so arch "springs" from the ground (imperfect foot)
			for (let anchor = 0; anchor < 2; anchor++) {
				const endCol = startCol + (dirX * (anchor === 0 ? 0 : archLength - 1));
				const anchorDepth = 0 + Math.floor(random() * 3);
				for (let d = 0; d <= anchorDepth; d++) {
					const key = `${endCol},${surfaceRow + d}`;
					if (!worldBlocks[key] || getBlockType(endCol, surfaceRow + d) === '') {
						worldBlocks[key] = { type: 'red_sandstone_block', mineProg: 0 };
					}
				}
			}
		}

		function generateSpire(centerCol, surfaceRow, blockTyper) {
			// Creates a tapered red sandstone spire with small irregularities
			const height = 4 + Math.floor(random() * 16); // 4..19 blocks tall
			const baseRadius = 1 + Math.floor(random() * 3); // 1..3 radius
			const wobbleChance = 0.18;

			// Reserve this column (prevent other red_rock features from overlapping)
			redRockColumns.add(centerCol);

			for (let h = 0; h < height; h++) {
				// row for this level
				const row = surfaceRow - h;
				// taper radius as we go up
				const radius = Math.max(0, Math.round(baseRadius * (1 - (h / (height + 1)))));

				// small chance to shift column slightly for a leaning spire
				const colShift = (random() < wobbleChance) ? (random() < 0.5 ? -1 : 1) : 0;
				const thisCenter = centerCol + colShift;

				for (let dx = -radius; dx <= radius; dx++) {
					for (let dy = -radius; dy <= radius; dy++) {
						if (Math.hypot(dx, dy) > radius + 0.3) continue;
						const px = thisCenter + dx;
						const py = row;
						const key = `${px},${py}`;
						// prefer placing into sky or shallow replace of topsoil (don't stomp deep structures)
						if (!worldBlocks[key] || getBlockType(px, py) === '') {
							worldBlocks[key] = { type: blockTyper, mineProg: 0 };
						}
					}
				}

				// occasional small outcroppings to break perfect symmetry
				if (random() < 0.12) {
					const outCol = thisCenter + (random() < 0.5 ? -1 : 1);
					const outKey = `${outCol},${row}`;
					if (!worldBlocks[outKey] || getBlockType(outCol, row) === '') {
						worldBlocks[outKey] = { type: blockTyper, mineProg: 0 };
					}
				}
			}
		}
		
		// Generates a long, winding voidVoidArch made of void_stone with ore pockets contained inside the void stone
		function generateVoidArch(startX, startY) {
			const voidVoidArchLength = 300 + Math.floor(random() * 401); // 300..700
			let cx = startX;
			let cy = startY;
			let dirX = (random() < 0.5 ? 1 : -1);
			let dirY = 0;

			// configuration local to this function (tweak if you want)
			const baseThickness = 2;             // minimum radius of the voidVoidArch cross-section
			const extraThicknessChance = 0.4;    // chance to expand cross-section occasionally
			const orePocketChance = 0.08;        // chance per segment to spawn an ore pocket
			const orePocketSizeMin = 3;
			const orePocketSizeMax = 8;
			const oreSpawnMultiplier = 2.5;      // ores are more likely inside voidVoidArches

			// helper: choose ore type by combining your existing ore probability variables
			function pickOreType() {
				// collect weights from global vein probability variables (assumes these exist)
				const weights = [
					['copper_compacted_stone', (typeof copperVeinProbability === 'number' ? copperVeinProbability : 0)],
					['tin_compacted_stone', (typeof tinVeinProbability === 'number' ? tinVeinProbability : 0)],
					['zinc_compacted_stone', (typeof zincVeinProbability === 'number' ? zincVeinProbability : 0)],
					['coal_compacted_stone', (typeof deepCoalVeinProbability === 'number' ? deepCoalVeinProbability : 0)],
					['iron_compacted_stone', (typeof ironVeinProbability === 'number' ? ironVeinProbability : 0)],
					['tungsten_compacted_stone', (typeof tungstenVeinProbability === 'number' ? tungstenVeinProbability : 0)],
					['gold_compacted_stone', (typeof goldVeinProbability === 'number' ? goldVeinProbability : 0)],
					['amethyst_compacted_stone', (typeof amethystVeinProbability === 'number' ? amethystVeinProbability : 0)],
					['ruby_compacted_stone', (typeof rubyVeinProbability === 'number' ? rubyVeinProbability : 0)],
					['sapphire_compacted_stone', (typeof sapphireVeinProbability === 'number' ? sapphireVeinProbability : 0)],
					['topaz_compacted_stone', (typeof topazVeinProbability === 'number' ? topazVeinProbability : 0)],
					['diamond_compacted_stone', (typeof diamondVeinProbability === 'number' ? diamondVeinProbability : 0)],
					['emerald_compacted_stone', (typeof emeraldVeinProbability === 'number' ? emeraldVeinProbability : 0)],
					['opal_compacted_stone', (typeof opalVeinProbability === 'number' ? opalVeinProbability : 0)],
					['jade_compacted_stone', (typeof jadeVeinProbability === 'number' ? jadeVeinProbability : 0)],
				];

				// apply multiplier and compute total
				let total = 0;
				for (let i = 0; i < weights.length; i++) {
					weights[i][1] *= oreSpawnMultiplier;
					total += weights[i][1];
				}
				if (total <= 0) return null;

				let r = random() * total;
				for (let i = 0; i < weights.length; i++) {
					if (r < weights[i][1]) return weights[i][0];
					r -= weights[i][1];
				}
				return null;
			}

			// helper: place a small ore cluster centered at (ox,oy). Only replace blocks that are void_stone (so ores stay contained)
			function placeOreCluster(ox, oy, size, oreType) {
				let px = ox;
				let py = oy;
				for (let i = 0; i < size; i++) {
					const key = `${px},${py}`;
					// place only if there's a void_stone here OR we just placed void stone earlier
					if (worldBlocks[key] && worldBlocks[key].type === 'void_stone') {
						worldBlocks[key] = { type: oreType, mineProg: 0 };
						// ensure immediate neighbors are void_stone to 'encase' the ore (if empty)
						const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
						for (const n of neighbors) {
							const nk = `${px + n[0]},${py + n[1]}`;
							if (!worldBlocks[nk]) worldBlocks[nk] = { type: 'void_stone', mineProg: 0 };
							else if (worldBlocks[nk].type !== 'void_stone' && worldBlocks[nk].type.indexOf('compacted_stone') === -1) {
								// if neighbor is something odd, prefer preserving it (skip)
							}
						}
					}
					// random walk to next placement position
					const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
					const d = dirs[Math.floor(random() * dirs.length)];
					px += d[0]; py += d[1];
				}
			}

			for (let i = 0; i < voidVoidArchLength; i++) {
				// gentle random direction change to create winding paths
				if (random() < 0.06) {
					const d = Math.floor(random() * 4);
					if (d === 0) { dirX = 1; dirY = 0; }
					else if (d === 1) { dirX = -1; dirY = 0; }
					else if (d === 2) { dirX = 0; dirY = 1; }
					else { dirX = 0; dirY = -1; }
				}

				cx += dirX;
				cy += dirY;

				// occasionally make the voidVoidArch thicker
				let thickness = baseThickness;
				if (random() < extraThicknessChance) thickness += 1 + Math.floor(random() * 2); // +1..+2

				// place a rounded cross-section (circle-ish)
				for (let dx = -thickness; dx <= thickness; dx++) {
					for (let dy = -thickness; dy <= thickness; dy++) {
						// circular mask
						if (Math.hypot(dx, dy) > thickness + 0.2) continue;
						const bx = cx + dx;
						const by = cy + dy;
						const key = `${bx},${by}`;

						// only write into empty space (don't stomp existing important world blocks)
						if (!worldBlocks[key]) {
							worldBlocks[key] = { type: 'void_stone', mineProg: 0 };
						}
					}
				}

				// small chance to create an internal ore pocket inside this voidVoidArch segment
				if (random() < orePocketChance) {
					const oreType = pickOreType();
					if (oreType) {
						const pocketSize = orePocketSizeMin + Math.floor(random() * (orePocketSizeMax - orePocketSizeMin + 1));
						// pick a center inside the current cross-section (bias toward the core)
						const offX = Math.floor((random() - 0.5) * (thickness - 0.5) * 2);
						const offY = Math.floor((random() - 0.5) * (thickness - 0.5) * 2);
						const ox = cx + offX;
						const oy = cy + offY;
						placeOreCluster(ox, oy, pocketSize, oreType);
					}
				}

				// slight drift up/down so voidVoidArches aren't perfectly straight
				if (random() < 0.04) cy += (random() < 0.5 ? -1 : 1);
			}
		}

        allBiome = 'start'
        
        // Determines the biome for a given column, now generates in both directions
        function getBiome(col) {
            if (worldBiomes[col]) {
                return worldBiomes[col].type;
            }

            // Function to determine the next biome type
            function selectNextBiome() {
                const biomeRoll = random();
                if (allBiome !== 'start') {
                    return allBiome;
                }
                // Anthill ~4%, Overgrown Forest ~10%, Deciduous Forest ~40%, Desert ~26%, Rocky ~20%
                if (biomeRoll < 0.03) return 'anthill';
                if (biomeRoll < 0.08) return 'overgrown_forest';
                if (biomeRoll < 0.13) return 'apple_grove';
				if (biomeRoll < 0.15) return 'lush_grasslands';
				if (biomeRoll < 0.23) return 'grass_field';
				if (biomeRoll < 0.25) return 'salt_flats';
				if (biomeRoll < 0.30) return 'rainforest';
				if (biomeRoll < 0.34) return 'muddy_swamp';
				if (biomeRoll < 0.54) return 'deciduous_forest';
				if (biomeRoll < 0.68) return 'coniferous_forest';
                if (biomeRoll < 0.79) return 'desert';
				if (biomeRoll < 0.81) return 'icy_hills';
                if (biomeRoll < 0.82) return 'lava_flats';
				if (biomeRoll < 0.86) return 'red_rocks';
				if (biomeRoll < 0.90) return 'redwood_forest';
				if (biomeRoll < 0.92) return 'granite_mountain';
				if (biomeRoll < 0.94) return 'clay_marsh';
				if (biomeRoll < 0.941) return 'dirt_plateau';
                return 'rocky';
            }

            // Generate to the right (positive columns)
            if (col > lastBiomeEndCol) {
                const biomeType = selectNextBiome();
                const biomeWidth = 40 + Math.floor(random() * 21); // 40-60 blocks wide
                const biomeStartCol = lastBiomeEndCol + 1;
                const biomeEndCol = biomeStartCol + biomeWidth - 1;

                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    worldBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                lastBiomeEndCol = biomeEndCol;
            } 
            // Generate to the left (negative columns)
            else if (col < firstBiomeStartCol) {
                const biomeType = selectNextBiome();
                const biomeWidth = 40 + Math.floor(random() * 21); // 40-60 blocks wide
                const biomeEndCol = firstBiomeStartCol - 1;
                const biomeStartCol = biomeEndCol - biomeWidth + 1;

                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    worldBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                firstBiomeStartCol = biomeStartCol;
            }
            
            return worldBiomes[col] ? worldBiomes[col].type : 'deciduous_forest'; // Fallback
        }

        hellBiome = 'start'
        
		function getUnderworldBiome(col) {
            if (underworldBiomes[col]) {
                return underworldBiomes[col].type;
            }

            function selectNextUnderworldBiome() {
				if (hellBiome !== 'start') {
                    return hellBiome;
                }
                return (r = random()) < 0.4 ? 'hell' : r < 0.5 ? 'golden_city' : r < 0.6 ? 'meat_world' : r < 0.7 ? 'magma_basin' : r < 0.75 ? 'doom_forest' : r < 0.8 ? 'flesh_forest' : r < 0.9 ? 'ash_wastes' : 'icy_hell';
			}

            if (col > lastUnderworldBiomeEndCol) {
                const biomeType = selectNextUnderworldBiome();
                const biomeWidth = 50 + Math.floor(random() * 31); // 50-80 blocks wide
                const biomeStartCol = lastUnderworldBiomeEndCol + 1;
                const biomeEndCol = biomeStartCol + biomeWidth - 1;
                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    underworldBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                lastUnderworldBiomeEndCol = biomeEndCol;
            } else if (col < firstUnderworldBiomeStartCol) {
                const biomeType = selectNextUnderworldBiome();
                const biomeWidth = 50 + Math.floor(random() * 31);
                const biomeEndCol = firstUnderworldBiomeStartCol - 1;
                const biomeStartCol = biomeEndCol - biomeWidth + 1;
                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    underworldBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                firstUnderworldBiomeStartCol = biomeStartCol;
            }
            
            return underworldBiomes[col] ? underworldBiomes[col].type : 'hell'; // Fallback
        }

        heavenBiome = 'start'
		
		function getHeavenBiome(col) {
            if (heavenBiomes[col]) {
                return heavenBiomes[col].type;
            }

            function selectNextHeavenBiome() {
                if (heavenBiome !== 'start') {
                    return heavenBiome;
                }
                // We'll give the new gilded forest a 20% chance to appear
                if (random() < 0.1) {
                    return 'gilded_forest';
                } else if (random() < 0.15) {
                    return 'blueglow_forest';
                } else if (random() < 0.35) {
                    return 'debris_flats';
                } else {
					return 'cloudscape'; // The default heaven biome
				}
            }

            // Generate to the right (positive columns)
            if (col > lastHeavenBiomeEndCol) {
                const biomeType = selectNextHeavenBiome();
                const biomeWidth = 50 + Math.floor(random() * 31); // 50-80 blocks wide
                const biomeStartCol = lastHeavenBiomeEndCol + 1;
                const biomeEndCol = biomeStartCol + biomeWidth - 1;
                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    heavenBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                lastHeavenBiomeEndCol = biomeEndCol;
            } 
            // Generate to the left (negative columns)
            else if (col < firstHeavenBiomeStartCol) {
                const biomeType = selectNextHeavenBiome();
                const biomeWidth = 50 + Math.floor(random() * 31);
                const biomeEndCol = firstHeavenBiomeStartCol - 1;
                const biomeStartCol = biomeEndCol - biomeWidth + 1;
                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    heavenBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                firstHeavenBiomeStartCol = biomeStartCol;
            }
            
            return heavenBiomes[col] ? heavenBiomes[col].type : 'cloudscape'; // Fallback
        }

		function checkAndCreateHeavenPortal(col, row) {
			// Define the shapes of the valid portal frame (C and backwards-C)
			// Coordinates are relative to the bottom-left block of the 2x7 bounding box.
			const portalPatterns = [
				{ // Standard "C" shape
					frame: [ [0,0], [1,0], [0,-1], [0,-2], [0,-3], [0,-4], [0,-5], [0,-6], [1,-6] ],
					inner: [ [1,-1], [1,-2], [1,-3], [1,-4], [1,-5] ],
					anchorOffset: { col: 1, row: -3 } // Portal center for teleporting
				},
				{ // Mirrored "C" shape
					frame: [ [0,0], [1,0], [1,-1], [1,-2], [1,-3], [1,-4], [1,-5], [0,-6], [1,-6] ],
					inner: [ [0,-1], [0,-2], [0,-3], [0,-4], [0,-5] ],
					anchorOffset: { col: 0, row: -3 } // Portal center for teleporting
				}
			];

			// Check around the placed block for a potential bottom-left corner of a portal frame
			for (let offsetX = -1; offsetX <= 0; offsetX++) {
				for (let offsetY = 0; offsetY <= 6; offsetY++) {
					const startCol = col + offsetX;
					const startRow = row + offsetY; // This is the potential bottom row of the frame

					// Try each pattern
					for (const pattern of portalPatterns) {
						let isFrameValid = true;
						for (const pos of pattern.frame) {
							if (getBlockType(startCol + pos[0], startRow + pos[1]) !== 'heaven_gate_brick_block') {
								isFrameValid = false;
								break;
							}
						}
						if (!isFrameValid) continue; // If this pattern fails, try the next one

						let isInnerEmpty = true;
						for (const pos of pattern.inner) {
							if (getBlockType(startCol + pos[0], startRow + pos[1]) !== '') {
								isInnerEmpty = false;
								break;
							}
						}
						if (!isInnerEmpty) continue;

						// If we reach here, a valid frame has been found!
						// Activate the portal by filling the inner area.
						for (const pos of pattern.inner) {
							const pCol = startCol + pos[0];
							const pRow = startRow + pos[1];
							worldBlocks[`${pCol},${pRow}`] = { type: 'heaven_portal', mineProg: 0 };
						}

						// Add this portal to our global list.
						// The anchor is the center of the portal blocks.
						const portalAnchorCol = startCol + pattern.anchorOffset.col;
						const portalAnchorRow = startRow + pattern.anchorOffset.row;
						const portalAnchorKey = `${portalAnchorCol},${portalAnchorRow}`;

						// Avoid adding duplicate portals
						if (portals.some(p => p.key === portalAnchorKey)) continue;

						portals.push({
							key: portalAnchorKey,
							col: portalAnchorCol, // Storing the center
							row: portalAnchorRow,
							dim: (portalAnchorRow > SUPER_HEAVEN_Y_OFFSET) ? 'overworld' : 'superHeaven',
							linkedPortalKey: null
						});

						console.log("Super Heaven Portal Activated at:", portalAnchorKey);
						return; // Exit after finding and creating one portal
					}
				}
			}
		}
		
		function teleportPlayer(fromPortal) {
			// Find the destination coordinates
			const inSuperHeaven = fromPortal.row < SUPER_HEAVEN_Y_OFFSET;
			const destCol = fromPortal.col; // fromPortal.col is the center of the portal blocks
			const destRow = inSuperHeaven ? fromPortal.row - SUPER_HEAVEN_Y_OFFSET : fromPortal.row + SUPER_HEAVEN_Y_OFFSET;
			
			player.portalCooldown = 1500; // Set 1.5 second cooldown

			// The key for a portal is its center coordinate string.
			const destKey = `${destCol},${destRow}`;
			let destinationPortal = portals.find(p => p.key === destKey);

			if (!destinationPortal) {
				// No portal exists, so we must generate one.
				console.log("No destination portal found. Generating one at", destKey);

				// We will generate a standard "C" shape portal.
				// The portal's center is (destCol, destRow).
				// For our "C" shape, the center is at (startCol+1, startRow-3).
				// So, we calculate the bottom-left corner (startCol, startRow) from that center.
				const startCol = destCol - 1;
				const startRow = destRow + 3;

				const pattern = { // Standard "C" shape, same as in checkAndCreateHeavenPortal
					frame: [ [0,0], [1,0], [0,-1], [0,-2], [0,-3], [0,-4], [0,-5], [0,-6], [1,-6] ],
					inner: [ [1,-1], [1,-2], [1,-3], [1,-4], [1,-5] ]
				};
				
				// Clear a safe 4x8 area for the new portal
				for(let x = -1; x <= 2; x++) {
					for(let y = -7; y <= 1; y++) {
						const clearKey = `${startCol + x},${startRow + y}`;
						// To be safe, only clear blocks that aren't already part of the frame
						if(getBlockType(startCol + x, startRow + y) !== 'heaven_gate_brick_block') {
							worldBlocks[clearKey] = { type: '', mineProg: 0 };
						}
					}
				}

				// Build the frame
				for (const pos of pattern.frame) {
					worldBlocks[`${startCol + pos[0]},${startRow + pos[1]}`] = { type: 'heaven_gate_brick_block', mineProg: 0 };
				}
				// Activate the portal
				for (const pos of pattern.inner) {
					worldBlocks[`${startCol + pos[0]},${startRow + pos[1]}`] = { type: 'heaven_portal', mineProg: 0 };
				}

				// Register the new portal and link it
				destinationPortal = {
					key: destKey,
					col: destCol, // The center
					row: destRow,
					dim: inSuperHeaven ? 'overworld' : 'superHeaven',
					linkedPortalKey: fromPortal.key
				};
				portals.push(destinationPortal);
				
				const sourcePortal = portals.find(p => p.key === fromPortal.key);
				if (sourcePortal) {
					sourcePortal.linkedPortalKey = destKey;
				}
			}

			// Teleport the player to stand in the empty part of the "C" frame
			player.x = ((destinationPortal.col - 1) * tileSize); 
			player.y = (destinationPortal.row * tileSize) - (playerHeight / 2); // Center player vertically in the portal
			player.dy = 0; // Stop vertical movement
			console.log(`Teleported to ${destinationPortal.key}`);
		}

        function getBlockData(col, row) {
			if (worldLimitEnabled) {
				if (col < worldMinX || col > worldMaxX || row < worldMinY || row > worldMaxY) {
					// Return an indestructible, solid, invisible barrier
					return { type: 'invisible_barrier', mineProg: 0 };
				}
			}
            const key = `${col},${row}`;
            if (worldBlocks[key] !== undefined) {
                return worldBlocks[key];
            }

			const spaceStartHeight = -500;
            if (row < spaceStartHeight && row > -99000) {
                // To handle infinite vertical generation, we divide space into vertical chunks
                const spaceChunkSize = 300; // Each chunk is 300 blocks high
                const chunkIndex = Math.floor(row / spaceChunkSize);
                const chunkKey = `${col},${chunkIndex}`; // A unique ID for this column's vertical chunk

                // Check if we've already processed this chunk to avoid re-running the logic
                if (!moonColumns.has(chunkKey)) {
                    moonColumns.add(chunkKey); // Mark this chunk as processed

                    // Roll the dice to see if a moon spawns in this chunk
                    if (random() < moonProbability) {
                        // Spawn the moon at a random Y position within this vertical chunk
                        const moonCenterY = (chunkIndex * spaceChunkSize) + Math.floor(random() * spaceChunkSize);
                        generateMoon(col, moonCenterY);
                    }
                }

                // After checking for generation, return the block if it exists, otherwise it's empty space
                if (worldBlocks[key]) {
                    return worldBlocks[key];
                }
                return (worldBlocks[key] = { type: ''}); // Default to sky
            }

            // NEW: Heaven generation
            const heavenStartHeight = -145;
            if (row < heavenStartHeight + 25) { // Check if in the heaven layer y-range
                let heavenSurfaceHeight;
                if (heavenColumnSurfaceHeights[col] !== undefined) {
                    heavenSurfaceHeight = heavenColumnSurfaceHeights[col];
                } else {
                    let prevSurface = 0;
                     if (heavenColumnSurfaceHeights[col - 1] !== undefined) {
                        prevSurface = heavenColumnSurfaceHeights[col - 1];
                    } else if (heavenColumnSurfaceHeights[col + 1] !== undefined) {
                        prevSurface = heavenColumnSurfaceHeights[col + 1];
                    }
                    const offset = Math.floor(random() * 5) - 2; // -2 to 2
                    let potentialHeight = prevSurface + offset;
                    heavenSurfaceHeight = Math.max(0, Math.min(20, potentialHeight)); // Clamp between 0 and 20
                    heavenColumnSurfaceHeights[col] = heavenSurfaceHeight;
                }
                
                const heavenBaseY = heavenStartHeight - heavenSurfaceHeight;

                if (row >= heavenBaseY) {
                    const heavenBiome = getHeavenBiome(col);
                    let blockType;

                    if (heavenBiome === 'gilded_forest' && row < heavenBaseY + 10) { 
                        // This logic is copied from the underworld's golden_city biome
                        if (row === heavenBaseY) {
                            blockType = 'gilded_grass_dirt_block';
                            // Generate a tree on this surface block if conditions are met
                            if (random() < 0.2) {
                                generateTree(col, heavenBaseY, 'gilded');
                            }
                        } else {
                            blockType = 'gilded_dirt_block';
                        }
                        return (worldBlocks[key] = { type: blockType, mineProg: 0 });

                    } else if (heavenBiome === 'blueglow_forest' && row < heavenBaseY + 15) { 
                        if (row === heavenBaseY) {
							if (random() < 0.05) {
								blockType = 'blueglow_grass_soil_block';
							} else {
								blockType = 'blueglow_grass_dirt_block';
							}
                            // Generate a tree on this surface block if conditions are met
                            if (random() < 0.2) {
                                generateTree(col, heavenBaseY, 'blueglow');
                            }
                        } else {
                            if (random() < 0.05) {
								blockType = 'blueglow_soil_block';
							} else {
								blockType = 'blueglow_dirt_block';
							}
                        }
                        return (worldBlocks[key] = { type: blockType, mineProg: 0 });

                    } else if (heavenBiome === 'debris_flats' && row < heavenBaseY + 10) { 
                        if (row === heavenBaseY) {
                            if (random() < 0.005) {
                                blockType = 'pure_heaven_debris_block';
                            }
							else if (random() < 0.05) {
                                blockType = 'strong_heaven_debris_block';
                            }
							else if (random() < 0.2) {
                                blockType = 'ancient_heaven_debris_block';
                            }
							else {
                                blockType = 'corroded_heaven_debris_block';
                            }
                        } else {
                            if (random() < 0.005) {
                                blockType = 'pure_heaven_debris_block';
                            }
							else if (random() < 0.035) {
                                blockType = 'strong_heaven_debris_block';
                            }
							else if (random() < 0.2) {
                                blockType = 'ancient_heaven_debris_block';
                            }
							else {
                                blockType = 'corroded_heaven_debris_block';
                            }
                        }
                        return (worldBlocks[key] = { type: blockType, mineProg: 0 });

                    } else { // Default biome is 'cloudscape' OR deeper parts of gilded forest
                        // Check for houses
                        const houseChunk = Math.floor(col / 50);
                        const housePos = houseChunk * 50 + 25;
                        const houseWidth = 10;
                        const houseHeight = 6;
                        if (col >= housePos && col < housePos + houseWidth && row < heavenBaseY + houseHeight && row >= heavenBaseY) {
                             const houseX = col - housePos;
                             const houseY = row - heavenBaseY;
                             if (houseX === 0 || houseX === houseWidth - 1 || houseY === 0) {
                                 return (worldBlocks[key] = { type: 'heaven_brick_block', mineProg: 0 });
                             } else {
                                  return (worldBlocks[key] = { type: '', mineProg: 0 });
                             }
                        }
                        if (random() < 0.00005) {
                            return worldBlocks[key] = { type: 'chest', mineProg: 0, inventory: [ { type: 'light_armor_tile', count: 1 }, { type: 'hellsteel_nugget', count: 6 }, { type: 'void_dust', count: 7 }, { type: 'heaven_gate_brick_block', count: 1 } ], label: 'Rare Treasure Chest' };
						} else if (random() < 0.0003) {
                            return worldBlocks[key] = { type: 'chest', mineProg: 0, inventory: [ { type: 'light_armor_tile', count: 1 }, { type: 'heaven_gate_brick_block', count: 1 } ], label: 'Compact Treasure Chest' };
						} else if (random() < 0.0010) {
                            return (worldBlocks[key] = { type: 'heavensteel_cloud_block', mineProg: 0 });
                        } else if (random() < 0.0035) {
                            return (worldBlocks[key] = { type: 'diviniron_cloud_block', mineProg: 0 });
                        } else if (random() < 0.1) {
                            return (worldBlocks[key] = { type: 'cloud_rock_block', mineProg: 0 });
                        } else {
                            return (worldBlocks[key] = { type: 'cloud_block', mineProg: 0 });
                        }
                    }
                }
            }

			// --- SUPER HEAVEN generation (fixed) ---
			const superHeavenStartHeight = SUPER_HEAVEN_Y_OFFSET; // keep consistent with teleport/portal logic

			// Ensure we have a separate heights map for Super Heaven to avoid colliding with normal Heaven.

			if (row < superHeavenStartHeight + 25) { // in Super Heaven vertical band
				let heavenSurfaceHeight; // proper camelCase name

				if (superHeavenColumnSurfaceHeights[col] !== undefined) {
					heavenSurfaceHeight = superHeavenColumnSurfaceHeights[col];
				} else {
					let prevSurface = 0;
					if (superHeavenColumnSurfaceHeights[col - 1] !== undefined) {
						prevSurface = superHeavenColumnSurfaceHeights[col - 1];
					} else if (superHeavenColumnSurfaceHeights[col + 1] !== undefined) {
						prevSurface = superHeavenColumnSurfaceHeights[col + 1];
					}
					const offset = Math.floor(random() * 5) - 2; // -2 to 2
					let potentialHeight = prevSurface + offset;
					heavenSurfaceHeight = Math.max(0, Math.min(20, potentialHeight)); // Clamp 0..20
					superHeavenColumnSurfaceHeights[col] = heavenSurfaceHeight;
				}

				// Use superHeavenStartHeight (not heavenStartHeight)
				const heavenBaseY = superHeavenStartHeight - heavenSurfaceHeight;

				if (row === -99976) {
					return (worldBlocks[key] = { type: 'heaven_magma_stone_block', mineProg: 0 });
				}
				else if (row >= heavenBaseY) {
					const heavenBiome = getHeavenBiome(col); // re-use biome chooser or create superHeaven-specific if desired
					let blockType;
						// cloudscape / default (same as your cloud logic)
						const houseChunk = Math.floor(col / 50);
						const housePos = houseChunk * 50 + 25;
						const houseWidth = 10;
						const houseHeight = 6;
						if (col >= housePos && col < housePos + houseWidth && row < heavenBaseY + houseHeight && row >= heavenBaseY) {
							const houseX = col - housePos;
							const houseY = row - heavenBaseY;
							if (houseX === 0 || houseX === houseWidth - 1 || houseY === 0) {
								return (worldBlocks[key] = { type: 'heaven_brick_block', mineProg: 0 });
							} else {
								return (worldBlocks[key] = { type: '', mineProg: 0 });
							}
						}
						let r = random()
						if (r < 0.05)    return (worldBlocks[key] = { type: 'heaven_gate_brick_block', mineProg: 0 });
						else if (r < 0.053)    return (worldBlocks[key] = { type: 'infinitungsten_super_mineral', mineProg: 0 });
						return (worldBlocks[key] = { type: 'super_mineral', mineProg: 0 });
				}
			}

            const biome = getBiome(col);

            let surfaceHeight;
            if (columnSurfaceHeights[col] !== undefined) {
                surfaceHeight = columnSurfaceHeights[col];
            } else {
                let prevSurface = baseSurfaceLevel + Math.floor(surfaceLevelRange / 2);
                if (columnSurfaceHeights[col - 1] !== undefined) {
                    prevSurface = columnSurfaceHeights[col - 1];
                } else if (columnSurfaceHeights[col + 1] !== undefined) {
                     prevSurface = columnSurfaceHeights[col + 1];
                }
                const offset = Math.floor(random() * 3) - 1;
                let potentialHeight = prevSurface + offset;
                surfaceHeight = Math.max(baseSurfaceLevel + minSurfaceVariation, Math.min(baseSurfaceLevel + maxSurfaceVariation, potentialHeight));
                columnSurfaceHeights[col] = surfaceHeight;
				
				// Check for Sandstone Temple
                if (biome === 'desert') {
                    let john = random()
					const biomeInfo = worldBiomes[col];
                    if (biomeInfo) { // Ensure biomeInfo is loaded
                        const biomeStartCol = biomeInfo.start;
                        // Check if we are at the center-most column of this biome and it hasn't been generated
                        const biomeCenterCol = Math.floor(biomeStartCol + (biomeInfo.end - biomeStartCol) / 2);
                        if (john <= 0.3) {
							if (col === biomeCenterCol && !sandstoneTempleColumns.has(biomeStartCol)) {
								generateSandstoneDesertTemple(col, surfaceHeight);
								sandstoneTempleColumns.add(biomeStartCol); // Mark this biome as done
							}
						}
                    }
                }

                // Sky Island Check
                if (random() < skyIslandProbability && !skyIslandColumns.has(col)) {
                    const islandCenterY = surfaceHeight - 60 - Math.floor(random() * 20);
                    generateSkyIsland(col, islandCenterY);
                }
                // Watchtower Check
                if (random() < watchtowerProbability && !watchtowerColumns.has(col)) {
                    generateWatchtower(col, surfaceHeight);
                }
				// Watchtower Check
                if (random() < powertowerProbability && !watchtowerColumns.has(col)) {
                    generatePowertower(col, surfaceHeight);
                }
				// NEW: Chasm Check
				if (random() < chasmProbability && !chasmColumns.has(col)) {
					generateChasm(col, surfaceHeight);
				}
				if ( (biome === 'rainforest')
					 && random() < jungleTempleProbability
					 && !jungleTempleColumns.has(col) ) {
				  generateJungleTemple(col, surfaceHeight);
				}
				if (random() < ruinedPortalProbability && !ruinedPortalColumns.has(col)) {
                    generateRuinedHeavenPortal(col, surfaceHeight);
                }
				const suitableBiomesForMineChamber = ['deciduous_forest', 'grass_field', 'coniferous_forest', 'rocky', 'icy_hills'];
                if (suitableBiomesForMineChamber.includes(biome) && random() < mineChamberProbability && !mineChamberColumns.has(col)) {
                    generateMineChamber(col, surfaceHeight);
                }
				if (biome === 'grass_field' && random() < plantationProbability && !plantationColumns.has(col)) {
                    generatePlantation(col, surfaceHeight);
                }
				if (biome === 'red_rocks') {
					// small chance to place a grounded arch at/near this column
					if (!redRockColumns.has(col) && random() < 0.02 && getBlockType(col, surfaceHeight - 1) === '') {
						// start the arch at this column (may extend left/right)
						generateRockArch(col, surfaceHeight);
						// mark a small range to avoid immediate overlap with another feature
						for (let r = -6; r <= 6; r++) redRockColumns.add(col + r);
					}

					// chance to spawn a spire (more common than arch)
					if (!redRockColumns.has(col) && random() < 0.06 && getBlockType(col, surfaceHeight - 1) === '') {
						// small horizontal jitter so spires don't always align on column boundaries
						const spawnCol = col + (Math.floor(random() * 3) - 1);
						generateSpire(spawnCol, surfaceHeight, 'red_sandstone_block');
						// block the immediate column from future spires/arches
						for (let r = -3; r <= 3; r++) redRockColumns.add(spawnCol + r);
					}
				}
				if (biome === 'icy_hills') {
					// chance to spawn a spire
					if (!icyHillColumns.has(col) && random() < 0.06 && getBlockType(col, surfaceHeight - 1) === '') {
						// small horizontal jitter so spires don't always align on column boundaries
						const spawnCol = col + (Math.floor(random() * 3) - 1);
						generateSpire(spawnCol, surfaceHeight, 'ice');
						// block the immediate column from future spires
						for (let r = -3; r <= 3; r++) icyHillColumns.add(spawnCol + r);
					}
				}
				if (biome === 'granite_mountain') {
					// chance to spawn a spire
					if (!graniteMountainColumns.has(col) && random() < 0.08 && getBlockType(col, surfaceHeight - 1) === '') {
						// small horizontal jitter so spires don't always align on column boundaries
						const spawnCol = col + (Math.floor(random() * 3) - 1);
						generateSpire(spawnCol, surfaceHeight, 'granite');
						// block the immediate column from future spires
						for (let r = -3; r <= 3; r++) graniteMountainColumns.add(spawnCol + r);
					}
				}
            }

            let blockType;
            const depth = row - surfaceHeight;

            if (depth < 0) {
                blockType = '';
            } else {
                // Determine base terrain by biome
                if (biome === 'deciduous_forest') {
                    if (depth === 0) blockType = blockType = (random() < 0.05) ? 'grass_soil' : 'grass_dirt';
                    else if (depth >= 1 && depth <= 9) blockType = (random() < 0.01) ? 'seed_dirt_block' : blockType = (random() < 0.06) ? 'soil' : 'dirt';
                } if (biome === 'grass_field') {
                    if (depth === 0) blockType = blockType = (random() < 0.1) ? 'grass_soil' : 'grass_dirt';
                    else if (depth >= 1 && depth <= 9) blockType = (random() < 0.02) ? 'seed_dirt_block' : blockType = (random() < 0.12) ? 'soil' : 'dirt';
                } else if (biome === 'lush_grasslands') {
                    if (depth === 0) blockType = blockType = (random() < 0.4) ? (random() < 0.4) ? 'overgrown_grass_soil' : 'overgrown_grass_soil' : (random() < 0.4) ? blockType = (random() < 0.4) ? 'overgrown_grass_mud' : 'grass_mud' : blockType = (random() < 0.4) ? 'grass_soil' : 'grass_dirt';
                    else if (depth >= 1 && depth <= 9) blockType = (random() < 0.4) ? 'soil' : blockType = (random() < 0.2) ? blockType = (random() < 0.1) ? 'fertilizer' : 'mud' : 'dirt';
                } else if (biome === 'coniferous_forest') {
                    if (depth === 0) blockType = random() < 0.25 ? 'taiga_grass_dirt_block_2' : 'taiga_grass_dirt_block_1';
                    else if (depth >= 1 && depth <= 9) blockType = 'taiga_dirt';
                } else if (biome === 'rocky') {
                    if (depth >= 0 && depth <= 9) blockType = (random() < 0.03) ? 'packed_ice' : 'rock_block';
                } else if (biome === 'muddy_swamp') {
                    if (depth === 0) blockType = (random() < 0.5) ? 'thick_mud' : 'mud';
                    else if (depth >= 1 && depth <= 4) blockType = (random() < 0.7) ? 'thick_mud' : 'mud'
					else if (depth >= 5 && depth <= 9) blockType = (random() < 0.9) ? 'thick_mud' : 'mud'
                } else if (biome === 'lava_flats') {
                    if (depth >= 0 && depth <= 9) blockType = (random() < 0.02) ? 'ash_block' : (random() < 0.1) ? 'compacted_stone' : 'magma_stone_block';
                } else if (biome === 'salt_flats') {
                    if (depth >= 0 && depth <= 9) blockType = (random() < 0.03) ? 'limestone' : 'salt_rock_block';
                } else if (biome === 'icy_hills') {
                    if (depth >= 0 && depth <= 9) blockType = (random() < 0.1) ? 'ice' : 'packed_ice';
                } else if (biome === 'desert') {
                    if (depth >= 0 && depth <= 9) blockType = 'sand';
                } else if (biome === 'clay_marsh') {
                    if (depth >= 0 && depth <= 9) blockType = 'clay';
                } else if (biome === 'red_rocks') {
                    if (depth === 0) blockType = random() < 0.2 ? 'red_sand_block' : 'red_sandstone_block';
                    else if (depth >= 1 && depth <= 9) blockType = random() < 0.2 ? 'red_sand_block' : 'red_sandstone_block';
                } else if (biome === 'redwood_forest') {
                    if (depth === 0) blockType = 'taiga_grass_dirt_block_1';
                    else if (depth >= 1 && depth <= 9) blockType = random() < 0.006 ? 'limestone' : random() < 0.006 ? 'schist' : 'taiga_dirt'
                } else if (biome === 'granite_mountain') {
                    if (depth >= 0 && depth <= 9) blockType = (random() < 0.004) ? 'aluminum_granite' : (random() < 0.001) ? 'iron_granite' : 'granite';
                } else if (biome === 'dirt_plateau') {
                    if (depth >= 0 && depth <= 9) blockType = 'dirt';
                } else if (biome === 'anthill') {
                    if (depth >= 0 && depth <= 9) { // Top layer of anthill
                        const blockRoll = random();
                        if (blockRoll < 0.88) blockType = 'anthill_sand_block';       
                        else if (blockRoll < 0.92) blockType = '';                 
                        else if (blockRoll < 0.96) blockType = 'sand';          
                        else if (blockRoll < 0.999) blockType = 'sandstone';    
                        else blockType = 'colony_heart_sand_block';                   
                    }
                    if (blockType === 'anthill_sand_block' && random() < antLarvaVeinProbability) {
                        generateVein(col, row, 'ant_larva_block', 6, 8, 'anthill_sand_block');
                        blockType = 'ant_larva_block';
                    }
                } else if (biome === 'overgrown_forest') {
                    if (depth === 0) blockType = random() < 0.3 ? 'weed_dirt' : 'dark_moss_dirt';
                    else if (depth >= 1 && depth <= 9) {
                        const subRoll = random();
                        if (subRoll < 0.6) blockType = 'dirt';
                        else if (subRoll < 0.8) blockType = 'mud';
                        else if (subRoll < 0.95) blockType = 'pest_dirt';
                        else blockType = 'raw_darkwood';
                    }
                } else if (biome === 'apple_grove') {
                    if (depth === 0) blockType = random() < 0.05 ? 'dark_grass_soil' : 'dark_grass_dirt';
                    else if (depth >= 1 && depth <= 9) blockType = (random() < 0.01) ? 'seed_dirt_block' : blockType = (random() < 0.06) ? 'soil' : 'dirt';
                } else if (biome === 'rainforest') {
                    if (depth === 0) {
						const b = random();
						if (b < 0.9) blockType = 'surface_mud';
						else blockType = 'mud';
					} else if (depth >= 1 && depth <= 9) {
						const b = random();
						if (b < 0.99) blockType = 'mud';
						else blockType = 'soil';
					}
                }

                // Deeper layers are consistent across biomes
				if (!blockType) {
					if (depth >= 10 && depth <= 19) {
						blockType = 'stone';
					} else if (depth === 20) {
						blockType = 'compacting_stone';
					} else if (depth >= 21 && depth <= 199) {
						blockType = 'compacted_stone';
					} else if (depth >= 200 && depth <= 205) {
						blockType = 'compressed_stone';
					} else if (depth >= 206 && depth <= 299) {
						blockType = '';
					}
					// existing underworld from 300 up to the void entrance (keep your existing getUnderworldBiome logic)
					else if (depth >= 300 && depth < 600) {
						const underworldBiome = getUnderworldBiome(col);
						if (underworldBiome === 'golden_city' && depth < 315) {
							if (depth === 300) blockType = 'gilded_grass_dirt_block';
							else blockType = 'gilded_dirt_block';
						} else if (underworldBiome === 'meat_world' && depth < 315) {
							if (depth === 300) {
								const b = random();
								if (b < 0.6) blockType = 'meat_block';
								else if (b < 0.95) blockType = 'spoiled_meat_block';
								else blockType = 'flesh_block';
							} else {
								const b = random();
								if (b < 0.7) blockType = 'meat_block';
								else if (b < 0.95) blockType = 'spoiled_meat_block';
								else blockType = 'flesh_block';
							}
						} else if (underworldBiome === 'doom_forest' && depth < 315) {
							if (depth === 300) {
								blockType = 'doom_hellstone';
							} else {
								blockType = 'hellstone';
							}
						} else if (underworldBiome === 'flesh_forest' && depth < 315) {
							if (depth === 300) {
								blockType = 'flesh_hellstone';
							} else {
								blockType = 'hellstone';
							}
						} else if (underworldBiome === 'ash_wastes' && depth < 315) {
							if (depth === 300) {
								const b = random();
								if (b < 0.8) blockType = 'ash_block';
								else blockType = 'obsidian_block';
							} else {
								const b = random();
								if (b < 0.8) blockType = 'ash_block';
								else blockType = 'obsidian_block';
							}
						} else if (underworldBiome === 'magma_basin' && depth < 315) {
							if (depth === 300) {
								const b = random();
								if (b < 0.9) blockType = 'magma_stone_block';
								else blockType = 'obsidian_block';
							} else {
								const b = random();
								if (b < 0.9) blockType = 'magma_stone_block';
								else blockType = 'obsidian_block';
							}
						} else if (underworldBiome === 'icy_hell' && depth < 315) {
							blockType = 'hell_ice';
						} else {
							const b = random();
								if (b < 0.05) blockType = 'hellrock';
								else if (b < 0.08) blockType = 'magma_stone_block';
								else blockType = 'hellstone';
						}
					}
					// VOID REALM (minimal inline values): depth 600..899
					else if (depth >= 600 && depth < 900) {
						// entrance wall: 13 blocks wide, 5 blocks tall, centered on player column if available else column 0
						const entranceCenter = (typeof player !== 'undefined' && player && typeof tileSize !== 'undefined')
							? Math.floor(player.x / tileSize)
							: 0;
						const entranceLeft = entranceCenter - Math.floor(13 / 2);
						const entranceRight = entranceCenter + Math.floor(13 / 2);

						// if row is within the 5-block tall entrance and this column lies within the entrance width -> bedrock
						if (depth >= 600 && depth < 600 + 5) {
							blockType = 'bedrock_stone';
						} else {
							// default: sky (void)
							blockType = '';

							// run generation once per column (small chance to spawn dust pad or voidVoidArch)
							if (!voidRealmColumns.has(col)) {
								voidRealmColumns.add(col);

								const spawnY = surfaceHeight + 600 + 10 + Math.floor(random() * (900 - 600 - 20)); // avoid edges

								// existing: inside if (!voidRealmColumns.has(col)) { voidRealmColumns.add(col); const spawnY = ...; const r = random(); ... }
								const r = random();

								// VERY RARE geode: ~0.5% chance per new column (tweak lower/higher if you want)
								if (r < 0.03) {
									generateGeode(col, spawnY);
								}
								else if (r < 0.2) {
									generateVoidArch(col, spawnY);
								}
								else if (r < 0.8) {
									generateDustPad(col, spawnY);
								}
								else {
									if (random() < 0.02) {
										generateDustPad(col + (random() < 0.5 ? -1 : 1), spawnY + (Math.floor(random() * 5) - 2));
									}
								}
							}
						}
					}
					// below void: infinite stone
					else if (depth >= 900 && depth < 1200) {
						const b = random();
						if (b < 0.005) blockType = 'iron_compressed_stone';
						else if (b < 0.008) blockType = 'aluminum_compressed_stone';
						else if (b < 0.0085) blockType = 'palladium_compressed_stone';
						else if (b < 0.03) blockType = 'coal_compressed_stone';
						else blockType = 'compressed_stone';
					}
					else if (depth >= 1200 && depth < 1225) {
						const b = random();
						blockType = 'outer_mantle_molten_stone';
					}
					else if (depth >= 1225 && depth < 1250) {
						const b = random();
						blockType = 'inner_mantle_molten_stone';
					}
					else if (depth >= 1250 && depth < 1300) {
						const b = random();
						blockType = 'core_molten_stone';
					}
					else if (depth >= 1300 && depth < 1305) {
						const b = random();
						blockType = 'bedrock_stone';
					}
					else if (depth >= 1305 && depth < 1500) {
						const b = random();
						if (b < 0.01) blockType = 'vine_stone';
						else blockType = '';
					}
					else if (depth >= 1500) {
						const b = random();
						blockType = 'vine_stone';
					}
				}

                // Specific replacements
                if (biome === 'desert' && blockType === 'sand' && random() < 0.2) {
                    blockType = 'sandstone';
                }
                if (biome === 'overgrown_forest' && blockType === 'stone' && random() < 0.15) {
                    blockType = random() < 0.6 ? 'pest_stone_block_weak' : 'pest_stone_block_strong';
                }
            }
            
            // Gravel Veins in Stone Layer
            if (blockType === 'stone' && random() < gravelVeinProbability) {
                 blockType = 'gravel';
            }
			
            // Cave, Mineshaft, and Dungeon Generation
            if (blockType === 'compacted_stone') {
                if (random() < dungeonProbability) {
                    generateDungeon(col, row);
                    blockType = worldBlocks[key] ? worldBlocks[key].type : getBlockType(col, row);
                } else if (random() < mineshaftProbability) {
                    generateMineshaft(col, row);
                    blockType = worldBlocks[key] ? worldBlocks[key].type : getBlockType(col, row);
                } else if (random() < lavaCaveProbability) { // ADD THIS
                    generateLavaCave(col, row);
                    blockType = worldBlocks[key] ? worldBlocks[key].type : '';
                } else if (random() < caveProbability) {
                    generateCave(col, row);
                    blockType = worldBlocks[key] ? worldBlocks[key].type : '';
                } else if (random() < bunkerProbability && !bunkerColumns.has(col)) { // ADD THIS
                    generateBunker(col, row);
                    blockType = worldBlocks[key] ? worldBlocks[key].type : getBlockType(col, row);
                }
            }
            
            // Check if this block is adjacent to a cave for boosted ore rates
            let isNearCave = false;
            if (row > baseSurfaceLevel + 25) { // Only check deep underground
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        if (caveBlocks.has(`${col + dx},${row + dy}`)) {
                            isNearCave = true;
                            break;
                        }
                    }
                    if (isNearCave) break;
                }
            }
            const oreSpawnMultiplier = isNearCave ? 2 : 1;


            // Ore generation logic
            if (blockType === 'stone' && random() < coalVeinProbability * oreSpawnMultiplier) {
                blockType = 'coal_stone';
            }
			
			if (blockType === 'stone' && random() < stumpStoneVeinProbability * oreSpawnMultiplier) {
                blockType = 'stump_stone';
            }
			
			if (blockType === 'stone' && random() < limestoneVeinProbability * oreSpawnMultiplier) {
                blockType = 'limestone';
            }
			
			if (blockType === 'stone' && random() < surfaceIronVeinProbability * oreSpawnMultiplier) {
                blockType = 'iron_stone';
            }
            
            // Stone Veins in Compacted Stone
            if (blockType === 'compacted_stone') {
                const veinRoll = random();
                if (veinRoll < graniteVeinProbability) {
                    generateVein(col, row, 'granite', 8, 12, 'compacted_stone');
                    blockType = 'granite';
                } else if (veinRoll < graniteVeinProbability + schistVeinProbability) {
                    generateVein(col, row, 'schist', 8, 12, 'compacted_stone');
                    blockType = 'schist';
                } else if (veinRoll < graniteVeinProbability + schistVeinProbability + slateVeinProbability) {
                    generateVein(col, row, 'slate', 8, 12, 'compacted_stone');
                    blockType = 'slate';
                } else if (veinRoll < graniteVeinProbability + schistVeinProbability + slateVeinProbability + rockVeinProbability) {
                    generateVein(col, row, 'rock_block', 4, 12, 'compacted_stone');
                    blockType = 'rock_block';
                } else if (veinRoll < graniteVeinProbability + schistVeinProbability + slateVeinProbability + rockVeinProbability + saltVeinProbability) {
                    generateVein(col, row, 'salt_rock_block', 4, 12, 'compacted_stone');
                    blockType = 'salt_rock_block';
                } else if (veinRoll < graniteVeinProbability + schistVeinProbability + slateVeinProbability + rockVeinProbability + saltVeinProbability + nitroVeinProbability) {
                    generateVein(col, row, 'nitro_compacted_stone', 4, 12, 'compacted_stone');
                    blockType = 'nitro_compacted_stone';
                } else if (veinRoll < graniteVeinProbability + schistVeinProbability + slateVeinProbability + rockVeinProbability + saltVeinProbability + nitroVeinProbability + crudeOilVeinProbability) {
                    generateVein(col, row, 'crude_oil_compacted_stone', 4, 12, 'compacted_stone');
                    blockType = 'crude_oil_compacted_stone';
                }
            }


            if (blockType === 'compacted_stone') {
                // Layer 1: Compacted Coal, Copper, Tin
                if (depth >= 21) { 
                    if (random() < copperVeinProbability * oreSpawnMultiplier) blockType = 'copper_compacted_stone';
                    else if (random() < tinVeinProbability * oreSpawnMultiplier) blockType = 'tin_compacted_stone';
					else if (random() < zincVeinProbability * oreSpawnMultiplier) blockType = 'zinc_compacted_stone';
					else if (random() < deepCoalVeinProbability * oreSpawnMultiplier) blockType = 'coal_compacted_stone';
                } 
                // Layer 2: Iron
                if (depth >= 35) { 
                    if (random() < ironVeinProbability * oreSpawnMultiplier) blockType = 'iron_compacted_stone';
                } 
                // Layer 3: Gold, Tungsten
                if (depth >= 45) { 
                    if (random() < goldVeinProbability * oreSpawnMultiplier) blockType = 'gold_compacted_stone';
					else if (random() < tungstenVeinProbability * oreSpawnMultiplier) blockType = 'tungsten_compacted_stone';
                } 
                // Layer 4: Ruby, Sapphire, Topaz, Amethyst
                if (depth >= 60) { 
                    if (random() < amethystVeinProbability * oreSpawnMultiplier) blockType = 'amethyst_compacted_stone';
                    else if (random() < rubyVeinProbability * oreSpawnMultiplier) blockType = 'ruby_compacted_stone';
                    else if (random() < sapphireVeinProbability * oreSpawnMultiplier) blockType = 'sapphire_compacted_stone';
                    else if (random() < topazVeinProbability * oreSpawnMultiplier) blockType = 'topaz_compacted_stone';
                }
                // Layer 5: Diamond, Emerald
                if (depth >= 60) {
                     if (random() < diamondVeinProbability * oreSpawnMultiplier) blockType = 'diamond_compacted_stone';
                     else if (random() < emeraldVeinProbability * oreSpawnMultiplier) blockType = 'emerald_compacted_stone';
                }
                // Layer 6: Opal
                if (depth >= 65) {
                    if (random() < opalVeinProbability * oreSpawnMultiplier) blockType = 'opal_compacted_stone';
					else if (random() < jadeVeinProbability * oreSpawnMultiplier) blockType = 'jade_compacted_stone';
                }
            }
			
			if (blockType === 'hellstone') {
				// Doom shacks: somewhat common in hell biomes
				if (random() < doomShackProbability && !doomShackColumns.has(col)) {
					generateDoomShack(col, row);
					// refresh the local blockType reference to whatever we just placed at this key (if needed)
					blockType = worldBlocks[`${col},${row}`] ? worldBlocks[`${col},${row}`].type : getBlockType(col, row);
				}
                if (random() < hellsteelVeinProbability * oreSpawnMultiplier) {
                    blockType = 'hellsteel_hellstone';
                } else if (random() < mighterrumVeinProbability * oreSpawnMultiplier) {
                    blockType = 'mighterrum_hellstone';
                } else if (random() < obsidianVeinProbability) {
                    generateVein(col, row, 'obsidian_block', 3, 5, 'hellstone');
                    blockType = 'obsidian_block';
                } else if (random() < boneSpineProbability) {
                    generateSpinalVein(col, row, 'bone_block', 20, 30);
                    blockType = 'bone_block';
                }
            }

            // Surface cover / foliage generation
            if (depth === 0) { // Only check for surface blocks
                if (biome === 'deciduous_forest') {
                    if (getBlockType(col, row - 1) === '') {
						if (random() < 0.02) worldBlocks[`${col},${row - 1}`] = { type: 'red_flower', mineProg: 0 };
						else if (random() < 0.05) worldBlocks[`${col},${row - 1}`] = { type: 'yellow_flower', mineProg: 0 };
						else if (random() < 0.08) worldBlocks[`${col},${row - 1}`] = { type: 'leaf_plant', mineProg: 0 };
                        else if (random() < 0.18) worldBlocks[`${col},${row - 1}`] = { type: 'tall_grass', mineProg: 0 };
                        else if (random() < 0.35) worldBlocks[`${col},${row - 1}`] = { type: 'grass', mineProg: 0 };
                    }
                    if (random() < 0.15 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, random() < 0.66 ? 'oak' : 'birch');
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            // Mark a buffer zone around the trader to prevent clumping
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'grass_field') {
                    if (getBlockType(col, row - 1) === '') {
						let rand = random(); // This is ideal rather than reusing random()
						if (rand < 0.04) worldBlocks[`${col},${row - 1}`] = { type: 'red_flower', mineProg: 0 };
						else if (rand < 0.1) worldBlocks[`${col},${row - 1}`] = { type: 'yellow_flower', mineProg: 0 };
						else if (rand < 0.12) worldBlocks[`${col},${row - 1}`] = { type: 'blue_flower', mineProg: 0 };
						else if (rand < 0.14) worldBlocks[`${col},${row - 1}`] = { type: 'orange_flower', mineProg: 0 };
						else if (rand < 0.16) worldBlocks[`${col},${row - 1}`] = { type: 'green_flower', mineProg: 0 };
						else if (rand < 0.2) worldBlocks[`${col},${row - 1}`] = { type: 'purple_flower', mineProg: 0 };
                        else if (rand < 0.23 && getBlockType(col, row - 1) === '') generateTallFoliage(col, row, 'sunflower');
                        else if (rand < 0.5) worldBlocks[`${col},${row - 1}`] = { type: 'tall_grass', mineProg: 0 };
						else if (rand < 0.65) worldBlocks[`${col},${row - 1}`] = { type: 'grass_sprouts', mineProg: 0 };
                        else worldBlocks[`${col},${row - 1}`] = { type: 'grass', mineProg: 0 };
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            // Mark a buffer zone around the trader to prevent clumping
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'lush_grasslands') {
                    if (getBlockType(col, row - 1) === '') {
						if (random() < 0.5) worldBlocks[`${col},${row - 1}`] = { type: 'tall_grass', mineProg: 0 };
						else if (random() < 0.6) worldBlocks[`${col},${row - 1}`] = { type: 'grass_sprouts', mineProg: 0 };
						else worldBlocks[`${col},${row - 1}`] = { type: 'grass', mineProg: 0 };
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            // Mark a buffer zone around the trader to prevent clumping
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'coniferous_forest') {
                    if (getBlockType(col, row - 1) === '') {
                        if (random() < 0.05) worldBlocks[`${col},${row - 1}`] = { type: 'pinecone_pile', mineProg: 0 };
                        else if (random() < 0.3) worldBlocks[`${col},${row - 1}`] = { type: 'pine_needle_pile', mineProg: 0 };
                    }
                    if (random() < 0.18 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'spruce');
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            // Mark a buffer zone around the trader to prevent clumping
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'apple_grove') {
                    let rand = random(); // This is ideal rather than reusing random()
					if (getBlockType(col, row - 1) === '') {
                        if (rand < 0.5) worldBlocks[`${col},${row - 1}`] = { type: 'grass', mineProg: 0 };
                    }
					rand = random();
                    if (rand < 0.2 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'apple');
                    } else if (rand < 0.27 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'orange');
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            // Mark a buffer zone around the trader to prevent clumping
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'rainforest') {
                    if (getBlockType(col, row - 1) === '') {
                        if (random() < 0.02) worldBlocks[`${col},${row - 1}`] = { type: 'mossy_root', mineProg: 0 };
                        else if (random() < 0.16) worldBlocks[`${col},${row - 1}`] = { type: 'leaf_pile', mineProg: 0 };
						else if (random() < 0.22) worldBlocks[`${col},${row - 1}`] = { type: 'dark_moss', mineProg: 0 };
						else if (random() < 0.24) worldBlocks[`${col},${row - 1}`] = { type: 'moss', mineProg: 0 };
						else if (random() < 0.30) worldBlocks[`${col},${row - 1}`] = { type: 'fern', mineProg: 0 };
                    }
                    if (random() < 0.35 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, random() < 0.5 ? 'mahogany' : random() < 0.3 ? 'cinnamon' : 'rubber');
                    }
					if (random() < 0.15 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'fern');
                    } else if (random() < 0.25 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'sugarcane');
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            // Mark a buffer zone around the trader to prevent clumping
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'overgrown_forest') { 
                    if (getBlockType(col, row - 1) === '') {
                        const foliageRoll = random();
                        if (foliageRoll < 0.1) worldBlocks[`${col},${row - 1}`] = { type: 'grass', mineProg: 0 };
                        else if (foliageRoll < 0.2) worldBlocks[`${col},${row - 1}`] = { type: 'weed', mineProg: 0 };
                        else if (foliageRoll < 0.3) worldBlocks[`${col},${row - 1}`] = { type: 'shroom', mineProg: 0 };
                        else if (foliageRoll < 0.5) worldBlocks[`${col},${row - 1}`] = { type: 'dark_moss', mineProg: 0 };
                        else if (foliageRoll < 0.7) worldBlocks[`${col},${row - 1}`] = { type: 'moss', mineProg: 0 };
						else if (foliageRoll < 0.75) worldBlocks[`${col},${row - 1}`] = { type: 'big_shroom', mineProg: 0 };
						else if (foliageRoll < 0.76) worldBlocks[`${col},${row - 1}`] = { type: 'devil_shroom', mineProg: 0 };
                    }
                    if (random() < 0.24 && getBlockType(col, row - 1) === '') { // Higher tree chance
                        generateTree(col, row, 'darkwood');
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            // Mark a buffer zone around the trader to prevent clumping
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'rocky') {
                    if (getBlockType(col, row - 1) === '') {
                        if (random() < 0.2) worldBlocks[`${col},${row - 1}`] = { type: 'large_snow_pile', mineProg: 0 };
                        else worldBlocks[`${col},${row - 1}`] = { type: 'snow', mineProg: 0 };
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            // Mark a buffer zone around the trader to prevent clumping
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'muddy_swamp') {
                    if (getBlockType(col, row - 1) === '') {
						let rand = random(); // This is ideal rather than reusing random()
						if (rand < 0.3) worldBlocks[`${col},${row - 1}`] = { type: 'milkweed', mineProg: 0 };
						else if (rand < 0.4) worldBlocks[`${col},${row - 1}`] = { type: 'tall_grass', mineProg: 0 };
						else if (rand < 0.5) generateTree(col, row, 'dead_tree');
						else if (rand < 0.55) generateTree(col, row, 'sugarcane');
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            // Mark a buffer zone around the trader to prevent clumping
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'salt_flats') {
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            // Mark a buffer zone around the trader to prevent clumping
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'lava_flats') {
                    if (random() < 0.32 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'magma');
                    }
                } else if (biome === 'icy_hills') {
                    if (getBlockType(col, row - 1) === '') {
                        if (random() < 0.3) worldBlocks[`${col},${row - 1}`] = { type: 'large_snow_pile', mineProg: 0 };
                        else worldBlocks[`${col},${row - 1}`] = { type: 'snow', mineProg: 0 };
                    }
                } else if (biome === 'desert') {
                    if (blockType === 'sand' && getBlockType(col, row - 1) === '') {
                        const foliageRoll = random();
                        if (foliageRoll < cactusProbability) generateCactus(col, row);
                        else if (foliageRoll < 0.20) worldBlocks[`${col},${row - 1}`] = { type: 'prickly_pear_cactus', mineProg: 0 };
                        else if (foliageRoll < 0.40) worldBlocks[`${col},${row - 1}`] = { type: 'desert_brush', mineProg: 0 };
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            // Mark a buffer zone around the trader to prevent clumping
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'red_rocks') {
                    if (getBlockType(col, row - 1) === '') {
                        if (random() < 0.2) worldBlocks[`${col},${row - 1}`] = { type: 'desert_grass', mineProg: 0 };
                    }
                } else if (biome === 'redwood_forest') {
                    if (getBlockType(col, row - 1) === '') {
                        if (random() < 0.3) worldBlocks[`${col},${row - 1}`] = { type: 'fern', mineProg: 0 };
                        else if (random() < 0.6) worldBlocks[`${col},${row - 1}`] = { type: 'pine_needle_pile', mineProg: 0 };
                    }
                    if (random() < 0.18 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'redwood');
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            // Mark a buffer zone around the trader to prevent clumping
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'anthill') {
                     if (blockType === 'anthill_sand_block' && getBlockType(col, row - 1) === '' && random() < anthillMoundProbability) {
                        worldBlocks[`${col},${row - 1}`] = { type: 'anthill_sand_mound', mineProg: 0 };
                    }
                    if (random() < traderProbability && !traderColumns.has(col) && getBlockType(col, row - 1) === '' && getBlockType(col, row - 2) === '' && getBlockType(col, row - 3) === '') {
                        if (placeTraderAt(col, row - 1)) {
                            console.log("Naturally spawned a Trader at", col);
                            // Mark a buffer zone around the trader to prevent clumping
                            for(let i = -15; i <= 15; i++) {
                                traderColumns.add(col + i);
                            }
                        }
                    }
                } else if (biome === 'granite_mountain') {
                    if (random() < 0.3 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'spruce');
                    } else if (random() < 0.6 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'granite');
                    }
                } else if (biome === 'dirt_plateau') {
                    if (random() < 1 && getBlockType(col, row - 1) === '') {
                        generateTree(col, row, 'dirt_column');
                    }
                }
            }
            // Underworld foliage
			if (blockType === 'hellstone' && depth === 300 && random() < 0.05) {
				generateTree(col, row, 'hell');
			}
            if (blockType === 'gilded_grass_dirt_block' && depth === 300 && random() < 0.2) {
                generateTree(col, row, 'gilded');
            }
			if (blockType === 'meat_block' && depth === 300 && random() < 0.2) {
                generateTree(col, row, 'meat');
            }
			if (blockType === 'spoiled_meat_block' && depth === 300 && random() < 0.2) {
                generateTree(col, row, 'spoiled_meat');
            }
			if (blockType === 'ash_block' && depth === 300 && random() < 0.2) {
                generateTree(col, row, 'ash');
            }
			if (blockType === 'magma_stone_block' && depth === 300 && random() < 0.2) {
                generateTree(col, row, 'magma');
            }

            // --- FIX: Check if a structure or vein generator has *already* placed this block ---
            // This prevents the default terrain (like 'sky' or 'stone') from overwriting
            // a structure block (like 'cloud_block' or 'planked_oak') that was
            // generated during this same function call.
            if (worldBlocks[key] !== undefined) {
                return worldBlocks[key];
            }
            // --- END FIX ---

            const newBlockData = { type: blockType, mineProg: 0 };
            worldBlocks[key] = newBlockData;
            return newBlockData;
        }
        
        // Generic Vein generator
        function generateVein(startX, startY, veinBlockType, minSize, maxSize, replaceBlock) {
            const veinSize = minSize + Math.floor(random() * (maxSize - minSize + 1));
            for (let i = 0; i < veinSize; i++) {
                const vCol = startX + Math.floor(random() * 3) - 1;
                const vRow = startY + Math.floor(random() * 3) - 1;
                const vKey = `${vCol},${vRow}`;
                const existingBlock = getBlockType(vCol, vRow);
                if (existingBlock === replaceBlock) {
                     worldBlocks[vKey] = { type: veinBlockType, mineProg: 0 };
                }
            }
        }

        // Spinal Vein Generator
        function generateSpinalVein(startX, startY, veinBlockType, minLength, maxLength) {
            const length = minLength + Math.floor(random() * (maxLength - minLength + 1));
            let currentX = startX;
            let currentY = startY;
            let directionX = random() < 0.5 ? 1 : -1;

            for (let i = 0; i < length; i++) {
                // Main spine
                worldBlocks[`${currentX},${currentY}`] = { type: veinBlockType, mineProg: 0 };

                // Ribs
                if (i % 2 === 0) {
                    worldBlocks[`${currentX},${currentY - 1}`] = { type: veinBlockType, mineProg: 0 };
                    worldBlocks[`${currentX},${currentY + 1}`] = { type: veinBlockType, mineProg: 0 };
                    if (random() < 0.5) {
                         worldBlocks[`${currentX},${currentY - 2}`] = { type: veinBlockType, mineProg: 0 };
                         worldBlocks[`${currentX},${currentY + 2}`] = { type: veinBlockType, mineProg: 0 };
                    }
                }

                // Change direction occasionally
                if (random() < 0.2) directionX *= -1;
                if (random() < 0.4) currentY += (random() < 0.5 ? 1 : -1);
                
                currentX += directionX;
            }
        }


        // --- CAVE GENERATION ---
        function generateCave(startX, startY) {
            console.log("Cave Generated");
			const caveSize = 100 + Math.floor(random() * 101); // 100-200 blocks
            let blocksCarved = 0;
            const toCarve = new Set([`${startX},${startY}`]);
            const carved = new Set(); // This will store all 'x,y' keys of carved AIR blocks

            while (blocksCarved < caveSize && toCarve.size > 0) {
                // Get a random block from the list of blocks to be carved
                const currentKey = Array.from(toCarve)[Math.floor(random() * toCarve.size)];
                toCarve.delete(currentKey);

                if (carved.has(currentKey)) continue;

                const [x, y] = currentKey.split(',').map(Number);

                // Carve out the block and its immediate neighbors to make tunnels wider
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const carveX = x + dx;
                        const carveY = y + dy;
                        const key = `${carveX},${carveY}`;
                        
                        // Don't carve too close to the surface
                        if (carveY < baseSurfaceLevel + 25) continue; 

                        // Replace the original block with a vine stone block
                        const originalBlock = getBlockType(carveX, carveY);
                        if(originalBlock !== '') {
                            worldBlocks[key] = { type: 'vine_stone', mineProg: 0 };
                        }

                        // Carve out the center block into air
                        if (dx === 0 && dy === 0) {
                             worldBlocks[key] = { type: '', mineProg: 0 };
                             caveBlocks.add(key); // Add to the set for ore checking
                             carved.add(key); // --- Store the AIR block's key ---
                             blocksCarved++;
                        }
                    }
                }

                // Add new potential carving paths
                for (let i = 0; i < 4; i++) { // Add more branching
                    if (random() < 0.6) { // Chance to branch off
                        const direction = Math.floor(random() * 4);
                        let nextX = x, nextY = y;
                        if (direction === 0) nextX++;
                        else if (direction === 1) nextX--;
                        else if (direction === 2) nextY++;
                        else nextY--;
                        
                        const nextKey = `${nextX},${nextY}`;
                        if (!carved.has(nextKey)) {
                            toCarve.add(nextKey);
                        }
                    }
                }
            }

            // --- ADD THIS NEW FOLIAGE PASS ---
            // Second pass: Add foliage to the floor
            const guanoProbability = 0.12; // 12% chance for guano
            
            carved.forEach(airKey => {
                const [col, row] = airKey.split(',').map(Number);
                const floorKey = `${col},${row + 1}`;
                const floorBlock = worldBlocks[floorKey];

                // Check if the block below is a solid cave floor block ('vine_stone')
                if (floorBlock && floorBlock.type === 'vine_stone') {
                    // Roll for guano
                    if (random() < guanoProbability) {
                        // Place guano in the AIR block (airKey)
                        worldBlocks[airKey] = { type: 'guano', mineProg: 0 };
                    }
                }
            });
            // --- END OF ADDITION ---
        }
        
        // --- MINESHAFT GENERATION (REVISED) ---
        function generateMineshaft(startX, startY) {
            console.log("Mineshaft Generated");
			const width = 20 + Math.floor(random() * 31); // 20-50 blocks wide
            const height = 4; // Always 4 blocks tall air space

            for (let x = startX; x < startX + width; x++) {
                for (let y = startY; y < startY + height + 2; y++) { // +2 for floor and ceiling
                    const key = `${x},${y}`;
                    // Floor and Ceiling
                    if (y === startY || y === startY + height + 1) {
                        worldBlocks[key] = { type: 'planked_oak', mineProg: 0 };
                    } 
                    // Walls
                    else if (x === startX || x === startX + width - 1) {
                        worldBlocks[key] = { type: 'planked_spruce', mineProg: 0 };
                    }
                    // Inside the mineshaft
                    else {
                        // 15% chance of cobweb, otherwise air
                        if (random() < 0.3) {
                            worldBlocks[key] = { type: 'planked_oak_wall', mineProg: 0 };
							worldBlocks[key].overlay = 'cobweb';
                        } else {
                            worldBlocks[key] = { type: 'planked_oak_wall', mineProg: 0 };
                        }
                    }
                }
            }

            // Add loot chest in the bottom corner
            const chestCol = startX + 1;
            const chestRow = startY + height;
            const chestKey = `${chestCol},${chestRow}`;
            
            const loot = [];
            const lootTypes = ['wooden_pickaxe', 'steel_nugget', 'asphalt', 'rock_pickaxe', 'wheat_bread', 'planked_hell_wood', 'rice_seeds'];
			const toolDurability = {'wooden_pickaxe': 11250, 'rock_pickaxe': 18750}; //75% Standard Durability
            const randomOre = lootTypes[Math.floor(random() * lootTypes.length)];
			//Add loot items to the array
			loot.push({ type: 'iron_nugget', count: 1 + Math.floor(random() * 5) });
			loot.push({ type: 'copper_nugget', count: 1 + Math.floor(random() * 5) });
			loot.push({ type: 'raw_birch', count: 1 + Math.floor(random() * 5) });
            loot.push({ type: 'rice_seeds', count: 1 + Math.floor(random() * 3) });

			// Handle randomOre logic
			if (toolDurability[randomOre]) {
				loot.push({
					type: randomOre,
					durability: toolDurability[randomOre],
					maxDurability: toolDurability[randomOre],
					count: 1
				});
			} else {
				loot.push({ type: randomOre, count: 1 + (randomOre === 'rice_seeds' ? Math.floor(random() * 3) : 0) });
			}

            // Create chest with inventory
            worldBlocks[chestKey] = { 
                type: 'chest', 
                mineProg: 0, 
                inventory: new Array(chestInventorySize).fill(null),
                label: 'Mineshaft Chest'
            };

            // Place loot into the chest inventory
            loot.forEach((item, index) => {
                if (index < chestInventorySize) {
                    worldBlocks[chestKey].inventory[index] = item;
                }
            });
        }

        // --- NEW DUNGEON GENERATION ---
        function generateDungeon(startX, startY) {
            console.log("Dungeon Generated at", startX, startY);
            const mainChamberWidth = 15 + Math.floor(random() * 10);
            const mainChamberHeight = 10 + Math.floor(random() * 6);
            
            // Carve main chamber
            for (let x = startX; x < startX + mainChamberWidth; x++) {
                for (let y = startY; y < startY + mainChamberHeight; y++) {
                    const key = `${x},${y}`;
                    // Walls and Floor
                    if (x === startX || x === startX + mainChamberWidth - 1 || y === startY || y === startY + mainChamberHeight - 1) {
                        worldBlocks[key] = { type: random() < 0.5 ? 'planked_spruce' : 'planked_darkwood', mineProg: 0 };
                    } else { // Inside
                        worldBlocks[key] = { type: '', mineProg: 0 };
                        if (random() < 0.2) { // Add cobwebs inside
                             worldBlocks[`${x},${y}`] = { type: 'cobweb', mineProg: 0 };
                        }
                    }
                }
            }

            // Add 3 rooms
            const roomWidth = 5 + Math.floor(random() * 3);
            const roomHeight = 4 + Math.floor(random() * 2);
            for (let i = 0; i < 3; i++) {
                const roomStartX = startX + 2 + i * (roomWidth + 1);
                const roomStartY = startY + mainChamberHeight; // Rooms are below the main chamber

                // Check if room fits
                if (roomStartX + roomWidth >= startX + mainChamberWidth - 1) continue;

                // Carve room and separator
                for (let x = roomStartX - 1; x < roomStartX + roomWidth + 1; x++) {
                    for (let y = roomStartY - 1; y < roomStartY + roomHeight + 1; y++) {
                        const key = `${x},${y}`;
                        // Separator wall
                        if (y === roomStartY - 1) {
                            worldBlocks[key] = { type: 'vine_stone', mineProg: 0 };
                        } 
                        // Room walls/floor
                        else if (x === roomStartX - 1 || x === roomStartX + roomWidth || y === roomStartY + roomHeight) {
                             worldBlocks[key] = { type: random() < 0.5 ? 'planked_spruce' : 'planked_darkwood', mineProg: 0 };
                        }
                        // Inside the room
                        else {
                            worldBlocks[key] = { type: '', mineProg: 0 };
                            if (random() < 0.3) { // More cobwebs in rooms
                                worldBlocks[key] = { type: 'cobweb', mineProg: 0 };
                            }
                        }
                    }
                }
                
                // Add a chest to each room
                const chestCol = roomStartX + Math.floor(roomWidth / 2);
                const chestRow = roomStartY + roomHeight - 1;
                const chestKey = `${chestCol},${chestRow}`;
                worldBlocks[chestKey] = { 
                    type: 'chest', 
                    mineProg: 0, 
                    inventory: new Array(chestInventorySize).fill(null),
                    label: 'Dungeon Chest'
                };
                // Add dungeon loot
                const loot = [];
                loot.push({ type: 'gold_nugget', count: 1 + Math.floor(random() * 3) });
                loot.push({ type: 'iron_nugget', count: 1 + Math.floor(random() * 5) });
                if (random() < 0.1) loot.push({ type: 'diamond_nugget', count: 1 + Math.floor(random() * 2) });
                if (random() < 0.5) loot.push({ type: 'corn_seeds', count: 2 + Math.floor(random() * 5) });
                if (random() < 0.2) loot.push({ type: 'iron_pickaxe', count: 1, durability: 15000, maxDurability: 50000 }); //30% Durability
				if (random() < 0.3) loot.push({ type: 'dark_armor_tile', count: 1});
				if (random() < 0.3) loot.push({ type: 'light_armor_tile', count: 1});
				if (random() < 0.3) loot.push({ "type": "book", "count": 1, "durability": 1, "maxDurability": 1, "title": "A Tribute To Mr. Lanbridge", "cover": "A Tribute To Mr. Lanbridge.png", "content": "To my dearest and most lamented friend, Gorge Lanbridge,\n\nI set quill to paper by the failing light of a world grown dim, and write with hands that tremble as though they knew already the cold that now walks the bones of the earth. If these lines find no hearth-side to warm them, let them nevertheless fall as witness  for thou wert a bright thing in that brief, furious day, and I am left to make of memory the only candle.\n\nRemember first how the cities once rang with the honest clang of labor and laughter: market-voices, bell-steeples, and the long slow commerce of folk who hired their living from soil and forge alike. Governments kept their parchments and councils; watchtowers stood proud; plantations breathed in sun. We flourished, we ate, we walked under merchanted awnings, and the world felt large and certain.\n\nThen came the meteors.\n\nAt first men spoke of marvel and portent. They fell like thrown embers from some obscene hearth, and where they struck the ground they opened wounds  black, deep chasms that yawned as if the earth herself had taken a great, grievous sigh. These chasms birthed gates of hellish heat; from them rose smoke, and the night-airs carried acrid ash. The first to fall into those yawning mouths were curious miners and devout fools; the second to fall were streets and bridges and the patient bones of small hamlets. What began as rumour  that the sky had been rent and something older stirred beneath  became the slow, sicking truth.\n\nThe chasms bred pestilence not of simple fever but of growth: a creeping, hungry vegetation that called itself 'pest' in the tongues of any foolish enough to name it. It wound through timber and bone, congealing the fields into a green rot; barns swelled and burst; grain turned sour on the stalk. Magma, once content to sleep in secret furnaces, came brazen to the surface and pooled where children once chased one another with stick-swords. Food spoiled in bowls and hands alike, and the air took on a scent that made men spit and weep.\n\nFear made us into strangers. Where a man had once greeted another with bread and jest, now he barred doors and bore axes. Houses burned not in battle but in blind rage: lighters sparked pyres for spite; arms that had built were used to break; tools were turned to terror. Many fled beneath the bones of the world and sank shafts and minechambers where the air was cooler and the earth more honest. Others raised watchtowers to look down upon neighbours like wardens of a failing realm, as though sight might forestall the rot.\n\nDungeons and caverns yawned like second cities; some folk found sanctuary there, and some found hunger. Rural plantations  for a spell, and a sorrowful one  kept their semblance of peace, their fields still golden beneath a pallid sun, until heat came to stay and the world, in its fever, took its toll.\n\nAnd then the world heated. I have no proper word for that final furnace. The sky pressed close; breath came thick and short. Men fell in the streets as if undone by invisible ovens. Great masses overheated and lay still, and the living among them wondered by what miracle certain bodies did not perish but were transmuted into something else. From those overheated hosts, curiously, there emerged traders  men and women wrapped in masks and cloths, carrying wares and sorrow in equal measure. Their faces, if ever they had faces beneath those coverings, were hid; their eyes were hollow with grief. Their grief was a chain upon them: it rooted them where they stood, made them immobile in numbers that would have moved nations. They traded still  hands that could not walk could yet give and receive  they spoke simple barters, they gave salt or seed, and they could not be stirred by exhortation or wrath. Thus the commerce of grief continued long after the commerce of plenty had died.\n\nBeneath hell and below even the underworld the void gates opened. I have seen things no pious sermon taught me to name: stalls of shadow where doom shacks rose like poor chapels for the damned; demons that smelled of metal and old winter; and creatures that gnawed at the seam between stone and soul. They mounted as if to claim the broken world. Yet even these enemies were not eternal. Heaven  or that which men dared to call heaven in those last reckonings  brushed once upon the clouds of our mortal breath, and where it touched the demonic air the devils withered and fell as one might scatter rotten fruit.\n\nIn that holy falling, strange and mournful losses followed: the laggy cows, fleshly and slow as corrupted memories, began to lag not only in gait but in being, and then they ceased; birds dwindled on silent wing; the buzz of life, so long taken for granted, went thin and then was not. All vanished that had once been living save for a narrow margin of miracle and stubbornness.\n\nOf the living that remained, Cornelius, be told, I name only a few: the void trader  an uncanny merchant who kept one foot in shadow and one in pocket  and those masked multitudes who traded without moving. There is also a man, unnamed in the records I keep, chosen by whatever small providence clung to our ruin. He walks alone with no companion but the traders and that silent void-dealer, and on him I lay all verses of hope and more than my prayers. He bears no heraldry; his name is a blank in my mouth, but they whisper that he was marked to survive, to keep a strain of human stubbornness from being utterly plucked.\n\nI confess to thee, Gorge, that I am sorry. I am sorry in ways that go beyond grief: I am sorry for the small failings, the soft betrayals, the days I wasted in idle mirth whilst the world sharpened behind its hand. I am sorry for the friends I ought to have held closer and the tasks I left to other's hands. I am sorry that when the meteors first came, I did not take you by the shoulder and tell thee the truth  that I loved thee as a friend loves a brother  and that I did not make of that love some better shield against the bitterness that followed.\n\nForgive me if thou canst. Forgive me if, in these lines, I make too public a thing of private sorrow. Forgive also the poor cadence of an old man who writes by lamplight and remembers the sound of thy laughter like a bell now muffled by dust.\n\nI set down here what I can of the world, not as chronicle but as hymn: the cities that were, the chasms that came, the pest that overgrew, the magma that pooled, the watchtowers and the minechambers, the dungeons and the plantations, the traders immobile with grief, the void gates, the rise and fall of demons, heaven's terrible touch upon the clouds, the strange demise of laggy cows and every living thing. Let this be kept, if only in a chest under a floorboard, that some other hand might read and know what fell and what, by stubborn mercy, remained.\n\nIf any hope there be, it rests upon the unnamed man. I have seen him once at dawn, a figure bent but unbroke, speaking in low barter to a masked trader. The words they exchanged were simple  seed for salt, water for story  and in that small trade I perceived a future: not one of cities wiederbuilt in a day, but of slow tending, of person to person, the planting of one seed at a time until green would trust the sun again.\n\nMy last command to thee is this, dear Gorge: keep your watch where it once mattered. If a child in some long-forgotten field chances upon this book, let them know our names and our follies and our love. Let them name us with both tenderness and warning. I, Cornelius Zaezit, who have loved and erred and learned the weight of silence, lay down this tribute and seal it with the only thing left that is honest  remembrance.\n\nEver thine in grief and gratitude,\n\nCornelius Zaezit\n\nP.S. If the void trader ever barters for this page, tell him that Gorge laughed once at a joke about cheese and carts, and that I would have said 'CHHEHHESEESE, cheese!' in a choir of lunatics if it would have made thee grin. I am ashamed to write such a foolish thing now, but some grief must still keep small laughter alive.\n", "published": true });
                loot.forEach((item, index) => {
                    if (index < chestInventorySize) {
                        worldBlocks[chestKey].inventory[index] = item;
                    }
                });
            }
        }

        // --- LAVA CAVE GENERATION ---
        function generateLavaCave(startX, startY) {
            console.log("Deep Magma Cave Generated: Hotter, Fuller, and Branchier!");
            
            // Increased cave size range (100-250 blocks) for a much fuller cave
            const caveSize = 100 + Math.floor(random() * 151); 
            let blocksCarved = 0;
            const toCarve = new Set([`${startX},${startY}`]);
            const carved = new Set();
            const floorBlocks = new Map(); // To store the lowest air block in each column
        
            // Increased carving radius for fuller caves/tunnels
            const carveRadius = 2; 
        
            // First Pass: Carve out the aggressive, branchy cave shape
            while (blocksCarved < caveSize && toCarve.size > 0) {
                // Pick a key to carve
                const currentKey = Array.from(toCarve)[Math.floor(random() * toCarve.size)];
                toCarve.delete(currentKey);
        
                if (carved.has(currentKey)) continue;
        
                const [x, y] = currentKey.split(',').map(Number);
        
                // Carve out a larger, fuller area (5x5 using carveRadius = 2)
                for (let dx = -carveRadius; dx <= carveRadius; dx++) {
                    for (let dy = -carveRadius; dy <= carveRadius; dy++) {
                        const carveX = x + dx;
                        const carveY = y + dy;
                        const key = `${carveX},${carveY}`;
        
                        // Ensure carving only happens deep underground
                        if (carveY < baseSurfaceLevel + 25) continue; 
        
                        // Aggressively replace surrounding blocks with magma stone
                        // This creates the distinct magma cave boundary
                        if (getBlockType(carveX, carveY) !== '') {
                            // Magma stone replacement occurs on the periphery of the carving
                            if (Math.abs(dx) === carveRadius || Math.abs(dy) === carveRadius) {
                                 worldBlocks[key] = { type: 'magma_stone_block', mineProg: 0 };
                            }
                        }
                        
                        // Carve the central area into air
                        if (Math.abs(dx) <= carveRadius - 1 && Math.abs(dy) <= carveRadius - 1) { 
                            worldBlocks[key] = { type: '', mineProg: 0 };
                            carved.add(key);
                            blocksCarved++;
        
                            // Track the floor blocks (lowest air block)
                            if (!floorBlocks.has(carveX) || carveY > floorBlocks.get(carveX)) {
                                floorBlocks.set(carveX, carveY);
                            }
                        }
                    }
                }
        
                // Add new potential carving paths for **branchiness**
                // Increased probability (0.80) to fork new paths
                for (let i = 0; i < 4; i++) {
                    if (random() < 0.80) { // High chance to branch!
                        const direction = Math.floor(random() * 4);
                        let nextX = x, nextY = y;
                        if (direction === 0) nextX += carveRadius; // Move by radius size for bigger jumps
                        else if (direction === 1) nextX -= carveRadius;
                        else if (direction === 2) nextY += carveRadius;
                        else nextY -= carveRadius;
                        
                        const nextKey = `${nextX},${nextY}`;
                        if (!carved.has(nextKey)) {
                            toCarve.add(nextKey);
                        }
                    }
                }
            }
            
            // --- Second Pass: Add Magma (Lava) and Pillars for Aethetics ---
            
            // 1. Generate Lava Pockets on the cave floor for magma-y feel
            floorBlocks.forEach((y, x) => {
                // We look one block below the carved air block (y) to find the solid floor
                const floorY = y + 1;
                const ceilingY = y - 1;
        
                // Check the floor below the air block is a magma stone block
                if (getBlockType(x, floorY) === 'magma_stone_block') {
                    
                    // 60% chance to replace the air block with lava
                    if (random() < 0.60) {
                         worldBlocks[`${x},${y}`] = { type: 'magma_stone_block', mineProg: 0 };
                    }
                }
        
                // 2. Generate magma pillars (stalagmites/stalactites)
                // Sturdy Pillars from Floor (Stalagmites) - 30% chance
                if (getBlockType(x, ceilingY) === '') { // Check ceiling is air
                    if (random() < 0.3) { 
                        // generateTree needs the *surface* block, which is the air block y
                        // It will replace air below it (y+1) with the 'trunk' block
                        generateTree(x, floorY, 'magma'); 
                    }
                }
                
                // Magma Drippers from Ceiling (Stalactites) - 15% chance
                // This requires the function to be able to place blocks upward/downward.
                // Assuming your 'generateTree' handles 'magma' as a special type of structure, 
                // we'll place ceiling blocks randomly here as well.
                if (random() < 0.15) {
                    // Check if the block above the current floor block (y-1) is a magma stone block
                    if (getBlockType(x, ceilingY) === 'magma_stone_block') {
                        // Place a few 'magma_stone_block's hanging down
                        for(let dy = 0; dy < 3; dy++) {
                            const dropY = ceilingY + dy;
                            if (getBlockType(x, dropY) === '') {
                                 worldBlocks[`${x},${dropY}`] = { type: 'magma_stone_block', mineProg: 0 };
                            } else {
                                break; // Stop if we hit something
                            }
                        }
                    }
                }
            });
        }

        // --- UNDERGROUND BUNKER GENERATION ---
        function generateBunker(startCol, startRow) {
            console.log("Generating Bunker at", startCol, startRow);
            const bunkerWidth = 12;
            const bunkerHeight = 7;

            // Mark columns as used to prevent other structures from generating here
            for (let i = 0; i < bunkerWidth; i++) {
                bunkerColumns.add(startCol + i);
            }

            // Build the bunker's shell
            for (let x = 0; x < bunkerWidth; x++) {
                for (let y = 0; y < bunkerHeight; y++) {
                    const col = startCol + x;
                    const row = startRow + y;
                    const key = `${col},${row}`;
                    const isWall = x === 0 || x === bunkerWidth - 1 || y === 0 || y === bunkerHeight - 1;

                    if (isWall) {
                        worldBlocks[key] = { type: 'iron_brick_block', mineProg: 0 };
                    } else {
                        worldBlocks[key] = { type: 'iron_brick_wall', mineProg: 0 }; // Clear the interior
                    }
                }
            }

            // Place Refrigerator on the floor and stock it with loot
            const fridgeCol = startCol + bunkerWidth - 2;
            const fridgeRow = startRow + bunkerHeight - 2;
            const fridgeKey = `${fridgeCol},${fridgeRow}`;

            const fridgeInventory = new Array(chestInventorySize).fill(null);
            
            // 1. Add 3 random types of seeds
            const possibleSeeds = ['grass_seeds', 'moss_seeds', 'wheat_seeds', 'cotton_seeds', 'rice_seeds', 'hop_seeds', 'coffee_seeds', 'oat_seeds', 'corn_seeds', 'barley_seeds', 'pumpkin_seeds', 'tomato_seeds', 'onion_seeds', 'garlic_seeds', 'chili_pepper_seeds', 'potato_seeds'];
            // Shuffle the array and pick the first 3 unique seeds
            const selectedSeeds = possibleSeeds.sort(() => 0.5 - random()).slice(0, 3);
            for(let i = 0; i < selectedSeeds.length; i++) {
                fridgeInventory[i] = { type: selectedSeeds[i], count: 2 };
            }

            // 2. Add other supplies with an 80% chance
            const supplies = ['butter', 'cup_of_milk', 'egg', 'raw_sugar', 'beef'];
            let currentSlot = 3; // Start placing after the seeds
            
            // The outer check for the *entire* block (if you still want it) is now gone,
            // as the inner loop handles individual randomness. If you want the *whole*
            // process to only run 80% of the time, keep the outer 'if'.
            // For the requested individual randomness, the outer 'if' is redundant.
            
            for (const supply of supplies) {
                // 1. New random number for each item, checking if it's < 0.8
                if (random() < 0.80) { 
                    if (currentSlot >= chestInventorySize) break; // Stop if fridge is full
                    
                    // The count already generates a new random number for each item:
                    const count = 1 + Math.floor(random() * 5); // Random count from 1 to 5
                    
                    fridgeInventory[currentSlot] = { type: supply, count: count };
                    currentSlot++;
                }
            }

            // Create the refrigerator block with its generated inventory
            worldBlocks[fridgeKey] = {
                type: 'refrigerator',
                mineProg: 0,
                inventory: fridgeInventory,
                label: 'Emergency Bunker'
            };
        }
		
		// NEW: Doom Shack generator for Underworld / Hell biomes
		function generateDoomShack(centerCol, centerRow) {
			console.log("Generating Doom Shack at", centerCol, centerRow);
			// small house dimensions (change as desired)
			const width = 7;
			const height = 5;

			// Prevent others from spawning near this
			for (let i = -Math.floor(width/2) - 3; i <= Math.floor(width/2) + 3; i++) {
				doomShackColumns.add(centerCol + i);
			}

			// Top-left corner of the box (we build downward from centerRow)
			const startCol = centerCol - Math.floor(width / 2);
			const startRow = centerRow; // treat centerRow as "surface" row in underworld

			// Determine interior wall type - fallback if 'hellstone_wall' isn't in your tileset
			const interiorWall = 'hellstone_wall'; // requested by you
			// (If your engine doesn't define hellstone_wall you can swap to 'hellstone' or another wall type.)
			
			// Build shell: outer walls of hellstone, interior filled with interiorWall (or hellstone fallback)
			for (let x = 0; x < width; x++) {
				for (let y = 0; y < height; y++) {
					const col = startCol + x;
					const row = startRow + y;
					const key = `${col},${row}`;
					const isEdge = x === 0 || x === width - 1 || y === 0 || y === height - 1;
					if (isEdge) {
						// outer shell: hellstone
						worldBlocks[key] = { type: 'hellstone', mineProg: 0 };
					} else {
						// interior: hellstone wall / fallback
						worldBlocks[key] = { type: interiorWall, mineProg: 0 };
					}
				}
			}

			// Floor: replace interior floor cells with solid hellstone floor (optional)
			for (let x = 1; x < width - 1; x++) {
				const floorKey = `${startCol + x},${startRow + height - 1}`;
				worldBlocks[floorKey] = { type: 'hellstone', mineProg: 0 };
			}

			// Corner decorations: gold brick at each corner, with obsidian wrapping to make 3-block corners
			const corners = [
				{ cx: startCol, cy: startRow }, // top-left
				{ cx: startCol + width - 1, cy: startRow }, // top-right
				{ cx: startCol, cy: startRow + height - 1 }, // bottom-left
				{ cx: startCol + width - 1, cy: startRow + height - 1 } // bottom-right
			];
			corners.forEach(c => {
				worldBlocks[`${c.cx},${c.cy}`] = { type: 'gold_brick_block', mineProg: 0 };
				// place 2 obsidian neighbors adjacent to the gold to form a 3-block corner accent
				const adj = [
					{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 0, dy: -1 }
				];
				// pick two adjacent obsidian placements if vacant
				let placed = 0;
				for (let i = 0; i < adj.length && placed < 2; i++) {
					const ax = c.cx + adj[i].dx;
					const ay = c.cy + adj[i].dy;
					const aKey = `${ax},${ay}`;
					if (!worldBlocks[aKey] || worldBlocks[aKey].type === '' || worldBlocks[aKey].type === undefined) {
						worldBlocks[aKey] = { type: 'obsidian_block', mineProg: 0 };
						placed++;
					}
				}
			});

			// Door: create a simple opening on one short side (randomize side)
			const doorSide = Math.random() < 0.5 ? 'left' : 'right';
			if (doorSide === 'left') {
				const doorKey = `${startCol},${startRow + Math.floor(height/2)}`;
				worldBlocks[doorKey] = { type: '', mineProg: 0 }; // empty spot for entry
			} else {
				const doorKey = `${startCol + width - 1},${startRow + Math.floor(height/2)}`;
				worldBlocks[doorKey] = { type: '', mineProg: 0 };
			}

			// Place a normal chest on the floor (center-ish)
			const chestCol = centerCol;
			const chestRow = startRow + height - 2; // one block above floor
			const chestKey = `${chestCol},${chestRow}`;
			worldBlocks[chestKey] = {
				type: 'chest',
				mineProg: 0,
				inventory: new Array(chestInventorySize).fill(null),
				label: 'Doom Shack Chest'
			};

			// Fill the normal chest:
			const chestInv = worldBlocks[chestKey].inventory;
			let slot = 0;

			// Guaranteed-ish/common items:
			if (Math.random() < 0.9 && slot < chestInv.length) chestInv[slot++] = { type: 'raw_hell_wood', count: 1 }; // often present
			if (Math.random() < 0.9 && slot < chestInv.length) chestInv[slot++] = { type: 'hellrock', count: 1 }; // often present

			// Fill remaining slots with a shuffled selection of rare-ish loot (each with its own probability)
			const rareLootPool = [
				{ type: 'hellsteel_nugget', chance: 0.08, maxCount: 1 },
				{ type: 'diviniron_nugget', chance: 0.06, maxCount: 1 },
				{ type: 'heavensteel_nugget', chance: 0.04, maxCount: 1 },
				{ type: 'amethyst_nugget', chance: 0.02, maxCount: 1 },
				{ type: 'gold_nugget', chance: 0.25, maxCount: 1 },
				{ type: 'coal', chance: 0.45, maxCount: 3 },
				{ type: 'dark_armor_tile', chance: 0.1, maxCount: 1 }
			];
			// Add common garbage / small stacks to fill
			while (slot < chestInv.length) {
				let added = false;
				for (const loot of rareLootPool) {
					if (slot >= chestInv.length) break;
					if (Math.random() < loot.chance) {
						const count = 1 + Math.floor(Math.random() * (loot.maxCount || 1));
						chestInv[slot++] = { type: loot.type, count: count };
						added = true;
					}
				}
				// if nothing got added this pass, add a small filler item to avoid infinite loop
				if (!added && slot < chestInv.length) {
					chestInv[slot++] = { type: 'coal', count: 1 + Math.floor(Math.random() * 4) };
				}
			}

			// Place a VOID CHEST somewhere in the shack (rare/unique container that uses global void storage)
			// pick a cell near the wall but not over the door
			const voidPositions = [
				{ dx: -1, dy: 0 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: 0, dy: 1 }
			];
			let placedVoid = false;
			for (let i = 0; i < voidPositions.length && !placedVoid; i++) {
				const p = voidPositions[i];
				const vCol = chestCol + p.dx;
				const vRow = chestRow + p.dy;
				const vKey = `${vCol},${vRow}`;
				if (!worldBlocks[vKey] || worldBlocks[vKey].type === '') {
					worldBlocks[vKey] = { type: 'void_chest', mineProg: 0 };
					placedVoid = true;
				}
			}
		}

		function generateSandstoneDesertTemple(centerCol, baseRow) {
            console.log(`Generating Sandstone Temple at ${centerCol}, ${baseRow}`);

            const mainWidth = 25;
            const mainHeight = 12;
            const towerWidth = 6;
            const towerHeight = 16;
            
            const wallBlock = 'sandstone';
            const accentBlock = 'red_sandstone_block';
            const trapChest = 'chest_lever_off';
            const realChest = 'chest';

            // --- 1. Clear the area and build the foundation ---
            const foundationDepth = 3;
            const totalWidth = mainWidth + towerWidth * 2;
            const startCol = centerCol - Math.floor(totalWidth / 2);

            for (let x = 0; x < totalWidth; x++) {
                for (let y = -mainHeight * 2; y < foundationDepth; y++) { // Clear a large area above
                    const col = startCol + x;
                    const row = baseRow + y;
                    const key = `${col},${row}`;
                    
                    if (y >= 0) {
                        // Build foundation
                        worldBlocks[key] = { type: wallBlock, mineProg: 0 };
                    } else if (y > -towerHeight || (x > towerWidth && x < totalWidth - towerWidth)) {
                        // Clear air for the structure
                        worldBlocks[key] = { type: '', mineProg: 0 };
                    }
                }
            }

            // --- 2. Build the 3 main structures ---
            // Left Tower
            for (let x = 0; x < towerWidth; x++) {
                for (let y = 0; y < towerHeight; y++) {
                    const col = startCol + x;
                    const row = baseRow - 1 - y;
                    const key = `${col},${row}`;
                    const isWall = x === 0 || x === towerWidth - 1;
                    const isRoof = y === towerHeight - 1;

                    if (isWall || isRoof) {
                        worldBlocks[key] = { type: wallBlock, mineProg: 0 };
                    } else {
                        worldBlocks[key] = { type: 'sandstone_wall', mineProg: 0 }; // Hollow inside
                    }
                    // Add crenellations
                    if (isRoof && x > 0 && x < towerWidth - 1 && x % 2 === 0) {
                         worldBlocks[`${col},${row - 1}`] = { type: accentBlock, mineProg: 0 };
                    }
                }
            }

            // Right Tower
            for (let x = 0; x < towerWidth; x++) {
                for (let y = 0; y < towerHeight; y++) {
                    const col = startCol + mainWidth + towerWidth + x;
                    const row = baseRow - 1 - y;
                    const key = `${col},${row}`;
                    const isWall = x === 0 || x === towerWidth - 1;
                    const isRoof = y === towerHeight - 1;

                    if (isWall || isRoof) {
                        worldBlocks[key] = { type: wallBlock, mineProg: 0 };
                    } else {
                        worldBlocks[key] = { type: 'sandstone_wall', mineProg: 0 }; // Hollow inside
                    }
                    // Add crenellations
                    if (isRoof && x > 0 && x < towerWidth - 1 && x % 2 === 0) {
                         worldBlocks[`${col},${row - 1}`] = { type: accentBlock, mineProg: 0 };
                    }
                }
            }
            
            // Main Hall
            const mainHallStartCol = startCol + towerWidth;
            for (let x = 0; x < mainWidth; x++) {
                for (let y = 0; y < mainHeight; y++) {
                    const col = mainHallStartCol + x;
                    const row = baseRow - 1 - y;
                    const key = `${col},${row}`;
                    const isWall = x === 0 || x === mainWidth - 1;
                    const isRoof = y === mainHeight - 1;

                    if (isWall || isRoof) {
                        worldBlocks[key] = { type: wallBlock, mineProg: 0 };
                    } else {
                        worldBlocks[key] = { type: 'sandstone_wall', mineProg: 0 }; // Hollow inside
                    }
                    // Add crenellations
                    if (isRoof && x > 0 && x < mainWidth - 1 && x % 3 === 0) {
                         worldBlocks[`${col},${row - 1}`] = { type: accentBlock, mineProg: 0 };
                    }
                }
            }

            // --- 3. Place Traps and Loot ---
            const chestRow = baseRow - 1;
            const trapRow = baseRow; // Trailer will be at the same level as the floor
            const bombRow = baseRow + 1; // Bomb will be in the foundation
            const chestCenterCol = mainHallStartCol + Math.floor(mainWidth / 2);
            
            const chestPositions = [
                chestCenterCol - 3, // Left chest
                chestCenterCol,     // Middle chest
                chestCenterCol + 3  // Right chest
            ];
            
            // Randomly decide which chest is the real one
            const realChestIndex = Math.floor(random() * 3);

            for (let i = 0; i < 3; i++) {
                const col = chestPositions[i];
                const chestKey = `${col},${chestRow}`;
                const trailerKey = `${col},${trapRow}`;
                const bombKey = `${col},${bombRow}`;

                if (i === realChestIndex) {
                    // This is the real, safe chest
                    worldBlocks[chestKey] = { 
                        type: realChest, 
                        mineProg: 0, 
                        inventory: new Array(chestInventorySize).fill(null),
                        label: 'Temple Treasure'
                    };
                    // Add loot
                    const loot = [
                        { type: 'gold_nugget', count: 5 + Math.floor(random() * 11) },
                        { type: 'diamond_nugget', count: 1 + Math.floor(random() * 3) },
                        { type: 'sandstone', count: 15 + Math.floor(random() * 20) }
                    ];
                    loot.forEach((item, index) => {
                        if (index < chestInventorySize) {
                            worldBlocks[chestKey].inventory[index] = item;
                        }
                    });

                } else {
                    // This is a trap chest
                    worldBlocks[chestKey] = { type: trapChest, mineProg: 0 };
                }

                // Place the wiring for all 3 chests
                // When the 'chest_lever_off' is clicked, it becomes 'chest_lever_on',
                // which powers the trailer, which detonates the bomb.
                // The real 'chest' won't power anything, so its trap is a dud.
                worldBlocks[trailerKey] = { type: 'trailer', mineProg: 0, cloakedAs: 'sandstone' };
                worldBlocks[bombKey] = { type: 'subnuclear_bomb', mineProg: 0, cloakedAs: 'sandstone' };
            }
        }

		// GENERATE Sky Island!!!
        function generateSkyIsland(centerX, centerY) {
            console.log("Sky Island Generated");
			const islandSize = 100 + Math.floor(random() * 301); // 100-400 blocks
            let blocksPlaced = 0;
            const toPlace = new Set([`${centerX},${centerY}`]);
            const placed = new Set();

            // Generate the cloud
            while (blocksPlaced < islandSize && toPlace.size > 0) {
                const currentKey = Array.from(toPlace)[Math.floor(random() * toPlace.size)];
                toPlace.delete(currentKey);
                if (placed.has(currentKey)) continue;

                const [x, y] = currentKey.split(',').map(Number);
                worldBlocks[currentKey] = { type: 'cloud_block', mineProg: 0 };
                placed.add(currentKey);
                blocksPlaced++;

                for (let i = 0; i < 4; i++) {
                    if (random() < 0.75) {
                        const direction = Math.floor(random() * 4);
                        let nextX = x, nextY = y;
                        if (direction === 0) nextX++; else if (direction === 1) nextX--;
                        else if (direction === 2) nextY++; else nextY--;
                        const nextKey = `${nextX},${nextY}`;
                        if (!placed.has(nextKey)) toPlace.add(nextKey);
                    }
                }
            }

            // Find the top surface to build the house
            let topY = centerY;
            while(placed.has(`${centerX},${topY - 1}`)) {
                topY--;
            }

            // Build a simple house
            const houseWidth = 5;
            const houseHeight = 4;
            const houseStartX = centerX - Math.floor(houseWidth / 2);
            const houseStartY = topY - houseHeight;

            for (let x = houseStartX; x < houseStartX + houseWidth; x++) {
                for (let y = houseStartY; y < houseStartY + houseHeight; y++) {
                    const key = `${x},${y}`;
                    if (x === houseStartX || x === houseStartX + houseWidth - 1 || y === houseStartY) {
                        worldBlocks[key] = { type: 'clay_brick_block', mineProg: 0 };
                    } else {
                        worldBlocks[key] = { type: '', mineProg: 0 };
                    }
                }
            }
            
            // Add loot chest
            const chestCol = centerX;
            const chestRow = topY - 1;
            const chestKey = `${chestCol},${chestRow}`;
            worldBlocks[chestKey] = { 
                type: 'chest', 
                mineProg: 0, 
                inventory: new Array(chestInventorySize).fill(null),
                label: 'Sky Chest'
            };
            const loot = [];
            loot.push({ type: 'diamond_nugget', count: 1 });
            loot.push({ type: 'coal', count: 1 + Math.floor(random() * 25) });
            loot.push({ type: 'steel_pickaxe', count: 1, durability: 7500, maxDurability: 150000 }); //5% Durability
			loot.push({ type: 'oat_seeds', count: 1 + Math.floor(random() * 3) });
			loot.push({ type: 'beef', count: 2 + Math.floor(random() * 3) });
            loot.forEach((item, index) => {
                if (index < chestInventorySize) {
                    worldBlocks[chestKey].inventory[index] = item;
                }
            });

            skyIslandColumns.add(centerX);
        }

        // OLD: Watchtower Generation
        function generateWatchtower(startCol, surfaceRow) {
            console.log("Attempting to generate Watchtower at", startCol);
            const towerWidth = 6;
            const towerHeight = 40 + Math.floor(random() * 21); // 40-60 blocks tall

            // 1. Check for flat ground
            let minSurface = surfaceRow;
            let maxSurface = surfaceRow;
            for (let i = 1; i < towerWidth; i++) {
                const currentSurface = columnSurfaceHeights[startCol + i] || surfaceRow;
                if (currentSurface < minSurface) minSurface = currentSurface;
                if (currentSurface > maxSurface) maxSurface = currentSurface;
            }
            if (maxSurface - minSurface > 2) {
                console.log("Ground not flat enough for watchtower.");
                return; // Abort if ground is not flat enough
            }
            const baseRow = maxSurface;

            // 2. Mark columns as used
            for (let i = 0; i < towerWidth; i++) {
                watchtowerColumns.add(startCol + i);
            }

            // 3. Build foundation
            for (let c = 0; c < towerWidth; c++) {
                for (let r = 0; r < 5; r++) {
                    worldBlocks[`${startCol + c},${baseRow + r}`] = { type: 'stone', mineProg: 0 };
                }
            }

            // 4. Build the tower structure
            for (let y = 0; y < towerHeight; y++) {
                const currentRow = baseRow - 1 - y;
                for (let x = 0; x < towerWidth; x++) {
                    const currentCol = startCol + x;
                    const isWall = x === 0 || x === towerWidth - 1 || (y > 0 && (x === 1 || x === towerWidth - 2) && (y % 8 === 0)); // Add some windows

                    if (isWall) {
                        worldBlocks[`${currentCol},${currentRow}`] = { type: 'stone', mineProg: 0 };
                    } else { // Inside
                        worldBlocks[`${currentCol},${currentRow}`] = { type: '', mineProg: 0 };
                    }
                }
                
                // Add floors and stairs
                if (y > 0 && y % 5 === 0) { // Floor every 5 blocks
                     for (let x = 1; x < towerWidth - 1; x++) {
                        worldBlocks[`${startCol + x},${currentRow}`] = { type: 'planked_oak', mineProg: 0 };
                    }
                }
                // Switchback stairs
                const stairY = y % 10;
                if (stairY < 5 && stairY > 0) { // Going up left side
                     worldBlocks[`${startCol + 1},${currentRow}`] = { type: 'planked_spruce', mineProg: 0 };
                } else if (stairY > 5) { // Going up right side
                     worldBlocks[`${startCol + towerWidth - 2},${currentRow}`] = { type: 'planked_spruce', mineProg: 0 };
                }
            }
            
            // 5. Build the top platform
            const topRow = baseRow - towerHeight;
            for (let x = 0; x < towerWidth; x++) {
                for (let y = 0; y < 2; y++) {
                     worldBlocks[`${startCol + x},${topRow + y}`] = { type: 'stone', mineProg: 0 };
                }
                if (x === 0 || x === towerWidth - 1) { // Crenellations
                     worldBlocks[`${startCol + x},${topRow - 1}`] = { type: 'stone', mineProg: 0 };
                }
            }
            
            // 6. Add loot chest
            const chestCol = startCol + Math.floor(towerWidth / 2);
            const chestRow = topRow - 1;
            worldBlocks[`${chestCol},${chestRow}`] = { 
                type: 'chest', 
                mineProg: 0, 
                inventory: new Array(chestInventorySize).fill(null),
                label: 'Watchtower Chest'
            };
            const loot = [];
            loot.push({ type: 'watchtower_stone_block', count: 10 + Math.floor(random() * 21) });
            loot.push({ type: 'gold_nugget', count: 1 + Math.floor(random() * 2) });
            if (random() < 0.4) loot.push({ type: 'diamond_nugget', count: 2 });
            if (random() < 0.5) loot.push({ "type": "book", "count": 1, "durability": 1, "maxDurability": 1, "title": "I Watched Dead Bodies Burn", "cover": "I Watched Dead Bodies Burn.png", "content": "They will want a name for a witness; they will ask for an affidavit, a long dry sort of paper that says what was seen and when. So fine. My name is Ronald. That is all the name I bother to give now. Ronald. Plain and honest. No heraldry for meno sigils or family sealand I like it that way. I have a watchtower and a ledger and, in the last dying hours, I have a pen that will not stop worrying at this page.\n\nI set myself up on the topmost plank to keep distance. The watchtower squats upon a wide and hungry desert, a place that used to be decent land with good bones, but the world was greedy and the sky was jealous, so here we are. I took to the tower because plague came, and the plague was an old and fickle sort: it wanted company but not sympathy. From that high perch I could see the world burn in a dozen different manners  people burning people, people burning their own houses, trees setting themselves like candles, and the occasional foolish cart or dog catching fire for reasons that make sense only in the small logic of collapse.\n\nI write now as I watched. I watched so much I got good at watching. Watching has a formal rhythm: first the sound, then the smell, then the way light makes a body look ridiculous and small. I watched a village set itself like a pyre, watched neighbours with lighters and axes and a sudden, combustible contempt. They moved as if they had forgotten how to be gentle; their hands had learned only certain hard trades: to strike, to scorch, to break. And when the work was done there were ash-floors where there had been tables, and ash where there had been faces and laughter. Only ash, mostly. Enough ash to make a man thoughtful for an hour or two.\n\nIt is odd to speak of such terrors in a voice that is sort of dull  I mean, I'm no poet (though I sometimes attempt it and mostly fail), and I cannot be bothered with melodrama. I prefer to say plain things plainly: the fires spread, the nights were not nights but long, patient blazes, and the daytime was a brazier. The plague did a lot of the quiet work; it took breath and softened resistance. Men fell in the market lane like sacks of grain; their boots lay empty in the dust. I watched one woman bend and pull her child's shoes from a small pair of feet that would not be needing them anymore. One does not forget scenes like that; they hang like a draft around your neck.\n\nThen came the ants. I had heard the warning from a trader once, in that peculiar market-talk they use  all barter, no promises  but even the trader's voice lacked conviction. Ants had always been creatures of habit, little soldiers of jam and crumbs. These ants were different. They rolled in from the blackened horizons and they were wrong-sized in the ways that make a man sip his tea twice and then stop. They were huge. They had the architecture of a nightmare stitched into their joints. They moved like armies that had been taught how to do sorrow instead of strategy.\n\nThey did not simply trample. No, that would be tidy and we would have had a story. Instead they consumed. They moved with a devouring patience: they gathered the dead  all the bodies which were left as ash or char or husk  and lifted them as if packing away old furniture. Where men had once been they carried off frames and husks and the brittle things that kept a person upright. They hauled these remnants to pits that smelled of colder things and deeper dark; they took them down into the mouth of the world. I watched them break what remained between living and not living, and they ferried their burden to the underworld like grim cartmen.\n\nAfter they carried the remains away, they left things behind: nests of larva, quiet and pale, tucked beneath crushed bow-wood; and odd, heart-like sacs  not the sort one reads about in anatomy books but something that held a slow and soft pulse, a stubborn tick that seemed to mock the end. Those vestiges sat like uninvited seeds of another story. That might sound gruesome if a man used gruesome words; I try instead to say that they were little promises, and promises in that time had a way of being wicked.\n\nGrowth, though, did not follow as promises often pretend. The great death stalled the progress of those larvae. They did not bloom into anything more useful; they remained small, still, a wasted metabolism. The world had been so thoroughly sick that even the things designed to feed off death found themselves in a famine of progress. The ants themselves seemed to slow, their leg-work becoming ritual rather than movement. I am an observer and a poor one at that, but I saw that their appetite ran against a reality that refused to nourish.\n\nFrom atop my tower, I measured heat and silence in equal portions. I kept a small ledger where I wrote the dates of fires, the number of lighters sighted, and the approximate count of bells that fell silent. I kept a list of names but with the plague a name is more like an old shirt  you wear it once, then it falls apart in the wash. I watched every day like a cheap drama series, except that there were no plots, only repetitions, only the same awful act performed with different cast and props. Sometimes I would shout, mostly to make a sound that was mine, and sometimes a distant figure would raise a hand and fling me a muted, graceless wave that made me laugh at my own loneliness.\n\nI must confess to the softest of foolishnesses: sense of humor. I cracked jokes sometimesbad onesabout cheese and carts, and once a chestnut vendor threw me a look that I mistook for delight. That is the sort of thing a man holds onto: a look, a half-laughed moment, a cart that kept its wheel despite everything. It keeps you human, or at least a reasonable approximation of it.\n\nAs the end approached, the desert did not talk any differently; it simply cooled into a sharper kind of quiet. My hands grew clumsy. The tower that had been my shelter became a place where the wind told me to be smaller. I remember leaning into the parapet to look at a procession of ants hauling a heap that used to be a man. I remember thinking, mildly, that they were efficient. I remember thinking too that the world had been a bad landlord and would not return the rent.\n\nThe cold came not like a knock but a pressure. It brushed across my shoulders like the hand of an old acquaintance who had waited tables all his life. It was not immediately violent; it was a sensible, formal thing: first the fingers in my toes, then the finger in my chin, then the surprised notice that my breath sounded different and I had to pay attention to it like one pays attention to accounts that might be wrong. I fumbled my pen. The pen fell from my fingers and slid toward the page like it was reluctant to stop. The book slipped as if it were a living thing deciding whether to keep me or let me be.\n\nIn those final measures of time I bent down to right the end. Those were my last deliberate motions: a dim, affectless bow to tidy the sentence. I now set my palm upon the paper and wrote what I could with the last of my ink-mind, and I make certain now that the tail of the final line reached to the margin. I liked small order in a world as messy as soup. I am not heroic by any old legend; I am only a man who wanted his book to look tidy when someone found it in a ruin.\n\nAnd so I leave this. Not a manifesto, not a sermon, just a scrap from a man who watched the end and took notes as if note-taking could soothe the majority of sorrow. If some future passer-by opens this and sighs, then perhaps I will have done a useful thing. If the void-dealers come and trade this page for salt, tell them the author signed as simply Ronald. Tell them he liked tidy things and kept bad jokes and that in the last motion he bent, properly, to right the end. And for my final words I will tell you that I didn't ever wa-", "published": true });
			loot.forEach((item, index) => {
                if (index < chestInventorySize) {
                    worldBlocks[`${chestCol},${chestRow}`].inventory[index] = item;
                }
            });
        }
		
		// NEW: Powertower Generation
        function generatePowertower(startCol, surfaceRow) {
            console.log("Attempting to generate Powertower at", startCol);
            const towerWidth = 10;
            const towerHeight = 60 + Math.floor(random() * 21); // 60-80 blocks tall

            // 1. Check for flat ground
            let minSurface = surfaceRow;
            let maxSurface = surfaceRow;
            for (let i = 1; i < towerWidth; i++) {
                const currentSurface = columnSurfaceHeights[startCol + i] || surfaceRow;
                if (currentSurface < minSurface) minSurface = currentSurface;
                if (currentSurface > maxSurface) maxSurface = currentSurface;
            }
            if (maxSurface - minSurface > 2) {
                console.log("Ground not flat enough for powertower.");
                return; // Abort if ground is not flat enough
            }
            const baseRow = maxSurface;

            // 2. Mark columns as used
            for (let i = 0; i < towerWidth; i++) {
                watchtowerColumns.add(startCol + i);
            }

            // 3. Build foundation
            for (let c = 0; c < towerWidth; c++) {
                for (let r = 0; r < 5; r++) {
                    worldBlocks[`${startCol + c},${baseRow + r}`] = { type: 'oxidizing_copper_brick_block', mineProg: 0 };
                }
            }

            // 4. Build the tower structure
            for (let y = 0; y < towerHeight; y++) {
                const currentRow = baseRow - 1 - y;
                for (let x = 0; x < towerWidth; x++) {
                    const currentCol = startCol + x;
                    const isWall = x === 0 || x === towerWidth - 1 || (y > 0 && (x === 1 || x === towerWidth - 2) && (y % 8 === 0)); // Add some windows

                    if (isWall) {
                        worldBlocks[`${currentCol},${currentRow}`] = { type: 'copper_brick_block', mineProg: 0 };
                    } else { // Inside
                        worldBlocks[`${currentCol},${currentRow}`] = { type: '', mineProg: 0 };
                    }
                }
                
                // Add floors and stairs
                if (y > 0 && y % 5 === 0) { // Floor every 5 blocks
                     for (let x = 1; x < towerWidth - 1; x++) {
                        worldBlocks[`${startCol + x},${currentRow}`] = { type: 'planked_redwood', mineProg: 0 };
                    }
                }
                // Switchback stairs
                const stairY = y % 10;
                if (stairY < 5 && stairY > 0) { // Going up left side
                     worldBlocks[`${startCol + 1},${currentRow}`] = { type: 'planked_rubber', mineProg: 0 };
                } else if (stairY > 5) { // Going up right side
                     worldBlocks[`${startCol + towerWidth - 2},${currentRow}`] = { type: 'planked_rubber', mineProg: 0 };
                }
            }
            
            // 5. Build the top platform
            const topRow = baseRow - towerHeight;
            for (let x = 0; x < towerWidth; x++) {
                for (let y = 0; y < 2; y++) {
                     worldBlocks[`${startCol + x},${topRow + y}`] = { type: 'copper_brick_block', mineProg: 0 };
                }
                if (x === 0 || x === towerWidth - 1) { // Crenellations
                     worldBlocks[`${startCol + x},${topRow - 1}`] = { type: 'copper_brick_block', mineProg: 0 };
                }
            }
            
            // 6. Add loot chest
            const chestCol = startCol + Math.floor(towerWidth / 2);
            const chestRow = topRow - 1;
            worldBlocks[`${chestCol},${chestRow}`] = { 
                type: 'chest', 
                mineProg: 0, 
                inventory: new Array(chestInventorySize).fill(null),
                label: 'Powertower Chest'
            };
            const loot = [];
            loot.push({ type: 'powertower_stone_block', count: 10 + Math.floor(random() * 21) });
            loot.push({ type: 'jade_nugget', count: 1 + Math.floor(random() * 2) });
            if (random() < 0.8) loot.push({ type: 'palladium_nugget', count: 2 });
            loot.forEach((item, index) => {
                if (index < chestInventorySize) {
                    worldBlocks[`${chestCol},${chestRow}`].inventory[index] = item;
                }
            });
        }
		
		/**
		 * Helper function to get a portal block, with a chance of it being ruined.
		 * @param {number} ruinChance - Chance from 0.0 to 1.0 for the block to be ruined.
		 */
		function getPortalBlockType(ruinChance) {
			return (random() < ruinChance) ? 'ruin_heaven_gate_brick_block' : 'heaven_gate_brick_block';
		}

		/**
		 * Main function to generate a ruined portal.
		 * It checks for space and then picks one of the 3 variations.
		 */
		function generateRuinedHeavenPortal(col, surfaceRow) {
			// Check for a 10-wide, 10-high clear space above the surface
			for (let x = -5; x <= 5; x++) {
				for (let y = -10; y <= 0; y++) {
					// If the block isn't air or foliage, it's obstructed
					const blockType = getBlockType(col + x, surfaceRow + y);
					if (blockType !== '' && !foliageTypes.includes(blockType)) {
						return; // Obstructed, don't generate
					}
				}
			}
			
			// Mark columns as used to prevent overlap
			for (let i = -10; i <= 10; i++) {
				ruinedPortalColumns.add(col + i);
			}
			
			// Pick one of the three variations
			const roll = random();
			if (roll < 0.33) {
				generateMagmaPortal(col, surfaceRow);
			} else if (roll < 0.66) {
				generatePleasantPortal(col, surfaceRow);
			} else {
				generateRemnantPortal(col, surfaceRow);
			}
		}

		/**
		 * Variation 1: Magma Portal
		 * Complete frame (25% ruin chance) on a magma pyramid.
		 */
		function generateMagmaPortal(col, surfaceRow) {
			// Build a 5-wide, 3-high pyramid
			for(let x = -2; x <= 2; x++) worldBlocks[`${col + x},${surfaceRow}`] = { type: 'magma_stone_block', mineProg: 0 };
			for(let x = -1; x <= 1; x++) worldBlocks[`${col + x},${surfaceRow - 1}`] = { type: 'magma_stone_block', mineProg: 0 };
			worldBlocks[`${col},${surfaceRow - 2}`] = { type: 'magma_stone_block', mineProg: 0 };

			// Portal frame definition (same as your checkAndCreateHeavenPortal)
			const portalFrame = [ [0,0], [1,0], [0,-1], [0,-2], [0,-3], [0,-4], [0,-5], [0,-6], [1,-6] ];
			
			// Center the 2-wide portal base *around* the 1-block peak
			const portalBaseCol = col - 1; 
			const portalBaseRow = surfaceRow - 3; // One block *above* the pyramid's peak
			
			for (const pos of portalFrame) {
				const blockType = getPortalBlockType(0.25); // 25% ruin chance
				const pCol = portalBaseCol + pos[0];
				const pRow = portalBaseRow + pos[1];
				worldBlocks[`${pCol},${pRow}`] = { type: blockType, mineProg: 0 }; // Overwrite air
			}
		}

		/**
		 * Variation 2: Pleasant Portal
		 * 7 of 9 blocks (35% ruin chance) on a super_mineral base.
		 */
		function generatePleasantPortal(col, surfaceRow) {
			// Base of 5 super mineral blocks
			for(let x = -2; x <= 2; x++) {
				worldBlocks[`${col + x},${surfaceRow}`] = { type: 'super_mineral', mineProg: 0 };
			}

			const portalFrame = [ [0,0], [1,0], [0,-1], [0,-2], [0,-3], [0,-4], [0,-5], [0,-6], [1,-6] ];
			
			// Shuffle and pick 7 random blocks from the frame
			const shuffledFrame = portalFrame.sort(() => random() - 0.5).slice(0, 7);
			
			const portalBaseCol = col - 1; // Center the 2-wide base
			const portalBaseRow = surfaceRow - 1; // Sit on top of the base
			
			for (const pos of shuffledFrame) {
				const blockType = getPortalBlockType(0.35); // 35% ruin chance
				const pCol = portalBaseCol + pos[0];
				const pRow = portalBaseRow + pos[1];
				worldBlocks[`${pCol},${pRow}`] = { type: blockType, mineProg: 0 }; // Overwrite air
			}
		}

		/**
		 * Variation 3: Remnant Portal
		 * 6 of 9 blocks (20% ruin chance) on a puffy cloud.
		 */
		function generateRemnantPortal(col, surfaceRow) {
			// Generate a "puffy cloud" on the ground (20-40 blocks)
			const cloudSize = 20 + Math.floor(random() * 21);
			let blocksPlaced = 0;
			const toPlace = new Set([`${col},${surfaceRow}`]);
			const placed = new Set();

			while (blocksPlaced < cloudSize && toPlace.size > 0) {
				const currentKey = Array.from(toPlace)[Math.floor(random() * toPlace.size)];
				toPlace.delete(currentKey);
				if (placed.has(currentKey)) continue;

				const [x, y] = currentKey.split(',').map(Number);
				
				// Only place clouds on/above the surface
				if (y <= surfaceRow) {
					const existingType = getBlockType(x, y);
					// Only replace air or foliage
					if(existingType === '' || foliageTypes.includes(existingType)) {
						 worldBlocks[currentKey] = { type: 'cloud_block', mineProg: 0 };
						 placed.add(currentKey);
						 blocksPlaced++;
					}
				}

				// Add neighbors, biased upwards and sideways
				for (let dx = -1; dx <= 1; dx++) {
					for (let dy = -1; dy <= 0; dy++) { // Only dy=0 or dy=-1 (up)
						if (random() < 0.65) {
							const nextKey = `${x + dx},${y + dy}`;
							if (!placed.has(nextKey)) toPlace.add(nextKey);
						}
					}
				}
			}

			const portalFrame = [ [0,0], [1,0], [0,-1], [0,-2], [0,-3], [0,-4], [0,-5], [0,-6], [1,-6] ];
			
			// Shuffle and pick 6 random blocks from the frame
			const shuffledFrame = portalFrame.sort(() => random() - 0.5).slice(0, 6);
			
			const portalBaseCol = col - 1; // Center the 2-wide base
			const portalBaseRow = surfaceRow - 1; // Sit on top of the cloud base
			
			for (const pos of shuffledFrame) {
				const blockType = getPortalBlockType(0.20); // 20% ruin chance
				const pCol = portalBaseCol + pos[0];
				const pRow = portalBaseRow + pos[1];
				worldBlocks[`${pCol},${pRow}`] = { type: blockType, mineProg: 0 }; // Overwrite air
			}
		}
		
		// --- NEW CHASM GENERATION ---
		function generateChasm(startCol, surfaceRow) {
			console.log("Attempting to generate Chasm at", startCol);
			const chasmWidth = 5 + Math.floor(random() * 4); // 5 to 8 blocks wide
			const underworldDepth = 200; // The target depth

			// 1. Check for relatively flat ground, similar to watchtowers
			let minSurface = surfaceRow;
			let maxSurface = surfaceRow;
			for (let i = 1; i < chasmWidth; i++) {
				const currentSurface = columnSurfaceHeights[startCol + i] || surfaceRow;
				minSurface = Math.min(minSurface, currentSurface);
				maxSurface = Math.max(maxSurface, currentSurface);
			}
			if (maxSurface - minSurface > 3) {
				console.log("Ground not flat enough for chasm.");
				return; // Abort if the ground is too uneven
			}
			const baseRow = maxSurface;

			// 2. Mark columns as used to prevent other structures from spawning here
			for (let i = -5; i < chasmWidth + 5; i++) { // Widen the exclusion zone
				chasmColumns.add(startCol + i);
			}

			// 3. Carve the path and create the destructive, varied border
			let currentXOffset = 0; // The horizontal shift of the chasm's center
			const borderThickness = 4; // How far the magma "burns" into the terrain

			for (let y = 0; y < underworldDepth; y++) {
				const currentRow = baseRow + y;

				// Occasionally shift the chasm left or right to make it jagged
				if (random() < 0.1) { // 10% chance to shift at each vertical step
					currentXOffset += Math.floor(random() * 3) - 1; // Shift by -1, 0, or 1
				}
				// Clamp the offset to prevent it from wandering too far
				currentXOffset = Math.max(-5, Math.min(5, currentXOffset));

				// Carve out the center of the chasm for this row
				for (let x = 0; x < chasmWidth; x++) {
					const currentCol = startCol + x + currentXOffset;
					worldBlocks[`${currentCol},${currentRow}`] = { type: '', mineProg: 0 };
				}

				// --- NEW: Destructive Magma Border Logic ---
				// This replaces the old, simple wall placement.

				// Left Side Border
				for (let i = 1; i <= borderThickness; i++) {
					// The further from the edge (as 'i' increases), the lower the chance to place magma.
					const probability = 1.0 - (i / (borderThickness + 1));
					if (random() < probability) {
						const borderCol = startCol + currentXOffset - i;
						worldBlocks[`${borderCol},${currentRow}`] = { type: 'chasm_magma_stone_block', mineProg: 0 };
					}
				}

				// Right Side Border
				for (let i = 1; i <= borderThickness; i++) {
					const probability = 1.0 - (i / (borderThickness + 1));
					if (random() < probability) {
						const borderCol = startCol + chasmWidth + currentXOffset + i - 1;
						worldBlocks[`${borderCol},${currentRow}`] = { type: 'chasm_magma_stone_block', mineProg: 0 };
					}
				}
			}
			console.log("Chasm Generated!");
		}
		
		function generateJungleTemple(startCol, surfaceRow) {
		  // --- size & flatness ---
		  const width  = 16 + Math.floor(random() * 6);   // 1621
		  const height = 9  + Math.floor(random() * 3);   // 911

		  // check ground flatness across footprint (like watchtower)
		  let minSurface = surfaceRow, maxSurface = surfaceRow;
		  for (let i = 1; i < width; i++) {
			const s = columnSurfaceHeights[startCol + i] ?? surfaceRow;
			if (s < minSurface) minSurface = s;
			if (s > maxSurface) maxSurface = s;
		  }
		  if (maxSurface - minSurface > 3) return; // too uneven; abort
		  const baseRow = maxSurface;

		  // reserve columns to avoid overlap
		  for (let i = 0; i < width; i++) jungleTempleColumns.add(startCol + i);

		  // --- build shell + fill with mud ---
		  for (let x = 0; x < width; x++) {
			for (let y = 0; y < height; y++) {
			  const col = startCol + x;
			  const row = baseRow - y;              // rises above ground
			  const key = `${col},${row}`;
			  const isWallOrRoof = (x === 0 || x === width - 1 || y === 0 || y === height - 1);

			  if (isWallOrRoof) {
				worldBlocks[key] = { type: 'vine_stone', mineProg: 0 };
			  } else {
				worldBlocks[key] = { type: 'mud', mineProg: 0 };
			  }
			}
		  }

		  // small crenellations on top for flavor
		  const roofY = baseRow - height + 1;
		  for (let x = 2; x < width - 2; x += 3) {
			const key = `${startCol + x},${roofY}`;
			worldBlocks[key] = { type: '', mineProg: 0 };
		  }

		  // --- chest full of mud, buried in the mud interior ---
		  const chestCol = startCol + width - 4;
		  const chestRow = baseRow - Math.floor(height / 2);
		  const chestKey = `${chestCol},${chestRow}`;
		  worldBlocks[chestKey] = {
			type: 'chest',
			mineProg: 0,
			inventory: new Array(chestInventorySize).fill(null),
			label: 'Mud Chest'
		  };
		  for (let i = 0; i < chestInventorySize; i++) {
			worldBlocks[chestKey].inventory[i] = { type: 'mud', count: 99 };
		  }
		}
        
        function generateMineChamber(startCol, surfaceRow) {
            console.log("Attempting to generate Mine Chamber at", startCol);
            const entranceWidth = 7;
            const shaftWidth = 5; // Internal space is 3x3
            const shaftDepth = 100 + Math.floor(random() * 51); // 100-150 deep
            const chamberWidth = 25 + Math.floor(random() * 11); // 25-35 wide
            const chamberHeight = 7;

            // 1. Check for flat ground
            let minSurface = surfaceRow;
            let maxSurface = surfaceRow;
            for (let i = 1; i < entranceWidth; i++) {
                const currentSurface = columnSurfaceHeights[startCol + i] || surfaceRow;
                minSurface = Math.min(minSurface, currentSurface);
                maxSurface = Math.max(maxSurface, currentSurface);
            }
            if (maxSurface - minSurface > 1) { // Needs very flat ground
                console.log("Ground not flat enough for Mine Chamber.");
                return;
            }
            const baseRow = maxSurface;

            // 2. Mark columns as used to prevent overlap
            for (let i = 0; i < Math.max(entranceWidth, chamberWidth); i++) {
                mineChamberColumns.add(startCol + i);
            }
            
            // 3. Build the entrance structure
            for (let x = 0; x < entranceWidth; x++) {
                const currentCol = startCol + x;
                // Foundation
                worldBlocks[`${currentCol},${baseRow + 1}`] = { type: 'planked_birch', mineProg: 0 };
                // Floor, except for the 3-wide hole in the middle
                const isHole = x >= 2 && x <= 4;
                if (!isHole) {
                    worldBlocks[`${currentCol},${baseRow}`] = { type: 'planked_birch', mineProg: 0 };
                } else {
                    worldBlocks[`${currentCol},${baseRow}`] = { type: '', mineProg: 0 };
                }

                // Walls (3 blocks high)
                for (let y = 1; y < 4; y++) {
                    if (x === 0 || x === entranceWidth - 1) {
                        worldBlocks[`${currentCol},${baseRow - y}`] = { type: 'planked_birch', mineProg: 0 };
                    } else {
                        worldBlocks[`${currentCol},${baseRow - y}`] = { type: '', mineProg: 0 };
                    }
                }
            }
            // A-Frame Roof
            for (let y = 0; y < 4; y++) {
                const roofRow = baseRow - 4 - y;
                for (let x = y; x < entranceWidth - y; x++) {
                    const currentCol = startCol + x;
                    if (x === y || x === entranceWidth - 1 - y) {
                         worldBlocks[`${currentCol},${roofRow}`] = { type: 'planked_birch', mineProg: 0 };
                    } else if (getBlockType(currentCol, roofRow) !== 'planked_birch') {
                         worldBlocks[`${currentCol},${roofRow}`] = { type: '', mineProg: 0 };
                    }
                }
            }

            // 4. Dig the shaft with switchback stairs
            const shaftStartCol = startCol + Math.floor((entranceWidth - shaftWidth) / 2);
            for (let y = 1; y <= shaftDepth; y++) {
                const currentRow = baseRow + y;
                // Carve the 5-wide vertical slice
                for (let x = 0; x < shaftWidth; x++) {
                    const currentCol = shaftStartCol + x;
                    const isWall = x === 0 || x === shaftWidth - 1;
                    if (isWall) {
                        worldBlocks[`${currentCol},${currentRow}`] = { type: 'planked_birch', mineProg: 0 };
                    } else {
                        worldBlocks[`${currentCol},${currentRow}`] = { type: '', mineProg: 0 };
                    }
                }

                // Add floors/stairs
                const level = Math.floor((y-1) / 5); // Which 5-block segment we are in
                if (y % 5 !== 0) { // It's a stair block
                    if (level % 2 === 0) { // Stairs on the left
                        worldBlocks[`${shaftStartCol + 1},${currentRow}`] = { type: 'red_sand_block', mineProg: 0 };
                    } else { // Stairs on the right
                        worldBlocks[`${shaftStartCol + shaftWidth - 2},${currentRow}`] = { type: 'sand', mineProg: 0 };
                    }
				}

                // Place cobwebs in the air blocks (3% chance)
                for (let x = 1; x < shaftWidth - 1; x++) {
                    const currentCol = shaftStartCol + x;
                    if (getBlockType(currentCol, currentRow) === '' && random() < 0.03) {
                         worldBlocks[`${currentCol},${currentRow}`] = { type: 'cobweb', mineProg: 0 };
                    }
                }
            }

            // 5. Carve the bottom chamber
            const chamberStartRow = baseRow + shaftDepth;
            const chamberStartCol = startCol + Math.floor((entranceWidth - chamberWidth) / 2); // Center the wider chamber
            for (let y = 0; y < chamberHeight; y++) {
                for (let x = 0; x < chamberWidth; x++) {
                    const currentCol = chamberStartCol + x;
                    const currentRow = chamberStartRow + y;
                    const isWall = x === 0 || x === chamberWidth - 1 || y === 0 || y === chamberHeight - 1;
                    if (isWall) {
                        worldBlocks[`${currentCol},${currentRow}`] = { type: 'planked_apple', mineProg: 0 };
                    } else {
                        worldBlocks[`${currentCol},${currentRow}`] = { type: '', mineProg: 0 };
                    }
                }
            }

            // 6. Place coal block piles
            const pileHeight = 3;
            const pileWidth = 5;
            // Left pile
            for (let y = 0; y < pileHeight; y++) {
                for (let x = 0; x < pileWidth; x++) {
                    if (random() < 0.75 - (y * 0.2)) { // Denser at the bottom
                        const currentCol = chamberStartCol + 2 + x;
                        const currentRow = chamberStartRow + chamberHeight - 2 - y;
                        worldBlocks[`${currentCol},${currentRow}`] = { type: 'coal_block', mineProg: 0 };
                    }
                }
            }
            // Right pile
            for (let y = 0; y < pileHeight; y++) {
                for (let x = 0; x < pileWidth; x++) {
                    if (random() < 0.75 - (y * 0.2)) {
                        const currentCol = chamberStartCol + chamberWidth - 3 - x;
                        const currentRow = chamberStartRow + chamberHeight - 2 - y;
                        worldBlocks[`${currentCol},${currentRow}`] = { type: 'coal_block', mineProg: 0 };
                    }
                }
            }
            
            // 7. Add a loot chest in the middle
            const chestCol = chamberStartCol + Math.floor(chamberWidth / 2);
            const chestRow = chamberStartRow + chamberHeight - 2; // On the floor
            const chestKey = `${chestCol},${chestRow}`;
            worldBlocks[chestKey] = { 
                type: 'chest', 
                mineProg: 0, 
                inventory: new Array(chestInventorySize).fill(null),
                label: 'Mine Chamber Chest'
            };
            const loot = [
                { type: 'topaz_nugget', count: 1 },
                { type: 'iron_nugget', count: 2 + Math.floor(random() * 4) },
                { type: 'gold_nugget', count: 2 },
                { type: 'steel_pickaxe', count: 1, durability: 150000 * (random() * 0.1), maxDurability: 150000 }
            ];
            loot.forEach((item, index) => {
                if (index < chestInventorySize) {
                    worldBlocks[chestKey].inventory[index] = item;
                }
            });
        }
        
        // NEW: Plantation Generation
        function generatePlantation(startCol, surfaceRow) {
			console.log("Attempting to generate Plantation at", startCol);
			// Updated house and farm dimensions
			const houseWidth = 9;
			const houseHeight = 6;
			const farmWidth = 20;
			const farmDepth = 2;
			const totalWidth = houseWidth + farmWidth;

			// Decide if the farm is on the left or right of the house
			const isMirrored = random() < 0.5;

			// 1. Check for flat ground to build on
			let minSurface = surfaceRow;
			let maxSurface = surfaceRow;
			for (let i = 1; i < totalWidth; i++) {
				const currentSurface = columnSurfaceHeights[startCol + i] || surfaceRow;
				minSurface = Math.min(minSurface, currentSurface);
				maxSurface = Math.max(maxSurface, currentSurface);
			}
			// Abort if the ground is too uneven
			if (maxSurface - minSurface > 2) {
				console.log("Ground not flat enough for plantation.");
				return;
			}
			const baseRow = maxSurface;

			// 2. Mark columns as used to prevent other structures from spawning here
			for (let i = 0; i < totalWidth; i++) {
				plantationColumns.add(startCol + i);
			}

			// 3. Define house and farm start columns based on mirroring
			const houseStartCol = isMirrored ? startCol + farmWidth : startCol;
			const farmStartCol = isMirrored ? startCol : startCol + houseWidth;

			// 4. CLEAR A SKY BAND ABOVE THE ENTIRE PLANTATION (so nothing hangs over)
			//    We clear a band starting some blocks above the house top down to just above the ground.
			//    If you want taller clearance change clearPadding.
			const clearPadding = 6; // how many extra sky rows above the house top to clear
			const clearStartRow = baseRow - (houseHeight + clearPadding); // higher up
			const clearEndRow = baseRow - 1; // just above ground (so crop rows become sky)
			for (let x = 0; x < totalWidth; x++) {
				const col = startCol + x;
				for (let row = clearStartRow; row <= clearEndRow; row++) {
					// guard: only set sky if not below bedrock or undefined scenario (optional)
					worldBlocks[`${col},${row}`] = { type: '', mineProg: 0 };
				}
			}

			// 5. GIVE THE WHOLE THING A PROPER DIRT BASE (a few blocks under the ground)
			const dirtDepth = 3; // how deep the prepared dirt base goes
			for (let x = 0; x < totalWidth; x++) {
				const col = startCol + x;
				for (let d = 1; d <= dirtDepth; d++) {
					const row = baseRow + d;
					worldBlocks[`${col},${row}`] = { type: 'dirt', mineProg: 0 };
				}
			}

			// 6. Build the improved house with better materials (house will overwrite sky where needed)
			for (let x = 0; x < houseWidth; x++) {
				for (let y = 0; y < houseHeight; y++) {
					const currentCol = houseStartCol + x;
					const currentRow = baseRow - y;

					// --- Define parts of the house ---
					const isFoundation = (y === 0);
					const isFloor = (y === 1);
					const isRoof = (y === houseHeight - 1);

					// Place the 3-block tall door on the side away from the farm
					let isDoor = false;
					// door spans y = 1..3 inclusive (3 blocks tall)
					if (isMirrored && x === houseWidth - 1 && y >= 1 && y <= 3) { // Farm on left, door on right wall
						isDoor = true;
					} else if (!isMirrored && x === 0 && y >= 1 && y <= 3) { // Farm on right, door on left wall
						isDoor = true;
					}

					// Place a window on the wall facing the farm
					let isWindow = false;
					if (isMirrored && x === 0 && y === 3) { // Farm on left, window on left wall
						isWindow = true;
					} else if (!isMirrored && x === houseWidth - 1 && y === 3) { // Farm on right, window on right wall
						isWindow = true;
					}

					// --- Place blocks based on the house part ---
					if (isDoor) {
						// Leave empty space for the 3-block tall doorway
						// (do not place any block here so it remains open from floor up)
						delete worldBlocks[`${currentCol},${currentRow}`]; // ensure cleared
					} else if (isFoundation) {
						worldBlocks[`${currentCol},${currentRow}`] = { type: 'stone_brick_block', mineProg: 0 };
					} else if (isFloor) {
						worldBlocks[`${currentCol},${currentRow}`] = { type: 'planked_oak', mineProg: 0 };
					} else if (isWindow) {
						worldBlocks[`${currentCol},${currentRow}`] = { type: 'glass_block', mineProg: 0 };
					} else if (x === 0 || x === houseWidth - 1 || isRoof) { // Build walls and roof
						worldBlocks[`${currentCol},${currentRow}`] = { type: 'planked_spruce', mineProg: 0 };
					} else { // Clear the interior (ensure interior is sky)
						worldBlocks[`${currentCol},${currentRow}`] = { type: '', mineProg: 0 };
					}
				}
			}

			// 7. Add Interior Decorations
			const floorRow = baseRow - 1; // The Y-coordinate for the floor level

			// Place a bed on the side opposite the door
			const bedStartCol = isMirrored ? houseStartCol + 1 : houseStartCol + houseWidth - 4;
			worldBlocks[`${bedStartCol},${floorRow}`] = { type: 'bed', part: 'left' };
			worldBlocks[`${bedStartCol + 1},${floorRow}`] = { type: 'bed', part: 'middle' };
			worldBlocks[`${bedStartCol + 2},${floorRow}`] = { type: 'bed', part: 'right' };

			// Place a chest with loot near the door
			const chestCol = isMirrored ? houseStartCol + houseWidth - 2 : houseStartCol + 1;
			const chestKey = `${chestCol},${floorRow}`;
			worldBlocks[chestKey] = {
				type: 'chest',
				mineProg: 0,
				inventory: new Array(chestInventorySize).fill(null),
				label: 'Farmhouse Chest'
			};
			// Add some starter loot to the chest
			const loot = [
				{ type: 'wheat_seeds', count: 5 + Math.floor(random() * 6) },
				{ type: 'wooden_pickaxe', count: 1, durability: 15000, maxDurability: 15000 },
				{ type: 'apple', count: 2 + Math.floor(random() * 3) }
			];
			loot.forEach((item, index) => {
				if (index < chestInventorySize) {
					worldBlocks[chestKey].inventory[index] = item;
				}
			});

			// 8. Build the farm with your specified dimensions and crop ratio
			for (let x = 0; x < farmWidth; x++) {
				// Till the soil (plantation_soil at baseRow and down)
				for (let y = 0; y < farmDepth; y++) {
					const currentCol = farmStartCol + x;
					const currentRow = baseRow + y;
					worldBlocks[`${currentCol},${currentRow}`] = { type: 'plantation_soil', mineProg: 0 };
				}

				// Ensure the crop row itself is sky (we cleared earlier, but re-assert on farm columns)
				const cropCol = farmStartCol + x;
				const cropRow = baseRow - 1;
				worldBlocks[`${cropCol},${cropRow}`] = { type: '', mineProg: 0 };

				// Plant the crops (80% corn, 20% cotton) only if spot is sky
				const cropType = random() < 0.8 ? 'corn' : 'cotton';
				if (getBlockType(cropCol, cropRow) === '') {
					worldBlocks[`${cropCol},${cropRow}`] = { type: cropType, mineProg: 0 };
				}
			}

			console.log("Plantation generated at", startCol, "baseRow", baseRow);
		}
		
		function generateMoon(centerX, centerY) {
            const radius = 20 + Math.floor(random() * 31); // Radius between 20 and 50
            const buffer = 15; // A 15-block buffer between moons

            // Define the bounding box for the new moon, including the buffer
            const boundingBox = {
                minX: centerX - radius - buffer,
                maxX: centerX + radius + buffer,
                minY: centerY - radius - buffer,
                maxY: centerY + radius + buffer,
            };

            // Check for overlap with any existing moons
            for (const region of moonRegions) {
                const intersects = (boundingBox.minX < region.maxX && boundingBox.maxX > region.minX &&
                                   boundingBox.minY < region.maxY && boundingBox.maxY > region.minY);
                if (intersects) {
                    // Abort generation if it would overlap with another moon
                    return;
                }
            }

            // If no overlap, add this moon's bounding box to our list and generate it
            moonRegions.push(boundingBox);
            console.log(`Generating moon at (${centerX}, ${centerY}) with radius ${radius}`);

            // Place a filled circle of rock_block
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    // Using squared distance is more efficient than square root
                    if (dx * dx + dy * dy <= radius * radius) {
                        const key = `${centerX + dx},${centerY + dy}`;
                        // Place block only if the space is empty
                        if (!worldBlocks[key] || worldBlocks[key].type === '') {
                             worldBlocks[key] = { type: 'rock_block', mineProg: 0 };
                        }
                    }
                }
            }
        }
		
		function createBlockBreakParticles(col, row, blockType) {
            const blockImg = assets[blockType];
            const blockProps = blockTypes[blockType];

            // If the broken block has no image, we can't make particles from it.
            if (!blockImg || failedAssets[blockType]) {
                return;
            }

            const blockCenterX = col * tileSize + tileSize / 2;
            const blockCenterY = row * tileSize + tileSize / 2;

            for (let i = 0; i < particleCount; i++) {
                // The size of the texture piece we'll grab for each particle (e.g., 4x4 pixels)
                const particleTextureSize = 4;
                
                const particle = {
                    // Start at the center of the broken block
                    x: blockCenterX,
                    y: blockCenterY,
                    
                    // Random outward velocity. Shoots up and to the sides.
                    dx: (Math.random() - 0.5) * 8, // Horizontal speed from -4 to 4
                    dy: (Math.random() * -8) - 2,     // Vertical speed from -2 to -10 (always upwards initially)
                    
                    // Lifespan in milliseconds. The particle will exist for 1 to 1.5 seconds.
                    life: 1000 + Math.random() * 500,
                    maxLife: 0, // We'll set this to the initial life value
                    
                    // The block's image to draw from
                    img: blockImg,
                    
                    // The random piece of the texture to draw
                    sourceX: Math.floor(Math.random() * (blockImg.width - particleTextureSize)),
                    sourceY: Math.floor(Math.random() * (blockImg.height - particleTextureSize)),
                    sourceSize: particleTextureSize,

                    // The size to draw the particle on the canvas. Let's make it a bit bigger.
                    drawSize: 6 
                };
                particle.maxLife = particle.life; // Store the initial life for fading calculation

                particles.push(particle);
            }
        }

        function getBlockType(col, row) {
            const blockData = worldBlocks[`${col},${row}`];
            // If the block isn't modified, return sky. This prevents infinite loops.
            return blockData ? blockData.type : ''; 
        }

        function isSolid(col, row) {
            const blockData = getBlockData(col, row);
            return blockTypes[blockData.type] && blockTypes[blockData.type].solid;
        }
		
		function isAxeBlock(blockType) {
			if (!blockType) return false;
			return blockType.startsWith('raw_') || 
				   blockType.startsWith('planked_') || 
				   blockType.startsWith('cactus_') || 
				   blockType.endsWith('_wood') ||
				   blockType.endsWith('_bush') ||
				   blockType === 'desert_brush' ||
				   blockType === 'desert_grass' ||
				   blockType === 'pine_needle_pile' ||
				   blockType === 'leaf_pile';
		}

        function worldToGrid(x, y) {
            return { col: Math.floor(x / tileSize), row: Math.floor(y / tileSize) };
        }

        function gridToWorld(col, row) {
            return { x: col * tileSize, y: row * tileSize };
        }

        function rectIntersects(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
        }

		function killMyself() {
			respawnPlayer()
		}

        function respawnPlayer() {
			// --- NEW: Death Chest Logic ---
			deathCount += 1;
			const playerHasItems = inventorySlots.some(item => item !== null);
			const deathCol = Math.floor((player.x + playerWidth / 2) / tileSize);
			const deathRow = Math.floor((player.y + playerHeight) / tileSize) - 1; // Place it at the player's feet
			const deathKey = `${deathCol},${deathRow}`;
			const biomeAtDeath = getBiome(deathCol);
			
			console.log(`Player died at ${deathKey}`);
			if (playerHasItems) {
				// Create a new inventory for the chest with 50 slots
				const deathChestInventory = new Array(50).fill(null);

				// Copy items from player's inventory to the chest's inventory
				for (let i = 0; i < inventorySlots.length; i++) {
					if (inventorySlots[i]) {
						let itemToDrop = inventorySlots[i];
						
						// Check if the player died in a rainforest AND the item is paper
						if (biomeAtDeath === 'rainforest' && itemToDrop.type === 'paper' && deathRow <= 20 && deathRow >= -20 ) {
							// Change the item's type to soggy_paper
							itemToDrop.type = 'soggy_paper';
						}

						// --- ADDED: Immediate Spoilage Logic ---
						const spoilInfo = itemTypes[itemToDrop.type]?.spoilable;
						if (spoilInfo) {
							itemToDrop.type = spoilInfo.into;
							delete itemToDrop.acquiredTime;
						}
						// --- End of Immediate Spoilage Logic ---

						deathChestInventory[i] = itemToDrop;
					}
				}
				
				// --- START: NEW FEATURE - Cup of Urine on Death ---
				// First, roll the dice for a 80% chance of this happening.
				if (Math.random() < 0.8) {
					// Find the inventory index of the first stack of glass cups.
					const glassCupIndex = deathChestInventory.findIndex(item => item && item.type === 'glass_cup');

					// Find the inventory index of the first available empty slot.
					const emptySlotIndex = deathChestInventory.findIndex(item => item === null);

					// If we found at least one glass cup AND an empty slot...
					if (glassCupIndex !== -1 && emptySlotIndex !== -1) {

						// Get a direct reference to the glass cup item in the chest inventory.
						const glassCupItem = deathChestInventory[glassCupIndex];

						// Decrease the count of the glass cups by one.
						glassCupItem.count--;

						// If that was the last cup in the stack, remove the item entirely.
						if (glassCupItem.count <= 0) {
							deathChestInventory[glassCupIndex] = null;
						}

						// Place a new 'cup_of_urine' in the empty slot we found.
						deathChestInventory[emptySlotIndex] = { type: 'cup_of_urine', count: 1 };
					}
				}
				// --- END: NEW FEATURE ---

				// Place the chest in the world
				worldBlocks[deathKey] = {
					type: 'dead_body_chest',
					mineProg: 0,
					inventory: deathChestInventory,
					label: 'Dead Body' // Give it a label
				};

				// Clear player's inventory
				inventorySlots.fill(null);
				hotbarIndices.fill(null);
				updateHotbar();
			}

			// Original respawn logic continues here
			player.x = 0;
			player.fallStartY = 0;
			player.y = 0; // Reduced from -320, although -320 definitely looked cooler
            if (random() < 0.5) {
                if (random() < 0.5) {
                    player.x = 8 * tileSize
                } else {
                    player.x = -8 * tileSize
                }
            }
			if (player.bedSpawnPoint) {
				player.x = player.bedSpawnPoint.x;
				player.y = player.bedSpawnPoint.y;
				player.fallStartY = player.bedSpawnPoint.y;
			}
			player.health = player.maxHealth;
			
			isPlayerOnHellfire = false;
            hellfireLevel = 1.0;
            isPlayerInHellfireZone = false;
			
			player.bloodAlcohol = 0;
            player.activeEffects = [];
            const vignette = document.getElementById('drunkVignette'); // --- ADD THIS ---
            if (canvas) canvas.style.filter = 'none';
            if (canvas) canvas.classList.remove('vibrating'); // --- ADD THIS ---
            if (vignette) vignette.style.display = 'none'; // --- ADD THIS ---
            
			player.onFire = false;
			player.fireDuration = 0;
			player.fireDamageTimer = 0;
			/*player.armor = { helmet: null, chestGear: null, legGear: null, boots: null };*/
		}

        function applyDamage(amount) {
            if (amount <= 0) return;

            let damageToApply = amount;
            let totalReduction = 0;

            // Iterate over equipped armor directly from the player.armor object
            for (const armorSlot in player.armor) { // 'helmet', 'chestGear', 'legGear', 'boots'
                const armorItem = player.armor[armorSlot]; // This is the item object, e.g., { type: 'trader_mask', ... }
                
                if (armorItem === null) continue; // Nothing in this slot

                const itemProps = itemTypes[armorItem.type];
                if (!itemProps || !itemProps.protectionFactor || !itemProps.isTool) continue;

                // Calculate damage reduction for this piece
                const reductionAmount = amount * itemProps.protectionFactor;
                totalReduction += reductionAmount;

                // Apply durability damage to the item object itself
                const durabilityDamage = reductionAmount; // You can scale this if needed
                if (armorItem.durability !== undefined) {
                    armorItem.durability -= durabilityDamage;

                    // Check if armor broke
                    if (armorItem.durability <= 0) {
                        player.armor[armorSlot] = null; // The armor breaks and disappears
                    }
                }
            }
            
            // Apply the reduced damage to the player
            damageToApply -= totalReduction;
            if (damageToApply < 0) damageToApply = 0; // Can't heal the player

            player.health -= damageToApply;

            // Check for death
            if (player.health <= 0) {
                respawnPlayer();
                return true; // Player died
            }
            
            return false; // Player did not die
        }

        function updatePlayer(dt) {
            const factor = isGameActive ? dt / 1000 * 60 : 0;
			
			if (hellfireOn) {
                const playerGridRow = Math.floor(player.y / tileSize);
                // Check if Y is between 200 and 600
                if (playerGridRow >= 200 && playerGridRow <= 600) {
                    isPlayerInHellfireZone = true;
                } else {
                    isPlayerInHellfireZone = false;
                }
            } else {
                isPlayerInHellfireZone = false; // Ensure it's off if the setting is disabled
            }
			
			if (player.portalCooldown > 0) {
				player.portalCooldown -= dt;
			} else {
				const playerCenterCol = Math.floor((player.x + playerWidth / 2) / tileSize);
				const playerCenterRow = Math.floor((player.y + playerHeight / 2) / tileSize);
				const blockAtPlayer = getBlockType(playerCenterCol, playerCenterRow);

				if (blockAtPlayer === 'heaven_portal') {
					// Find which portal we are in by checking nearby portal anchors
					let currentPortal = null;
					for(const portal of portals) {
						const distSq = (playerCenterCol - portal.col)**2 + (playerCenterRow - portal.row)**2;
						if (distSq < 100) { // Check within a 10-block radius
							currentPortal = portal;
							break;
						}
					}
					if (currentPortal) {
						teleportPlayer(currentPortal);
					}
				}
			}
            
            // Check for cobweb slowdown and more
            const playerGridPos = worldToGrid(player.x + playerWidth / 2, player.y + playerHeight / 2);

            const blockDataCenter = getBlockData(playerGridPos.col, playerGridPos.row);
            const blockDataAbove = getBlockData(playerGridPos.col, playerGridPos.row - 1); // B is above
            const blockDataBelow = getBlockData(playerGridPos.col, playerGridPos.row + 1); // U is below
            
            // For compatibility with logic below
            const blockUnderPlayer = blockDataCenter.type; 
            const blockUnderPlayerU = blockDataBelow.type;
            const blockUnderPlayerB = blockDataAbove.type;

            const feetRow = Math.floor((player.y + playerHeight) / tileSize);
			const blockBelowFeet = getBlockType(playerGridPos.col, feetRow);
			const isOnAsphalt = blockBelowFeet === 'asphalt';
			const isOnThickMud = blockBelowFeet === 'thick_mud';
            
            const isInCobweb = blockDataCenter.type === 'cobweb' || blockDataCenter.overlay === 'cobweb' ||
                               blockDataAbove.type === 'cobweb' || blockDataAbove.overlay === 'cobweb' ||
                               blockDataBelow.type === 'cobweb' || blockDataBelow.overlay === 'cobweb';
			
            // Get the grid coordinates for the block directly under the player's feet
            const playerCenterCol = Math.floor((player.x + playerWidth / 2) / tileSize);
            const rowBelowFeet = Math.floor((player.y + playerHeight) / tileSize);
            const blockBelow = getBlockType(playerCenterCol, rowBelowFeet);

            // Check if the block is our test "heat block"
            if (blockBelow === 'magma_stone_block') {
                // Apply damage over time. The '50' means 50 health per second.
                // You can adjust this value to make the damage faster or slower.
                player.onFire = true;
				player.fireDuration = PLAYER_FIRE_DURATION;
                if (applyDamage(50 * (dt / 1000))) return;
            } else if (blockBelow === 'chasm_magma_stone_block') {
                // Apply damage over time. The '50' means 50 health per second.
                // You can adjust this value to make the damage faster or slower.
                if (applyDamage(10 * (dt / 1000))) return;
            } else if (blockBelow === 'heaven_magma_stone_block') {
                // Apply damage over time. The '50' means 50 health per second.
                // You can adjust this value to make the damage faster or slower.
                if (applyDamage(50 * (dt / 1000))) return;
            }
			
            
            if (isCreativeMode === 1) {
                const flightSpeed = player.speed * factor * CREATIVE_FLIGHT_SPEED;
                
                // 1. Disable Gravity
                player.dy = 0; 
                player.onGround = true; // Prevent jump logic from running
            
                // 2. Vertical Flight (W/S or Up/Down Arrow keys)
                if (keys['ArrowUp'] || keys['w'] || keys['W']) {
                    player.y -= flightSpeed;
                } else if (keys['ArrowDown'] || keys['s'] || keys['S']) {
                    player.y += flightSpeed;
                }
                
                // Apply horizontal movement (Vertical movement (player.y) was applied directly above)
                player.x += player.dx;
            }
                // 1. Check if player is touching a fire block
				const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };
				let isTouchingFire = false;
				for (const fireKey in fireBlocks) {
					const [col, row] = fireKey.split(',').map(Number);
					const fireRect = { x: col * tileSize, y: row * tileSize, width: tileSize, height: tileSize };
					const fireHeatRect = { x: col * tileSize, y: (row + -1) * tileSize, width: tileSize, height: tileSize };

					if (rectIntersects(playerRect, fireRect)) {
						isTouchingFire = true;
						break; // Found one, no need to check others
					} else if (rectIntersects(playerRect, fireHeatRect)) {
						isTouchingFire = true;
						break; // Found one, no need to check others
					}
				}

				// 2. Set player on fire or reset timer
				if (isTouchingFire) {
					player.onFire = true;
					player.fireDuration = PLAYER_FIRE_DURATION; // (Re)set the burn timer
				}

				// 3. Handle burning state
				if (player.onFire) {
					player.fireDuration -= dt;
					player.fireDamageTimer -= dt;

					// Apply damage every 200ms
					if (player.fireDamageTimer <= 0) {
						player.fireDamageTimer = PLAYER_FIRE_DAMAGE_TICK; // Reset tick timer
						if (applyDamage(PLAYER_FIRE_DAMAGE)) return;
					}

					// Check if fire goes out
					if (player.fireDuration <= 0) {
						player.onFire = false;
						player.fireDamageTimer = 0;
					}
				}
				
				if (hellfireOn && isPlayerOnHellfire) {
					// Apply constant fire damage. We can re-use the same timers/damage as regular fire.
					player.fireDamageTimer -= dt;
					if (player.fireDamageTimer <= 0) {
						player.fireDamageTimer = PLAYER_FIRE_DAMAGE_TICK; // Reset tick timer
						if (applyDamage(PLAYER_FIRE_DAMAGE)) return; // Player died
					}
					// This ensures the player *looks* on fire
					player.onFire = true; 
					player.fireDuration = PLAYER_FIRE_DURATION; // Keep resetting the visual
				}

                // 1. Get base stats from the player object
            let effectiveSpeed = player.speed;
            let effectiveJump = player.jumpStrength;
            let effectiveGravity = player.gravity; // This is our base 0.8

            // 2. Apply food effects FIRST
            for (const effect of player.activeEffects) {
                for (const change of effect.changes) {
                    if (change.prop === 'speed') {
                        if (change.type === 'add') effectiveSpeed += change.value;
                        if (change.type === 'set') effectiveSpeed = change.value;
                    } else if (change.prop === 'jumpStrength') {
                        if (change.type === 'add') effectiveJump += change.value;
                        if (change.type === 'set') effectiveJump = change.value;
                    } else if (change.prop === 'gravity') {
                        if (change.type === 'add') effectiveGravity += change.value;
                        if (change.type === 'set') effectiveGravity = change.value;
                    }
                }
            }

            // 3. Apply armor effects SECOND (Feather Boots)
            const boots = player.armor.boots;
            if (boots && boots.type === 'feather_boots') {
                const bootProps = itemTypes[boots.type];
                if (bootProps.gravityMultiplier) {
                    effectiveGravity *= bootProps.gravityMultiplier;
                }
            }

            // 4. Apply environmental modifiers (Cobweb, Asphalt, etc.)
            const currentSpeed = isInCobweb ? effectiveSpeed * 0.2 : isOnAsphalt ? effectiveSpeed * 1.5 : isOnThickMud ? effectiveSpeed * 0.5 : effectiveSpeed;
            const currentJumpStrength = isInCobweb ? effectiveJump * 0.2 : isOnThickMud ? effectiveJump * 0 : effectiveJump;
            const currentGravity = isInCobweb ? effectiveGravity * 0.1 : effectiveGravity;

            // 5. Apply gravity
            player.dy += currentGravity * factor;
    
            // 6. Get effective BAC for drunkenness masks
            let effectiveBAC = player.bloodAlcohol;
            const helmet = player.armor.helmet;
            if (helmet) {
                if (helmet.type === 'sober_mask') {
                    effectiveBAC *= 0.25; // 75% reduction
                } else if (helmet.type === 'drunk_mask') {
                    effectiveBAC += 100; // Simulate +100
                }
            }
                
                if (keys['ArrowLeft'] || keys['KeyA']) { // Check for 'A'
					player.dx = -currentSpeed;
					player.facingDirection = -1;
				}
    			else if (keys['ArrowRight'] || keys['KeyD']) { // Check for 'D'
					player.dx = currentSpeed;
					player.facingDirection = 1;
				}
    			else player.dx = 0;

            // --- Fall Damage Logic ---
            if (!player.onGround && player.dy > 0) {
                // If we just started falling, record the start position
                if (player.fallStartY === 0) {
                    player.fallStartY = player.y;
                }
            }

            let nextPlayerX = player.x + player.dx * factor;
            let nextPlayerY = player.y + player.dy * factor;

            const playerRectY = { x: player.x, y: nextPlayerY, width: playerWidth, height: playerHeight };
            const startRowY = Math.floor(Math.min(player.y, nextPlayerY) / tileSize) - 2;
            const endRowY = Math.ceil(Math.max(player.y + playerHeight, nextPlayerY + playerHeight) / tileSize) + 2;
            const startColY = Math.floor(player.x / tileSize);
            const endColY = Math.floor((player.x + playerWidth - 1) / tileSize);

            let wasOnGround = player.onGround;
            player.onGround = false;
            for (let col = startColY; col <= endColY; col++) {
                for (let row = startRowY; row <= endRowY; row++) {
                    if (isSolid(col, row)) {
                        const blockRect = { x: col * tileSize, y: row * tileSize, width: tileSize, height: tileSize };
                        if (rectIntersects(playerRectY, blockRect)) {
                            if (player.dy > 0) {
                                player.y = blockRect.y - playerHeight;
                                player.dy = 0;
                                player.onGround = true;
                            } else if (player.dy < 0) {
                                player.y = blockRect.y + tileSize;
                                player.dy = 0;
                            }
                            nextPlayerY = player.y;
                        }
                    }
                }
            }
            player.y = nextPlayerY;

            // Calculate fall damage when landing
			// Check if player is inside a cobweb
			const playerBodyCol = Math.floor((player.x + playerWidth / 2) / tileSize);
			const playerBodyRow = Math.floor((player.y + playerHeight / 2) / tileSize);
			const blockAtPlayerBody = getBlockType(playerBodyCol, playerBodyRow);
            let FALL_INTENSITY = 4
            
			// If in a cobweb, reset fall distance continuously
			if (isInCobweb || blockAtPlayerBody === 'cobweb') {
				player.fallStartY = player.y;
			}
            if (player.onGround && !wasOnGround && player.fallStartY !== 0) {
                const fallDistance = player.y - player.fallStartY;
                const fallDistanceInBlocks = fallDistance / tileSize;
                if (fallDistanceInBlocks > (5 / player.gravity)) {
                    const damage = Math.floor(fallDistanceInBlocks - (5 / player.gravity)) * FALL_INTENSITY * player.gravity;
                    if (applyDamage(damage)) { return; }
                    /*if (player.health <= 0) {
                        respawnPlayer();
						return;
						player.x = 0;
						player.y = 0;
						let titleCycle = ["Block Game Ultimate [HTML EDITION]", "Block Game Ultimate [STOP DYING]", "Block Game Ultimate [TRY WINNING]"];
						let i = 0;
						setInterval(() => {
							document.title = titleCycle[i % titleCycle.length];
							i++;
						}, 600);
                    }*/
                }
                player.fallStartY = 0; // Reset fall tracker
            } else if (!player.onGround && wasOnGround) {
                player.fallStartY = player.y; // Start tracking fall
            }

            const playerRectX = { x: nextPlayerX, y: player.y, width: playerWidth, height: playerHeight };
            const startColX = Math.floor(Math.min(player.x, nextPlayerX) / tileSize) - 2;
            const endColX = Math.ceil(Math.max(player.x + playerWidth, nextPlayerX + playerWidth) / tileSize) + 2;
            const startRowX = Math.floor(player.y / tileSize);
            const endRowX = Math.floor((player.y + playerHeight - 1) / tileSize);

            for (let col = startColX; col <= endColX; col++) {
                for (let row = startRowX; row <= endRowX; row++) {
                    if (isSolid(col, row)) {
                        const blockRect = { x: col * tileSize, y: row * tileSize, width: tileSize, height: tileSize };
                        if (rectIntersects(playerRectX, blockRect)) {
                            if (player.dx > 0) nextPlayerX = blockRect.x - playerWidth;
                            else if (player.dx < 0) nextPlayerX = blockRect.x + tileSize;
                            player.dx = 0;
                        }
                    }
                }
            }
            player.x = nextPlayerX;

            if ((keys['ArrowUp'] || keys['KeyW']) && player.onGround) { // Check for 'W'
				player.dy = currentJumpStrength;
				player.onGround = false;
			}
			if (player.y < -150 * tileSize) {
				unlockAchievement('SKY_CHASER');
			}
			// World border safety check
			if (worldLimitEnabled) {
				if (player.x < worldMinX * tileSize) {
					player.x = worldMinX * tileSize;
					player.dx = 0;
				}
				if (player.x + playerWidth > worldMaxX * tileSize) {
					player.x = (worldMaxX * tileSize) - playerWidth;
					player.dx = 0;
				}
				if (player.y < worldMinY * tileSize) {
					player.y = worldMinY * tileSize;
					player.dy = 0;
				}
				if (player.y + playerHeight > worldMaxY * tileSize) {
					player.y = (worldMaxY * tileSize) - playerHeight;
					player.dy = 0;
					player.onGround = true; // Land if hitting bottom
				}
			}
        }

        function updateCamera() {
            camera.x = player.x + playerWidth / 2 - canvas.width / 2;
            camera.y = player.y + playerHeight / 2 - canvas.height / 2;
        }

        function handleMiningDrops(blockProps, targetKey) {
            const [col, row] = targetKey.split(',').map(Number); // Get coords for spawning
			const blockData = worldBlocks[targetKey];
			
			if (blockData && blockData.type === 'void_crystal' && player.y > 600 * tileSize) {
				unlockAchievement('REALM_NOTHINGNESS');
			}
            if (blockData && blockData.type === 'guano') {
				guanoMined += 1;
                if (guanoMined >= 25) unlockAchievement('SPELUNKER')
			}
            
			// If the block was a World Mover, drop its fuel first
            if (blockData && blockData.type === 'world_mover' && blockData.inventory) {
                const fuelItem = blockData.inventory[0];
                if (fuelItem) {
                    addToInventory(fuelItem.type, fuelItem.count);
                    // Clear the inventory so it doesn't get duplicated on save/load
                    blockData.inventory[0] = null;
                }
            }
			
            // If the block was a chest, drop its contents
            if (blockData && blockData.type === 'chest' && blockData.inventory) {
                blockData.inventory.forEach(item => {
                    if (item) {
                        addToInventory(item.type, item.count, item.durability);
                    }
                });
            }
            
            // If the block was part of a bed, handle bed breaking
      if (blockData && blockData.type === 'bed') {
        const [col, row] = targetKey.split(',').map(Number);
        const bedPart = blockData.part;
        let startCol = col;
        // Find the starting (left) part of the bed
        if (bedPart === 'middle') {
          startCol = col - 1;
        } else if (bedPart === 'right') {
          startCol = col - 2;
        }
        // Check if all parts are still there before removing
        let bedIntact = true;
        for (let i = 0; i < 3; i++) {
          const partKey = `${startCol + i},${row}`;
          if (!worldBlocks[partKey] || worldBlocks[partKey].type !== 'bed') {
            bedIntact = false;
            break;
          }
        }
        if (bedIntact) {
          // Replace all three parts of the bed with sky
          for (let i = 0; i < 3; i++) {
            const key = `${startCol + i},${row}`;
						player.bedSpawnPoint = null
            worldBlocks[key] = {
              type: '',
              solid: false
            };
            // If you need to redraw the block:
            // redrawBlock(key);
          }
          // Drop a single bed item
          addToInventory('bed', 1);
        }
        return; // Stop further processing for this block
      }

			// If the block was part of a trader, handle vertical trader breaking
			if (blockData && blockData.type === 'trader') {
				const [col, row] = targetKey.split(',').map(Number);
				const part = blockData.part; // 'bottom'|'middle'|'top'
				let bottomRow = row;
				if (part === 'middle') bottomRow = row + 1;
				else if (part === 'top') bottomRow = row + 2;

				// verify trader intact (bottom, middle, top)
				let traderIntact = true;
				for (let dy = 0; dy <= 2; dy++) {
					const k = `${col},${bottomRow - dy}`; // bottomRow, bottomRow-1, bottomRow-2
					if (!worldBlocks[k] || worldBlocks[k].type !== 'trader') {
						traderIntact = false; break;
					}
				}
				if (traderIntact) {
					// remove all three parts
					for (let dy = 0; dy <= 2; dy++) {
						const k = `${col},${bottomRow - dy}`;
						worldBlocks[k] = { type: '', mineProg: 0 };
					}
					// drop trader item once (or some coin/item if you'd prefer)
					traderDropRandom = random() < 0.5 ? 'bronze_coin' : random() < 0.5 ? 'trader_mask' : 'gold_coin';
					addToInventory(traderDropRandom, 1);
				}
			}


            // Handle the block's own drops
            if (blockProps && blockProps.drops) {
                blockProps.drops.forEach(drop => {
                    if (random() < drop.chance) {
						if (animateDrops) {
							// NEW: Create an animated drop instead
							createAnimatedDrop(col, row, drop);
						} else {
							// ORIGINAL: Add directly to inventory
							const count = drop.min + Math.floor(random() * (drop.max - drop.min + 1));
							if (count > 0) {
								addToInventory(drop.item, count);
							}
						}
					}
                });
            }
        }
        function handleBombDrops(blockProps, targetKey) {
            const blockData = worldBlocks[targetKey];

            // If the block was a chest, world mover, etc., drop its contents into the void
            if (blockData && blockData.inventory) {
                blockData.inventory.forEach(item => {
                    if (item) {
                        addToVoidStorage(item.type, item.count, item.durability, item.maxDurability);
                    }
                });
                // Clear the inventory so it doesn't get duplicated
                blockData.inventory.fill(null);
            }

            // Handle the block's own drops
            if (blockProps && blockProps.drops) {
                blockProps.drops.forEach(drop => {
                    // Bombs ignore drop chance and always drop the item
                    const count = drop.min + Math.floor(random() * (drop.max - drop.min + 1));
                    if (count > 0) {
                        addToVoidStorage(drop.item, count);
                    }
                });
            }
        }
		
		function updateAnimatedDrops(dt) {
			const dropSpeed = 0.08;
			const pickupRadiusSq = (tileSize * 1.5) * (tileSize * 1.5); // Squared for efficiency

			for (let i = animatedDrops.length - 1; i >= 0; i--) {
				const drop = animatedDrops[i];

				// Update pickup delay
				if (drop.pickupDelay > 0) {
					drop.pickupDelay -= dt;
				}

				// Apply gravity
				drop.dy += 0.3; 

				// Move towards player after delay
				if (drop.pickupDelay <= 0) {
					const playerCenterX = player.x + playerWidth / 2;
					const playerCenterY = player.y + playerHeight / 2;

					const vecX = playerCenterX - drop.x;
					const vecY = playerCenterY - drop.y;
					const dist = Math.sqrt(vecX * vecX + vecY * vecY);

					if (dist > 1) { // Normalize and apply force
						drop.dx += (vecX / dist) * dropSpeed * dt;
						drop.dy += (vecY / dist) * dropSpeed * dt;
					}
				}

				// Apply friction/drag
				drop.dx *= 0.95;
				drop.dy *= 0.95;

				// Update position
				drop.x += drop.dx;
				drop.y += drop.dy;

				// Check for pickup
				const distToPlayerSq = Math.pow(player.x + playerWidth / 2 - drop.x, 2) + Math.pow(player.y + playerHeight / 2 - drop.y, 2);
				if (drop.pickupDelay <= 0 && distToPlayerSq < pickupRadiusSq) {
					if (addToInventory(drop.type, drop.count)) {
						animatedDrops.splice(i, 1); // Remove from array if picked up
					}
				}
			}
		}
		
		function createAnimatedDrop(col, row, drop) {
			const itemProps = itemTypes[drop.item] || blockTypes[drop.item];
			if (!itemProps) return;

			const count = drop.min + Math.floor(random() * (drop.max - drop.min + 1));
			if (count <= 0) return;

			const dropEntity = {
				x: col * tileSize + tileSize / 2, // Start at block center
				y: row * tileSize + tileSize / 2,
				dx: (Math.random() - 0.5) * 6, // Initial random pop
				dy: -Math.random() * 5,
				type: drop.item,
				count: count,
				pickupDelay: 500, // 0.5 second delay before pickup
				img: assets[drop.item]
			};
			animatedDrops.push(dropEntity);
		}
        
        // New function to check if inventory can accept drops
        function canInventoryAcceptDrops(drops) {
            if (!drops || drops.length === 0) return true;

            // Create a deep copy of the inventory to simulate adding items
            const tempInventory = JSON.parse(JSON.stringify(inventorySlots));

            for (const drop of drops) {
                let remainingCount = drop.min; // Check for minimum guaranteed drop
                const itemType = drop.item;
                const itemProps = itemTypes[itemType] || blockTypes[itemType];
                
                if (itemProps.isTool) {
                    let hasEmptySlot = false;
                    for (let i = 0; i < totalInventorySlots; i++) {
                        if (!tempInventory[i]) {
                            tempInventory[i] = { type: itemType, count: 1 }; // Placeholder
                            hasEmptySlot = true;
                            remainingCount--;
                            break;
                        }
                    }
                    if (!hasEmptySlot) return false; // No space for the tool

                } else {
                    // First pass: fill existing stacks
                    for (let i = 0; i < totalInventorySlots; i++) {
                        if (remainingCount === 0) break;
                        const slot = tempInventory[i];
                        if (slot && slot.type === itemType && slot.count < maxStackSize) {
                            const canAdd = Math.min(remainingCount, maxStackSize - slot.count);
                            slot.count += canAdd;
                            remainingCount -= canAdd;
                        }
                    }

                    // Second pass: use empty slots
                    if (remainingCount > 0) {
                        for (let i = 0; i < totalInventorySlots; i++) {
                            if (remainingCount === 0) break;
                            if (!tempInventory[i]) {
                                const canAdd = Math.min(remainingCount, maxStackSize);
                                tempInventory[i] = { type: itemType, count: canAdd }; // Placeholder
                                remainingCount -= canAdd;
                            }
                        }
                    }
                }
                
                if (remainingCount > 0) return false; // Not enough space for this drop
            }

            return true; // All drops can be accommodated
        }


        function updateMining(dt) {
			if (!isGameActive || isGamePaused) return;
			
			const worldMouseX = mouse.x + camera.x;
			const worldMouseY = mouse.y + camera.y;
			const targetCol = Math.floor(worldMouseX / tileSize);
			const targetRow = Math.floor(worldMouseY / tileSize);
			const targetKey = `${targetCol},${targetRow}`;
			let blockData = worldBlocks[targetKey] || getBlockData(targetCol, targetRow);
			
			const equippedItemObject = getSelectedItem();
            const equippedItemProps = equippedItemObject ? itemTypes[equippedItemObject.type] : null;

            if (mouse.down && equippedItemProps && equippedItemProps.isGun) {
                handleShooting(dt);
                return; // Don't run mining logic
            }
			
			// Determine the effective block type and its properties
			// --- NEW: Prioritize Overlay for Mining ---
			let effectiveBlockType;
			if (blockData.overlay) {
				effectiveBlockType = blockData.overlay;
			} else {
				effectiveBlockType = blockData.type;
			}
			// --- END NEW ---

			if (blockData.type.startsWith('planted_')) {
				const seedType = blockData.type.replace('planted_', '').replace('_seeds', '');
				effectiveBlockType = `${seedType}_${blockData.baseBlockType}`;
			}
			const blockPropsForMining = blockTypes[effectiveBlockType];

			// Determine player's current mining capabilities
			const equippedItemType = equippedItemObject ? equippedItemObject.type : null;
			let currentMiningPower;

			// Determine power based on tool and block type
			if (equippedItemProps && equippedItemProps.isTool) {
				const isAxeBlock = effectiveBlockType.startsWith('raw_') || effectiveBlockType.startsWith('planked_') || effectiveBlockType.startsWith('cactus_') || effectiveBlockType.endsWith('_wood');
				const isShovelBlock = blockPropsForMining && blockPropsForMining.shovelBlock;
                const isPickaxe = equippedItemType.includes('_pickaxe');

                if (isPickaxe && (isAxeBlock || isShovelBlock)) {
                    // If a pickaxe is used on an axe or shovel block, nerf its power
                    currentMiningPower = 0.1;
                } else if (isAxeBlock && equippedItemProps.axePower) {
					// Correct tool (axe) for wood blocks
					currentMiningPower = equippedItemProps.axePower;
					unlockAchievement('TIMBER');
				} else if (isShovelBlock && equippedItemProps.shovelPower) {
					// Correct tool (shovel) for shovelable blocks
					currentMiningPower = equippedItemProps.shovelPower;
					unlockAchievement('POOP_SCOOP');
				} else {
					// It's a tool, but not the right one for this special block, or it's a generic block. Use its base mining power.
                    currentMiningPower = equippedItemProps.miningPower;
					// Check for Terraformer (Pickaxe on a non-special block)
					if (isPickaxe && blockPropsForMining && blockPropsForMining.solid && !isAxeBlock && !isShovelBlock) {
						unlockAchievement('TERRAFORMER');
					}
				}
			} else {
				// Player is using their hand
				currentMiningPower = handMiningPower;
			}
			
			let effectiveBAC = player.bloodAlcohol;
            const helmet = player.armor.helmet;
            if (helmet) {
                if (helmet.type === 'sober_mask') {
                    effectiveBAC *= 0.25; // 75% reduction
                } else if (helmet.type === 'drunk_mask') {
                    effectiveBAC += 100; // Simulate +100
                }
            }

            if (effectiveBAC > 25) {
                // 1% power reduction for every BAC point *above* 25
                let reductionPercent = (player.bloodAlcohol - 25) * 0.01;
				if (reductionPercent >= 0.9) {
					reductionPercent = 0.9
				}
                // Clamp reduction between 0% (0.0) and 100% (1.0)
                const cappedReduction = Math.max(0, Math.min(1, reductionPercent));
                // Apply the reduction
                currentMiningPower *= (1 - cappedReduction);
            }

			// --- NEW: ADVANCED MINING CHECKS ---
			let canMine = true;
			if (blockPropsForMining) {
				// 1. Check for required power level
				if (blockPropsForMining.requiredMiningPower && currentMiningPower < blockPropsForMining.requiredMiningPower) {
					canMine = false;
				}

				// 2. Check for a specific required tool
				if (blockPropsForMining.requiredTool) {
					const required = blockPropsForMining.requiredTool;
					if (Array.isArray(required)) {
						// If it's an array, check if the held tool is in the array
						if (!required.includes(equippedItemType)) {
							canMine = false;
						}
					} else {
						// If it's a single string, check for an exact match
						if (equippedItemType !== required) {
							canMine = false;
						}
					}
				}
			}
			// --- END OF NEW CHECKS ---

			// If the mouse is pressed on a new block, and we can mine it, set it as the target.
			if (mouse.down && (!miningTarget || miningTarget.col !== targetCol || miningTarget.row !== targetRow)) {
				if (blockData && blockPropsForMining?.miningHardness > 0 && canMine) { // <-- Added canMine check
					miningTarget = {
						col: targetCol,
						row: targetRow,
						progress: maintainBlockDurability ? (blockData.mineProg || 0) : 0,
						requiredProgress: blockPropsForMining.miningHardness
					};
					// This puts out fire *in* the block
					if (fireBlocks[targetKey]) {
						delete fireBlocks[targetKey];
					}
					// This puts out fire *above* the block
					const blockAboveKey = `${targetCol},${targetRow - 1}`;
					if (fireBlocks[blockAboveKey] && fireBlocks[blockAboveKey].burningBlockKey === targetKey) {
						delete fireBlocks[blockAboveKey];
					}
				} else {
					miningTarget = null;
				}
			}

			// If holding mouse down on a valid target, continue mining
			if (mouse.down && miningTarget && miningTarget.col === targetCol && miningTarget.row === targetRow) {
				// Double-check that conditions are still met (e.g., tool didn't break)
				if (!canMine || !blockData || blockPropsForMining?.miningHardness === 0) {
					if (maintainBlockDurability && worldBlocks[targetKey]) worldBlocks[targetKey].mineProg = 0;
					miningTarget = null;
					return;
				}

				// Check for special inventory-not-empty case for chests
				const blockToMine = worldBlocks[targetKey];
				if (blockToMine && (blockToMine.type === 'chest' || blockToMine.type === 'dead_body_chest' || blockToMine.type === 'refrigerator' || blockToMine.type === 'oven')) {
					if (blockToMine.inventory && blockToMine.inventory.some(item => item !== null)) {
						miningTarget = null;
						return;
					}
				}

				miningTarget.progress += dt * currentMiningPower;
				if (maintainBlockDurability) worldBlocks[targetKey].mineProg = miningTarget.progress;

				// Decrease tool durability
				if (equippedItemObject && equippedItemProps?.isTool && equippedItemObject.durability !== undefined) {
					equippedItemObject.durability -= dt * currentMiningPower; // Simplified durability loss
					if (equippedItemObject.durability <= 0) {
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						miningTarget = null;
						updateHotbar();
						return;
					}
				}

				// Check if block is fully mined
				if (miningTarget.progress >= miningTarget.requiredProgress) {

					const minedBlockProps = blockTypes[effectiveBlockType]; // This now correctly points to the overlay if one existed

					// --- NEW: Handle Overlay Breaking ---
					if (blockData.overlay) {
						// Only drop the overlay item
						handleMiningDrops(minedBlockProps, targetKey); // handleMiningDrops uses blockProps, so this is fine
						createBlockBreakParticles(miningTarget.col, miningTarget.row, effectiveBlockType); // Particles for the overlay

						// Remove the overlay, but leave the wall
						blockData.overlay = null;
						blockData.mineProg = 0; // Reset mine progress
						miningTarget = null;
						return; // Stop here, the wall is not broken
					}
					// --- END NEW ---

					// If no overlay, proceed with original logic
					const blockToMineData = worldBlocks[targetKey];
                    if (blockToMineData && blockToMineData.type === 'world_mover') {
                        let spaceNeeded = 1; // 1 slot for the mover block itself
                        const fuel = blockToMineData.inventory ? blockToMineData.inventory[0] : null;
                        
                        let hasSpace = false;
                        const tempInventory = JSON.parse(JSON.stringify(inventorySlots)); // A safe copy

                        // First, find a slot for the mover itself
                        let moverSlotIndex = -1;
                        for (let i = 0; i < tempInventory.length; i++) {
                            if (!tempInventory[i]) {
                                moverSlotIndex = i;
                                tempInventory[i] = { type: 'world_mover', count: 1 }; // Temporarily occupy the slot
                                break;
                            }
                        }

                        if (moverSlotIndex !== -1) {
                            // Now check if there's space for the fuel
                            if (!fuel) {
                                hasSpace = true; // No fuel, so space is fine
                            } else {
                                let fuelRemaining = fuel.count;
                                // Try adding to existing stacks first
                                for (let i = 0; i < tempInventory.length; i++) {
                                    if (tempInventory[i] && tempInventory[i].type === fuel.type && tempInventory[i].count < maxStackSize) {
                                        const canAdd = maxStackSize - tempInventory[i].count;
                                        const toAdd = Math.min(fuelRemaining, canAdd);
                                        tempInventory[i].count += toAdd;
                                        fuelRemaining -= toAdd;
                                    }
                                }
                                // Try adding to empty slots
                                while (fuelRemaining > 0) {
                                    let foundEmpty = false;
                                    for (let i = 0; i < tempInventory.length; i++) {
                                        if (!tempInventory[i]) {
                                            const toAdd = Math.min(fuelRemaining, maxStackSize);
                                            tempInventory[i] = { type: fuel.type, count: toAdd };
                                            fuelRemaining -= toAdd;
                                            foundEmpty = true;
                                            break;
                                        }
                                    }
                                    if (!foundEmpty) break; // No more empty slots
                                }
                                if (fuelRemaining <= 0) hasSpace = true;
                            }
                        }
                        
                        if (!hasSpace) {
                            miningTarget.progress = miningTarget.requiredProgress - 1; // Prevent insta-break
                            return; // Stop the breaking process
                        }
                    }

					handleMiningDrops(minedBlockProps, targetKey);

					createBlockBreakParticles(miningTarget.col, miningTarget.row, effectiveBlockType);

					if (blockData.type !== 'bed') {
						worldBlocks[targetKey] = { type: '', mineProg: 0 };
					}
                    exploredMap[targetKey] = '#000000'; // --- ADD THIS: Set broken block to "air" color ---
					const brokenBlockType = blockData.type;
                    const mechageezerComponents = ['lever_off', 'lever_on', 'chest_lever_off', 'chest_lever_on', 'reactant', 'trailer', 'lit_trailer', 'stone_trailer'];
                    if (mechageezerComponents.includes(brokenBlockType)) {
                        const [col, row] = targetKey.split(',').map(Number);
						// Update only neighbor mech blocks (so the updater starts from a real mech block)
						const mechNeighbors = [
						  { col: col, row: row - 1 },
						  { col: col, row: row + 1 },
						  { col: col - 1, row: row },
						  { col: col + 1, row: row }
						];

						for (const n of mechNeighbors) {
						  const nt = getBlockType(n.col, n.row);
						  // only call the network updater for actual mech nodes to avoid unnecessary work
						  if (['lever_off','lever_on','chest_lever_off','chest_lever_on','reactant','trailer','lit_trailer','stone_trailer'].includes(nt)) {
							scheduleMechUpdate(n.col, n.row);
						  }
						}
                    }

                    // Break all foliage blocks stacked above the mined block
                    let currentRow = targetRow - 1; // Start with the block directly above
                    
                    while (true) {
                        const blockAboveKey = `${targetCol},${currentRow}`;
                        const blockAboveData = worldBlocks[blockAboveKey];
                    
                        // Check if the block is a breakable foliage type
                        if (blockAboveData && foliageTypes.includes(blockAboveData.type)) {
                            const blockAboveProps = blockTypes[blockAboveData.type];
                    
                            // Check if player has inventory space for the drops
                            if (canInventoryAcceptDrops(blockAboveProps.drops)) {
                                worldBlocks[blockAboveKey] = { type: '', mineProg: 0 };
                                handleMiningDrops(blockAboveProps, blockAboveKey);
                                currentRow--; // Move up to check the next block
                            } else {
                                // Stop the cascade if inventory is full
                                break;
                            }
                        } else {
                            // Stop if the block is solid, air, or not foliage
                            break;
                        }
                    }
                    
                    miningTarget = null;
				}
			} else if (!mouse.down && miningTarget) {
				// If mouse is released, reset mining progress (if not maintaining durability)
				if (!maintainBlockDurability && worldBlocks[`${miningTarget.col},${miningTarget.row}`]) {
					worldBlocks[`${miningTarget.col},${miningTarget.row}`].mineProg = 0;
				}
				miningTarget = null;
			}
		}
		
		function updateFire(dt) {
			if (isGamePaused) return;

			const FIRE_ANIM_SPEED = 200; // Milliseconds per frame
			const keysToDelete = []; // To avoid modifying object while iterating

			// Use Object.keys to iterate safely while adding new fires
			const currentFireKeys = Object.keys(fireBlocks);

			for (const fireKey of currentFireKeys) {
				// Check if fire was put out by another process
				if (!fireBlocks[fireKey]) continue; 

				const fireData = fireBlocks[fireKey];
				const burningBlockKey = fireData.burningBlockKey;
				const blockData = worldBlocks[burningBlockKey];
				const blockType = blockData ? blockData.type : '';

				// Check if fire should go out
				if (!blockData || !isAxeBlock(blockType)) {
					keysToDelete.push(fireKey);
					continue;
				}

				// Update animation
				fireData.animTimer += dt;
				if (fireData.animTimer >= FIRE_ANIM_SPEED) {
					fireData.animTimer -= FIRE_ANIM_SPEED;
					fireData.animFrame = (fireData.animFrame % 3) + 1; // Cycles 1, 2, 3, 1, 2, 3...

					// Apply damage
					const blockProps = blockTypes[blockType];
					if (blockProps) {
						blockData.mineProg = (blockData.mineProg || 0) + 1; // Add 3 durability damage

						// Check if block is destroyed
						if (blockData.mineProg >= blockProps.miningHardness) {
							worldBlocks[burningBlockKey] = (random() < 0.1) ? { type: 'ash_block', mineProg: 0 } : { type: '', mineProg: 0 };
							// Fire goes out because the block it was burning is gone
							keysToDelete.push(fireKey); 
							continue; // Stop processing this fire, it's out
						}
					}

					// --- NEW: Fire Spreading Logic ---
                    // Get the coordinates of the block that is *actually burning* (the wood)
					const [burningCol, burningRow] = burningBlockKey.split(',').map(Number);

					// Define neighbors to check (4-way spread)
					const neighbors = [
						{ dx: -1, dy: 0 }, { dx: 1, dy: 0 }, // Left/Right
						{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }  // Up/Down
					];

					for (const n of neighbors) {
						// Check spread chance
						if (random() < FIRE_SPREAD_CHANCE) {
							
                            // 1. Get the coordinates and type of the neighboring block
							const targetBlockKey = `${burningCol + n.dx},${burningRow + n.dy}`;
							const targetBlockType = getBlockType(burningCol + n.dx, burningRow + n.dy);

							// 2. Is this neighbor block burnable (an "axe block")?
							if (isAxeBlock(targetBlockType)) {
								
								// 3. Find the block this new target block
								const fireSpotKey = `${burningCol + n.dx},${burningRow + n.dy}`;
								const fireSpotType = getBlockType(burningCol + n.dx, burningRow + n.dy);

								// 4. If the spot is not already on fire...
								if (!fireBlocks[fireSpotKey]) {
									
									// ...Light it on fire!
									fireBlocks[fireSpotKey] = {
										animFrame: 1,
										animTimer: 0,
										burningBlockKey: targetBlockKey // This new fire now burns the target block
									};
								}
							}
						}
					}
					// --- END NEW Fire Spreading ---
				}
			}

			// Clean up extinguished fires
			for (const key of keysToDelete) {
				delete fireBlocks[key];
			}
		}
		
		// NEW: Function to draw fire on the player
		function drawPlayer() {
			// 1. Draw the base player image
            ctx.drawImage(
				playerImg,
				player.x - camera.x,
				player.y - camera.y,
				playerWidth,
				playerHeight
			);

            // 2. Draw equipped armor over the player
            // We define a render order
            const renderOrder = ['legGear', 'boots', 'chestGear', 'helmet'];

            for (const armorSlot of renderOrder) {
                // Get the item object DIRECTLY from the player.armor slot
                const armorItem = player.armor[armorSlot]; 
                
                // If there's no item, skip to the next slot
                if (armorItem === null) continue; 

                // Get the *equipped* asset key (e.g., "dark_helmet_equipped")
                const equippedAssetKey = `${armorItem.type}_equipped`;
                const armorImg = assets[equippedAssetKey];

                // Check if the equipped image asset exists and loaded successfully
                if (armorImg && !failedAssets[equippedAssetKey]) {
                    // Draw the armor image in the same position and size as the player
                    ctx.drawImage(
                        armorImg,
                        player.x - camera.x,
                        player.y - camera.y,
                        playerWidth,
                        playerHeight
                    );
                }
                // No placeholder "else" block, as requested
            }
		}
		
		// NEW: Function to draw fire on the player
		function drawPlayerFire() {
			if (!player.onFire) return;

			// Use the damage timer to cycle the animation (it has the same 200ms tick)
			const animProgress = (PLAYER_FIRE_DAMAGE_TICK - player.fireDamageTimer) / PLAYER_FIRE_DAMAGE_TICK;
			let animFrame = 1;
			if (animProgress > 0.66) animFrame = 3;
			else if (animProgress > 0.33) animFrame = 2;

			let img;
			if (animFrame === 1) img = assets['fire_1'];
			else if (animFrame === 2) img = assets['fire_2'];
			else img = assets['fire_3'];

			if (img) {
				const screenX = player.x - camera.x;
				const screenY = player.y - camera.y;

				// Draw 3 flames covering the player (left, middle, right)
				ctx.globalAlpha = 0.85;
				ctx.drawImage(img, screenX - playerWidth * 0.25, screenY, playerWidth, playerHeight);
				ctx.drawImage(img, screenX, screenY - playerHeight * 0.25, playerWidth, playerHeight);
				ctx.drawImage(img, screenX + playerWidth * 0.25, screenY, playerWidth, playerHeight);
				ctx.globalAlpha = 1.0;
			}
		}
		
		function updateParticles(dt) {
			// We loop backwards because we might be removing items from the array while looping.
			// Looping forwards would cause us to skip the next item after a removal.
			for (let i = particles.length - 1; i >= 0; i--) {
				const p = particles[i];

				// 1. Decrease lifespan
				p.life -= dt;

				// 2. If life is over, remove the particle
				if (p.life <= 0) {
					particles.splice(i, 1);
					continue; // Move to the next particle
				}

				// 3. Apply gravity
				p.dy += particleGravity;

				// 4. Update position based on velocity
				p.x += p.dx;
				p.y += p.dy;
			}
		}
		
		function updateHeldItemAnimation(dt) {
            const heldItem = getSelectedItem();
            const heldItemType = heldItem ? heldItem.type : null; // Get the type
            const itemProps = heldItem ? (itemTypes[heldItemType] || blockTypes[heldItemType]) : null; // Get full props
            const now = performance.now();
        
            // Determine item type
            const isGun = itemProps && itemProps.isGun;

            // Determine actions
            const isPlacing = mouse.rightDown && heldItem && blockTypes[heldItem.type];
            // 'miningTarget' is only set in updateMining() if the item is NOT a gun.
            const isMining = mouse.down && miningTarget; 
            
            // --- START/STOP SWING LOGIC (THE FIX) ---
            if (!isGun) {
                // Logic for regular tools/blocks
                if (isPlacing || isMining) {
                    if (!heldItemState.isSwinging) {
                        // Start a new swing
                        heldItemState.isSwinging = true;
                        heldItemState.swingTimer = 0;
                    }
                } else {
                    // If not placing or mining, stop swinging
                    heldItemState.isSwinging = false;
                }
            }
            // For guns, 'isSwinging' is used to mean "is recoiling".
            // It's set to 'true' in handleShooting().
            // It's set to 'false' inside the recoil animation itself when it finishes.
            // This logic now correctly leaves gun recoil alone.
            // --- END OF FIX ---
        
            // --- Calculate animation based on state ---
            if (heldItemState.isSwinging) { // This now means "is swinging" OR "is recoiling"
    
                // --- NEW: GUN LOGIC ---
                if (isGun) {
                    // Point at mouse
                    heldItemState.angle = heldItemState.gunAngle;

                    // Recoil animation
                    const recoilSpeed = 50; 
                    heldItemState.swingTimer += dt / 1000 * recoilSpeed;
                    const recoilProgress = Math.sin(heldItemState.swingTimer);

                    if (recoilProgress < 0 || heldItemState.swingTimer > Math.PI) {
                        // Animation finished
                        heldItemState.isSwinging = false;
                        heldItemState.swingTimer = 0;
                        heldItemState.offsetX = 0;
                        heldItemState.offsetY = 0;
                    } else {
                        // Play animation
                        heldItemState.offsetX = -recoilProgress * 10; // Kick back
                        heldItemState.offsetY = -recoilProgress * 5;  // Kick up
                    }
                // --- END GUN LOGIC ---

                } else if (heldItemType && heldItemType.includes('_axe')) {
                    // AXE: Hefty, forceful, slightly erratic swing
                    const swingSpeed = 20;
                    heldItemState.swingTimer += dt / 1000 * swingSpeed;
                    heldItemState.angle = Math.sin(heldItemState.swingTimer) * 2.2 + Math.sin(heldItemState.swingTimer * 3) * 0.2;
                    heldItemState.offsetX = Math.sin(heldItemState.swingTimer) * 25;
                    heldItemState.offsetY = (Math.cos(heldItemState.swingTimer) * 15) - 15;
        
                } else if (heldItemType && heldItemType.includes('_shovel')) {
                    // SHOVEL: A vertical "scooping" motion
                    const swingSpeed = 25;
                    heldItemState.swingTimer += dt / 1000 * swingSpeed;
                    heldItemState.angle = 0.25 - Math.sin(heldItemState.swingTimer) * 1.0;
                    heldItemState.offsetX = 5 + Math.sin(heldItemState.swingTimer) * 10;
                    heldItemState.offsetY = Math.cos(heldItemState.swingTimer) * 15;
        
                } else {
                    // DEFAULT / PICKAXE / BLOCK: Original swing animation
                    const swingSpeed = 25;
                    heldItemState.swingTimer += dt / 1000 * swingSpeed;
                    heldItemState.angle = Math.sin(heldItemState.swingTimer) * 1.8;
                    heldItemState.offsetX = Math.sin(heldItemState.swingTimer) * 20;
                    heldItemState.offsetY = (Math.cos(heldItemState.swingTimer) * 10) - 10;
                }
    
            } else {
                // IDLE / MOVING ANIMATION
                
                // --- NEW: Gun idle pointing ---
                if (isGun) {
                    heldItemState.angle = heldItemState.gunAngle; // Always point at mouse
                    
                    // Add idle bob
                    const returnSpeed = 0.15;
                    heldItemState.offsetX += (0 - heldItemState.offsetX) * returnSpeed; // Recoil reset
                    let bobOffsetY = 0;
                    if (player.onGround && player.dx !== 0) {
                        const bobSpeed = 15;
                        const bobAmount = 3;
                        heldItemState.bobTimer += dt / 1000 * bobSpeed;
                        bobOffsetY = Math.sin(heldItemState.bobTimer) * bobAmount;
                    } else {
                        heldItemState.bobTimer = 0;
                    }
                    let jumpOffsetY = 0;
                    if (!player.onGround) {
                        jumpOffsetY = player.dy * 0.8;
                    }
                    const targetY = bobOffsetY + jumpOffsetY;
                    heldItemState.offsetY += (targetY - heldItemState.offsetY) * returnSpeed;

                // --- END GUN IDLE ---
                } else {
                    // Original idle logic for tools
                    const returnSpeed = 0.15;
                    const defaultAngle = 0.5; 
            
                    heldItemState.angle += (defaultAngle - heldItemState.angle) * returnSpeed;
                    heldItemState.offsetX += (0 - heldItemState.offsetX) * returnSpeed;
            
                    let bobOffsetY = 0;
                    if (player.onGround && player.dx !== 0) {
                        const bobSpeed = 15;
                        const bobAmount = 3;
                        heldItemState.bobTimer += dt / 1000 * bobSpeed;
                        bobOffsetY = Math.sin(heldItemState.bobTimer) * bobAmount;
                    } else {
                        heldItemState.bobTimer = 0;
                    }
            
                    let jumpOffsetY = 0;
                    if (!player.onGround) {
                        jumpOffsetY = player.dy * 0.8;
                    }
            
                    const targetY = bobOffsetY + jumpOffsetY;
                    heldItemState.offsetY += (targetY - heldItemState.offsetY) * returnSpeed;
                }
            }
        }

		const bombDamagePatterns = {
			'napalm_bomb': [90, 80, 70, 60, 50, 40, 30, 20, 10], // Radius 9
			'dynamite_bomb': [90, 80, 70, 60, 50, 40, 30, 20, 10], // Radius 9, more focused power
			'octogen_bomb': [90, 80, 70, 60, 50, 40, 30, 20, 10], // Radius 9, much stronger
			'weak_nuclear_bomb': [150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10], // Radius 15
			'subnuclear_bomb': [250, 240, 230, 220, 210, 200, 190, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10], // Radius 25
            'nuclear_bomb': [600, 590, 580, 570, 560, 550, 540, 530, 520, 510, 500, 490, 480, 470, 460, 450, 440, 430, 420, 410, 400, 390, 380, 370, 360, 350, 340, 330, 320, 310, 300, 290, 280, 270, 260, 250, 240, 230, 220, 210, 200, 190, 180, 170, 160, 150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10], // Radius 50
			'trap_stone': [90, 80, 70, 60, 50, 40, 30, 20, 10], // Radius 9
			'trap_compacted_stone': [90, 80, 70, 60, 50, 40, 30, 20, 10], // Radius 9
			'trap_compressed_stone': [150, 140, 130, 120, 110, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10], // Radius 15
		};

		function detonateBomb(col, row, bombType) {
			const bombProps = blockTypes[bombType];
			if (!bombProps) {
				console.error(`Bomb properties not found for type: ${bombType}`);
				return;
			}
            if (bombType === 'nuclear_bomb') unlockAchievement('KABOOM');

			const radius = bombProps.bombRadius;
			const bombDamage = bombProps.bombDamage;
			const damageLayers = bombDamagePatterns[bombType];

			if (!damageLayers) {
				console.error(`Damage pattern not found for bomb type: ${bombType}`);
				return;
			}

			// Create a massive particle burst at the bomb's location
			const originalParticleCount = particleCount;
			particleCount = 10; // Temporarily increase for a big explosion effect
			createBlockBreakParticles(col, row, bombType);
			particleCount = originalParticleCount;

			// Iterate through a square area around the bomb
			for (let x = col - radius; x <= col + radius; x++) {
				for (let y = row - radius; y <= row + radius; y++) {
					// Calculate distance from the center
					const distance = Math.floor(Math.sqrt(Math.pow(x - col, 2) + Math.pow(y - row, 2)));

					if (distance < radius) {
						const targetKey = `${x},${y}`;
						const blockData = worldBlocks[targetKey];
						if (!blockData || blockData.type === 'sky' || blockData.type === '') continue;

						const blockProps = blockTypes[blockData.type];
						// Skip indestructible or non-mineable blocks
						if (!blockProps || blockProps.miningHardness === 0 || blockProps.miningHardness > 250000) continue;
                        if (blockProps.requiredTool) continue; // --- ADD THIS FIX ---
						
						// Apply damage based on the distance layer

						// Apply damage based on the distance layer
						const damageMultiplier = damageLayers[distance] || 0;
						const damageDealt = bombDamage * (damageMultiplier); // Normalize multiplier
						
						if (!blockData.mineProg) blockData.mineProg = 0;
						blockData.mineProg += damageDealt;

						// Check if the block should break
						if (blockData.mineProg >= blockProps.miningHardness) {
							// If there's space, break the block and get drops
							handleBombDrops(blockProps, targetKey);
								
							// Create particles for each broken block
							const tempParticleCount = particleCount;
							particleCount = 3; // Fewer particles for secondary blocks
							createBlockBreakParticles(x, y, blockData.type);
							particleCount = tempParticleCount;

							worldBlocks[targetKey] = { type: '', mineProg: 0 };
							exploredMap[targetKey] = '#000000';
						}
					}
				}
			}
			// The bomb itself is consumed in the explosion
			worldBlocks[`${col},${row}`] = { type: '', mineProg: 0 };
			exploredMap[`${col},${row}`] = '#000000';
			// --- Player Damage Calculation ---
			const playerCenterX = player.x + playerWidth / 2;
			const playerCenterY = player.y + playerHeight / 2;
			const bombCenterX = col * tileSize + tileSize / 2;
			const bombCenterY = row * tileSize + tileSize / 2;

			const distancePixels = Math.sqrt(Math.pow(playerCenterX - bombCenterX, 2) + Math.pow(playerCenterY - bombCenterY, 2));
			const distanceTiles = distancePixels / tileSize;

			// Check if the player is within the bomb's radius
			if (distanceTiles < radius) {
				const { playerDamageMin, playerDamageMax } = bombProps;
				
				// Use linear interpolation to calculate damage falloff.
				// Damage is highest at the center and lowest at the edge.
				const damage = playerDamageMax - (distanceTiles / radius) * (playerDamageMax - playerDamageMin);
				
				if (damage > 0) {
					applyDamage(Math.floor(damage));
					console.log(`Player took ${Math.floor(damage)} damage from explosion.`);
				}
			}
			// The bomb itself is consumed in the explosion
			worldBlocks[`${col},${row}`] = { type: '', mineProg: 0 };
		}
		
		function isPowerSource(col, row) {
			const type = getBlockType(col, row);
			// ONLY real sources  do NOT treat lit_trailer as a power source
			return type === 'lever_on' || type === 'chest_lever_on' || type === 'reactant';
		}

		// ---------- Global coalescing queue ----------
		const pendingMechUpdates = new Set();
		let mechUpdateScheduled = false;

		function scheduleMechUpdate(col, row) {
		  // add request to set and schedule a single batch processing
		  pendingMechUpdates.add(`${col},${row}`);
		  if (!mechUpdateScheduled) {
			mechUpdateScheduled = true;
			// process in next tick, coalescing multiple schedule calls
			setTimeout(() => { processMechUpdates(); }, 0);
		  }
		}

		function processMechUpdates() {
		  mechUpdateScheduled = false;
		  if (pendingMechUpdates.size === 0) return;

		  // We'll process all requested starts but avoid duplicating work for overlapping components.
		  const starts = Array.from(pendingMechUpdates);
		  pendingMechUpdates.clear();

		  const globalVisited = new Set(); // prevents reprocessing same coordinates across multiple starts
		  const bombsToDetonate = new Set();

		  for (const start of starts) {
			const [sc, sr] = start.split(',').map(Number);
			// If this coord is already covered by a previously processed component, skip.
			const key = `${sc},${sr}`;
			if (globalVisited.has(key)) continue;

			// Run a single BFS for this component (but mark nodes in globalVisited).
			const stack = [{ col: sc, row: sr }];
			const component = [];
			const localVisited = new Set();

			const isMechBlock = (t) => ['lever_on','lever_off','chest_lever_off','chest_lever_on','reactant','trailer','lit_trailer','stone_trailer'].includes(t);

			while (stack.length) {
			  const { col, row } = stack.pop();
			  const k = `${col},${row}`;
			  if (localVisited.has(k)) continue;
			  localVisited.add(k);
			  if (globalVisited.has(k)) continue; // already accounted for by an earlier component

			  const t = getBlockType(col, row);
			  if (!isMechBlock(t)) continue;

			  component.push({ col, row, type: t });
			  globalVisited.add(k);

			  const neighbors = [
				{ c: col, r: row - 1 }, { c: col, r: row + 1 },
				{ c: col - 1, r: row }, { c: col + 1, r: row }
			  ];
			  for (const n of neighbors) {
				const nk = `${n.c},${n.r}`;
				if (!localVisited.has(nk) && !globalVisited.has(nk)) {
				  const nt = getBlockType(n.c, n.r);
				  if (isMechBlock(nt)) stack.push({ col: n.c, row: n.r });
				}
			  }
			} // end BFS

			if (component.length === 0) continue;

			// Decide if the component is powered by any REAL source
			const hasRealSource = component.some(b => {
			  const t = b.type;
			  return t === 'lever_on' || t === 'chest_lever_on' || t === 'reactant';
			});

			// Check for trailer changes, but do not commit until we know we actually need to write something.
			const toChange = [];
			for (const b of component) {
			  const nowType = b.type; // we cached it from getBlockType
			  if (nowType === 'trailer' || nowType === 'lit_trailer') {
				const desired = hasRealSource ? 'lit_trailer' : 'trailer';
				if (nowType !== desired) toChange.push({ col: b.col, row: b.row, type: desired });
			  } else if (nowType === 'stone_trailer') {
				const desired = hasRealSource ? 'lit_trailer' : 'stone_trailer';
				if (nowType !== desired) toChange.push({ col: b.col, row: b.row, type: desired });
			  }
			}

			// If nothing changes AND there are no lit_trailers that should detonate bombs, skip heavy work
			// BUT we still must detonate bombs that are adjacent to any lit_trailer (even if no trailers change),
			// because the user requested bombs trigger whenever a lit_trailer exists (past or present).
			// So detect lit_trailers in the current component first.
			const litTrailers = component.filter(b => b.type === 'lit_trailer');
			if (toChange.length === 0 && litTrailers.length === 0 && !hasRealSource) {
			  // component is unpowered, no lit trailers, no changes -> nothing to do.
			  continue;
			}

			// Commit the trailer state changes (only what's necessary)
			for (const ch of toChange) {
			  const k = `${ch.col},${ch.row}`;
			  // update worldBlocks (preserve other properties but set type and reset mineProg)
			  worldBlocks[k] = Object.assign(worldBlocks[k] || {}, { type: ch.type, mineProg: 0 });
			}

			// After change commit, gather bombs adjacent to any lit_trailer (either existing or newly lit).
			// Use a Set to dedupe bomb positions within this batch.
			const componentLitCoords = new Set();
			// reflect current world state (some trailers might have been changed)
			for (const b of component) {
			  const curType = getBlockType(b.col, b.row); // cheap local call; component is usually small
			  if (curType === 'lit_trailer') componentLitCoords.add(`${b.col},${b.row}`);
			}

			// Collect neighboring bombs to detonate
			const bombs = ['napalm_bomb','dynamite_bomb','octogen_bomb','weak_nuclear_bomb','subnuclear_bomb','nuclear_bomb', 'trap_stone', 'trap_compacted_stone', 'trap_compressed_stone'];
			for (const lt of componentLitCoords) {
			  const [lc, lr] = lt.split(',').map(Number);
			  const neighbors = [
				{ c: lc, r: lr - 1 }, { c: lc, r: lr + 1 },
				{ c: lc - 1, r: lr }, { c: lc + 1, r: lr }
			  ];
			  for (const n of neighbors) {
				const nt = getBlockType(n.c, n.r);
				if (bombs.includes(nt)) bombsToDetonate.add(`${n.c},${n.r},${nt}`);
			  }
			}
		  } // end processing starts

		  // Detonate bombs once after all components are processed.
		  if (bombsToDetonate.size > 0) {
			// small single timeout to keep UI consistent but avoid many timeouts
			setTimeout(() => {
			  for (const b of bombsToDetonate) {
				const [bc, br, btype] = b.split(',');
				// double-check block is still the same bomb before detonating
				if (getBlockType(Number(bc), Number(br)) === btype) {
				  detonateBomb(Number(bc), Number(br), btype);
				}
			  }
			}, 40);
		  }
		}
		
        function handleBlockPlacement() {
            if (!isGameActive || isGamePaused || !mouse.rightDown) return;
            
			//  Eat food instead of placing if selected item is edible
				const selectedItemObject = getSelectedItem();
				const selectedItemType = selectedItemObject ? selectedItemObject.type : null;
                const itemProps = selectedItemObject ? (itemTypes[selectedItemType] || blockTypes[selectedItemType]) : null;
				
				const worldMouseX = mouse.x + camera.x;
				const worldMouseY = mouse.y + camera.y;
				const targetCol = Math.floor(worldMouseX / tileSize);
				const targetRow = Math.floor(worldMouseY / tileSize);
				const targetKey = `${targetCol},${targetRow}`;
				const blockAtTarget = getBlockData(targetCol, targetRow);
				
				// --- NEW: Book Interaction ---
				if (selectedItemObject && itemTypes[selectedItemType]?.isBook) {
					if (blockAtTarget.type === 'item_frame') {
						// This block allows placing the book in an item frame.
						// We let the item frame logic below handle this.
					} else {
						// This is not an item frame, so open the book.
						if (selectedItemObject.published) {
							openBookReader(selectedItemObject);
						} else {
							openBookEditor(selectedHotbarSlot);
						}
						mouse.rightDown = false; // Consume the right-click
						return; // Stop processing
					}
				}
				
				if ( selectedItemObject && selectedItemObject.count > 0 && itemTypes[selectedItemType]?.isFood && blockAtTarget.type !== 'item_frame' ) {
				  const props = itemTypes[selectedItemType];
                  let actualHealAmount = 0;
				  
				  if (selectedItemType === 'chili_pepper') {
					  unlockAchievement('IT_BURNS');
				  }
                  if (selectedItemType === 'human_flesh') {
					  unlockAchievement('IS_THIS_ME');
				  }
                  if (selectedItemType === 'cup_of_urine') {
					  unlockAchievement('ROCK_BOTTOM');
				  }
                  if (selectedItemType === 'cup_of_beer') {
					  unlockAchievement('CHEERS');
				  }
                  if (selectedItemType === 'cup_of_coffee') {
					  insomnia += 1;
                      if (insomnia >= 10) {
    					  unlockAchievement('INSOMNIAC');
    				  }
				  }

				  // 1) If item increases maxHealth, apply it first (so heal can fill the new max)
				  if (typeof props.addsMaxHealth === 'number' && props.addsMaxHealth !== 0) {
					// ensure player.maxHealth exists
					player.maxHealth = (player.maxHealth || 100) + props.addsMaxHealth;
				  }

				  // 2) Apply healing behavior:
				  if (props.fullHeal) {
					// set health to the (possibly new) max
					actualHealAmount = player.maxHealth - player.health;
					player.health = player.maxHealth;
                    if (props.alcoholicPower) {
                        player.bloodAlcohol += props.alcoholicPower;
                        if (player.bloodAlcohol > 100) {
                            unlockAchievement('COOL_IT');
                        }
                    }
                    if (props.effect) {
                          // Add a new effect object to the player's active list
                          player.activeEffects.push({
                              ...props.effect, // Copy all properties from the effect
                              startTime: gameTime // Set the start time
                          });
                    }
                    removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
				  } else {
					const healAmount = props.healAmount || 0;
					if (healAmount > 0) {
						if (player.health < player.maxHealth) {
							const healthBeforeHeal = player.health; // Store old health
							player.health += healAmount;
							if (player.health > player.maxHealth) player.health = player.maxHealth;
                            actualHealAmount = player.health - healthBeforeHeal; // Calculate true amount healed
							// remove one consumed item and stop placement
                            if (props.alcoholicPower) {
                                player.bloodAlcohol += props.alcoholicPower;
                                if (player.bloodAlcohol > 100) {
                                    unlockAchievement('COOL_IT');
                                }
                            }
                            if (props.effect) {
                                  // Add a new effect object to the player's active list
                                  player.activeEffects.push({
                                      ...props.effect, // Copy all properties from the effect
                                      startTime: gameTime // Set the start time
                                  });
                            }
							removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						}
					} else {
						player.health += healAmount;
						if (player.health > player.maxHealth) player.health = player.maxHealth;
						// remove one consumed item and stop placement
                        if (props.alcoholicPower) {
                            player.bloodAlcohol += props.alcoholicPower;
                            if (player.bloodAlcohol > 100) {
                                unlockAchievement('COOL_IT');
                            }
                        }
                        if (props.effect) {
                              // Add a new effect object to the player's active list
                              player.activeEffects.push({
                                  ...props.effect, // Copy all properties from the effect
                                  startTime: gameTime // Set the start time
                              });
                        }
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						if (player.health <= 0) {
							respawnPlayer();
							return;
						}
					}
				  }
				  if (hellfireOn && actualHealAmount > 0 && hellfireLevel < 1.0) {
                      const saturationGain = (actualHealAmount * 0.03); // 3% per HP
                      hellfireLevel += saturationGain;
                      if (hellfireLevel > 1.0) {
                          hellfireLevel = 1.0;
                      }
                  }
				  mouse.rightDown = false;
				  return; // Stop block placement
				}
			const blockProps = blockTypes[blockAtTarget.type];
            if (blockProps && blockProps.anvilPower > 0) {
                toggleAnvilMenu(targetCol, targetRow, blockAtTarget.type, blockProps.anvilPower);
                mouse.rightDown = false;
                return;
            }
			
            // --- FIX 1: Cleaned up the interaction logic into a proper if/else if chain ---
            // Check for chest/bed interaction first
            if (blockAtTarget.type === 'chest' || blockAtTarget.type === 'dead_body_chest' || blockAtTarget.type === 'refrigerator' || blockAtTarget.type === 'magical_chest') {
                toggleChestMenu(targetCol, targetRow);
                mouse.rightDown = false;
                return;
            } else if (blockAtTarget.type === 'void_chest') {
				toggleVoidChestMenu();
				mouse.rightDown = false;
				return;
			} else if (blockAtTarget.type === 'oven' || blockAtTarget.type === 'magma_furnace' || blockAtTarget.type === 'power_forge') {
				toggleFurnaceMenu(targetCol, targetRow, blockAtTarget.type); // Pass the block type
				mouse.rightDown = false;
				return;
			} else if (blockAtTarget.type === 'item_frame') { // The item frame interaction logic is now properly chained.
                const selectedItemObject = getSelectedItem();
                if (selectedItemObject) {
					if (selectedItemType != 'item_frame') {
						worldBlocks[targetKey].item = { 
							type: selectedItemObject.type, 
							count: selectedItemObject.count
						}
                    };
                } else {
                    worldBlocks[targetKey].item = null;
                }
                mouse.rightDown = false;
                return; 
            } else if (blockAtTarget.type === 'world_mover') {
                const selectedItem = getSelectedItem();
                const moverData = worldBlocks[targetKey];

                if (selectedItem && selectedItem.type === 'pure_fuel') {
                    if (!moverData.inventory) {
                        moverData.inventory = new Array(1).fill(null);
                    }
                    const fuelSlot = moverData.inventory[0];
                    if (!fuelSlot) {
                        moverData.inventory[0] = { type: selectedItem.type, count: selectedItem.count };
                        removeItemFromInventory(hotbarIndices[selectedHotbarSlot], selectedItem.count);
                        showMessageBox(`Fueled World Mover with ${moverData.inventory[0].count} Pure Fuel.`, 'alert');
                    } else if (fuelSlot.type === 'pure_fuel' && fuelSlot.count < maxStackSize) {
                        const spaceAvailable = maxStackSize - fuelSlot.count;
                        const amountToAdd = Math.min(selectedItem.count, spaceAvailable);
                        fuelSlot.count += amountToAdd;
                        removeItemFromInventory(hotbarIndices[selectedHotbarSlot], amountToAdd);
                        showMessageBox(`Added ${amountToAdd} Pure Fuel. Total: ${fuelSlot.count}.`, 'alert');
                    } else {
                        showMessageBox(`World Mover fuel tank is full.`, 'alert');
                    }
                } else {
                    toggleWorldMoverMenu(targetCol, targetRow);
                }
                mouse.rightDown = false;
                return;
            } else if (blockAtTarget.type === 'trader') {
                toggleTraderMenu(targetCol, targetRow);
                mouse.rightDown = false;
                return; // <-- ADD THIS LINE
            } else if (blockAtTarget.type === 'bed') {
                player.bedSpawnPoint = { x: (targetCol - 1) * tileSize, y: (targetRow - playerHeightBlocks) * tileSize };
                mouse.rightDown = false;
                showMessageBox("Bed point set! Press the ; key to teleport to bed as long as your health is above 50! It will cost you 10 health points though!", 'alert');
                return;
            } else if (blockAtTarget.type === 'lever_off' || blockAtTarget.type === 'lever_on') {
                // Toggle the lever's state
                const newState = blockAtTarget.type === 'lever_off' ? 'lever_on' : 'lever_off';
                worldBlocks[targetKey].type = newState;

                // Update the network starting from the toggled lever and its neighbors
                scheduleMechUpdate(targetCol, targetRow);
                
                mouse.rightDown = false; // Consume the right-click
                return;
            } else if (blockAtTarget.type === 'chest_lever_off' || blockAtTarget.type === 'chest_lever_on') {
                // Toggle the lever's state
                const newState = blockAtTarget.type === 'chest_lever_off' ? 'chest_lever_on' : 'chest_lever_off';
                worldBlocks[targetKey].type = newState;

                // Update the network starting from the toggled lever and its neighbors
                scheduleMechUpdate(targetCol, targetRow);
                
                mouse.rightDown = false; // Consume the right-click
                return;
            }
			
			if (selectedItemType === 'lighter') {
                const blockToIgnite = getBlockType(targetCol, targetRow);
                const blockBelow = getBlockType(targetCol, targetRow + 1);
    
                // We can light the top of a burnable block OR the side of one
                if (isAxeBlock(blockToIgnite) || (blockAtTarget.type === '' && isAxeBlock(blockBelow))) {
    
                    // If we clicked in the air, but the block below is burnable, place fire in the air block
                    // Otherwise, place it in the block we clicked
                    const fireKey = targetKey; 
                    const blockKey = isAxeBlock(blockToIgnite) ? targetKey : `${targetCol},${targetRow + 1}`;
    
                    if (!fireBlocks[fireKey]) { // Don't light a block that's already on fire
                        fireBlocks[fireKey] = {
                            animFrame: 1,
                            animTimer: 0,
                            burningBlockKey: blockKey // Track which block we are burning
                        };
    
                        // Consume durability
                        if (selectedItemObject.durability !== undefined) {
                            selectedItemObject.durability -= 1;
                            if (selectedItemObject.durability <= 0) {
                                removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
                                updateHotbar();
                            }
                        }
                    }
                }
                mouse.rightDown = false; // Consume the click
                return; // Stop here, don't try to place the lighter
            }

            if (selectedItemObject && selectedItemObject.count > 0) {
                const selectedItemIsPlaceableBlock = selectedItemType && blockTypes[selectedItemType] && blockTypes[selectedItemType].solid;
                const selectedItemIsBed = selectedItemType === 'bed';
				const selectedItemIsTrader = selectedItemType === 'trader';
				const selectedItemIsGrassSeeds = selectedItemType === 'grass_seeds';
				const selectedItemIsMossSeeds = selectedItemType === 'moss_seeds';
                const selectedItemIsPest = selectedItemType === 'pest';
				const selectedItemIsPlaceworthy = selectedItemType === 'cobweb' || selectedItemType.endsWith('_wall') || selectedItemType === 'viking_wood_pole';
                const selectedItemIsSeeds = selectedItemType === 'wheat_seeds' || selectedItemType === 'tomato_seeds' || selectedItemType === 'pumpkin_seeds' || selectedItemType === 'cotton_seeds' || selectedItemType === 'rice_seeds' || selectedItemType === 'hop_seeds' || selectedItemType === 'coffee_seeds' || selectedItemType === 'oat_seeds' || selectedItemType === 'corn_seeds' || selectedItemType === 'barley_seeds' || selectedItemType === 'onion_seeds' || selectedItemType === 'garlic_seeds' || selectedItemType === 'chili_pepper_seeds' || selectedItemType === 'potato_seeds';
                const currentBlockAtTarget = getBlockType(targetCol, targetRow);
                const placementRect = { x: targetCol * tileSize, y: targetRow * tileSize, width: tileSize, height: tileSize };
                const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };
				const itemProps = itemTypes[selectedItemType] || blockTypes[selectedItemType];
                const targetIsWall = currentBlockAtTarget.endsWith('_wall');
                const itemIsWallPlacer = itemProps && itemProps.wallPlace === true;

                if (rectIntersects(placementRect, playerRect)) {
                    mouse.rightDown = false;
                    return;
                }

                if (selectedItemIsBed) {
                    const canPlaceBed = isSolid(targetCol, targetRow + 1) && isSolid(targetCol - 1, targetRow + 1) && isSolid(targetCol + 1, targetRow + 1) &&
                                        getBlockType(targetCol, targetRow) === '' && getBlockType(targetCol - 1, targetRow) === '' && getBlockType(targetCol + 1, targetRow) === '';
                    
                    if (canPlaceBed) {
                        worldBlocks[`${targetCol - 1},${targetRow}`] = { type: 'bed', part: 'left' };
                        worldBlocks[`${targetCol},${targetRow}`] = { type: 'bed', part: 'middle' };
                        worldBlocks[`${targetCol + 1},${targetRow}`] = { type: 'bed', part: 'right' };
                        unlockAchievement('HOME_SWEET_HOME');
                        removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
                    }
				} else if (itemIsWallPlacer && targetIsWall && !blockAtTarget.overlay) {
                    // Place as an overlay
                    worldBlocks[targetKey].overlay = selectedItemType;
                    removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
                    //mouse.rightDown = false; // Consume click
                } else if (selectedItemIsTrader) {
					// try to place a 1x3 vertical trader with bottom at targetRow
					const canPlaceTrader = getBlockType(targetCol, targetRow) === '' &&
										   getBlockType(targetCol, targetRow - 1) === '' &&
										   getBlockType(targetCol, targetRow - 2) === '' &&
										   isSolid(targetCol, targetRow + 1); // require ground beneath bottom

					if (canPlaceTrader) {
						// remove one trader item from inventory and place
						const placed = placeTraderAt(targetCol, targetRow);
						if (placed) removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
					}
				} else if (selectedItemType.endsWith('_flower') || selectedItemType === 'milkweed') {
					let seedUsed = false;
					const blockAtTarget = getBlockData(targetCol, targetRow);
					const blockAboveKey = `${targetCol},${targetRow - 1}`;
					const blockAboveType = getBlockType(targetCol, targetRow - 1);

					// Prevent placing inside the player
					const placementRect = { x: targetCol * tileSize, y: targetRow * tileSize, width: tileSize, height: tileSize };
					const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };
					if (rectIntersects(placementRect, playerRect)) {
						mouse.rightDown = false;
						return;
					}
					
					// Case 1: Target is PROPER
					if (blockAboveType === '') {
						if (blockAtTarget.type === 'grass_dirt' || blockAtTarget.type === 'dark_grass_dirt' || blockAtTarget.type === 'grass_soil' || blockAtTarget.type === 'dark_grass_soil' || blockAtTarget.type === 'mud' || blockAtTarget.type === 'thick_mud' || blockAtTarget.type === 'grass_mud') {
							worldBlocks[blockAboveKey] = { type: selectedItemType, mineProg: 0 };
							seedUsed = true;
						}
					}
					
					// If any action was successful, consume the flowers
					if (seedUsed) {
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						mouse.rightDown = false; // Prevents using multiple flowers in one click
					}
				} else if (selectedItemIsGrassSeeds) {
					let seedUsed = false;
					const blockAtTarget = getBlockData(targetCol, targetRow);
					const blockAboveKey = `${targetCol},${targetRow - 1}`;
					const blockAboveType = getBlockType(targetCol, targetRow - 1);

					// Prevent placing inside the player
					const placementRect = { x: targetCol * tileSize, y: targetRow * tileSize, width: tileSize, height: tileSize };
					const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };
					if (rectIntersects(placementRect, playerRect)) {
						mouse.rightDown = false;
						return;
					}

					// --- RESTRUCTURED LOGIC BEGINS ---

					// Case 1: Target is DIRT
					if (blockAtTarget.type === 'dirt') {
						if (blockAboveType === 'ice') {
							worldBlocks[targetKey] = { type: 'dark_grass_dirt', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: '', mineProg: 0 }; // Remove ice
							seedUsed = true;
						} else if (blockAboveType === 'packed_ice') {
							worldBlocks[targetKey] = { type: 'dark_grass_dirt', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: 'ice', mineProg: 0 }; // Downgrade packed ice
							seedUsed = true;
						} else {
							worldBlocks[targetKey] = { type: 'grass_dirt', mineProg: 0 }; // Default case
							seedUsed = true;
						}
					} 
					// Case 2: Target is SOIL
					else if (blockAtTarget.type === 'soil') {
						if (blockAboveType === 'ice') {
							worldBlocks[targetKey] = { type: 'dark_grass_soil', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: '', mineProg: 0 };
							seedUsed = true;
						} else if (blockAboveType === 'packed_ice') {
							worldBlocks[targetKey] = { type: 'dark_grass_soil', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: 'ice', mineProg: 0 };
							seedUsed = true;
						} else {
							worldBlocks[targetKey] = { type: 'grass_soil', mineProg: 0 };
							seedUsed = true;
						}
					}
					// Case 3: Target is MUD
					else if (blockAtTarget.type === 'mud') {
						worldBlocks[targetKey] = { type: 'grass_mud', mineProg: 0 };
						seedUsed = true;
					}
					// Case 3: Target is SAND and RED SAND
					else if (blockAtTarget.type === 'sand') {
						if (blockAboveType === '') {
							worldBlocks[blockAboveKey] = { type: 'desert_brush', mineProg: 0 };
							seedUsed = true;
						} else if (blockAboveType === 'desert_brush') {
							worldBlocks[blockAboveKey] = { type: 'prickly_pear_cactus', mineProg: 0 };
							seedUsed = true;
						}
					} else if (blockAtTarget.type === 'red_sand_block') {
						if (blockAboveType === '') {
							worldBlocks[blockAboveKey] = { type: 'desert_grass', mineProg: 0 };
							seedUsed = true;
						} if (blockAboveType === 'desert_grass') {
							worldBlocks[blockAboveKey] = { type: 'prickly_pear_cactus', mineProg: 0 };
							seedUsed = true;
						}
					}
					// Case 4: Target is any GRASS DIRT/SOIL variant
					else if (['grass_dirt', 'grass_soil', 'dark_grass_dirt', 'dark_grass_soil'].includes(blockAtTarget.type)) {
						if (blockAboveType === '') {
							worldBlocks[blockAboveKey] = { type: 'grass_sprouts', mineProg: 0 };
							seedUsed = true;
						} else if (blockAboveType === 'grass_sprouts') {
							worldBlocks[blockAboveKey] = { type: 'grass', mineProg: 0 };
							seedUsed = true;
						} else if (blockAboveType === 'grass') {
							worldBlocks[blockAboveKey] = { type: 'tall_grass', mineProg: 0 };
							seedUsed = true;
						} else if (blockAboveType === 'tall_grass' || blockAboveType !== '') { // Make overgrown if tall grass or anything else is on top
							if (blockAtTarget.type === 'grass_dirt') {
								worldBlocks[targetKey] = { type: 'overgrown_grass_dirt', mineProg: 0 };
							} else if (blockAtTarget.type === 'grass_soil') {
								worldBlocks[targetKey] = { type: 'overgrown_grass_soil', mineProg: 0 };
							} else if (blockAtTarget.type === 'dark_grass_dirt') {
								worldBlocks[targetKey] = { type: 'overgrown_dark_grass_dirt', mineProg: 0 };
							} else if (blockAtTarget.type === 'dark_grass_soil') {
								worldBlocks[targetKey] = { type: 'overgrown_dark_grass_soil', mineProg: 0 };
							}
							seedUsed = true;
						}
					}
					// Case 5: Target is GRASS MUD
					else if (blockAtTarget.type === 'grass_mud') {
						if (blockAboveType === '') {
							worldBlocks[blockAboveKey] = { type: 'fern', mineProg: 0 };
						} else {
							worldBlocks[targetKey] = { type: 'overgrown_grass_mud', mineProg: 0 };
						}
						seedUsed = true;
					}

					// If any action was successful, consume the seed
					if (seedUsed) {
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						mouse.rightDown = false; // Prevents using multiple seeds in one click
					}
                } else if (selectedItemIsMossSeeds) {
					let seedUsed = false;
					const blockAtTarget = getBlockData(targetCol, targetRow);
					const blockAboveKey = `${targetCol},${targetRow - 1}`;
					const blockAboveType = getBlockType(targetCol, targetRow - 1);

					// Prevent placing inside the player
					const placementRect = { x: targetCol * tileSize, y: targetRow * tileSize, width: tileSize, height: tileSize };
					const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };
					if (rectIntersects(placementRect, playerRect)) {
						mouse.rightDown = false;
						return;
					}
					
					// Case 1: Target is DIRT
					if (blockAtTarget.type === 'dirt') {
						if (blockAboveType === 'ice') {
							worldBlocks[targetKey] = { type: 'dark_moss_dirt', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: '', mineProg: 0 }; // Remove ice
							seedUsed = true;
						} else if (blockAboveType === 'packed_ice') {
							worldBlocks[targetKey] = { type: 'dark_moss_dirt', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: 'ice', mineProg: 0 }; // Downgrade packed ice
							seedUsed = true;
						} else {
							worldBlocks[targetKey] = { type: 'moss_dirt', mineProg: 0 }; // Default case
							seedUsed = true;
						}
					}
					// Case 2: Target is SOIL
					if (blockAtTarget.type === 'soil') {
						if (blockAboveType === 'ice') {
							worldBlocks[targetKey] = { type: 'dark_moss_soil', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: '', mineProg: 0 }; // Remove ice
							seedUsed = true;
						} else if (blockAboveType === 'packed_ice') {
							worldBlocks[targetKey] = { type: 'dark_moss_soil', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: 'ice', mineProg: 0 }; // Downgrade packed ice
							seedUsed = true;
						} else {
							worldBlocks[targetKey] = { type: 'moss_soil', mineProg: 0 }; // Default case
							seedUsed = true;
						}
					}
					// Case 3: Target is STONE BRICKS
					else if (blockAtTarget.type === 'stone_brick_block') {
						if (blockAboveType === 'ice') {
							worldBlocks[targetKey] = { type: 'dark_moss_stone_brick_block', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: '', mineProg: 0 }; // Remove ice
							seedUsed = true;
						} else if (blockAboveType === 'packed_ice') {
							worldBlocks[targetKey] = { type: 'dark_moss_stone_brick_block', mineProg: 0 };
							worldBlocks[blockAboveKey] = { type: 'ice', mineProg: 0 }; // Downgrade packed ice
							seedUsed = true;
						} else {
							worldBlocks[targetKey] = { type: 'moss_stone_brick_block', mineProg: 0 }; // Default case
							seedUsed = true;
						}
					}
					// Case 4: Target is any MOSS DIRT/SOIL variant
					else if (['moss_dirt', 'moss_soil', 'dark_moss_dirt', 'dark_moss_soil'].includes(blockAtTarget.type)) {
						if (blockAboveType === '') {
							if (blockAtTarget.type === 'moss_dirt' || blockAtTarget.type === 'moss_soil') {
								worldBlocks[blockAboveKey] = { type: 'moss', mineProg: 0 };
								seedUsed = true;
							} else if (blockAtTarget.type === 'dark_moss_dirt' || blockAtTarget.type === 'dark_moss_soil') {
								worldBlocks[blockAboveKey] = { type: 'dark_moss', mineProg: 0 };
								seedUsed = true;
							}
						}
					}
					// Case 5: Target is GRASS DIRT
					if (blockAtTarget.type === 'grass_dirt') {
						if (blockAboveType === '') {
							worldBlocks[blockAboveKey] = { type: 'leaf_plant', mineProg: 0 };
							seedUsed = true;
						}
					}
					
					// If any action was successful, consume the seed
					if (seedUsed) {
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						mouse.rightDown = false; // Prevents using multiple seeds in one click
					}
				} else if (selectedItemIsPest) {
					let seedUsed = false;
					const blockAtTarget = getBlockData(targetCol, targetRow);
					const blockAboveKey = `${targetCol},${targetRow - 1}`;
					const blockAboveType = getBlockType(targetCol, targetRow - 1);

					// Prevent placing inside the player
					const placementRect = { x: targetCol * tileSize, y: targetRow * tileSize, width: tileSize, height: tileSize };
					const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };
					if (rectIntersects(placementRect, playerRect)) {
						mouse.rightDown = false;
						return;
					}
					
					// Case 1: Target is GRASS DIRT
					if (blockAtTarget.type === 'grass_dirt') {
						worldBlocks[targetKey] = { type: 'weed_dirt', mineProg: 0 };
						seedUsed = true;
					}

                    // Case 2: Target is WEED DIRT
                    else if (blockAtTarget.type === 'weed_dirt') {
						if (blockAboveType === '') {
							worldBlocks[blockAboveKey] = { type: 'weed', mineProg: 0 };
							seedUsed = true;
						}
					}

                    // Case 3: Target is SOIL
					else if (blockAtTarget.type === 'soil') {
						worldBlocks[targetKey] = { type: 'pest_dirt', mineProg: 0 };
						seedUsed = true;
					}

                    // Case 4: Target is STONES
					else if (blockAtTarget.type === 'stone') {
						worldBlocks[targetKey] = { type: 'pest_stone_block_weak', mineProg: 0 };
						seedUsed = true;
					} else if (blockAtTarget.type === 'pest_stone_block_weak') {
                        if (blockAboveType === 'pest_stone_block_weak') {
						    worldBlocks[targetKey] = { type: 'pest_stone_block_strong', mineProg: 0 };
                            worldBlocks[blockAboveKey] = { type: '', mineProg: 0 };
						    seedUsed = true;
                        }
					}
					
					// If any action was successful, consume the pest
					if (seedUsed) {
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						mouse.rightDown = false; // Prevents using multiple pest in one click
					}
				} else if (selectedItemIsPlaceworthy) {
					let seedUsed = false;
					const blockAtTarget = getBlockData(targetCol, targetRow);
					const blockAboveKey = `${targetCol},${targetRow - 1}`;
					const blockAboveType = getBlockType(targetCol, targetRow - 1);

					// Prevent placing inside the player
					const placementRect = { x: targetCol * tileSize, y: targetRow * tileSize, width: tileSize, height: tileSize };
					const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };
					if (rectIntersects(placementRect, playerRect)) {
						mouse.rightDown = false;
						return;
					}
					
                    // CASE 1: Place The Selected In Sky
					else if (blockAtTarget.type === '') {
						worldBlocks[targetKey] = { type: selectedItemType, mineProg: 0 };
						seedUsed = true;
					}
					
					// If any action was successful, consume the cobweb
					if (seedUsed) {
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
					}
				} else if (selectedItemIsSeeds) {
                    if (['dirt', 'soil', 'fertilizer'].includes(currentBlockAtTarget)) {
                        if (currentBlockAtTarget === 'fertilizer') {
							unlockAchievement('FRANTIC_FARMER');
						}
						worldBlocks[targetKey] = { type: `planted_${selectedItemType}`, mineProg: 0, plantTime: gameTime, baseBlockType: currentBlockAtTarget };
                        activePlants.add(targetKey);
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
                    }
                } else if (selectedItemIsPlaceableBlock) {
                        if (replaceableBlocks.includes(currentBlockAtTarget)) {
                        if (currentBlockAtTarget !== '') {
                            const replacedBlockProps = blockTypes[currentBlockAtTarget];
                            handleMiningDrops(replacedBlockProps, targetKey);
                        }
                        
						delete exploredMap[targetKey];
						
                        // --- FIX 2: Corrected the block initialization logic ---
                        if (selectedItemType === 'chest') {
							worldBlocks[targetKey] = { type: selectedItemType, mineProg: 0, inventory: new Array(chestInventorySize).fill(null), label: '' };
						} else if (selectedItemType === 'refrigerator') {
							worldBlocks[targetKey] = { type: selectedItemType, mineProg: 0, inventory: new Array(18).fill(null), label: '' };
						} else if (selectedItemType === 'magical_chest') {
							worldBlocks[targetKey] = { type: selectedItemType, mineProg: 0, inventory: new Array(50).fill(null), label: '' };
						} else if (selectedItemType === 'oven' || selectedItemType === 'magma_furnace' || selectedItemType === 'power_forge') {
							worldBlocks[targetKey] = { type: selectedItemType, mineProg: 0, inventory: new Array(12).fill(null) };
						} else if (selectedItemType === 'item_frame') { // The item frame is now correctly placed as an 'else if'.
                            worldBlocks[targetKey] = { 
                                type: selectedItemType, 
                                mineProg: 0, 
                                item: null // Initialize with no item
                            };
                        } else {
							worldBlocks[targetKey] = { type: selectedItemType, mineProg: 0 };
                            // After a block has been placed in handleBlockPlacement...
                            const placedType = selectedItemType;
                            const neighbors = [
                                { col: targetCol, row: targetRow - 1 }, // Above
                                { col: targetCol, row: targetRow + 1 }, // Below
                                { col: targetCol - 1, row: targetRow }, // Left
                                { col: targetCol + 1, row: targetRow }  // Right
                            ];
                            
                            for (const neighbor of neighbors) {
                                const neighborType = getBlockType(neighbor.col, neighbor.row);
                                const neighborKey = `${neighbor.col},${neighbor.row}`;
                            
                                // Case 1: Placed Magma next to Ice
                                if (placedType === 'ice' && neighborType === 'magma_stone_block') {
                                    worldBlocks[neighborKey] = { type: 'obsidian_block', mineProg: 0 };
                                }
                            
                                // Case 2: Placed Ice next to Magma
                                if (placedType === 'magma_stone_block' && neighborType === 'ice') {
                                    // The block we just placed is the one that transforms
                                    worldBlocks[targetKey] = { type: 'obsidian_block', mineProg: 0 };
                                    break; // Stop checking other neighbors since this block already changed
                                }

                                // Case 1: Placed Magma next to Packed Ice
                                if (placedType === 'packed_ice' && neighborType === 'magma_stone_block') {
                                    worldBlocks[neighborKey] = { type: 'obsidian_block', mineProg: 0 };
                                }
                            
                                // Case 2: Placed Packed Ice next to Magma
                                if (placedType === 'magma_stone_block' && neighborType === 'packed_ice') {
                                    // The block we just placed is the one that transforms
                                    worldBlocks[targetKey] = { type: 'obsidian_block', mineProg: 0 };
                                    break; // Stop checking other neighbors since this block already changed
                                }
                            }
						}
                        
						const mechageezerComponents = ['lever_off', 'lever_on', 'chest_lever_off', 'chest_lever_on', 'reactant', 'trailer', 'lit_trailer', 'stone_trailer'];
                        if (mechageezerComponents.includes(selectedItemType)) {
                            // Schedule an update for the newly placed block itself and its neighbors
                            // This ensures the entire connected component re-evaluates its power state.
                            scheduleMechUpdate(targetCol, targetRow);
                            
                            // Also check its direct neighbors to trigger updates from adjacent networks
                            const neighbors = [
                                { col: targetCol, row: targetRow - 1 }, // Above
                                { col: targetCol, row: targetRow + 1 }, // Below
                                { col: targetCol - 1, row: targetRow }, // Left
                                { col: targetCol + 1, row: targetRow }  // Right
                            ];
                            for (const n of neighbors) {
                                if (mechageezerComponents.includes(getBlockType(n.col, n.row))) {
                                    scheduleMechUpdate(n.col, n.row);
                                }
                            }
                        }
						
                        // --- FIX 3: This now correctly removes ALL placed blocks from inventory ---
                        removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
                        
                        if (selectedItemType === 'heaven_gate_brick_block') {
                            checkAndCreateHeavenPortal(targetCol, targetRow);
                        }
                    }
                }
            }
        }

		// ----------------- Per-item spoilage helpers -----------------
		function _ensureAcquiredTimes(slot, now) {
			// Convert legacy acquiredTime or create the array to match slot.count.
			if (!slot) return;
			now = now ?? gameTime;
			if (!Array.isArray(slot.acquiredTimes)) {
				if (slot.acquiredTime !== undefined) {
					slot.acquiredTimes = Array(slot.count || 0).fill(slot.acquiredTime);
					delete slot.acquiredTime;
				} else {
					slot.acquiredTimes = Array(slot.count || 0).fill(now);
				}
			} else {
				// keep length matching count (trim oldest if too many, fill with now if too few)
				while (slot.acquiredTimes.length < (slot.count || 0)) slot.acquiredTimes.push(now);
				while (slot.acquiredTimes.length > (slot.count || 0)) slot.acquiredTimes.shift();
			}
		}

		function _takeTimestamps(slot, takeCount) {
			// Remove 'takeCount' timestamps from the *oldest* side (FIFO), return them.
			// If slot has no timestamps, returns an array of gameTime values for fallback.
			if (!slot) return [];
			if (!Array.isArray(slot.acquiredTimes)) {
				// fallback - create an array with current gameTime for each removed
				const now = gameTime;
				slot.acquiredTimes = Array(slot.count || 0).fill(now);
			}
			const taken = slot.acquiredTimes.splice(0, takeCount);
			// If it returned fewer than requested (shouldn't happen if counts sync), pad
			while (taken.length < takeCount) taken.push(gameTime);
			return taken;
		}

		function _pushTimestampsIntoSlot(slot, timestamps) {
			if (!slot) return;
			if (!Array.isArray(slot.acquiredTimes)) slot.acquiredTimes = [];
			slot.acquiredTimes.push(...timestamps);
			// maintain length = count (caller should have updated slot.count)
			while (slot.acquiredTimes.length > slot.count) slot.acquiredTimes.shift();
		}

        function addToInventory(itemType, count = 1, durability = null, acquiredTimes = null, inventory = inventorySlots) {
			// Adds to the given inventory array (defaults to player inventory).
			// acquiredTimes: optional array (length == count) to transfer timestamps (useful when moving items between containers)
			if (!itemTypes[itemType] && !blockTypes[itemType]) {
				console.warn(`Attempted to add unknown item type: ${itemType}`);
				return false;
			}
			const itemProps = itemTypes[itemType] || blockTypes[itemType];
			let remaining = count;
			const now = gameTime;

			// helper to take some timestamps out of acquiredTimes param
			function takeFromParam(n) {
				if (!acquiredTimes) return Array(n).fill(now);
				return acquiredTimes.splice(0, n).concat(Array(Math.max(0, n - (acquiredTimes ? acquiredTimes.length : 0))).fill(now));
			}

			if (itemProps?.isTool) {
				// Tools don't stack: place individually
				for (let i = 0; i < inventory.length && remaining > 0; i++) {
					if (!inventory[i]) {
						inventory[i] = { type: itemType, count: 1, durability: durability ?? itemProps.maxDurability, maxDurability: itemProps.maxDurability };
						
						// --- THIS IS THE FIX ---
						// If the empty slot is on the hotbar, link it.
						if (i < hotbarSize && hotbarIndices[i] === null) {
							hotbarIndices[i] = i;
						}
						// --- END OF FIX ---

						remaining--;
					}
				}
			} else {
				// First fill existing stacks (for non-tools)
				for (let i = 0; i < inventory.length && remaining > 0; i++) {
					const slot = inventory[i];
					if (slot && slot.type === itemType && slot.count < maxStackSize) {
						const amountToAdd = Math.min(remaining, maxStackSize - slot.count);
						const timestamps = takeFromParam(amountToAdd);
						slot.count += amountToAdd;
						if (itemProps?.spoilable) {
							if (!Array.isArray(slot.acquiredTimes)) _ensureAcquiredTimes(slot, now);
							_pushTimestampsIntoSlot(slot, timestamps);
						}
						remaining -= amountToAdd;
					}
				}
				// Then create new stacks into empty slots
				for (let i = 0; i < inventory.length && remaining > 0; i++) {
					if (!inventory[i]) {
						const amountForNewStack = Math.min(remaining, maxStackSize);
						const timestamps = takeFromParam(amountForNewStack);
						inventory[i] = { type: itemType, count: amountForNewStack };
						if (itemProps?.isTool) {
							inventory[i].durability = durability ?? itemProps.maxDurability;
							inventory[i].maxDurability = itemProps.maxDurability;
						} else if (itemProps?.spoilable) {
							inventory[i].acquiredTimes = timestamps.slice(); // array of timestamps per unit
						}
						// This logic was already correct for stackable items
						if (i < hotbarSize && hotbarIndices[i] === null) {
							hotbarIndices[i] = i;
						}
						remaining -= amountForNewStack;
					}
				}
			}

			updateHotbar();
			if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
			if (chestOverlay.style.display === 'flex') updateChestMenu();

			if (remaining > 0) {
				// If items are leftover, send them to the void instead of destroying them.
				addToVoidStorage(itemType, remaining, durability, itemProps?.maxDurability);
			}
			return true; // Always return true because the item is never truly lost now.
		}
		
		function animateVoidCharacter() {
			if (!isVoidChestOpen) return; // Stop animation when menu is closed

			const character = document.getElementById('voidCharacter');
			voidCharacterBob += 0.05 * voidCharacterBobDirection;

			if (Math.abs(voidCharacterBob) > 2) { // Bob up and down by 2 pixels
				voidCharacterBobDirection *= -1;
			}

			character.style.transform = `translateY(${voidCharacterBob}px)`;

			requestAnimationFrame(animateVoidCharacter);
		}

		function generateVoidTradeOffer() {
			if (voidStorage.length === 0) {
				currentVoidTrade = null;
				return;
			}

			// 1. Pick a random item from the void
			const itemToOffer = voidStorage[Math.floor(random() * voidStorage.length)];
			const itemProps = itemTypes[itemToOffer.type] || blockTypes[itemToOffer.type];

			// 2. Determine quantity
			let offerCount = 1;
			if (!itemProps.isTool) {
				offerCount = 1 + Math.floor(random() * 30); // 1-30
				if (offerCount > itemToOffer.count) {
					offerCount = itemToOffer.count; // Cap at available amount
				}
			}

			// 3. Determine price
			const costPerItem = 1 + Math.floor(random() * 5); // 1-5
			const coinType = random() < 0.5 ? 'bronze_coin' : 'gold_coin';

			currentVoidTrade = {
				itemType: itemToOffer.type,
				count: offerCount,
				costPerItem: costPerItem,
				coinType: coinType,
				durability: itemToOffer.durability,
				maxDurability: itemToOffer.maxDurability
			};
		}

		function updateVoidTradeOfferUI() {
			const characterContainer = document.getElementById('voidCharacterContainer');
			const tradeOfferBubble = document.getElementById('voidTradeOffer'); // Get the bubble itself
			const dialogueText = document.getElementById('voidDialogue');

			// Always ensure the main container is visible when this function is called
			characterContainer.style.display = 'flex';

			if (!currentVoidTrade) {
				// If there's no trade, hide only the bubble and change the text
				tradeOfferBubble.style.display = 'none';
				dialogueText.textContent = "The void is quiet... for now.";
				return;
			}
			
			// If there is a trade, show the bubble and set the correct text
			tradeOfferBubble.style.display = 'flex';
			dialogueText.textContent = "Care to make a deal for what's been lost?";

			// Update Item Display
			const offerItemSlot = document.getElementById('voidOfferItem');
			offerItemSlot.innerHTML = '';
			const itemSlotContent = createInventorySlot({ type: currentVoidTrade.itemType, count: currentVoidTrade.count, durability: currentVoidTrade.durability, maxDurability: currentVoidTrade.maxDurability }, -1, 'trade');
			offerItemSlot.appendChild(itemSlotContent);

			// Update Cost Display
			const offerCostDiv = document.getElementById('voidOfferCost');
			const totalCost = currentVoidTrade.costPerItem * currentVoidTrade.count;
			const coinImgSrc = assets[currentVoidTrade.coinType]?.src || '';
			offerCostDiv.innerHTML = `<span>Cost: ${totalCost}</span> <img src="${coinImgSrc}" alt="${currentVoidTrade.coinType}">`;
			//<script>
			// Check if player can afford and update Accept button
			const acceptButton = document.getElementById('voidAcceptButton');
			let playerCoinCount = 0;
			inventorySlots.forEach(item => {
				if (item && item.type === currentVoidTrade.coinType) {
					playerCoinCount += item.count;
				}
			});

			acceptButton.disabled = playerCoinCount < totalCost;
		}
		
		function addToVoidStorage(itemType, count, durability = null, maxDurability = null) {
			if (!itemType || count <= 0) return;

			// Check if this item type is new to the void
			const isNewItemType = !voidStorage.some(item => item && item.type === itemType);

			const itemProps = itemTypes[itemType] || blockTypes[itemType];
			if (itemProps && itemProps.isTool) {
				for (let i = 0; i < count; i++) {
					voidStorage.push({
						type: itemType,
						count: 1,
						durability: durability ?? itemProps.maxDurability,
						maxDurability: maxDurability ?? itemProps.maxDurability
					});
				}
			} else {
				let existingStack = voidStorage.find(item => item && item.type === itemType);
				if (existingStack) {
					existingStack.count += count;
				} else {
					voidStorage.push({ type: itemType, count: count });
				}
			}
			if (itemType === 'gold_coin') {
				if (count >= 5) {
					generateVoidTradeOffer()
				}
			} else if (itemType === 'bronze_coin') {
				if (count >= 10) {
					generateVoidTradeOffer()
				}
			}

			// If a new item was added and a trade isn't active, 20% chance to generate one
			if (isNewItemType && random() < 0.2) {
				generateVoidTradeOffer();
			}
		}
		
		

        function removeItemFromInventory(slotIndex, count = 1, inventory = inventorySlots) {
			if (slotIndex === null || slotIndex === undefined || !inventory[slotIndex]) {
				console.warn(`Attempted to remove item from empty or invalid slot: ${slotIndex}`);
				return;
			}
			const itemInSlot = inventory[slotIndex];
			const toRemove = Math.min(count, itemInSlot.count);
			// if spoilable and has acquiredTimes, remove their timestamps (oldest first)
			if (itemTypes[itemInSlot.type]?.spoilable && Array.isArray(itemInSlot.acquiredTimes)) {
				itemInSlot.acquiredTimes.splice(0, toRemove);
			}
			itemInSlot.count -= toRemove;
			if (itemInSlot.count <= 0) {
				inventory[slotIndex] = null;
				const hotbarIdx = hotbarIndices.indexOf(slotIndex);
				if (hotbarIdx !== -1) hotbarIndices[hotbarIdx] = null;
			}
			updateHotbar();
			if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
			if (chestOverlay.style.display === 'flex') updateChestMenu();
		}

        function getSelectedItem() {
            const hotbarSlotIndex = hotbarIndices[selectedHotbarSlot];
            return (hotbarSlotIndex !== null && hotbarSlotIndex !== undefined) ? inventorySlots[hotbarSlotIndex] : null;
        }
		
		function tp(XPOS, YPOS) {
			player.y = -YPOS * tileSize;
			player.x = XPOS * tileSize
		}

        function updateHotbar() {
            hotbarDiv.innerHTML = '';
            for (let i = 0; i < hotbarSize; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.classList.add('hotbar-slot');
                if (i === selectedHotbarSlot) slotDiv.classList.add('selected');
                
                // === NEW: Add touch listener for hotbar switching ===
                slotDiv.addEventListener('touchstart', (e) => {
                    if (isGamePaused) return; // Don't switch if in a menu
                    e.preventDefault();
                    e.stopPropagation();
                    selectedHotbarSlot = i;
                    updateHotbar(); // Redraw to show new selection
                    showHotbarSwitchTooltip(getSelectedItem()); // Show name
                }, { passive: false });
                // === END NEW ===

                const inventorySlotIndex = hotbarIndices[i];
                const itemObject = (inventorySlotIndex !== null && inventorySlotIndex !== undefined) ? inventorySlots[inventorySlotIndex] : null;

                if (itemObject) {
                    const itemProps = itemTypes[itemObject.type] || blockTypes[itemObject.type];
                    const itemImg = assets[itemObject.type];
                    if (itemImg && !failedAssets[itemObject.type]) {
                        const imgElement = document.createElement('img');
                        imgElement.src = itemImg.src;
                        slotDiv.appendChild(imgElement);
                    } else if (itemProps?.color) {
                        const fallbackDiv = document.createElement('div');
                        fallbackDiv.classList.add('fallback');
                        fallbackDiv.style.backgroundColor = itemProps.color;
                        fallbackDiv.textContent = itemObject.type.substring(0, 3).toUpperCase();
                        slotDiv.appendChild(fallbackDiv);
                    }
                    const countSpan = document.createElement('span');
                    countSpan.textContent = itemObject.count;
                    slotDiv.appendChild(countSpan);

                    if (itemProps?.isTool && itemObject.durability !== null && itemObject.durability !== undefined) {
                        const durabilityBar = document.createElement('div');
                        durabilityBar.classList.add('durability-bar');
                        const durabilityFill = document.createElement('div');
                        durabilityFill.classList.add('durability-fill');
                        const durabilityRatio = itemObject.durability / itemObject.maxDurability;
                        durabilityFill.style.width = `${Math.max(0, durabilityRatio * 100)}%`;
                        durabilityFill.style.backgroundColor = durabilityRatio > 0.6 ? '#28a745' : (durabilityRatio > 0.3 ? '#ffc107' : '#dc3545');
                        durabilityBar.appendChild(durabilityFill);
                        slotDiv.appendChild(durabilityBar);
                    }
                }
                hotbarDiv.appendChild(slotDiv);
            }

		   const selectedToolObject = getSelectedItem();
            const selectedToolProps = selectedToolObject ? itemTypes[selectedToolObject.type] : null;
        }

        // New function to pre-generate chunks off-screen
        function generateOffscreenChunks() {
            const playerCol = Math.floor((player.x + playerWidth / 2) / tileSize);
            const playerRow = Math.floor((player.y + playerHeight / 2) / tileSize);
            
            const viewWidthInTiles = Math.ceil(canvas.width / tileSize);
            const viewHeightInTiles = Math.ceil(canvas.height / tileSize);

            const startCol = playerCol - Math.floor(viewWidthInTiles / 2) - generationBuffer;
            const endCol = playerCol + Math.ceil(viewWidthInTiles / 2) + generationBuffer;
            const startRow = playerRow - Math.floor(viewHeightInTiles / 2) - generationBuffer;
            const endRow = playerRow + Math.ceil(viewHeightInTiles / 2) + generationBuffer;

            for (let col = startCol; col < endCol; col++) {
                // Generate deeper to ensure caves/ores are ready
                for (let row = startRow; row < endRow + 50; row++) {
                    getBlockData(col, row); // This function already prevents re-generation
                }
            }
        }

        function drawWorld() {
            // Background color change based on depth
            const playerGridY = Math.floor(player.y / tileSize);
            
            if (playerGridY < -100000) { // Super Heaven
                document.body.style.backgroundColor = '#ff8700';
            } 
            else if (playerGridY < -265) { // Space biome starts at y = -245
                document.body.style.backgroundColor = '#000000';
            } else if (playerGridY < -145) { // Heaven
                document.body.style.backgroundColor = '#d8d043';
            } else if (playerGridY > 605) { // Underworld
                document.body.style.backgroundColor = '#000000';
			} else if (playerGridY > 205) { // Underworld
                document.body.style.backgroundColor = '#4d0f0f';
            } else if (playerGridY > 20) { // Compacted Stone
                document.body.style.backgroundColor = '#2e2e2e';
            } else if (playerGridY > 10) { // Stone
                document.body.style.backgroundColor = '#4e626d';
            } else { // Surface / Sky
                document.body.style.backgroundColor = '#d8fffe';
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const startCol = Math.floor(camera.x / tileSize) - 1;
            const endCol = Math.ceil((camera.x + canvas.width) / tileSize) + 1;
            const startRow = Math.floor(camera.y / tileSize) - 1;
            const endRow = Math.ceil((camera.y + canvas.height) / tileSize) + 1;

            for (let col = startCol; col < endCol; col++) {
                for (let row = startRow; row < endRow; row++) {
                    const key = `${col},${row}`;
					const blockData = worldBlocks[key];
					if (!blockData || blockData.type === '') continue; // skip empty/air tiles
                    let blockType = blockData.type;
                    let blockProps = blockTypes[blockType];
                    const screenX = col * tileSize - camera.x;
                    const screenY = row * tileSize - camera.y;

                    if (blockData.type.startsWith('planted_')) {
                        const seedType = blockData.type.replace('planted_', '').replace('_seeds', '');
                        blockType = `${seedType}_${blockData.baseBlockType}`;
                        blockProps = blockTypes[blockType];
                    }

                    if (blockType !== '' && blockProps) {
                        // --- NEW: Cloaking Logic ---
                        // Determine what to display. If cloaked, use the cloaked type, otherwise use the real type.
						if (cloakingEnabled === true) {
							displayType = blockData.cloakedAs || blockType;
							// displayType = 'dirt'; // Fun To Mess With
						} else {
							displayType = blockType;
						}
                        const displayProps = blockTypes[displayType] || blockProps; // Get props for the display type
                        const blockImg = assets[displayType]; // Use the displayType's image
                        // --- END NEW ---
                    
                        if (blockImg && !failedAssets[displayType]) { // <-- This line was modified
                            // Special drawing for beds (3 blocks wide)
                            if (blockType === 'trader' && blockData.part === 'bottom') {
								// draw trader as 1 column wide, 3 rows tall - draw from bottom up so y shifts up 2 tiles
								ctx.drawImage(blockImg, screenX, screenY - tileSize*2, tileSize, tileSize*3);
							} else if (blockType === 'bed' && blockData.part === 'left') {
                                ctx.drawImage(blockImg, screenX, screenY, tileSize * 3, tileSize);
                            } else if (blockType !== 'bed') { // Draw normal blocks
                                ctx.drawImage(blockImg, screenX, screenY, tileSize, tileSize);
                            }
                        } else if (displayProps && displayProps.color) { // <-- This line was modified
                             ctx.fillStyle = displayProps.color; // <-- This line was modified
                             ctx.fillRect(screenX, screenY, tileSize, tileSize);
                        }
                        // --- NEW: Draw Overlay ---
                        if (blockData.overlay) {
                            const overlayImg = assets[blockData.overlay];
                            const overlayProps = blockTypes[blockData.overlay];
                            if (overlayImg && !failedAssets[blockData.overlay]) {
                                ctx.drawImage(overlayImg, screenX, screenY, tileSize, tileSize);
                            } else if (overlayProps && overlayProps.color) {
                                ctx.fillStyle = overlayProps.color;
                                ctx.fillRect(screenX, screenY, tileSize, tileSize);
                            }
                        }
						// If the block is an item frame and has an item, draw the item
                        if (blockType === 'item_frame' && blockData.item) {
                            const itemToDraw = assets[blockData.item.type];
                            if (itemToDraw) {
                                // Calculate size and position for the item
                                const itemSize = tileSize * 0.80; // 80% of the block size
                                const itemOffset = (tileSize - itemSize) / 2; // Center it
                                
                                const itemX = screenX + itemOffset;
                                const itemY = screenY + itemOffset;

                                ctx.drawImage(itemToDraw, itemX, itemY, itemSize, itemSize);
                            }
                        }
                        if (maintainBlockDurability && blockData.mineProg > 0) {
                            let effectiveMiningHardness = blockTypes[blockData.type].miningHardness;
                            // ... (rest of the durability drawing logic, no changes needed here)
                            const progressRatio = blockData.mineProg / effectiveMiningHardness;
                            let overlayImage = null;
                            if (progressRatio >= 0.75) overlayImage = assets['breaking_stage_3'];
                            else if (progressRatio >= 0.50) overlayImage = assets['breaking_stage_2'];
                            else if (progressRatio >= 0.25) overlayImage = assets['breaking_stage_1'];
                            if (overlayImage) ctx.drawImage(overlayImage, screenX, screenY, tileSize, tileSize);
                        }
                    }
                }
            }
        }
		
		function drawAnimatedDrops() {
			if (animatedDrops.length === 0) return;

			for (const drop of animatedDrops) {
				if (drop.img && !failedAssets[drop.type]) {
					const drawSize = tileSize * 0.5; // Draw items smaller
					ctx.drawImage(
						drop.img,
						drop.x - (drawSize / 2) - camera.x,
						drop.y - (drawSize / 2) - camera.y,
						drawSize,
						drawSize
					);
				}
			}
		}
		
		function drawParticles() {
			for (let i = 0; i < particles.length; i++) {
				const p = particles[i];

				// Calculate opacity for the fade-out effect.
				const opacity = p.life / p.maxLife;
				ctx.globalAlpha = Math.max(0, opacity); // Ensure alpha doesn't go below 0

				// This is the powerful 9-argument version of drawImage:
				// ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
				// It lets us clip a piece from the source image (s) and draw it to the destination canvas (d).
				ctx.drawImage(
					p.img,
					p.sourceX,           // sx: The x-coord of the top-left corner of our sub-rectangle in the source image.
					p.sourceY,           // sy: The y-coord of the top-left corner.
					p.sourceSize,        // sWidth: The width of our sub-rectangle.
					p.sourceSize,        // sHeight: The height of our sub-rectangle.
					p.x - camera.x,      // dx: The x-coord on the canvas to draw the particle.
					p.y - camera.y,      // dy: The y-coord on the canvas.
					p.drawSize,          // dWidth: The width to draw the particle on the canvas.
					p.drawSize           // dHeight: The height to draw the particle.
				);
			}

			// IMPORTANT: Reset globalAlpha so it doesn't affect other drawing operations.
			ctx.globalAlpha = 1.0;
		}
		
		function createHealthParticles(type, amount) {
            // 1. Find the health bar's position on the screen
            const healthBarRect = healthBarDiv.getBoundingClientRect();
            if (!healthBarRect) return;

            // 2. Convert screen position to world coordinates for the particle system
            const particleOriginX = healthBarRect.left + camera.x + (healthBarRect.width / 2);
            const particleOriginY = healthBarRect.top + camera.y + (healthBarRect.height / 2);

            // 3. Choose which heart image to use for the particle
            let particleImg;
            if (type === 'heal') {
                particleImg = assets['full_heart'];
            } else { // 'damage'
                particleImg = assets['half_heart']; 
            }
            if (!particleImg) return; // Asset not loaded

            // 4. Determine how many particles to burst (more damage/heal = more particles)
            const numParticles = Math.max(1, Math.min(20, Math.ceil(amount / 2)));

            for (let i = 0; i < numParticles; i++) {
                const particle = {
                    // Start at the center of the health bar
                    x: particleOriginX + (Math.random() - 0.5) * healthBarRect.width,
                    y: particleOriginY,
                    
                    // Random outward "burst" velocity
                    dx: (Math.random() - 0.5) * 9, // Horizontal speed from -4.5 to 4.5
                    dy: (Math.random() * -7) - 2,     // Vertical speed from -2 to -9 (always up)
                    
                    // Lifespan: 0.7 to 1.2 seconds
                    life: 700 + Math.random() * 500, 
                    maxLife: 0,
                    
                    // Use the full heart image as the particle texture
                    img: particleImg,
                    sourceX: 0,
                    sourceY: 0,
                    sourceSize: particleImg.width, // Use the full image

                    // Draw the particle as a small, spinning heart
                    drawSize: 8 + Math.random() * 8 
                };
                particle.maxLife = particle.life; // Store initial life for fading
                particles.push(particle);
            }
        }
		
		function drawHeldItem() {
			const heldItem = getSelectedItem();
			if (!heldItem) {
				return; // Don't draw anything if the player is holding nothing
			}

			const itemImg = assets[heldItem.type];
			if (!itemImg || failedAssets[heldItem.type]) {
				return; // Can't draw if the image didn't load
			}

			// --- Calculate Position ---
			// Base position relative to the player's center. This is our pivot point.
			let pivotX = player.x - camera.x + playerWidth / 2;
			let pivotY = player.y - camera.y + playerHeight / 2.5; // Changed for closer centering
            
			ctx.save(); // Save the current state of the canvas (important!)

			// 1. Move the canvas origin to our pivot point
			ctx.translate(pivotX, pivotY);

            // --- NEW GUN AIMING LOGIC ---
            const itemProps = itemTypes[heldItem.type] || blockTypes[heldItem.type];
            if (itemProps && itemProps.isGun) {
                // For guns:
                // 1. Rotate the canvas to the absolute gun angle
                ctx.rotate(heldItemState.angle); // This is already set to gunAngle by updateHeldItemAnimation

                // 2. Check if we are aiming left (angle is > 90 or < -90)
                const isAimingLeft = Math.abs(heldItemState.angle) > (Math.PI / 2);
                if (isAimingLeft) {
                    // Flip the sprite vertically (which mirrors it horizontally after rotation)
                    ctx.scale(1, -1);
                }
            } else {
                // For all other tools:
                // 1. Flip based on player direction
			    ctx.scale(player.facingDirection, 1);
                // 2. Rotate by the swing animation angle
			    ctx.rotate(heldItemState.angle);
            }
            // --- END NEW LOGIC ---

			// 4. Draw the item image.
			// We draw it relative to the new, transformed origin.
			// The offsets from our animation state are applied here.
			ctx.drawImage(
				itemImg, 
				10 + heldItemState.offsetX,  // Base distance from player + animation offset
				-5 + heldItemState.offsetY, // Base height + animation offset
				tileSize * 0.8, // Make the item slightly smaller than a full block
				tileSize * 0.8
			);

			ctx.restore(); // Restore the canvas to its original state for the next draw operations
		}

        function drawmineProg() {
            if (miningTarget) {
                const progressRatio = miningTarget.progress / miningTarget.requiredProgress;
                const screenX = miningTarget.col * tileSize - camera.x;
                const screenY = miningTarget.row * tileSize - camera.y;
                let overlayImage = null;
                if (progressRatio >= 0.75) overlayImage = assets['breaking_stage_3'];
                else if (progressRatio >= 0.50) overlayImage = assets['breaking_stage_2'];
                else if (progressRatio >= 0.25) overlayImage = assets['breaking_stage_1'];
                if (overlayImage) ctx.drawImage(overlayImage, screenX, screenY, tileSize, tileSize);
            }
        }

        function drawHealth() {
            // 1. Clear previous effect classes
            healthBarDiv.classList.remove('glow-yellow', 'flash-red', 'glow-green');

            // 2. Check for health changes and apply effects + particles
            if (player.health > player.lastHealth) {
                // HEAL: Apply green glow and create healing particles
                healthBarDiv.classList.add('glow-green');
                createHealthParticles('heal', player.health - player.lastHealth);

            } else if (player.health < player.lastHealth) {
                // DAMAGE: Apply red flash and create damage particles
                healthBarDiv.classList.add('flash-red');
                createHealthParticles('damage', player.lastHealth - player.health);

            } else if (player.health >= player.maxHealth) {
                // FULL: Apply yellow glow
                healthBarDiv.classList.add('glow-yellow');
            }
            
            // 3. Update the lastHealth tracker for the next frame
            player.lastHealth = player.health;

            // 4. Render the heart images (with corrected logic)
			healthBarDiv.innerHTML = '';
			const totalHearts = Math.ceil(player.maxHealth / 20); // Use ceil for partial max health

			for (let i = 0; i < totalHearts; i++) {
				const img = document.createElement('img');
				
				// Calculate the health value for *this specific heart* (from 0 to 20)
				const heartMinValue = i * 20;
				const currentHeartValue = Math.min(20, Math.max(0, player.health - heartMinValue));

				// Apply the new logic:
				// 10.01 - 20   = Full Heart
				// 0.01 - 10    = Half Heart
				// 0 or less    = Empty Heart
				if (currentHeartValue > 10) {
					// --- FIX: Check if asset exists before using it ---
					if (assets['full_heart']) {
						img.src = assets['full_heart'].src;
					}
				} else if (currentHeartValue > 0) {
					// --- FIX: Check if asset exists before using it ---
					if (assets['half_heart']) {
						img.src = assets['half_heart'].src;
					}
				} else {
					// --- FIX: Check if asset exists before using it ---
					if (assets['empty_heart']) {
						img.src = assets['empty_heart'].src;
					}
				}
				
				healthBarDiv.appendChild(img);
			}
        }
		
		function drawBlockOutline() {
            if (!showBlockOutline || isGamePaused) return;

            const worldMouseX = mouse.x + camera.x;
			const worldMouseY = mouse.y + camera.y;
			const targetCol = Math.floor(worldMouseX / tileSize);
			const targetRow = Math.floor(worldMouseY / tileSize);

            const blockType = getBlockType(targetCol, targetRow);
            const blockProps = blockTypes[blockType];

            // Don't draw outline on air or non-solid foliage
            if (blockType === '' || (blockProps && !blockProps.solid && !foliageTypes.includes(blockType))) {
                return;
            }

            const screenX = targetCol * tileSize - camera.x;
            const screenY = targetRow * tileSize - camera.y;

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White, 70% opacity
            ctx.lineWidth = 2;
            ctx.strokeRect(screenX, screenY, tileSize, tileSize);
        }
		
		function drawFire() {
			if (isGamePaused) return;

			const startCol = Math.floor(camera.x / tileSize) - 1;
			const endCol = Math.ceil((camera.x + canvas.width) / tileSize) + 1;
			const startRow = Math.floor(camera.y / tileSize) - 1;
			const endRow = Math.ceil((camera.y + canvas.height) / tileSize) + 1;

			for (const fireKey in fireBlocks) {
				const [col, row] = fireKey.split(',').map(Number);

				// Check if fire is on screen
				if (col >= startCol && col <= endCol && row >= startRow && row <= endRow) {
					const fireData = fireBlocks[fireKey];
					const animFrame = fireData.animFrame;
					let img;

					if (animFrame === 1) img = assets['fire_1'];
					else if (animFrame === 2) img = assets['fire_2'];
					else img = assets['fire_3'];

					if (img) {
						const screenX = col * tileSize - camera.x;
						const screenY = row * tileSize - camera.y;

						// Draw with transparency
						ctx.globalAlpha = 0.85; 
						ctx.drawImage(img, screenX, screenY, tileSize, tileSize);
						ctx.globalAlpha = 1.0; // Reset alpha
					}
				}
			}
		}

        function drawDrunkEffect() {
            let effectiveBAC = player.bloodAlcohol;
            const helmet = player.armor.helmet;
            if (helmet) {
                if (helmet.type === 'sober_mask') {
                    effectiveBAC *= 0.25; // 75% reduction
                } else if (helmet.type === 'drunk_mask') {
                    effectiveBAC += 100; // Simulate +100
                }
            }
            
            // Get both the canvas and the new vignette element
            if (!canvas) return; 
            const vignette = document.getElementById('drunkVignette');
            if (!vignette) return;

            if (player.bloodAlcohol > 100) {
                if (random() < 0.001) {
                    applyDamage(60);
                }
            }
            
            if (effectiveBAC > 30) {
                // 1. Calculate the effect intensity (0.0 to 1.0)
                const maxBacEffect = 150; // Max effect at this BAC
                const minBacEffect = 30;  // Effect starts here
                const effectProgress = Math.max(0, Math.min(1, (effectiveBAC - minBacEffect) / (maxBacEffect - minBacEffect)));

                // 2. Calculate the strength of each effect
                
                // HYPER BLUR: Max 50px blur
                const maxBlur = 50; 
                const blurAmount = (effectProgress * maxBlur).toFixed(2);

                // GLOW & TINT: Max 90% Sepia (yellow) and 150% Brightness (glow)
                const maxSepia = 90;
                const maxBrightness = 1.5; // 1.0 is normal, 1.5 is 50% brighter
                const sepiaAmount = (effectProgress * maxSepia).toFixed(2);
                const brightnessAmount = (1.0 + (effectProgress * (maxBrightness - 1.0))).toFixed(2);

                // 3. Apply the filters to the canvas
                canvas.style.filter = `blur(${blurAmount}px) sepia(${sepiaAmount}%) brightness(${brightnessAmount})`;

                // 4. VIBRATE: Add or remove the vibration class
                // Start vibrating once the effect is noticeable (e.g., 20% progress)
                if (effectProgress > 0.2) {
                    canvas.classList.add('vibrating');
                } else {
                    canvas.classList.remove('vibrating');
                }

                // 5. VIGNETTE: Show and set opacity
                vignette.style.display = 'block';
                // Max 90% opacity for the black vignette
                vignette.style.opacity = (effectProgress * 0.9).toFixed(2);

            } else {
                // 6. Clear all effects if sober
                if (canvas.style.filter !== 'none') {
                    canvas.style.filter = 'none';
                }
                if (canvas.classList.contains('vibrating')) {
                    canvas.classList.remove('vibrating');
                }
                if (vignette.style.display !== 'none') {
                    vignette.style.display = 'none';
                }
            }
        }

        window.addEventListener('keydown', (e) => {
			if (isLoadingAssets && (e.key === 't' || e.key === 'T')) {
                triggerTextureUpload();
                return;
            }
            if (e.key === '/') {
				e.preventDefault(); // This stops the '/' from being typed anywhere else
				toggleDevConsole();
				return; // Stop processing other keys
			}
			
			if (e.code === 'KeyM' && !isGamePaused && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
                showMinimap = !showMinimap;
                document.getElementById('minimapContainer').style.display = showMinimap ? 'block' : 'none';
            }
			
			// --- NEW: Skin Upload Trigger ---
            // Only listen if no menus are open and we are not in an input
            if (!isGamePaused && !isConsoleOpen && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                if (e.key.length === 1) { // Only track printable characters
                    skinTriggerSequence += e.key.toUpperCase();
                    
                    // Check if the end of our sequence matches the target
                    if (skinTriggerSequence.endsWith(targetSkinSequence)) {
                        openSkinUploader();
                        skinTriggerSequence = ""; // Reset sequence
                    }
                    
                    // Keep the sequence buffer from growing too large
                    if (skinTriggerSequence.length > targetSkinSequence.length * 2) {
                        skinTriggerSequence = skinTriggerSequence.substring(skinTriggerSequence.length - targetSkinSequence.length);
                    }
                } else if (e.key === 'Shift') {
                    // Ignore shift key itself
                } else {
                    // Reset on other keys like 'Enter', 'Escape', etc.
                    skinTriggerSequence = "";
                }
            }

			// If console is open, ignore other game-related key presses
			if (isConsoleOpen && e.code !== 'Escape') {
				return;
			}
			//keys[e.code] = true;
			// Don't register WASD if a text input is focused (even though we have stopPropagation)
			if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
				keys[e.code] = true;
			} else if (e.code === 'Escape') {
				// Still allow Escape to work from anywhere
				keys[e.code] = true;
			}
            if (e.code === 'Escape') {
				if (isGamePaused && skinUploadOverlay.style.display === 'flex') {
                    closeSkinUploader();
                } else if (isGamePaused && xpMenuOverlay.style.display === 'flex') {
					toggleXPMenu();
				} else if (isConsoleOpen) {
					toggleDevConsole();
                } else if (isGamePaused && bookReaderOverlay.style.display === 'flex') {
                    closeBookReader();
                } else if (isGamePaused && publishMenuOverlay.style.display === 'flex') {
                    closePublishMenu();
                } else if (isGamePaused && bookMenuOverlay.style.display === 'flex') {
                    saveAndCloseBook(); // Save on escape from editor
				} else if (isGamePaused && inventoryCraftingOverlay.style.display === 'flex') {
					toggleInventoryMenu();
				} else if (isGamePaused && chestOverlay.style.display === 'flex') {
					toggleChestMenu();
				} else if (isGamePaused && ovenOverlay.style.display === 'flex') {
                    toggleFurnaceMenu();
                } else if (isGamePaused && worldMoverConfigOverlay.style.display === 'flex') {
                    toggleWorldMoverMenu();
                } else if (isGamePaused && worldMoverTeleportOverlay.style.display === 'flex') {
                    toggleTeleportMenu();
                } else if (isGamePaused && anvilOverlay.style.display === 'flex') { // ADD THIS
                    toggleAnvilMenu();
                } else if (isGamePaused && voidChestOverlay.style.display === 'flex') {
					toggleVoidChestMenu();
				} else if (isGamePaused && isTraderMenuOpen === true) {
					toggleTraderMenu();
				} else if (isGamePaused && gameMenuOverlay.style.display === 'flex') {
					toggleGameMenu();
				} else {
					toggleGameMenu();
				}
			}
            if (e.code === 'KeyE') {
                if (isGamePaused && chestOverlay.style.display === 'flex') return; // Don't open crafting if chest is open
                if (!isGamePaused || (isGamePaused && inventoryCraftingOverlay.style.display === 'flex')) toggleInventoryMenu();
            }
            if (!isGamePaused) {
                if (e.key >= '1' && e.key <= '9') selectedHotbarSlot = parseInt(e.key) - 1;
                else if (e.key === '0') selectedHotbarSlot = 9;
                updateHotbar();
            }
			if (e.key === ';' && player.health > 50) {
				if (player.bedSpawnPoint) {
					applyDamage(10);
					player.x = player.bedSpawnPoint.x;
					player.y = player.bedSpawnPoint.y;
				}
			}
            if (e.key === '?') {
				if (particleCount > 30) {
                    showMessageBox("Particle Effects Reduced To 30!");
                    particleCount = 30;
                } else if (particleCount > 15) {
                    showMessageBox("Particle Effects Reduced To 15!");
                    particleCount = 15;
                } else if (particleCount > 5) {
                    showMessageBox("Particle Effects Reduced To 5!");
                    particleCount = 5;
                } else if (particleCount > 3) {
                    showMessageBox("Particle Effects Reduced To 3!");
                    particleCount = 3;
                } else if (particleCount > 0) {
                    showMessageBox("Particle Effects Reduced To None!");
                    particleCount = 0;
                } else if (particleCount === 0) {
                    showMessageBox("Particle Effects Increased To 60!");
                    particleCount = 60;
                }
                let gameParticles = particleCount
                localStorage.setItem('gameParticles', String(particleCount));
                showMessageBox(`Particle Effects set to ${particleCount} (saved).`);
			}
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'Space'].includes(e.code)) e.preventDefault();
			if (e.key === '%') {
				showDebugStats = !showDebugStats; // Toggle the flag
				debugStatsDiv.style.display = showDebugStats ? 'block' : 'none';
			}
        });

        window.addEventListener('keyup', (e) => { keys[e.code] = false; });
		document.addEventListener('mousemove', (e) => {
			// Position the tooltip slightly below and to the right of the cursor
			itemTooltip.style.left = (e.clientX + 15) + 'px';
			itemTooltip.style.top = (e.clientY + 10) + 'px';
		});
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (!isGamePaused) {
                if (e.button === 0) mouse.down = true;
                else if (e.button === 2) mouse.rightDown = true;
            }
        });
        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            if (e.button === 0) mouse.down = false;
            else if (e.button === 2) mouse.rightDown = false;
        });
		canvas.addEventListener('wheel', (e) => {
            if (isGamePaused) return; // Don't scroll if game is paused
            
            e.preventDefault(); // Stop the page from scrolling
            
            if (e.deltaY < 0) { // Scroll Up
                selectedHotbarSlot--;
            } else { // Scroll Down
                selectedHotbarSlot++;
            }

            // Wrap around logic
            if (selectedHotbarSlot < 0) {
                selectedHotbarSlot = hotbarSize - 1; // 9
            } else if (selectedHotbarSlot >= hotbarSize) {
                selectedHotbarSlot = 0;
            }

            updateHotbar();
            showHotbarSwitchTooltip(getSelectedItem()); // Show tooltip
        });
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.y;
        });
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        document.addEventListener('visibilitychange', () => {
            isGameActive = !document.hidden;
            if (isGameActive) lastTime = performance.now();
        });
        window.addEventListener('resize', resizeCanvas);
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            draw();
        }

        function showMessageBox(message, type = 'alert', callback = null) {
            messageBoxText.innerHTML = message;
            messageBoxButtons.innerHTML = '';
            return new Promise(resolve => {
                const okButton = document.createElement('button');
                okButton.textContent = 'OK';
                okButton.onclick = () => { customMessageBoxOverlay.style.display = 'none'; resolve(true); if (callback) callback(true); };
                messageBoxButtons.appendChild(okButton);
                if (type === 'confirm') {
                    const cancelButton = document.createElement('button');
                    cancelButton.textContent = 'Cancel';
                    cancelButton.onclick = () => { customMessageBoxOverlay.style.display = 'none'; resolve(false); if (callback) callback(false); };
                    messageBoxButtons.appendChild(cancelButton);
                }
                customMessageBoxOverlay.style.display = 'flex';
            });
        }

        /**
         * Warns the user before they close the tab or navigate away.
         * This helps prevent accidental loss of progress.
         */
        window.addEventListener('beforeunload', (e) => {
            // Don't show the prompt if:
            // 1. We are still on the initial loading screen.
            // 2. The main game menu is open (implying a "safe" state).
            if (isLoadingAssets || gameMenuOverlay.style.display === 'flex') {
                return; // No prompt will be shown
            }
            
            // If the game is active or a game sub-menu (like inventory, console, chest) is open,
            // then leaving would cause progress loss. Show the confirmation prompt.
            
            const confirmationMessage = 'Your progress may not be saved! Don\'t leave!';
            
            // For modern browsers
            e.preventDefault();
            // For older browsers
            e.returnValue = confirmationMessage;
            if (autosave) exportWorldBGU2();
        });

        const recipes = [
            { name: "Bed",
                input: { 0: { type: 'cotton_item', count: 1 }, 1: { type: 'cotton_item', count: 1 }, 2: { type: 'cotton_item', count: 1 }, 3: { type: 'cotton_item', count: 1 }, 4: { type: 'any_plank', count: 1 }, 5: { type: 'any_plank', count: 1 }, 6: { type: 'any_plank', count: 1 }, 7: { type: 'any_plank', count: 1 } },
                output: 'bed', outputCount: 1,
            },
            { name: "Chest", 
                input: { 0: { type: 'any_plank', count: 1 }, 1: { type: 'any_plank', count: 1 }, 2: { type: 'any_plank', count: 1 }, 3: { type: 'any_plank', count: 1 }, 4: { type: 'any_plank', count: 1 }, 5: { type: 'any_plank', count: 1 }, 6: { type: 'any_plank', count: 1 }, 7: { type: 'any_plank', count: 1 } },
                output: 'chest', outputCount: 1,
            },
			{ name: "Refrigerator",
				input: { 0: { type: 'chest', count: 1 }, 1: { type: 'packed_ice', count: 1 } },
				output: 'refrigerator', outputCount: 1
			},
			{ name: "Magical Chest", 
                input: { 0: { type: 'chest', count: 1 }, 1: { type: 'gold_nugget', count: 1 } },
                output: 'magical_chest', outputCount: 1,
            },
			{ name: "Void Chest", 
                input: { 0: { type: 'magical_chest', count: 1 }, 1: { type: 'void_crystal', count: 1 }, 2: { type: 'void_crystal', count: 1 }, 3: { type: 'void_crystal', count: 1 } },
                output: 'void_chest', outputCount: 1,
            },
			{ name: "Oven",
				input: { 0: { type: 'stone', count: 1 }, 1: { type: 'stone', count: 1 }, 2: { type: 'stone', count: 1 }, 3: { type: 'stone', count: 1 }, 4: { type: 'coal', count: 1 }, 5: { type: 'compacted_stone', count: 1 }, 6: { type: 'compacted_stone', count: 1 }, 7: { type: 'coal', count: 1 } },
				output: 'oven', outputCount: 1
			},
			{ name: "Magma Furnace",
				input: { 0: { type: 'compacted_stone', count: 1 }, 1: { type: 'stone', count: 1 }, 2: { type: 'stone', count: 1 }, 3: { type: 'compacted_stone', count: 1 }, 4: { type: 'coal', count: 1 }, 5: { type: 'compressed_stone', count: 1 }, 6: { type: 'compressed_stone', count: 1 }, 7: { type: 'coal', count: 1 }, 8: { type: 'magma_stone_block', count: 1 }, 9: { type: 'magma_stone_block', count: 1 }, 10: { type: 'magma_stone_block', count: 1 }, 11: { type: 'magma_stone_block', count: 1 } },
				output: 'magma_furnace', outputCount: 1
			},
			{ name: "Power Forge", 
                input: { 0: { type: 'magma_furnace', count: 1 }, 1: { type: 'forge_hammer', count: 1 }, 2: { type: 'any_plank', count: 1 } },
                output: 'power_forge', outputCount: 1,
            },
			{ name: "Rock Anvil",
				input: { 0: { type: 'rock_block', count: 1 }, 1: { type: 'rock_block', count: 1 }, 2: { type: 'rock_block', count: 1 }, 3: { type: 'rock_block', count: 1 }, 6: { type: 'rock_block', count: 1 }, 10: { type: 'rock_block', count: 1 }, 14: { type: 'rock_block', count: 1 }, 15: { type: 'rock_block', count: 1 } },
				output: 'rock_anvil', outputCount: 1
			},
			{ name: "Brass Anvil",
				input: { 0: { type: 'brass_nugget', count: 1 }, 1: { type: 'brass_nugget', count: 1 }, 2: { type: 'brass_nugget', count: 1 }, 3: { type: 'brass_nugget', count: 1 }, 6: { type: 'brass_nugget', count: 1 }, 10: { type: 'brass_nugget', count: 1 }, 14: { type: 'brass_nugget', count: 1 }, 15: { type: 'brass_nugget', count: 1 } },
				output: 'brass_anvil', outputCount: 1
			},
			{ name: "Iron Anvil",
				input: { 0: { type: 'iron_nugget', count: 1 }, 1: { type: 'iron_nugget', count: 1 }, 2: { type: 'iron_nugget', count: 1 }, 3: { type: 'iron_nugget', count: 1 }, 6: { type: 'iron_nugget', count: 1 }, 10: { type: 'iron_nugget', count: 1 }, 14: { type: 'iron_nugget', count: 1 }, 15: { type: 'iron_nugget', count: 1 } },
				output: 'iron_anvil', outputCount: 1
			},
			{ name: "Tungsten Anvil",
				input: { 0: { type: 'tungsten_nugget', count: 1 }, 1: { type: 'tungsten_nugget', count: 1 }, 2: { type: 'tungsten_nugget', count: 1 }, 3: { type: 'tungsten_nugget', count: 1 }, 6: { type: 'tungsten_nugget', count: 1 }, 10: { type: 'tungsten_nugget', count: 1 }, 14: { type: 'tungsten_nugget', count: 1 }, 15: { type: 'tungsten_nugget', count: 1 } },
				output: 'tungsten_anvil', outputCount: 1
			},
            { name: "Pumpkin Seeds",
				input: { 0: { type: 'pumpkin', count: 1 } },
				output: 'pumpkin_seeds', outputCount: 2
			},
            { name: "Tomato Seeds",
				input: { 0: { type: 'tomato', count: 1 } },
				output: 'tomato_seeds', outputCount: 2
			},
			{ name: "Chili Pepper Seeds",
				input: { 0: { type: 'chili_pepper', count: 1 } },
				output: 'chili_pepper_seeds', outputCount: 2
			},
			{ name: "Bronze Coins", 
                input: { 0: { type: 'bronze_nugget', count: 1 } },
                output: 'bronze_coin', outputCount: 10,
            },
			{ name: "Gold Coins", 
                input: { 0: { type: 'gold_nugget', count: 1 } },
                output: 'gold_coin', outputCount: 10,
            },
			{ name: "Pure Fuel",
				input: { 0: { type: 'cup_of_gasoline', count: 1 } },
				output: 'pure_fuel', outputCount: 3
			},
			{ name: "Pure Fuel",
				input: { 0: { type: 'coal', count: 1 } },
				output: 'pure_fuel', outputCount: 3
			},
			{ name: "Pure Fuel",
				input: { 0: { type: 'paper', count: 1 } },
				output: 'pure_fuel', outputCount: 1
			},
            { name: "Pure Fuel",
				input: { 0: { type: 'leaf', count: 5 } },
				output: 'pure_fuel', outputCount: 1
			},
            { name: "Paper",
				input: { 0: { type: 'any_plank', count: 1 }, 3: { type: 'any_plank', count: 1 } },
				output: 'paper', outputCount: 3,
            },
			{ name: "Book",
                input: { 0: { type: 'vulcanized_rubber', count: 1 }, 1: { type: 'paper', count: 1 }, 2: { type: 'paper', count: 1 }, 3: { type: 'paper', count: 1 }, 4: { type: 'vulcanized_rubber', count: 1 }, 5: { type: 'paper', count: 1 }, 6: { type: 'paper', count: 1 }, 7: { type: 'paper', count: 1 }, 8: { type: 'vulcanized_rubber', count: 1 }, 9: { type: 'paper', count: 1 }, 10: { type: 'paper', count: 1 }, 11: { type: 'paper', count: 1 }, 12: { type: 'vulcanized_rubber', count: 1 }, 13: { type: 'paper', count: 1 }, 14: { type: 'paper', count: 1 }, 15: { type: 'paper', count: 1 } },
                output: 'book', outputCount: 1
            },
			{ name: "Wooden Sticks", input: { 0: { type: 'any_plank', count: 1 } }, output: 'wooden_stick', outputCount: 3,
            },
			{ name: "Wield Wooden Stick", input: { 0: { type: 'wooden_stick', count: 1 }, 1: { type: 'gravel', count: 1 }, 2: { type: 'gravel', count: 1 }, 3: { type: 'gravel', count: 1 } }, output: 'wield_wooden_stick', outputCount: 1,
            },
			{ name: "Coffee Beans",
                input: { 0: { type: 'coffee', count: 1 } },
                output: 'coffee_bean', outputCount: 3
            },
			{ name: "Wooden Bowl",
                input: { 0: { type: 'any_plank', count: 1 }, 3: { type: 'any_plank', count: 1 }, 4: { type: 'any_plank', count: 1 }, 7: { type: 'any_plank', count: 1 }, 8: { type: 'any_plank', count: 1 }, 9: { type: 'any_plank', count: 1 }, 10: { type: 'any_plank', count: 1 }, 11: { type: 'any_plank', count: 1 } },
                output: 'wooden_bowl', outputCount: 3,
            },
			{ name: "Taco Salad",
                input: { 0: { type: 'wooden_bowl', count: 1 }, 1: { type: 'tomato', count: 1 }, 2: { type: 'corn_item', count: 1 }, 3: { type: 'rice_item', count: 1 } },
                output: 'taco_salad', outputCount: 1
            },
			{ name: "Mushroom Soup",
                input: { 0: { type: 'wooden_bowl', count: 1 }, 1: { type: 'shroom', count: 1 }, 2: { type: 'shroom', count: 1 }, 3: { type: 'shroom', count: 1 } },
                output: 'mushroom_soup', outputCount: 1
            },
			{ name: "3 Mushroom Soups",
                input: { 0: { type: 'wooden_bowl', count: 3 }, 1: { type: 'big_shroom', count: 1 }, 2: { type: 'big_shroom', count: 1 }, 3: { type: 'big_shroom', count: 1 } },
                output: 'mushroom_soup', outputCount: 3
            },
			{ name: "Tomato Soup",
                input: { 0: { type: 'wooden_bowl', count: 1 }, 1: { type: 'tomato', count: 1 }, 2: { type: 'tomato', count: 1 }, 3: { type: 'tomato', count: 1 } },
                output: 'tomato_soup', outputCount: 1
            },
			{ name: "Cup Of Crude Oil",
                input: { 0: { type: 'glass_cup', count: 3 }, 1: { type: 'crude_oil_chunk', count: 1 } },
                output: 'cup_of_crude_oil', outputCount: 3
            },
			{ name: "Cup Of Beer",
                input: { 0: { type: 'cup_of_water', count: 1 }, 1: { type: 'barley_item', count: 1 }, 2: { type: 'corn_item', count: 1 }, 4: { type: 'hop_item', count: 1 }, 5: { type: 'hop_item', count: 1 }, 6: { type: 'hop_item', count: 1 } },
                output: 'cup_of_beer', outputCount: 1
            },
            { name: "Wooden Pickaxe",
                input: { 0: { type: 'any_plank', count: 1 }, 1: { type: 'any_plank', count: 1 }, 2: { type: 'any_plank', count: 1 }, 3: { type: 'any_plank', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'wooden_pickaxe', outputCount: 1
            },
			{ name: "Wooden Shovel",
                input: { 0: { type: 'any_plank', count: 1 }, 1: { type: 'any_plank', count: 1 }, 2: { type: 'any_plank', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'wooden_shovel', outputCount: 1
            },
            { name: "Wooden Axe",
                input: { 0: { type: 'any_plank', count: 1 }, 1: { type: 'any_plank', count: 1 }, 2: { type: 'any_plank', count: 1 }, 6: { type: 'any_plank', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'wooden_axe', outputCount: 1
            },
            { name: "Rock Pickaxe",
                input: { 0: { type: 'rock_block', count: 1 }, 1: { type: 'rock_block', count: 1 }, 2: { type: 'rock_block', count: 1 }, 3: { type: 'rock_block', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'rock_pickaxe', outputCount: 1
            },
			{ name: "Rock Shovel",
                input: { 0: { type: 'rock_block', count: 1 }, 1: { type: 'rock_block', count: 1 }, 2: { type: 'rock_block', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'rock_shovel', outputCount: 1
            },
            { name: "Rock Axe",
                input: { 0: { type: 'rock_block', count: 1 }, 1: { type: 'rock_block', count: 1 }, 2: { type: 'rock_block', count: 1 }, 6: { type: 'rock_block', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'rock_axe', outputCount: 1
            },
			{ name: "Reinforced Rock Pickaxe",
                input: { 0: { type: 'rock_pickaxe', count: 1 }, 1: { type: 'iron_nugget', count: 1 }, 4: { type: 'iron_nugget', count: 1 } },
                output: 'reinforced_rock_pickaxe', outputCount: 1
            },
            { name: "Copper Pickaxe",
                input: { 0: { type: 'copper_nugget', count: 1 }, 1: { type: 'copper_nugget', count: 1 }, 2: { type: 'copper_nugget', count: 1 }, 3: { type: 'copper_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'copper_pickaxe', outputCount: 1
            },
			{ name: "Copper Shovel",
                input: { 0: { type: 'copper_nugget', count: 1 }, 1: { type: 'copper_nugget', count: 1 }, 2: { type: 'copper_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'copper_shovel', outputCount: 1
            },
            { name: "Copper Axe",
                input: { 0: { type: 'copper_nugget', count: 1 }, 1: { type: 'copper_nugget', count: 1 }, 2: { type: 'copper_nugget', count: 1 }, 6: { type: 'copper_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'copper_axe', outputCount: 1
            },
            { name: "Tin Pickaxe",
                input: { 0: { type: 'tin_nugget', count: 1 }, 1: { type: 'tin_nugget', count: 1 }, 2: { type: 'tin_nugget', count: 1 }, 3: { type: 'tin_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'tin_pickaxe', outputCount: 1
            },
			{ name: "Tin Shovel",
                input: { 0: { type: 'tin_nugget', count: 1 }, 1: { type: 'tin_nugget', count: 1 }, 2: { type: 'tin_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'tin_shovel', outputCount: 1
            },
            { name: "Tin Axe",
                input: { 0: { type: 'tin_nugget', count: 1 }, 1: { type: 'tin_nugget', count: 1 }, 2: { type: 'tin_nugget', count: 1 }, 6: { type: 'tin_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'tin_axe', outputCount: 1
            },
            { name: "Bronze Nugget", input: { 0: { type: 'tin_nugget', count: 1 }, 1: { type: 'copper_nugget', count: 1 } }, output: 'bronze_nugget', outputCount: 1 },
            { name: "Bronze Pickaxe",
                input: { 0: { type: 'bronze_nugget', count: 1 }, 1: { type: 'bronze_nugget', count: 1 }, 2: { type: 'bronze_nugget', count: 1 }, 3: { type: 'bronze_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'bronze_pickaxe', outputCount: 1
            },
			{ name: "Bronze Shovel",
                input: { 0: { type: 'bronze_nugget', count: 1 }, 1: { type: 'bronze_nugget', count: 1 }, 2: { type: 'bronze_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'bronze_shovel', outputCount: 1
            },
            { name: "Bronze Axe",
                input: { 0: { type: 'bronze_nugget', count: 1 }, 1: { type: 'bronze_nugget', count: 1 }, 2: { type: 'bronze_nugget', count: 1 }, 6: { type: 'bronze_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'bronze_axe', outputCount: 1
            },
			{ name: "Brass Nugget", input: { 0: { type: 'zinc_nugget', count: 1 }, 1: { type: 'copper_nugget', count: 1 } }, output: 'brass_nugget', outputCount: 1 },
            { name: "Iron Pickaxe",
                input: { 0: { type: 'iron_nugget', count: 1 }, 1: { type: 'iron_nugget', count: 1 }, 2: { type: 'iron_nugget', count: 1 }, 3: { type: 'iron_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'iron_pickaxe', outputCount: 1
            },
			{ name: "Iron Shovel",
                input: { 0: { type: 'iron_nugget', count: 1 }, 1: { type: 'iron_nugget', count: 1 }, 2: { type: 'iron_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'iron_shovel', outputCount: 1
            },
            { name: "Iron Axe",
                input: { 0: { type: 'iron_nugget', count: 1 }, 1: { type: 'iron_nugget', count: 1 }, 2: { type: 'iron_nugget', count: 1 }, 6: { type: 'iron_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'iron_axe', outputCount: 1
            },
			{ name: "Tungsten Pickaxe",
                input: { 0: { type: 'tungsten_nugget', count: 1 }, 1: { type: 'tungsten_nugget', count: 1 }, 2: { type: 'tungsten_nugget', count: 1 }, 3: { type: 'tungsten_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'tungsten_pickaxe', outputCount: 1
            },
			{ name: "Tungsten Shovel",
                input: { 0: { type: 'tungsten_nugget', count: 1 }, 1: { type: 'tungsten_nugget', count: 1 }, 2: { type: 'tungsten_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'tungsten_shovel', outputCount: 1
            },
            { name: "Tungsten Axe",
                input: { 0: { type: 'tungsten_nugget', count: 1 }, 1: { type: 'tungsten_nugget', count: 1 }, 2: { type: 'tungsten_nugget', count: 1 }, 6: { type: 'tungsten_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'tungsten_axe', outputCount: 1
            },
            { name: "Steel Nugget",
                input: { 1: { type: 'coal', count: 1 }, 4: { type: 'coal', count: 1 }, 5: { type: 'iron_nugget', count: 1 }, 6: { type: 'coal', count: 1 }, 9: { type: 'coal', count: 1 }, 10: { type: 'coal', count: 1 } },
                output: 'steel_nugget', outputCount: 1
            },
            { name: "Steel Pickaxe",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 2: { type: 'steel_nugget', count: 1 }, 3: { type: 'steel_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'steel_pickaxe', outputCount: 1
            },
			{ name: "Steel Shovel",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 2: { type: 'steel_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'steel_shovel', outputCount: 1
            },
            { name: "Steel Axe",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 2: { type: 'steel_nugget', count: 1 }, 6: { type: 'steel_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'steel_axe', outputCount: 1
            },
            { name: "Ruby Plated Steel Pickaxe",
                input: { 0: { type: 'ruby_nugget', count: 1 }, 1: { type: 'steel_pickaxe', count: 1 }, 2: { type: 'ruby_nugget', count: 1 }, 5: { type: 'ruby_nugget', count: 1 } },
                output: 'ruby_plated_steel_pickaxe', outputCount: 1
            },
            { name: "Diamond Plated Steel Pickaxe",
                input: { 0: { type: 'diamond_nugget', count: 1 }, 1: { type: 'steel_pickaxe', count: 1 }, 2: { type: 'diamond_nugget', count: 1 }, 5: { type: 'diamond_nugget', count: 1 } },
                output: 'diamond_plated_steel_pickaxe', outputCount: 1
            },
			{ name: "Diviniron Pickaxe",
                input: { 0: { type: 'diviniron_nugget', count: 1 }, 1: { type: 'diviniron_nugget', count: 1 }, 2: { type: 'diviniron_nugget', count: 1 }, 3: { type: 'diviniron_nugget', count: 1 }, 5: { type: 'wield_wooden_stick', count: 1 }, 9: { type: 'wield_wooden_stick', count: 1 }, 13: { type: 'wield_wooden_stick', count: 1 } },
                output: 'diviniron_pickaxe', outputCount: 1
            },
			{ name: "Mighterrum Pickaxe",
                input: { 0: { type: 'mighterrum_nugget', count: 1 }, 1: { type: 'mighterrum_nugget', count: 1 }, 2: { type: 'mighterrum_nugget', count: 1 }, 3: { type: 'mighterrum_nugget', count: 1 }, 5: { type: 'wield_wooden_stick', count: 1 }, 9: { type: 'wield_wooden_stick', count: 1 }, 13: { type: 'wield_wooden_stick', count: 1 } },
                output: 'mighterrum_pickaxe', outputCount: 1
            },
			{ name: "Hellrock Pickaxe",
                input: { 0: { type: 'hellrock', count: 1 }, 1: { type: 'hellrock', count: 1 }, 2: { type: 'hellrock', count: 1 }, 3: { type: 'hellrock', count: 1 }, 5: { type: 'rock_pickaxe', count: 1 }, 9: { type: 'rock_pickaxe', count: 1 }, 13: { type: 'rock_pickaxe', count: 1 } },
                output: 'hellrock_pickaxe', outputCount: 1
            },
			{ name: "Hellsteel Pickaxe",
                input: { 0: { type: 'hellsteel_nugget', count: 1 }, 1: { type: 'hellsteel_nugget', count: 1 }, 2: { type: 'hellsteel_nugget', count: 1 }, 3: { type: 'hellsteel_nugget', count: 1 }, 5: { type: 'steel_pickaxe', count: 1 }, 9: { type: 'steel_pickaxe', count: 1 }, 13: { type: 'steel_pickaxe', count: 1 } },
                output: 'hellsteel_pickaxe', outputCount: 1
            },
			{ name: "Anthill Hellsteel Pickaxe",
                input: { 0: { type: 'hellsteel_pickaxe', count: 1 }, 1: { type: 'colony_heart', count: 1 }, 2: { type: 'colony_heart', count: 1 }, 3: { type: 'colony_heart', count: 1 } },
                output: 'anthill_hellsteel_pickaxe', outputCount: 1
            },
			{ name: "Void Hellsteel Pickaxe",
                input: { 0: { type: 'hellsteel_pickaxe', count: 1 }, 1: { type: 'void_crystal', count: 1 }, 2: { type: 'void_crystal', count: 1 }, 3: { type: 'void_crystal', count: 1 }, 4: { type: 'void_crystal', count: 1 }, 5: { type: 'void_crystal', count: 1 }, 6: { type: 'void_crystal', count: 1 }, 7: { type: 'void_crystal', count: 1 }, 8: { type: 'void_crystal', count: 1 }, 9: { type: 'void_crystal', count: 1 }, 10: { type: 'void_crystal', count: 1 }, 11: { type: 'void_crystal', count: 1 }, 12: { type: 'void_crystal', count: 1 }, 13: { type: 'void_crystal', count: 1 }, 14: { type: 'void_crystal', count: 1 }, 15: { type: 'void_crystal', count: 1 } },
                output: 'void_hellsteel_pickaxe', outputCount: 1
            },
			{ name: "Heavenrock Pickaxe",
                input: { 0: { type: 'cloud_rock_block', count: 1 }, 1: { type: 'cloud_rock_block', count: 1 }, 2: { type: 'cloud_rock_block', count: 1 }, 3: { type: 'cloud_rock_block', count: 1 }, 5: { type: 'rock_pickaxe', count: 1 }, 9: { type: 'rock_pickaxe', count: 1 }, 13: { type: 'rock_pickaxe', count: 1 } },
                output: 'heavenrock_pickaxe', outputCount: 1
            },
			{ name: "Heavensteel Pickaxe",
                input: { 0: { type: 'heavensteel_nugget', count: 1 }, 1: { type: 'heavensteel_nugget', count: 1 }, 2: { type: 'heavensteel_nugget', count: 1 }, 3: { type: 'heavensteel_nugget', count: 1 }, 5: { type: 'steel_pickaxe', count: 1 }, 9: { type: 'steel_pickaxe', count: 1 }, 13: { type: 'steel_pickaxe', count: 1 } },
                output: 'heavensteel_pickaxe', outputCount: 1
            },
			{ name: "Anthill Heavensteel Pickaxe",
                input: { 0: { type: 'heavensteel_pickaxe', count: 1 }, 1: { type: 'colony_heart', count: 1 }, 2: { type: 'colony_heart', count: 1 }, 3: { type: 'colony_heart', count: 1 } },
                output: 'anthill_heavensteel_pickaxe', outputCount: 1
            },
			{ name: "Void Heavensteel Pickaxe",
                input: { 0: { type: 'heavensteel_pickaxe', count: 1 }, 1: { type: 'void_crystal', count: 1 }, 2: { type: 'void_crystal', count: 1 }, 3: { type: 'void_crystal', count: 1 }, 4: { type: 'void_crystal', count: 1 }, 5: { type: 'void_crystal', count: 1 }, 6: { type: 'void_crystal', count: 1 }, 7: { type: 'void_crystal', count: 1 }, 8: { type: 'void_crystal', count: 1 }, 9: { type: 'void_crystal', count: 1 }, 10: { type: 'void_crystal', count: 1 }, 11: { type: 'void_crystal', count: 1 }, 12: { type: 'void_crystal', count: 1 }, 13: { type: 'void_crystal', count: 1 }, 14: { type: 'void_crystal', count: 1 }, 15: { type: 'void_crystal', count: 1 } },
                output: 'void_heavensteel_pickaxe', outputCount: 1
            },
			{ name: "Infinitungsten Pickaxe",
                input: { 0: { type: 'infinitungsten_nugget', count: 1 }, 1: { type: 'infinitungsten_nugget', count: 1 }, 2: { type: 'infinitungsten_nugget', count: 1 }, 3: { type: 'infinitungsten_nugget', count: 1 }, 5: { type: 'wield_wooden_stick', count: 1 }, 9: { type: 'wield_wooden_stick', count: 1 }, 13: { type: 'wield_wooden_stick', count: 1 } },
                output: 'infinitungsten_pickaxe', outputCount: 1
            },
			{ name: "Infinitungsten Shovel",
                input: { 0: { type: 'infinitungsten_nugget', count: 1 }, 1: { type: 'infinitungsten_nugget', count: 1 }, 2: { type: 'infinitungsten_nugget', count: 1 }, 5: { type: 'wield_wooden_stick', count: 1 }, 9: { type: 'wield_wooden_stick', count: 1 }, 13: { type: 'wield_wooden_stick', count: 1 } },
                output: 'infinitungsten_shovel', outputCount: 1
            },
			{ name: "Infinitungsten Axe",
                input: { 0: { type: 'infinitungsten_nugget', count: 1 }, 1: { type: 'infinitungsten_nugget', count: 1 }, 2: { type: 'infinitungsten_nugget', count: 1 }, 6: { type: 'infinitungsten_nugget', count: 1 }, 5: { type: 'wield_wooden_stick', count: 1 }, 9: { type: 'wield_wooden_stick', count: 1 }, 13: { type: 'wield_wooden_stick', count: 1 } },
                output: 'infinitungsten_axe', outputCount: 1
            },
            { name: "Anthill Infinitungsten Pickaxe",
                input: { 0: { type: 'infinitungsten_pickaxe', count: 1 }, 1: { type: 'colony_heart', count: 1 }, 2: { type: 'colony_heart', count: 1 }, 3: { type: 'colony_heart', count: 1 } },
                output: 'anthill_infinitungsten_pickaxe', outputCount: 1
            },
			{ name: "Void Infinitungsten Pickaxe",
                input: { 0: { type: 'infinitungsten_pickaxe', count: 1 }, 1: { type: 'void_crystal', count: 1 }, 2: { type: 'void_crystal', count: 1 }, 3: { type: 'void_crystal', count: 1 }, 4: { type: 'void_crystal', count: 1 }, 5: { type: 'void_crystal', count: 1 }, 6: { type: 'void_crystal', count: 1 }, 7: { type: 'void_crystal', count: 1 }, 8: { type: 'void_crystal', count: 1 }, 9: { type: 'void_crystal', count: 1 }, 10: { type: 'void_crystal', count: 1 }, 11: { type: 'void_crystal', count: 1 }, 12: { type: 'void_crystal', count: 1 }, 13: { type: 'void_crystal', count: 1 }, 14: { type: 'void_crystal', count: 1 }, 15: { type: 'void_crystal', count: 1 } },
                output: 'void_infinitungsten_pickaxe', outputCount: 1
            },
			{ name: "Mythicalithium Pickaxe",
                input: { 0: { type: 'mythicalithium_nugget', count: 1 }, 1: { type: 'mythicalithium_nugget', count: 1 }, 2: { type: 'mythicalithium_nugget', count: 1 }, 3: { type: 'mythicalithium_nugget', count: 1 }, 5: { type: 'diviniron_pickaxe', count: 1 }, 9: { type: 'diviniron_pickaxe', count: 1 }, 13: { type: 'diviniron_pickaxe', count: 1 } },
                output: 'mythicalithium_pickaxe', outputCount: 1
            },
			{ name: "Forge Hammer",
                input: { 0: { type: 'iron_nugget', count: 1 }, 1: { type: 'copper_nugget', count: 1 }, 2: { type: 'tungsten_nugget', count: 1 }, 3: { type: 'tin_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 6: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 10: { type: 'wooden_stick', count: 1 } },
                output: 'forge_hammer', outputCount: 1
            },
            { name: "Snow Block",
                input: { 0: { type: 'snow_ball', count: 1 }, 1: { type: 'snow_ball', count: 1 }, 2: { type: 'snow_ball', count: 1 }, 4: { type: 'snow_ball', count: 1 }, 5: { type: 'snow_ball', count: 1 }, 6: { type: 'snow_ball', count: 1 }, 8: { type: 'snow_ball', count: 1 }, 9: { type: 'snow_ball', count: 1 }, 10: { type: 'snow_ball', count: 1 } },
                output: 'snow_block', outputCount: 1
            },
            { name: "Oak Planks", input: { 0: { type: 'raw_oak', count: 1 } }, output: 'planked_oak', outputCount: 3 },
            { name: "Birch Planks", input: { 0: { type: 'raw_birch', count: 1 } }, output: 'planked_birch', outputCount: 3 },
            { name: "Spruce Planks", input: { 0: { type: 'raw_spruce', count: 1 } }, output: 'planked_spruce', outputCount: 3 },
			{ name: "Apple Planks", input: { 0: { type: 'raw_apple', count: 1 } }, output: 'planked_apple', outputCount: 3 },
			{ name: "Orange Planks", input: { 0: { type: 'raw_orange', count: 1 } }, output: 'planked_orange', outputCount: 3 },
			{ name: "Rubber Planks", input: { 0: { type: 'raw_rubber', count: 1 } }, output: 'planked_rubber', outputCount: 3 },
			{ name: "Mahogany Planks", input: { 0: { type: 'raw_mahogany', count: 1 } }, output: 'planked_mahogany', outputCount: 3 },
			{ name: "Cinnamon Planks", input: { 0: { type: 'raw_cinnamon', count: 1 } }, output: 'planked_cinnamon', outputCount: 3 },
			{ name: "Redwood Planks", input: { 0: { type: 'raw_redwood', count: 1 } }, output: 'planked_redwood', outputCount: 3 },
			{ name: "Hell Wood Planks", input: { 0: { type: 'raw_hell_wood', count: 1 } }, output: 'planked_hell_wood', outputCount: 3 },
            { name: "Darkwood Planks", input: { 0: { type: 'raw_darkwood', count: 1 } }, output: 'planked_darkwood', outputCount: 3 },
            { name: "Gilded Wood Planks", input: { 0: { type: 'raw_gilded_wood', count: 1 } }, output: 'planked_gilded_wood', outputCount: 3 },
			{ name: "Blueglow Wood Planks", input: { 0: { type: 'raw_blueglow_wood', count: 1 } }, output: 'planked_blueglow_wood', outputCount: 3 },
			{ name: "Deadwood Planks", input: { 0: { type: 'raw_deadwood', count: 1 } }, output: 'planked_deadwood', outputCount: 3 },
            { name: "Cinnamon", input: { 0: { type: 'raw_cinnamon', count: 1 }, 4: { type: 'raw_cinnamon', count: 1 }, 8: { type: 'raw_cinnamon', count: 1 }, 12: { type: 'raw_cinnamon', count: 1 } }, output: 'cinnamon', outputCount: 10 },
			{ name: "Hay Bale",
                input: { 0: { type: 'wheat_item', count: 1 }, 1: { type: 'barley_item', count: 1 }, 4: { type: 'barley_item', count: 1 }, 5: { type: 'wheat_item', count: 1 } },
                output: 'hay_bale', outputCount: 1
            },
			{ name: "Flour",
                input: { 0: { type: 'wheat_item', count: 1 } },
                output: 'flour', outputCount: 2
            },
			{ name: "Iodized Salt",
                input: { 0: { type: 'rock_salt', count: 1 } },
                output: 'iodized_salt', outputCount: 2
            },
			{ name: "Saltpeter",
                input: { 0: { type: 'guano', count: 1 } },
                output: 'saltpeter', outputCount: 1
            },
            { name: "Tomato Sandwich",
                input: { 1: { type: 'wheat_bread', count: 1 }, 5: { type: 'tomato', count: 1 }, 6: { type: 'tomato', count: 1 }, 7: { type: 'tomato', count: 1 }, 9: { type: 'wheat_bread', count: 1 } },
                output: 'tomato_sandwich', outputCount: 1,
            },
			{ name: "Tomato Sandwich",
                input: { 1: { type: 'barley_bread', count: 1 }, 5: { type: 'tomato', count: 1 }, 6: { type: 'tomato', count: 1 }, 7: { type: 'tomato', count: 1 }, 9: { type: 'barley_bread', count: 1 } },
                output: 'tomato_sandwich', outputCount: 1,
            },
            { name: "Fertilizer",
                input: { 0: { type: 'soil', count: 1 }, 1: { type: 'coal', count: 1 } },
                output: 'fertilizer', outputCount: 1
            },
			{ name: "Fertilizer",
                input: { 0: { type: 'plantation_soil', count: 1 }, 1: { type: 'plantation_soil', count: 1 }, 2: { type: 'plantation_soil', count: 1 } },
                output: 'fertilizer', outputCount: 1
            },
			{ name: "Stone Stairs Right",
				input: { 3: { type: 'stone', count: 1 }, 6: { type: 'stone', count: 1 }, 7: { type: 'stone', count: 1 }, 9: { type: 'stone', count: 1 }, 10: { type: 'stone', count: 1 }, 11: { type: 'stone', count: 1 }, 12: { type: 'stone', count: 1 }, 13: { type: 'stone', count: 1 }, 14: { type: 'stone', count: 1 }, 15: { type: 'stone', count: 1 } },
				output: 'stone_stairs_right', outputCount: 10
			},
			{ name: "Stone Stairs Left",
				input: { 0: { type: 'stone', count: 1 }, 4: { type: 'stone', count: 1 }, 5: { type: 'stone', count: 1 }, 8: { type: 'stone', count: 1 }, 9: { type: 'stone', count: 1 }, 10: { type: 'stone', count: 1 }, 12: { type: 'stone', count: 1 }, 13: { type: 'stone', count: 1 }, 14: { type: 'stone', count: 1 }, 15: { type: 'stone', count: 1 } },
				output: 'stone_stairs_left', outputCount: 10
			},
			{ name: "Clay Brick Block",
                input: { 0: { type: 'soil', count: 1 }, 1: { type: 'clay', count: 1 }, 4: { type: 'clay', count: 1 }, 5: { type: 'soil', count: 1 } },
                output: 'clay_brick_block', outputCount: 1
            },
			{ name: "Stone Brick Block",
                input: { 0: { type: 'stone', count: 1 }, 1: { type: 'compacted_stone', count: 1 }, 4: { type: 'compacted_stone', count: 1 }, 5: { type: 'stone', count: 1 } },
                output: 'stone_brick_block', outputCount: 3
            },
			{ name: "Asphalt Block",
                input: { 0: { type: 'stone', count: 1 }, 1: { type: 'schist', count: 1 }, 2: { type: 'slate', count: 1 }, 3: { type: 'granite', count: 1 }, 5: { type: 'compacted_stone', count: 1 }, 6: { type: 'rock_block', count: 1 } },
                output: 'asphalt', outputCount: 6
            },
			{ name: "Asphalt Block",
                input: { 0: { type: 'asphalt_fragment', count: 1 }, 1: { type: 'asphalt_fragment', count: 1 }, 2: { type: 'asphalt_fragment', count: 1 }, 3: { type: 'asphalt_fragment', count: 1 } },
                output: 'asphalt', outputCount: 1
            },
			{ name: "Bronze Brick Block",
                input: { 0: { type: 'bronze_nugget', count: 1 }, 1: { type: 'bronze_nugget', count: 1 }, 4: { type: 'bronze_nugget', count: 1 }, 5: { type: 'bronze_nugget', count: 1 } },
                output: 'bronze_brick_block', outputCount: 1
            },
			{ name: "Brass Brick Block",
                input: { 0: { type: 'brass_nugget', count: 1 }, 1: { type: 'brass_nugget', count: 1 }, 4: { type: 'brass_nugget', count: 1 }, 5: { type: 'brass_nugget', count: 1 } },
                output: 'brass_brick_block', outputCount: 1
            },
			{ name: "Steel Brick Block",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 4: { type: 'steel_nugget', count: 1 }, 5: { type: 'steel_nugget', count: 1 } },
                output: 'steel_brick_block', outputCount: 1
            },
			{ name: "Iron Brick Block",
                input: { 0: { type: 'iron_nugget', count: 1 }, 1: { type: 'iron_nugget', count: 1 }, 4: { type: 'iron_nugget', count: 1 }, 5: { type: 'iron_nugget', count: 1 } },
                output: 'iron_brick_block', outputCount: 1
            },
			{ name: "Tungsten Brick Block",
                input: { 0: { type: 'tungsten_nugget', count: 1 }, 1: { type: 'tungsten_nugget', count: 1 }, 4: { type: 'tungsten_nugget', count: 1 }, 5: { type: 'tungsten_nugget', count: 1 } },
                output: 'tungsten_brick_block', outputCount: 1
            },
			{ name: "Tin Brick Block",
                input: { 0: { type: 'tin_nugget', count: 1 }, 1: { type: 'tin_nugget', count: 1 }, 4: { type: 'tin_nugget', count: 1 }, 5: { type: 'tin_nugget', count: 1 } },
                output: 'tin_brick_block', outputCount: 1
            },
			{ name: "Zinc Brick Block",
                input: { 0: { type: 'zinc_nugget', count: 1 }, 1: { type: 'zinc_nugget', count: 1 }, 4: { type: 'zinc_nugget', count: 1 }, 5: { type: 'zinc_nugget', count: 1 } },
                output: 'zinc_brick_block', outputCount: 1
            },
			{ name: "Copper Brick Block",
                input: { 0: { type: 'copper_nugget', count: 1 }, 1: { type: 'copper_nugget', count: 1 }, 4: { type: 'copper_nugget', count: 1 }, 5: { type: 'copper_nugget', count: 1 } },
                output: 'copper_brick_block', outputCount: 1
            },
            { name: "Gold Brick Block",
                input: { 0: { type: 'gold_nugget', count: 1 }, 1: { type: 'gold_nugget', count: 1 }, 4: { type: 'gold_nugget', count: 1 }, 5: { type: 'gold_nugget', count: 1 } },
                output: 'gold_brick_block', outputCount: 1
            },
			{ name: "Gold Power Brick Block",
                input: { 0: { type: 'gold_brick_block', count: 1 }, 1: { type: 'cactus_block', count: 1 }, 2: { type: 'cactus_block', count: 1 }, 3: { type: 'gold_brick_block', count: 1 }, 5: { type: 'coal', count: 1 }, 6: { type: 'coal', count: 1 } },
                output: 'gold_power_brick_block', outputCount: 1
            },
			{ name: "Aluminum Brick Block",
                input: { 0: { type: 'aluminum_nugget', count: 1 }, 1: { type: 'aluminum_nugget', count: 1 }, 4: { type: 'aluminum_nugget', count: 1 }, 5: { type: 'aluminum_nugget', count: 1 } },
                output: 'aluminum_brick_block', outputCount: 1
            },
            { name: "Palladium Brick Block",
                input: { 0: { type: 'palladium_nugget', count: 1 }, 1: { type: 'palladium_nugget', count: 1 }, 4: { type: 'palladium_nugget', count: 1 }, 5: { type: 'palladium_nugget', count: 1 } },
                output: 'palladium_brick_block', outputCount: 1
            },
			{ name: "Nickel Brick Block",
                input: { 0: { type: 'nickel_nugget', count: 1 }, 1: { type: 'nickel_nugget', count: 1 }, 4: { type: 'nickel_nugget', count: 1 }, 5: { type: 'nickel_nugget', count: 1 } },
                output: 'nickel_brick_block', outputCount: 1
            },
			{ name: "Lead Brick Block",
                input: { 0: { type: 'lead_nugget', count: 1 }, 1: { type: 'lead_nugget', count: 1 }, 4: { type: 'lead_nugget', count: 1 }, 5: { type: 'lead_nugget', count: 1 } },
                output: 'lead_brick_block', outputCount: 1
            },
            { name: "Gold Nugget",
                input: { 0: { type: 'any_gilded', count: 1 }, 1: { type: 'any_gilded', count: 1 }, 2: { type: 'any_gilded', count: 1 }, 3: { type: 'any_gilded', count: 1 }, 4: { type: 'any_gilded', count: 1 }, 5: { type: 'any_gilded', count: 1 }, 6: { type: 'any_gilded', count: 1 }, 7: { type: 'any_gilded', count: 1 }, 8: { type: 'any_gilded', count: 1 }, 9: { type: 'any_gilded', count: 1 }, 10: { type: 'any_gilded', count: 1 }, 11: { type: 'any_gilded', count: 1 }, 12: { type: 'any_gilded', count: 1 }, 13: { type: 'any_gilded', count: 1 }, 14: { type: 'any_gilded', count: 1}, 15: { type: 'any_gilded', count: 1 } },
                output: 'gold_nugget', outputCount: 1
            },
			{ name: "Glass Cup",
                input: { 0: { type: 'glass_block', count: 1 }, 2: { type: 'glass_block', count: 1 }, 4: { type: 'glass_block', count: 1 }, 6: { type: 'glass_block', count: 1 }, 8: { type: 'glass_block', count: 1 }, 10: { type: 'glass_block', count: 1 }, 12: { type: 'glass_block', count: 1 }, 13: { type: 'glass_block', count: 1 }, 14: { type: 'glass_block', count: 1 } },
                output: 'glass_cup', outputCount: 4
            },
			{ name: "Void Dust Block",
                input: { 0: { type: 'void_dust', count: 1 }, 1: { type: 'void_dust', count: 1 }, 4: { type: 'void_dust', count: 1 }, 5: { type: 'void_dust', count: 1 } },
                output: 'void_dust_block', outputCount: 1
            },
			{ name: "Red Void Crystal",
                input: { 0: { type: 'colony_heart', count: 1 }, 1: { type: 'void_crystal', count: 1 }, 4: { type: 'void_crystal', count: 1 }, 5: { type: 'void_crystal', count: 1 } },
                output: 'red_void_crystal', outputCount: 1
            },
			{ name: "Ancient Heaven Debris Blocks",
                input: { 0: { type: 'corroded_heaven_debris_block', count: 1 }, 1: { type: 'corroded_heaven_debris_block', count: 1 }, 2: { type: 'corroded_heaven_debris_block', count: 1 }, 3: { type: 'corroded_heaven_debris_block', count: 1 }, 4: { type: 'corroded_heaven_debris_block', count: 1 }, 5: { type: 'corroded_heaven_debris_block', count: 1 }, 6: { type: 'corroded_heaven_debris_block', count: 1 }, 7: { type: 'corroded_heaven_debris_block', count: 1 }, 8: { type: 'corroded_heaven_debris_block', count: 1 }, 9: { type: 'corroded_heaven_debris_block', count: 1 }, 10: { type: 'corroded_heaven_debris_block', count: 1 }, 11: { type: 'corroded_heaven_debris_block', count: 1 }, 12: { type: 'corroded_heaven_debris_block', count: 1 }, 13: { type: 'corroded_heaven_debris_block', count: 1 }, 14: { type: 'corroded_heaven_debris_block', count: 1}, 15: { type: 'corroded_heaven_debris_block', count: 1 } },
                output: 'ancient_heaven_debris_block', outputCount: 2
            },
			{ name: "Strong Heaven Debris Blocks",
                input: { 0: { type: 'ancient_heaven_debris_block', count: 1 }, 1: { type: 'ancient_heaven_debris_block', count: 1 }, 2: { type: 'ancient_heaven_debris_block', count: 1 }, 3: { type: 'ancient_heaven_debris_block', count: 1 }, 4: { type: 'ancient_heaven_debris_block', count: 1 }, 5: { type: 'ancient_heaven_debris_block', count: 1 }, 6: { type: 'ancient_heaven_debris_block', count: 1 }, 7: { type: 'ancient_heaven_debris_block', count: 1 }, 8: { type: 'ancient_heaven_debris_block', count: 1 }, 9: { type: 'ancient_heaven_debris_block', count: 1 }, 10: { type: 'ancient_heaven_debris_block', count: 1 }, 11: { type: 'ancient_heaven_debris_block', count: 1 }, 12: { type: 'ancient_heaven_debris_block', count: 1 }, 13: { type: 'ancient_heaven_debris_block', count: 1 }, 14: { type: 'ancient_heaven_debris_block', count: 1}, 15: { type: 'ancient_heaven_debris_block', count: 1 } },
                output: 'strong_heaven_debris_block', outputCount: 2
            },
			{ name: "Pure Heaven Debris Block",
                input: { 0: { type: 'corroded_heaven_debris_block', count: 1 }, 1: { type: 'ancient_heaven_debris_block', count: 1 }, 2: { type: 'ancient_heaven_debris_block', count: 1 }, 3: { type: 'corroded_heaven_debris_block', count: 1 }, 4: { type: 'ancient_heaven_debris_block', count: 1 }, 5: { type: 'strong_heaven_debris_block', count: 1 }, 6: { type: 'strong_heaven_debris_block', count: 1 }, 7: { type: 'ancient_heaven_debris_block', count: 1 }, 8: { type: 'ancient_heaven_debris_block', count: 1 }, 9: { type: 'strong_heaven_debris_block', count: 1 }, 10: { type: 'strong_heaven_debris_block', count: 1 }, 11: { type: 'ancient_heaven_debris_block', count: 1 }, 12: { type: 'corroded_heaven_debris_block', count: 1 }, 13: { type: 'ancient_heaven_debris_block', count: 1 }, 14: { type: 'ancient_heaven_debris_block', count: 1}, 15: { type: 'corroded_heaven_debris_block', count: 1 } },
                output: 'pure_heaven_debris_block', outputCount: 1
            },
			{ name: "Heaven Gate Brick Block",
                input: { 0: { type: 'pure_heaven_debris_block', count: 1 }, 1: { type: 'pure_heaven_debris_block', count: 1 }, 2: { type: 'pure_heaven_debris_block', count: 1 }, 3: { type: 'pure_heaven_debris_block', count: 1 }, 4: { type: 'pure_heaven_debris_block', count: 1 }, 5: { type: 'pure_heaven_debris_block', count: 1 }, 6: { type: 'pure_heaven_debris_block', count: 1 }, 7: { type: 'pure_heaven_debris_block', count: 1 }, 8: { type: 'pure_heaven_debris_block', count: 1 }, 9: { type: 'pure_heaven_debris_block', count: 1 }, 10: { type: 'pure_heaven_debris_block', count: 1 }, 11: { type: 'pure_heaven_debris_block', count: 1 }, 12: { type: 'pure_heaven_debris_block', count: 1 }, 13: { type: 'pure_heaven_debris_block', count: 1 }, 14: { type: 'pure_heaven_debris_block', count: 1}, 15: { type: 'pure_heaven_debris_block', count: 1 } },
                output: 'heaven_gate_brick_block', outputCount: 1
            },
			{ name: "Heaven Gate Brick Block",
                input: { 0: { type: 'pure_heaven_debris_block', count: 1 }, 1: { type: 'pure_heaven_debris_block', count: 1 }, 2: { type: 'pure_heaven_debris_block', count: 1 }, 3: { type: 'pure_heaven_debris_block', count: 1 }, 4: { type: 'pure_heaven_debris_block', count: 1 }, 5: { type: 'mighterrum_nugget', count: 1 }, 6: { type: 'mighterrum_nugget', count: 1 }, 7: { type: 'pure_heaven_debris_block', count: 1 }, 8: { type: 'pure_heaven_debris_block', count: 1 }, 9: { type: 'mighterrum_nugget', count: 1 }, 10: { type: 'mighterrum_nugget', count: 1 }, 11: { type: 'pure_heaven_debris_block', count: 1 }, 12: { type: 'pure_heaven_debris_block', count: 1 }, 13: { type: 'pure_heaven_debris_block', count: 1 }, 14: { type: 'pure_heaven_debris_block', count: 1}, 15: { type: 'pure_heaven_debris_block', count: 1 } },
                output: 'heaven_gate_brick_block', outputCount: 1
            },
			{ name: "Heaven Gate Brick Block",
                input: { 0: { type: 'ruin_heaven_gate_brick_block', count: 1 }, 1: { type: 'pure_heaven_debris_block', count: 1 }, 4: { type: 'pure_heaven_debris_block', count: 1 }, 5: { type: 'pure_heaven_debris_block', count: 1 } },
                output: 'heaven_gate_brick_block', outputCount: 1
            },
			{ name: "Impure Infinitungsten Nugget",
                input: { 0: { type: 'hellsteel_nugget', count: 1 }, 1: { type: 'hellsteel_nugget', count: 1 }, 2: { type: 'heavensteel_nugget', count: 1 }, 3: { type: 'heavensteel_nugget', count: 1 }, 4: { type: 'hellsteel_nugget', count: 1 }, 5: { type: 'hellsteel_nugget', count: 1 }, 6: { type: 'heavensteel_nugget', count: 1 }, 7: { type: 'heavensteel_nugget', count: 1 }, 8: { type: 'hellsteel_nugget', count: 1 }, 9: { type: 'hellsteel_nugget', count: 1 }, 10: { type: 'heavensteel_nugget', count: 1 }, 11: { type: 'heavensteel_nugget', count: 1 }, 12: { type: 'hellsteel_nugget', count: 1 }, 13: { type: 'hellsteel_nugget', count: 1 }, 14: { type: 'heavensteel_nugget', count: 1}, 15: { type: 'heavensteel_nugget', count: 1 } },
                output: 'impure_infinitungsten_nugget', outputCount: 1
            },
			{ name: "Power Orb",
                input: { 0: { type: 'diamond_nugget', count: 1 }, 1: { type: 'topaz_nugget', count: 1 }, 2: { type: 'sapphire_nugget', count: 1 }, 3: { type: 'ruby_nugget', count: 1 }, 4: { type: 'emerald_nugget', count: 1 }, 5: { type: 'opal_nugget', count: 1 }, 6: { type: 'amethyst_nugget', count: 1 }, 7: { type: 'jade_nugget', count: 1 }, 8: { type: 'gold_nugget', count: 1 }, 9: { type: 'tin_nugget', count: 1 }, 10: { type: 'aluminum_nugget', count: 1 }, 11: { type: 'iron_nugget', count: 1 }, 12: { type: 'copper_nugget', count: 1 }, 13: { type: 'zinc_nugget', count: 1 }, 14: { type: 'palladium_nugget', count: 1}, 15: { type: 'tungsten_nugget', count: 1 } },
                output: 'power_orb', outputCount: 1
            },
            { name: "Impotent Orb",
                input: { 0: { type: 'power_orb', count: 1 }, 1: { type: 'nuclear_core', count: 1 } },
                output: 'impotent_orb', outputCount: 3
            },
			{ name: "Power Soup",
                input: { 0: { type: 'wooden_bowl', count: 2 }, 1: { type: 'power_orb', count: 1 } },
                output: 'power_soup', outputCount: 2
            },
			{ name: "Powered Wooden Pickaxe",
                input: { 0: { type: 'wooden_pickaxe', count: 1 }, 1: { type: 'power_orb', count: 1 } },
                output: 'powered_wooden_pickaxe', outputCount: 1,
            },
			{ name: "World Mover",
                input: { 0: { type: 'red_sand_block', count: 1 }, 3: { type: 'red_sand_block', count: 1 }, 12: { type: 'red_sand_block', count: 1 }, 15: { type: 'red_sand_block', count: 1 }, 5: { type: 'infinitungsten_nugget', count: 1 }, 6: { type: 'infinitungsten_nugget', count: 1 }, 9: { type: 'infinitungsten_nugget', count: 1 }, 10: { type: 'infinitungsten_nugget', count: 1 } },
                output: 'world_mover', outputCount: 1
            },
            { name: "Mechageezer: Trailer",
                input: { 0: { type: 'copper_nugget', count: 1 }, 1: { type: 'dirt', count: 1 } },
                output: 'trailer', outputCount: 12,
            },
			{ name: "Mechageezer: Stone Trailer",
                input: { 0: { type: 'trailer', count: 1 }, 1: { type: 'stone', count: 1 } },
                output: 'stone_trailer', outputCount: 1,
            },
            { name: "Mechageezer: Reactant",
                input: { 0: { type: 'copper_nugget', count: 1 }, 1: { type: 'pure_fuel', count: 1 } },
                output: 'reactant', outputCount: 1,
            },
            { name: "Mechageezer: Lever",
                input: { 0: { type: 'planked_oak', count: 1 }, 1: { type: 'stone', count: 1 }, 2: { type: 'compacted_stone', count: 1 }, 3: { type: 'copper_nugget', count: 1 } },
                output: 'lever_off', outputCount: 1,
            },
			{ name: "Mechageezer: Chest Lever",
                input: { 0: { type: 'lever_off', count: 1 }, 1: { type: 'chest', count: 1 } },
                output: 'chest_lever_off', outputCount: 1,
            },
            { name: "Napalm Bomb",
                input: { 0: { type: 'paper', count: 1 }, 1: { type: 'paper', count: 1 }, 2: { type: 'paper', count: 1 }, 3: { type: 'paper', count: 1 }, 4: { type: 'paper', count: 1 }, 5: { type: 'cup_of_crude_oil', count: 1 }, 6: { type: 'cup_of_crude_oil', count: 1 }, 7: { type: 'paper', count: 1 }, 8: { type: 'paper', count: 1 }, 9: { type: 'cup_of_crude_oil', count: 1 }, 10: { type: 'cup_of_crude_oil', count: 1 }, 11: { type: 'paper', count: 1 }, 12: { type: 'paper', count: 1 }, 13: { type: 'paper', count: 1 }, 14: { type: 'paper', count: 1 }, 15: { type: 'paper', count: 1 } },
                output: 'napalm_bomb', outputCount: 1
            },
            { name: "Dynamite Bomb",
                input: { 0: { type: 'sand', count: 1 }, 1: { type: 'paper', count: 1 }, 2: { type: 'paper', count: 1 }, 3: { type: 'red_sand_block', count: 1 }, 4: { type: 'paper', count: 1 }, 5: { type: 'nitro_powder', count: 1 }, 6: { type: 'nitro_powder', count: 1 }, 7: { type: 'paper', count: 1 }, 8: { type: 'paper', count: 1 }, 9: { type: 'nitro_powder', count: 1 }, 10: { type: 'nitro_powder', count: 1 }, 11: { type: 'paper', count: 1 }, 12: { type: 'red_sand_block', count: 1 }, 13: { type: 'paper', count: 1 }, 14: { type: 'paper', count: 1 }, 15: { type: 'sand', count: 1 } },
                output: 'dynamite_bomb', outputCount: 1
            },
            { name: "Octogen Bomb",
                input: { 0: { type: 'nitro_powder', count: 1 }, 1: { type: 'paper', count: 1 }, 2: { type: 'paper', count: 1 }, 3: { type: 'nitro_powder', count: 1 }, 4: { type: 'paper', count: 1 }, 5: { type: 'nitro_powder', count: 1 }, 6: { type: 'nitro_powder', count: 1 }, 7: { type: 'paper', count: 1 }, 8: { type: 'paper', count: 1 }, 9: { type: 'nitro_powder', count: 1 }, 10: { type: 'nitro_powder', count: 1 }, 11: { type: 'paper', count: 1 }, 12: { type: 'nitro_powder', count: 1 }, 13: { type: 'paper', count: 1 }, 14: { type: 'paper', count: 1 }, 15: { type: 'nitro_powder', count: 1 } },
                output: 'octogen_bomb', outputCount: 1
            },
            { name: "Weak Nuclear Bomb",
                input: { 0: { type: 'nuclear_core', count: 1 }, 1: { type: 'copper_brick_block', count: 1 }, 2: { type: 'copper_brick_block', count: 1 }, 3: { type: 'copper_brick_block', count: 1 } },
                output: 'weak_nuclear_bomb', outputCount: 1
            },
            { name: "Subnuclear Bomb",
                input: { 0: { type: 'weak_nuclear_bomb', count: 1 }, 1: { type: 'gold_brick_block', count: 1 }, 2: { type: 'gold_brick_block', count: 1 }, 3: { type: 'gold_brick_block', count: 1 } },
                output: 'subnuclear_bomb', outputCount: 1
            },
            { name: "Nuclear Bomb",
                input: { 0: { type: 'subnuclear_bomb', count: 1 }, 1: { type: 'nuclear_core', count: 1 }, 2: { type: 'nuclear_core', count: 1 }, 3: { type: 'nuclear_core', count: 1 } },
                output: 'nuclear_bomb', outputCount: 1
            },
			{ name: "Trap Stone",
                input: { 0: { type: 'dynamite_bomb', count: 1 }, 1: { type: 'stone', count: 1 } },
                output: 'trap_stone', outputCount: 1,
            },
			{ name: "Trap Compacted Stone",
                input: { 0: { type: 'octogen_bomb', count: 1 }, 1: { type: 'compacted_stone', count: 1 } },
                output: 'trap_compacted_stone', outputCount: 1,
            },
			{ name: "Trap Compressed Stone",
                input: { 0: { type: 'weak_nuclear_bomb', count: 1 }, 1: { type: 'compressed_stone', count: 1 } },
                output: 'trap_compressed_stone', outputCount: 1,
            },
			{ name: "Machine Gun",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 2: { type: 'nitro_powder', count: 1 }, 4: { type: 'steel_nugget', count: 1 }, 5: { type: 'steel_nugget', count: 1 }, 6: { type: 'steel_nugget', count: 1 }, 7: { type: 'steel_nugget', count: 1 }, 8: { type: 'steel_nugget', count: 1 }, 9: { type: 'vulcanized_rubber', count: 1 } },
                output: 'machine_gun', outputCount: 1,
            },
			{ name: "Blue Concrete Block",
                input: { 0: { type: 'concrete', count: 3 }, 1: { type: 'blue_flower', count: 1 } },
                output: 'blue_concrete', outputCount: 3,
            },
			{ name: "Purple Concrete Block",
                input: { 0: { type: 'concrete', count: 3 }, 1: { type: 'purple_flower', count: 1 } },
                output: 'purple_concrete', outputCount: 3,
            },
			{ name: "Pink Concrete Block",
                input: { 0: { type: 'concrete', count: 3 }, 1: { type: 'milkweed', count: 1 } },
                output: 'pink_concrete', outputCount: 3,
            },
			{ name: "Red Concrete Block",
                input: { 0: { type: 'concrete', count: 3 }, 1: { type: 'red_flower', count: 1 } },
                output: 'red_concrete', outputCount: 3,
            },
			{ name: "Orange Concrete Block",
                input: { 0: { type: 'concrete', count: 3 }, 1: { type: 'orange_flower', count: 1 } },
                output: 'orange_concrete', outputCount: 3,
            },
			{ name: "Yellow Concrete Block",
                input: { 0: { type: 'concrete', count: 3 }, 1: { type: 'yellow_flower', count: 1 } },
                output: 'yellow_concrete', outputCount: 3,
            },
			{ name: "Green Concrete Block",
                input: { 0: { type: 'concrete', count: 3 }, 1: { type: 'green_flower', count: 1 } },
                output: 'green_concrete', outputCount: 3,
            },
			{ name: "Cyan Concrete Block",
                input: { 0: { type: 'concrete', count: 3 }, 1: { type: 'blue_flower', count: 1 }, 2: { type: 'green_flower', count: 1 } },
                output: 'cyan_concrete', outputCount: 3,
            },
			{ name: "Blue Dark Concrete Block",
                input: { 0: { type: 'dark_concrete', count: 3 }, 1: { type: 'blue_flower', count: 1 } },
                output: 'blue_dark_concrete', outputCount: 3,
            },
			{ name: "Purple Dark Concrete Block",
                input: { 0: { type: 'dark_concrete', count: 3 }, 1: { type: 'purple_flower', count: 1 } },
                output: 'purple_dark_concrete', outputCount: 3,
            },
			{ name: "Pink Dark Concrete Block",
                input: { 0: { type: 'dark_concrete', count: 3 }, 1: { type: 'milkweed', count: 1 } },
                output: 'pink_dark_concrete', outputCount: 3,
            },
			{ name: "Red Dark Concrete Block",
                input: { 0: { type: 'dark_concrete', count: 3 }, 1: { type: 'red_flower', count: 1 } },
                output: 'red_dark_concrete', outputCount: 3,
            },
			{ name: "Orange Dark Concrete Block",
                input: { 0: { type: 'dark_concrete', count: 3 }, 1: { type: 'orange_flower', count: 1 } },
                output: 'orange_dark_concrete', outputCount: 3,
            },
			{ name: "Yellow Dark Concrete Block",
                input: { 0: { type: 'dark_concrete', count: 3 }, 1: { type: 'yellow_flower', count: 1 } },
                output: 'yellow_dark_concrete', outputCount: 3,
            },
			{ name: "Green Dark Concrete Block",
                input: { 0: { type: 'dark_concrete', count: 3 }, 1: { type: 'green_flower', count: 1 } },
                output: 'green_dark_concrete', outputCount: 3,
            },
			{ name: "Cyan Dark Concrete Block",
                input: { 0: { type: 'dark_concrete', count: 3 }, 1: { type: 'blue_flower', count: 1 }, 2: { type: 'green_flower', count: 1 } },
                output: 'cyan_dark_concrete', outputCount: 3,
            },
			{ name: "Blue Light Concrete Block",
                input: { 0: { type: 'light_concrete', count: 3 }, 1: { type: 'blue_flower', count: 1 } },
                output: 'blue_light_concrete', outputCount: 3,
            },
			{ name: "Purple Light Concrete Block",
                input: { 0: { type: 'light_concrete', count: 3 }, 1: { type: 'purple_flower', count: 1 } },
                output: 'purple_light_concrete', outputCount: 3,
            },
			{ name: "Pink Light Concrete Block",
                input: { 0: { type: 'light_concrete', count: 3 }, 1: { type: 'milkweed', count: 1 } },
                output: 'pink_light_concrete', outputCount: 3,
            },
			{ name: "Red Light Concrete Block",
                input: { 0: { type: 'light_concrete', count: 3 }, 1: { type: 'red_flower', count: 1 } },
                output: 'red_light_concrete', outputCount: 3,
            },
			{ name: "Orange Light Concrete Block",
                input: { 0: { type: 'light_concrete', count: 3 }, 1: { type: 'orange_flower', count: 1 } },
                output: 'orange_light_concrete', outputCount: 3,
            },
			{ name: "Yellow Light Concrete Block",
                input: { 0: { type: 'light_concrete', count: 3 }, 1: { type: 'yellow_flower', count: 1 } },
                output: 'yellow_light_concrete', outputCount: 3,
            },
			{ name: "Green Light Concrete Block",
                input: { 0: { type: 'light_concrete', count: 3 }, 1: { type: 'green_flower', count: 1 } },
                output: 'green_light_concrete', outputCount: 3,
            },
			{ name: "Cyan Light Concrete Block",
                input: { 0: { type: 'light_concrete', count: 3 }, 1: { type: 'blue_flower', count: 1 }, 2: { type: 'green_flower', count: 1 } },
                output: 'cyan_light_concrete', outputCount: 3,
            },
        ];
		const anvilRecipes = [
			{ name: "Rock Block",
                input: { 0: { type: 'stone', count: 1 }, 1: { type: 'magma_stone_block', count: 1 } },
				anvilPower: 1,
                output: 'rock_block', outputCount: 1,
            },
			{
				name: "Sandstone",
				input: { 0: { type: 'sand', count: 4 } },
				anvilPower: 1,
				output: 'sandstone', outputCount: 1
			},
			{
				name: "Red Sandstone",
				input: { 0: { type: 'red_sand_block', count: 4 } },
				anvilPower: 1,
				output: 'red_sandstone_block', outputCount: 1
			},
			{ name: "Compacted Stone Block",
                input: { 0: { type: 'stone', count: 1 }, 1: { type: 'stone', count: 1 }, 2: { type: 'stone', count: 1 }, 3: { type: 'stone', count: 1 }, 5: { type: 'stone', count: 1 }, 6: { type: 'stone', count: 1 } },
				anvilPower: 1,
                output: 'compacted_stone', outputCount: 1,
            },
			{ name: "Compacted Stone Block",
                input: { 0: { type: 'compressed_stone', count: 1 } },
				anvilPower: 1,
                output: 'compacted_stone', outputCount: 4,
            },
			{
				name: "Wood Bullets (x25)",
				input: { 0: { type: 'any_plank', count: 1 }, 1: { type: 'saltpeter', count: 1 }, 2: { type: 'saltpeter', count: 1 } },
				anvilPower: 1,
				output: 'wood_bullet', outputCount: 25
			},
            {
				name: "Brass Bullets (x25)",
				input: { 0: { type: 'brass_nugget', count: 1 }, 1: { type: 'saltpeter', count: 1 }, 2: { type: 'saltpeter', count: 1 } },
				anvilPower: 1,
				output: 'brass_bullet', outputCount: 25
			},
            {
				name: "Steel Bullets (x25)",
				input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'saltpeter', count: 1 }, 2: { type: 'saltpeter', count: 1 } },
				anvilPower: 1,
				output: 'steel_bullet', outputCount: 25
			},
            {
				name: "Mythicalithium Bullets (x25)",
				input: { 0: { type: 'mythicalithium_nugget', count: 1 }, 1: { type: 'saltpeter', count: 1 }, 2: { type: 'saltpeter', count: 1 } },
				anvilPower: 1,
				output: 'mythicalithium_bullet', outputCount: 25
			},
			{ name: "Armor Tile",
                input: { 0: { type: 'any_plank', count: 1 }, 1: { type: 'clay', count: 1 } },
				anvilPower: 2,
                output: 'armor_tile', outputCount: 1,
            },
			{ name: "Armor Tile",
                input: { 0: { type: 'any_plank', count: 1 }, 1: { type: 'taiga_dirt', count: 1 } },
				anvilPower: 2,
                output: 'armor_tile', outputCount: 1,
            },
			{ name: "Compressed Stone Block",
                input: { 0: { type: 'compacted_stone', count: 1 }, 1: { type: 'compacted_stone', count: 1 }, 2: { type: 'compacted_stone', count: 1 }, 3: { type: 'compacted_stone', count: 1 }, 5: { type: 'compacted_stone', count: 1 }, 6: { type: 'compacted_stone', count: 1 } },
				anvilPower: 2,
                output: 'compressed_stone', outputCount: 1,
            },
			{ name: "Compressed Stone Block",
                input: { 0: { type: 'bedrock_stone', count: 1 } },
				anvilPower: 2,
                output: 'compressed_stone', outputCount: 4,
            },
			{ name: "Compressed Stone Block",
                input: { 0: { type: 'compressed_stone', count: 1 }, 1: { type: 'compressed_stone', count: 1 }, 2: { type: 'compressed_stone', count: 1 }, 3: { type: 'compressed_stone', count: 1 }, 5: { type: 'compressed_stone', count: 1 }, 6: { type: 'compressed_stone', count: 1 } },
				anvilPower: 3,
                output: 'bedrock_stone', outputCount: 1,
            },
		];
		const ovenRecipes = [
            { name: "Wheat Bread",
                input: { 0: { type: 'wheat_item', count: 1 }, 1: { type: 'wheat_item', count: 1 }, 2: { type: 'wheat_item', count: 1 } },
				fuel: 1,
                output: 'wheat_bread', outputCount: 1,
            },
			{ name: "Barley Bread",
                input: { 0: { type: 'barley_item', count: 1 }, 1: { type: 'barley_item', count: 1 }, 2: { type: 'barley_item', count: 1 } },
				fuel: 1,
                output: 'barley_bread', outputCount: 1,
            },
			{ name: "Cooked Beef",
                input: { 0: { type: 'beef', count: 1 } },
				fuel: 1,
                output: 'cooked_beef', outputCount: 1,
            },
			{ name: "Cooked Pork",
                input: { 0: { type: 'pork', count: 1 } },
				fuel: 1,
                output: 'cooked_pork', outputCount: 1,
            },
			{ name: "Vulcanized Rubber Block",
                input: { 0: { type: 'raw_rubber', count: 1 } },
				fuel: 1,
                output: 'vulcanized_rubber', outputCount: 1,
            },
			{ name: "Dry Paper",
				input: { 0: { type: 'soggy_paper', count: 1 } },
				fuel: 1,
				output: 'paper', outputCount: 1,
			},
			{ name: "Bulk Dry Paper",
				input: { 0: { type: 'soggy_paper', count: 5 }, 1: { type: 'soggy_paper', count: 5 } },
				fuel: 1,
				output: 'paper', outputCount: 10,
			},
			{ name: "Raw Sugar",
                input: { 0: { type: 'sugarcane', count: 1 }  },
				fuel: 1,
                output: 'raw_sugar', outputCount: 3,
				byproduct: 'molasses', byproductCount: 1,
            },
			{ name: "Refined Sugar",
                input: { 0: { type: 'raw_sugar', count: 1 }, 1: { type: 'raw_sugar', count: 1 }, 3: { type: 'raw_sugar', count: 1 }, 4: { type: 'raw_sugar', count: 1 }  },
				fuel: 1,
                output: 'refined_sugar', outputCount: 3,
				byproduct: 'molasses', byproductCount: 1,
            },
			{ name: "Cup Of Purified Water",
                input: { 0: { type: 'glass_cup', count: 1 }, 1: {type: 'ice', count: 1} },
                fuel: 1,
				output: 'cup_of_water', outputCount: 1,
            },
			{ name: "Cup Of Purified Water",
                input: { 0: { type: 'cup_of_urine', count: 1 } },
                fuel: 1,
				output: 'cup_of_water', outputCount: 1,
            },
			{ name: "Saltpeter",
                input: { 0: { type: 'cup_of_urine', count: 5 } },
                fuel: 1,
				output: 'saltpeter', outputCount: 1,
				byproduct: 'glass_cup', byproductCount: 5,
            },
			{ name: "Cup Of Coffee",
                input: { 0: { type: 'cup_of_water', count: 1 }, 1: { type: 'coffee_bean', count: 1 }, 2: { type: 'coffee_bean', count: 1 }, 3: { type: 'coffee_bean', count: 1 }, 4: { type: 'coffee_bean', count: 1 }, 5: { type: 'coffee_bean', count: 1 } },
                fuel: 1,
				output: 'cup_of_coffee', outputCount: 1,
            },
            { name: "Cup Of Pine Needle Tea",
                input: { 0: { type: 'cup_of_water', count: 1 }, 1: { type: 'pine_needle_living', count: 1 }, 2: { type: 'pine_needle_living', count: 1 }, 3: { type: 'pine_needle_living', count: 1 }, 4: { type: 'pine_needle_living', count: 1 }, 5: { type: 'pine_needle_living', count: 1 } },
                fuel: 1,
				output: 'cup_of_pine_needle_tea', outputCount: 1,
            },
			{ name: "Noodles",
                input: { 0: { type: 'cup_of_water', count: 1 }, 1: { type: 'flour', count: 1 }, 2: { type: 'flour', count: 1 }, 3: { type: 'iodized_salt', count: 1 } },
                fuel: 1,
				output: 'noodles', outputCount: 1,
            },
			{ name: "Ramen Noodles",
                input: { 0: { type: 'wooden_bowl', count: 1 }, 1: { type: 'cup_of_water', count: 1 }, 2: { type: 'iodized_salt', count: 1 }, 3: { type: 'chili_pepper', count: 1 }, 4: { type: 'garlic_item', count: 1 }, 5: { type: 'onion_item', count: 1 }, 6: { type: 'noodles', count: 1 }, 7: { type: 'egg', count: 1 }, 8: { type: 'noodles', count: 1 } },
                fuel: 1,
				output: 'ramen_noodles', outputCount: 1,
				byproduct: 'glass_cup', outputCount: 1,
            },
			{ name: "Spaghetti And Marinara",
                input: { 0: { type: 'wooden_bowl', count: 1 }, 1: { type: 'cup_of_water', count: 1 }, 2: { type: 'iodized_salt', count: 1 }, 3: { type: 'tomato', count: 1 }, 4: { type: 'garlic_item', count: 1 }, 5: { type: 'tomato', count: 1 }, 6: { type: 'noodles', count: 1 }, 7: { type: 'cooked_pork', count: 1 }, 8: { type: 'noodles', count: 1 } },
                fuel: 1,
				output: 'spaghetti', outputCount: 1,
				byproduct: 'glass_cup', outputCount: 1,
            },
			{ name: "Cake",
                input: { 0: { type: 'flour', count: 1 }, 1: { type: 'egg', count: 1 }, 2: { type: 'flour', count: 1 }, 3: { type: 'raw_sugar', count: 1 }, 4: { type: 'butter', count: 1 }, 5: { type: 'raw_sugar', count: 1 }, 7: { type: 'cup_of_milk', count: 1 } },
                fuel: 2,
				output: 'cake', outputCount: 1,
				byproduct: 'glass_cup', byproductCount: 1
            },
			{ name: "Pumpkin Pie",
                input: { 0: { type: 'cinnamon', count: 1 }, 1: { type: 'egg', count: 1 }, 2: { type: 'cinnamon', count: 1 }, 3: { type: 'refined_sugar', count: 1 }, 4: { type: 'butter', count: 1 }, 5: { type: 'refined_sugar', count: 1 }, 6: { type: 'pumpkin', count: 1 }, 7: { type: 'cup_of_milk', count: 1 }, 8: { type: 'pumpkin', count: 1 } },
                fuel: 2,
				output: 'pumpkin_pie', outputCount: 1,
				byproduct: 'glass_cup', byproductCount: 1
            },
		];
		const furnaceRecipes = [
            { name: "Glass Block",
                input: { 0: { type: 'sand', count: 1 } },
				fuel: 1,
                output: 'glass_block', outputCount: 2,
            },
			{ name: "Concrete Block",
                input: { 0: { type: 'limestone', count: 1 }, 1: { type: 'gravel', count: 1 }, 2: { type: 'sand', count: 1 }, 3: { type: 'limestone', count: 1 }, 4: { type: 'gravel', count: 1 }, 5: { type: 'sand', count: 1 }, 6: { type: 'limestone', count: 1 }, 7: { type: 'gravel', count: 1 }, 8: { type: 'sand', count: 1 } },
				fuel: 1,
                output: 'concrete', outputCount: 6
            },
			{ name: "Dark Concrete Block",
                input: { 0: { type: 'concrete', count: 5 }, 1: { type: 'ash_block', count: 1 } },
				fuel: 1,
                output: 'dark_concrete', outputCount: 1
            },
			{ name: "Light Concrete Block",
                input: { 0: { type: 'concrete', count: 5 }, 1: { type: 'bone_block', count: 1 } },
				fuel: 1,
                output: 'light_concrete', outputCount: 1
            },
			{ name: "Infinitungsten Nugget",
                input: { 0: { type: 'impure_infinitungsten_nugget', count: 1 }, 1: { type: 'tungsten_nugget', count: 1 } },
				fuel: 3,
                output: 'infinitungsten_nugget', outputCount: 1,
            },
			{ name: "Cup Of Gasoline",
                input: { 0: { type: 'cup_of_crude_oil', count: 1 } },
				fuel: 1,
                output: 'cup_of_gasoline', outputCount: 1,
            },
            { name: "Nuclear Core",
                input: { 0: { type: 'stone_brick_block', count: 1 }, 1: { type: 'stone_brick_block', count: 1 }, 2: { type: 'stone_brick_block', count: 1 }, 3: { type: 'stone_brick_block', count: 1 }, 4: { type: 'infinitungsten_nugget', count: 1 }, 5: { type: 'stone_brick_block', count: 1 }, 6: { type: 'stone_brick_block', count: 1 }, 7: { type: 'stone_brick_block', count: 1 }, 8: { type: 'stone_brick_block', count: 1 } },
				fuel: 5,
                output: 'nuclear_core', outputCount: 1
            },
			{ name: "Mythicalithium Nugget",
                input: { 0: { type: 'infinitungsten_nugget', count: 1 }, 1: { type: 'mighterrum_nugget', count: 1 }, 2: { type: 'infinitungsten_nugget', count: 1 } },
				fuel: 3,
                output: 'mythicalithium_nugget', outputCount: 1,
            },
		];
        const forgeRecipes = [
            { name: "Steel Helmet",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 2: { type: 'steel_nugget', count: 1 }, 3: { type: 'steel_nugget', count: 1 }, 4: { type: 'armor_tile', count: 1 }, 5: { type: 'steel_nugget', count: 1 } },
				fuel: 1,
                output: 'steel_helmet', outputCount: 1,
            },
            { name: "Steel Chestplate",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 2: { type: 'steel_nugget', count: 1 }, 3: { type: 'steel_nugget', count: 1 }, 4: { type: 'armor_tile', count: 1 }, 5: { type: 'steel_nugget', count: 1 }, 6: { type: 'steel_nugget', count: 1 }, 7: { type: 'steel_nugget', count: 1 }, 8: { type: 'steel_nugget', count: 1 } },
				fuel: 1,
                output: 'steel_chestplate', outputCount: 1,
            },
            { name: "Steel Pants",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 2: { type: 'steel_nugget', count: 1 }, 3: { type: 'steel_nugget', count: 1 }, 4: { type: 'armor_tile', count: 1 }, 5: { type: 'steel_nugget', count: 1 }, 6: { type: 'steel_nugget', count: 1 }, 8: { type: 'steel_nugget', count: 1 } },
				fuel: 1,
                output: 'steel_pants', outputCount: 1,
            },
            { name: "Steel Boots",
                input: { 3: { type: 'steel_nugget', count: 1 }, 4: { type: 'armor_tile', count: 1 }, 5: { type: 'steel_nugget', count: 1 }, 6: { type: 'steel_nugget', count: 1 }, 7: { type: 'steel_nugget', count: 1 }, 8: { type: 'steel_nugget', count: 1 } },
				fuel: 1,
                output: 'steel_boots', outputCount: 1,
            },
			{ name: "Diviniron Helmet",
                input: { 0: { type: 'diviniron_nugget', count: 1 }, 1: { type: 'diviniron_nugget', count: 1 }, 2: { type: 'diviniron_nugget', count: 1 }, 3: { type: 'diviniron_nugget', count: 1 }, 4: { type: 'armor_tile', count: 1 }, 5: { type: 'diviniron_nugget', count: 1 } },
				fuel: 1,
                output: 'diviniron_helmet', outputCount: 1,
            },
			{ name: "Diviniron Chestplate",
                input: { 0: { type: 'diviniron_nugget', count: 1 }, 1: { type: 'diviniron_nugget', count: 1 }, 2: { type: 'diviniron_nugget', count: 1 }, 3: { type: 'diviniron_nugget', count: 1 }, 4: { type: 'armor_tile', count: 1 }, 5: { type: 'diviniron_nugget', count: 1 }, 6: { type: 'diviniron_nugget', count: 1 }, 7: { type: 'diviniron_nugget', count: 1 }, 8: { type: 'diviniron_nugget', count: 1 } },
				fuel: 1,
                output: 'diviniron_chestplate', outputCount: 1,
            },
            { name: "Diviniron Pants",
                input: { 0: { type: 'diviniron_nugget', count: 1 }, 1: { type: 'diviniron_nugget', count: 1 }, 2: { type: 'diviniron_nugget', count: 1 }, 3: { type: 'diviniron_nugget', count: 1 }, 4: { type: 'armor_tile', count: 1 }, 5: { type: 'diviniron_nugget', count: 1 }, 6: { type: 'diviniron_nugget', count: 1 }, 8: { type: 'diviniron_nugget', count: 1 } },
				fuel: 1,
                output: 'diviniron_pants', outputCount: 1,
            },
            { name: "Diviniron Boots",
                input: { 3: { type: 'diviniron_nugget', count: 1 }, 4: { type: 'armor_tile', count: 1 }, 5: { type: 'diviniron_nugget', count: 1 }, 6: { type: 'diviniron_nugget', count: 1 }, 7: { type: 'diviniron_nugget', count: 1 }, 8: { type: 'diviniron_nugget', count: 1 } },
				fuel: 1,
                output: 'diviniron_boots', outputCount: 1,
            },
			{ name: "Dark Helmet",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 2: { type: 'steel_nugget', count: 1 }, 3: { type: 'steel_nugget', count: 1 }, 4: { type: 'dark_armor_tile', count: 1 }, 5: { type: 'steel_nugget', count: 1 } },
				fuel: 1,
                output: 'dark_helmet', outputCount: 1,
            },
            { name: "Dark Chestplate",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 2: { type: 'steel_nugget', count: 1 }, 3: { type: 'steel_nugget', count: 1 }, 4: { type: 'dark_armor_tile', count: 1 }, 5: { type: 'steel_nugget', count: 1 }, 6: { type: 'steel_nugget', count: 1 }, 7: { type: 'steel_nugget', count: 1 }, 8: { type: 'steel_nugget', count: 1 } },
				fuel: 1,
                output: 'dark_chestplate', outputCount: 1,
            },
            { name: "Dark Pants",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 2: { type: 'steel_nugget', count: 1 }, 3: { type: 'steel_nugget', count: 1 }, 4: { type: 'dark_armor_tile', count: 1 }, 5: { type: 'steel_nugget', count: 1 }, 6: { type: 'steel_nugget', count: 1 }, 8: { type: 'steel_nugget', count: 1 } },
				fuel: 1,
                output: 'dark_pants', outputCount: 1,
            },
            { name: "Dark Boots",
                input: { 3: { type: 'steel_nugget', count: 1 }, 4: { type: 'dark_armor_tile', count: 1 }, 5: { type: 'steel_nugget', count: 1 }, 6: { type: 'steel_nugget', count: 1 }, 7: { type: 'steel_nugget', count: 1 }, 8: { type: 'steel_nugget', count: 1 } },
				fuel: 1,
                output: 'dark_boots', outputCount: 1,
            },
            { name: "Light Helmet",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 2: { type: 'steel_nugget', count: 1 }, 3: { type: 'steel_nugget', count: 1 }, 4: { type: 'light_armor_tile', count: 1 }, 5: { type: 'steel_nugget', count: 1 } },
				fuel: 1,
                output: 'light_helmet', outputCount: 1,
            },
            { name: "Light Chestplate",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 2: { type: 'steel_nugget', count: 1 }, 3: { type: 'steel_nugget', count: 1 }, 4: { type: 'light_armor_tile', count: 1 }, 5: { type: 'steel_nugget', count: 1 }, 6: { type: 'steel_nugget', count: 1 }, 7: { type: 'steel_nugget', count: 1 }, 8: { type: 'steel_nugget', count: 1 } },
				fuel: 1,
                output: 'light_chestplate', outputCount: 1,
            },
            { name: "Light Pants",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 2: { type: 'steel_nugget', count: 1 }, 3: { type: 'steel_nugget', count: 1 }, 4: { type: 'light_armor_tile', count: 1 }, 5: { type: 'steel_nugget', count: 1 }, 6: { type: 'steel_nugget', count: 1 }, 8: { type: 'steel_nugget', count: 1 } },
				fuel: 1,
                output: 'light_pants', outputCount: 1,
            },
            { name: "Light Boots",
                input: { 3: { type: 'steel_nugget', count: 1 }, 4: { type: 'light_armor_tile', count: 1 }, 5: { type: 'steel_nugget', count: 1 }, 6: { type: 'steel_nugget', count: 1 }, 7: { type: 'steel_nugget', count: 1 }, 8: { type: 'steel_nugget', count: 1 } },
				fuel: 1,
                output: 'light_boots', outputCount: 1,
            },
		];
		const traderTrades = [
			// Money For Trade
            { input: { type: 'apple', count: 17 }, output: { type: 'bronze_coin', count: 15 } },
            { input: { type: 'wheat_item', count: 17 }, output: { type: 'gold_coin', count: 5 } },
            // Tools For Trade
            { input: { type: 'topaz_nugget', count: 2 }, output: { type: 'iron_pickaxe', count: 1 } },
            { input: { type: 'coal', count: 20 }, output: { type: 'rock_pickaxe', count: 1 } },
            { input: { type: 'planked_oak', count: 35 }, output: { type: 'iron_axe', count: 1 } },
			{ input: { type: 'zinc_nugget', count: 5 }, output: { type: 'iron_shovel', count: 1 } },
			{ input: { type: 'armor_tile', count: 25 }, output: { type: 'pistol', count: 1 } },
			// Nuggets For Trade
            { input: { type: 'hellrock', count: 30 }, output: { type: 'heavensteel_nugget', count: 1 } },
			{ input: { type: 'cloud_rock_block', count: 30 }, output: { type: 'hellsteel_nugget', count: 1 } },
			{ input: { type: 'hellsteel_nugget', count: 10 }, output: { type: 'heavensteel_nugget', count: 5 } },
			{ input: { type: 'heavensteel_nugget', count: 10 }, output: { type: 'hellsteel_nugget', count: 5 } },
			{ input: { type: 'infinitungsten_nugget', count: 4 }, output: { type: 'mythicalithium_nugget', count: 1 } },
			{ input: { type: 'book', count: 25 }, output: { type: 'impure_infinitungsten_nugget', count: 1 } },
            // Seed For Trade
            { input: { type: 'refrigerator', count: 1 }, output: { type: 'chili_pepper_seeds', count: 8 } },
            { input: { type: 'oven', count: 1 }, output: { type: 'coffee_seeds', count: 8 } },
            { input: { type: 'bed', count: 1 }, output: { type: 'corn_seeds', count: 8 } },
            // Food For Sale
            { input: { type: 'bronze_coin', count: 3 }, output: { type: 'prickly_pear_fruit', count: 5 } },
            { input: { type: 'gold_coin', count: 2 }, output: { type: 'tomato_sandwich', count: 1 } },
			{ input: { type: 'compressed_stone', count: 15 }, output: { type: 'pumpkin_pie', count: 1 } },
            // Food For Trade
            // Miscalleneous For Sale
            { input: { type: 'bronze_coin', count: 1 }, output: { type: 'grass_seeds', count: 5 } },
            { input: { type: 'gold_coin', count: 2 }, output: { type: 'oak_bush', count: 40 } },
            { input: { type: 'bronze_coin', count: 4 }, output: { type: 'trailer', count: 25 } },
            { input: { type: 'gold_coin', count: 200 }, output: { type: 'nuclear_core', count: 1 } },
            { input: { type: 'bronze_coin', count: 25 }, output: { type: 'glass_cup', count: 5 } },
            // Miscalleneous For Trade
            { input: { type: 'diviniron_nugget', count: 13 }, output: { type: 'colony_heart', count: 1 } },
			{ input: { type: 'mighterrum_nugget', count: 1 }, output: { type: 'clay', count: 10 } },
			{ input: { type: 'stone', count: 12 }, output: { type: 'watchtower_stone_block', count: 1 } },
			{ input: { type: 'stone', count: 15 }, output: { type: 'powertower_stone_block', count: 1 } },
            // Civilization Blocks For Trade
            { input: { type: 'cactus_block', count: 25 }, output: { type: 'asphalt', count: 5 } },
			{ input: { type: 'pest', count: 20 }, output: { type: 'concrete', count: 5 } },
			// Butter
			{ input: { type: 'dirt', count: 120 }, output: { type: 'butter', count: 1 } },
		];
		const level2TraderTrades = [
			{ input: { type: 'gold_coin', count: 50 }, output: { type: 'diamond_nugget', count: 1 } },
			{ input: { type: 'steel_pickaxe', count: 1 }, output: { type: 'ruby_plated_steel_pickaxe', count: 1 } }
			// ... add 5 or more trades here
		];
        const farmerTraderTrades = [
			{ input: { type: 'bronze_coin', count: 5 }, output: { type: 'wheat_seeds', count: 10 } },
			{ input: { type: 'bronze_coin', count: 5 }, output: { type: 'cotton_seeds', count: 10 } },
			{ input: { type: 'gold_coin', count: 1 }, output: { type: 'pumpkin_seeds', count: 8 } },
			{ input: { type: 'apple', count: 15 }, output: { type: 'fertilizer', count: 5 } },
			{ input: { type: 'gold_coin', count: 10 }, output: { type: 'refrigerator', count: 1 } },
		];

		const minerTraderTrades = [
			{ input: { type: 'gold_coin', count: 2 }, output: { type: 'coal', count: 25 } },
			{ input: { type: 'iron_nugget', count: 10 }, output: { type: 'rock_pickaxe', count: 1 } },
			{ input: { type: 'gold_coin', count: 8 }, output: { type: 'iron_pickaxe', count: 1 } },
			{ input: { type: 'diamond_nugget', count: 6 }, output: { type: 'emerald_nugget', count: 3 } },
			{ input: { type: 'wooden_stick', count: 30 }, output: { type: 'planked_oak', count: 9 } },
		];

		// This defines our trader types, their appearance, and their trades.
		const traderTypes = [
			{ name: 'Trader', imgSrc: 'Trader.png', trades: traderTrades },
			{ name: 'Farmer', imgSrc: 'Farmer Trader.png', trades: farmerTraderTrades },
			{ name: 'Miner', imgSrc: 'Miner Trader.png', trades: minerTraderTrades },
			{ name: 'Full_Trader', imgSrc: 'Full Trader.png', trades: minerTraderTrades },
		];
		
		// Choose N random trades (no duplicates)
		function pickRandomTradesFromPool(count = 5) {
			if (!Array.isArray(traderTrades) || traderTrades.length === 0) return [];
			const pool = traderTrades.slice();
			const picks = [];
			for (let i = 0; i < Math.min(count, pool.length); i++) {
				const idx = Math.floor(random() * pool.length);
				picks.push(JSON.parse(JSON.stringify(pool[idx]))); // deep copy
				pool.splice(idx, 1);
			}
			return picks;
		}

		// Place a vertical 1x3 trader at (col,row) such that `row` is the bottom block row.
		// Returns true if placed.
		function placeTraderAt(col, row, presetTrades = null) {
            // Ensure the three vertical spots (row, row-1, row-2) are replaceable
			if (!replaceableBlocks.includes(getBlockType(col, row)) || 
                !replaceableBlocks.includes(getBlockType(col, row - 1)) || 
                !replaceableBlocks.includes(getBlockType(col, row - 2))) {
                return false;
            }

			// Can't place inside player
			const placementRect = { x: col * tileSize, y: row * tileSize - (tileSize * 2), width: tileSize, height: tileSize * 3 };
			const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };
			if (rectIntersects(playerRect, placementRect)) return false;

			const trades = presetTrades || pickRandomTradesFromPool(5);

			worldBlocks[`${col},${row}`]     = { type: 'trader', part: 'bottom', mineProg: 0, trades: trades };
			worldBlocks[`${col},${row-1}`]   = { type: 'trader', part: 'middle', mineProg: 0 };
			worldBlocks[`${col},${row-2}`]   = { type: 'trader', part: 'top', mineProg: 0 };
			return true;
		}

        let craftingGridSlots = new Array(16).fill(null);

        function toggleInventoryMenu() {
            if (gameMenuOverlay.style.display === 'flex' && !isGamePaused) return;
            isGamePaused = !isGamePaused;
            if (isGamePaused) {
                inventoryCraftingOverlay.style.display = 'flex';
                updateInventoryMenu();
                renderRecipes();
				// --- NEW Recipe Sidebar Logic ---
                const recipeSearch = document.getElementById('recipeSearchInput');
                const recipeList = document.getElementById('recipeListContainer');
                const recipeIcons = document.getElementById('recipeIconContainer');
                const listToggle = document.getElementById('recipeViewToggleList');
                const iconToggle = document.getElementById('recipeViewToggleIcons');
                
                // Search listener
                recipeSearch.oninput = () => {
                    renderRecipes(recipeSearch.value);
                    // Ensure the current view is maintained after search
                    const isIconView = recipeIcons.style.display === 'grid';
                    recipeList.style.display = isIconView ? 'none' : 'block';
                    recipeIcons.style.display = isIconView ? 'grid' : 'none';
                };
				recipeSearch.onkeydown = (e) => e.stopPropagation();
                
                // Toggle listeners
                listToggle.onclick = () => {
                    recipeList.style.display = 'block';
                    recipeIcons.style.display = 'none';
                    listToggle.classList.add('active');
                    iconToggle.classList.remove('active');
                };
                iconToggle.onclick = () => {
                    recipeList.style.display = 'none';
                    recipeIcons.style.display = 'grid';
                    listToggle.classList.remove('active');
                    iconToggle.classList.add('active');
                };
                
                // Set initial state
                if (recipeIcons.style.display !== 'grid') {
                    listToggle.click(); // Default to list view
                }
                // --- END Recipe Sidebar Logic ---
            } else {
                inventoryCraftingOverlay.style.display = 'none';
                // Return crafting items to inventory
                for(let i = 0; i < craftingGridSlots.length; i++) {
                    const slot = craftingGridSlots[i];
                    if (slot && slot.type && slot.count > 0) {
                        addToInventory(slot.type, slot.count, slot.durability);
                        craftingGridSlots[i] = null;
                    }
                }
                // Return held item to inventory
                if (heldItem) {
                    addToInventory(heldItem.type, heldItem.count, heldItem.durability);
                    heldItem = null;
                    heldItemSource = { type: null, index: -1 };
                }
                lastTime = performance.now();
            }
        }

        function updateInventoryMenu() {
            playerInventoryGrid.innerHTML = '';
            inventoryHotbarGrid.innerHTML = '';
            const armorGrid = document.getElementById('armorGrid');
            const paperDollDiv = document.getElementById('paperDoll'); // Get the paper doll
            armorGrid.innerHTML = '';
            paperDollDiv.innerHTML = ''; // Clear previously drawn armor
            
            // Hotbar section in the inventory menu
            for (let i = 0; i < hotbarSize; i++) {
                const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
                slotDiv.classList.add('hotbar-slot');
                inventoryHotbarGrid.appendChild(slotDiv);
            }
            // Main inventory section
            for (let i = hotbarSize; i < totalInventorySlots; i++) {
                const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
                playerInventoryGrid.appendChild(slotDiv);
            }
            
            // --- NEW: Render Armor Slots ---
            const armorSlotOrder = ['helmet', 'chestGear', 'legGear', 'boots'];
            let totalProtection = 0;

            for (const slotKey of armorSlotOrder) {
                const armorItem = player.armor[slotKey];
                const slotDiv = createInventorySlot(armorItem, slotKey, 'armor');
                
                // Add a placeholder background
                slotDiv.style.backgroundImage = 'Dark Boots.png'; // ... (keep all placeholder styles) ...
                slotDiv.style.backgroundSize = '32px 32px';
                slotDiv.style.backgroundPosition = 'center';
                slotDiv.style.backgroundRepeat = 'no-repeat';
                slotDiv.style.opacity = '0.7';
                
                if (armorItem) {
                    const itemProps = itemTypes[armorItem.type];
                    if (itemProps && itemProps.protectionFactor) {
                        totalProtection += itemProps.protectionFactor;
                    }
                    slotDiv.style.opacity = '1.0'; // Full opacity if item is present

                    // --- NEW: Draw armor on paper doll ---
                    const equippedAssetKey = `${armorItem.type}_equipped`;
                    const armorImgAsset = assets[equippedAssetKey];

                    if (armorImgAsset && !failedAssets[equippedAssetKey]) {
                        const imgElement = document.createElement('img');
                        imgElement.src = armorImgAsset.src;
                        imgElement.classList.add('paper-doll-armor');
						const zForArmorType = {
						  'helmet': 40,
						  'chestGear': 30,
						  'legGear': 10,
						  'boots': 20
						};
						imgElement.style.position = 'absolute';    // ensure z-index works reliably
						imgElement.style.zIndex = zForArmorType[slotKey] ?? 0;
                        paperDollDiv.appendChild(imgElement);
                    }
                }
                
                armorGrid.appendChild(slotDiv);
            }

            // Update Protection Display
            const protectionDisplay = document.getElementById('totalProtectionDisplay');
            protectionDisplay.textContent = `${(totalProtection * 100).toFixed(0)}%`;
            // --- END NEW ---

            // Crafting grid section
            craftingGridDiv.innerHTML = '';
            for (let i = 0; i < 16; i++) {
                const slotDiv = createInventorySlot(craftingGridSlots[i], i, 'crafting');
                craftingGridDiv.appendChild(slotDiv);
            }
            // Delete Slot
            /*deleteSlot.addEventListener('mousedown', (e) => {
				e.stopPropagation();
				e.preventDefault();
				handleSlotClick(e);
			});*/ // Removed From Excessive LAG

            checkCraftingRecipe();
        }

        function createInventorySlot(itemObject, slotIndex, sourceType) {
			const slot = document.createElement('div');
			slot.classList.add('inventory-slot');
			slot.dataset.slotIndex = slotIndex;
			slot.dataset.sourceType = sourceType;

            // --- 1. Standard Mouse Listener (for Desktop) ---
			slot.addEventListener('mousedown', (e) => {
				e.stopPropagation();
				e.preventDefault();
				handleSlotClick(e);
			});

            // --- 2. NEW: Touch Listeners (for Mobile "Hold-to-Split") ---
            let touchTimer = null;
            let touchMoved = false;

            slot.addEventListener('touchstart', (e) => {
                // Only run this logic if we are in a menu
                if (isGamePaused) {
                    e.stopPropagation(); // Stop canvas from getting this touch
                    // e.preventDefault(); // <-- REMOVED: This was blocking the scroll
                    touchMoved = false;
                    
                    // Start a timer. If it fires, it's a long press (right-click)
                    touchTimer = setTimeout(() => {
                        e.preventDefault(); // Prevent scroll *now* that we know it's a hold
                        handleSlotClick({ 
                            currentTarget: slot, 
                            button: 2, // 2 = Right Click
                            preventDefault: () => {}, 
                            stopPropagation: () => {} 
                        });
                        touchTimer = null; // Mark as fired
                    }, 800); // CHANGED: 300ms to 800ms
                }
            }, { passive: false });

            slot.addEventListener('touchmove', (e) => {
                if (touchTimer) {
                    touchMoved = true;
                    clearTimeout(touchTimer); // Cancel long press if finger drags
                    touchTimer = null;
                }
            }, { passive: false });

            slot.addEventListener('touchend', (e) => {
                if (isGamePaused) {
                    e.stopPropagation();
                    
                    if (touchTimer) { // It was a tap
                        clearTimeout(touchTimer);
                        touchTimer = null;
                        if (!touchMoved) {
                            e.preventDefault(); // Prevent ghost click
                            // Fire a simulated Left-Click
                            handleSlotClick({ 
                                currentTarget: slot, 
                                button: 0, // 0 = Left Click
                                preventDefault: () => {}, 
                                stopPropagation: () => {} 
                            });
                        }
                    } else if (!touchMoved) { // It was a long press that already fired
                        e.preventDefault(); // FIX: Prevent the ghost click
                    }
                    // If touchMoved, we don't preventDefault, allowing the scroll to finish.
                }
            }, { passive: false });
            // --- END OF NEW TOUCH LOGIC ---


			// --- Tooltip Hover Events (for Desktop) ---
			slot.onmouseenter = (e) => {
                if (itemObject) {
                    const itemProps = itemTypes[itemObject.type] || blockTypes[itemObject.type]; // Get props
                    let itemName;

                    if (itemProps && itemProps.isBook) { // Check if it's a book
                        if (itemObject.published && itemObject.title) {
                            itemName = itemObject.title; // Show custom title
                        } else {
                            itemName = "Book (Editable)";
                        }
                    } else {
                        // Original logic
                        itemName = (itemObject.type.replace(/_/g, ' ')).replace(/\b\w/g, l => l.toUpperCase());
                        if (itemProps && itemProps.isTool && itemObject.durability !== undefined) {
                            itemName += ` (${Math.ceil(itemObject.durability)} / ${itemObject.maxDurability})`;
                        }
                    }
            
                    itemTooltip.textContent = itemName;
                    itemTooltip.style.display = 'block';
                }
            };
			slot.onmouseleave = (e) => {
				itemTooltip.style.display = 'none';
			};

            // --- Rest of the function (drawing the slot) ---
            if (sourceType === 'delete') {
                slot.id = 'deleteSlot';
                slot.innerHTML = 'X';
                return slot;
            }

            if (heldItemSource.type === sourceType && heldItemSource.index === slotIndex) {
                slot.style.backgroundColor = '#888';
            }

            if (itemObject && itemObject.type && itemObject.count > 0) {
                const itemProps = itemTypes[itemObject.type] || blockTypes[itemObject.type];
                const itemImg = assets[itemObject.type];
                if (itemImg && !failedAssets[itemObject.type]) {
                    const imgElement = document.createElement('img');
                    imgElement.src = itemImg.src;
                    slot.appendChild(imgElement);
                } else if (itemProps?.color) {
                    const fallbackDiv = document.createElement('div');
                    fallbackDiv.classList.add('fallback');
                    fallbackDiv.style.backgroundColor = itemProps.color;
                    fallbackDiv.textContent = itemObject.type.substring(0, 3).toUpperCase();
                    slot.appendChild(fallbackDiv);
                }
                const countSpan = document.createElement('span');
                countSpan.classList.add('item-count');
                countSpan.textContent = itemObject.count;
                slot.appendChild(countSpan);
                if (itemProps?.isTool && itemObject.durability !== null && itemObject.durability !== undefined) {
                    const durabilityBar = document.createElement('div');
                    durabilityBar.classList.add('durability-bar');
                    const durabilityFill = document.createElement('div');
                    durabilityFill.classList.add('durability-fill');
                    const durabilityRatio = itemObject.durability / itemObject.maxDurability;
                    durabilityFill.style.width = `${Math.max(0, durabilityRatio * 100)}%`;
                    durabilityFill.style.backgroundColor = durabilityRatio > 0.6 ? '#28a745' : (durabilityRatio > 0.3 ? '#ffc107' : '#dc3545');
                    durabilityBar.appendChild(durabilityFill);
                    slot.appendChild(durabilityBar);
                }
            }
            return slot;
        }

        function handleSlotClick(event) {
			event.preventDefault();
			const slotDiv = event.currentTarget;
			const sourceType = slotDiv.dataset.sourceType;
			const slotIndex = slotDiv.dataset.slotIndex; // This is a number for inventory, or a string key for armor

            // --- NEW: Right-click to Equip/De-equip ---
            if (event.button === 2) { // Right-click
                if (sourceType === 'inventory') {
					const itemToEquip = inventorySlots[slotIndex]; // Get item in slot (or null)
					
					// --- FIX: Logic is re-ordered ---
					
					// 1. CHECK FOR PLACING AN ITEM (if we are holding one)
					if (heldItem !== null) {
						if (heldItem.count > 0) {
							if (!itemToEquip) {
								// Placing into an EMPTY slot
								const timestamps = (itemTypes[heldItem.type]?.spoilable && Array.isArray(heldItem.acquiredTimes)) ? [heldItem.acquiredTimes.shift()] : (itemTypes[heldItem.type]?.spoilable ? [gameTime] : null);
								inventorySlots[slotIndex] = { type: heldItem.type, count: 1 };
								if (itemTypes[heldItem.type]?.isTool) {
									inventorySlots[slotIndex].durability = heldItem.durability ?? (itemTypes[heldItem.type]?.maxDurability ?? null);
									inventorySlots[slotIndex].maxDurability = heldItem.maxDurability ?? (itemTypes[heldItem.type]?.maxDurability ?? null);
								} else if (timestamps) {
									inventorySlots[slotIndex].acquiredTimes = timestamps.slice();
								}
								heldItem.count--;
							} else if (itemToEquip.type === heldItem.type && !(itemTypes[heldItem.type] || blockTypes[heldItem.type])?.isTool && itemToEquip.count < maxStackSize) {
								// Merging one into an existing stack
								const ts = (itemTypes[heldItem.type]?.spoilable && Array.isArray(heldItem.acquiredTimes)) ? heldItem.acquiredTimes.shift() : (itemTypes[heldItem.type]?.spoilable ? gameTime : null);
								itemToEquip.count++;
								if (ts) {
									if (!Array.isArray(itemToEquip.acquiredTimes)) _ensureAcquiredTimes(itemToEquip, gameTime);
									itemToEquip.acquiredTimes.push(ts);
								}
								heldItem.count--;
							}
							if (heldItem.count <= 0) {
								heldItem = null; heldItemSource = { type: null, index: -1 };
							}
						}
					} 
					// 2. CHECK FOR EQUIPPING ARMOR (if we are NOT holding an item)
					else if (itemToEquip && itemTypes[itemToEquip.type] && itemTypes[itemToEquip.type].armorType) {
						const itemProps = itemTypes[itemToEquip.type];
						const targetSlotKey = itemProps.armorType;
						
						// Swap item in armor slot with item in inventory
						const previouslyEquipped = player.armor[targetSlotKey];
						player.armor[targetSlotKey] = itemToEquip;
						inventorySlots[slotIndex] = previouslyEquipped; // Put old item back
						
						if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
						syncHotbarIndices();

                        const a = player.armor;
                        if (a.helmet && a.chestGear && a.legGear && a.boots) {
                            unlockAchievement('FULL_SET');
                            if (a.helmet.type.startsWith('steel_') &&
                                a.chestGear.type.startsWith('steel_') &&
                                a.legGear.type.startsWith('steel_') &&
                                a.boots.type.startsWith('steel_')) {
                                unlockAchievement('STEEL_PLATED');
                            }
                            if (a.helmet.type.startsWith('diviniron_') &&
                                a.chestGear.type.startsWith('diviniron_') &&
                                a.legGear.type.startsWith('diviniron_') &&
                                a.boots.type.startsWith('diviniron_')) {
                                unlockAchievement('DIVINE_PROTECTION');
                            }
                        }
					}
					// 3. CHECK FOR PICKING UP HALF (if we are NOT holding an item)
					else if (itemToEquip && itemToEquip.count > 1) {
						// Pick up half
						const halfCount = Math.ceil(itemToEquip.count / 2);
						const timestamps = itemTypes[itemToEquip.type]?.spoilable ? _takeTimestamps(itemToEquip, halfCount) : null;
						heldItem = {
							type: itemToEquip.type,
							count: halfCount,
							durability: itemToEquip.durability,
							maxDurability: itemToEquip.maxDurability,
							acquiredTimes: timestamps
						};
						itemToEquip.count -= halfCount;
						if (itemToEquip.count <= 0) inventorySlots[slotIndex] = null;
						heldItemSource = { type: sourceType, index: slotIndex };
					}
				} else if (sourceType === 'armor') {
                    // Right-click to de-equip
                    const itemToDequip = player.armor[slotIndex];
                    if (!itemToDequip) return;

                    // Use addToInventory to find the first available slot
                    if (addToInventory(itemToDequip.type, 1, itemToDequip.durability, itemToDequip.acquiredTimes)) {
                         player.armor[slotIndex] = null;
                         if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
                         syncHotbarIndices();
                    }
                } else if (sourceType === 'crafting' || sourceType === 'chest' || sourceType === 'oven' || sourceType === 'magma_furnace' || sourceType === 'power_forge' || sourceType === 'world_mover_fuel' || sourceType === 'anvil') {
                    // --- Handle right-click splitting for other containers ---
                    let sourceArray;
                    if (sourceType === 'crafting') sourceArray = craftingGridSlots;
                    else if (sourceType === 'anvil') sourceArray = anvilGridSlots; // ADD THIS
                    else if (sourceType === 'chest') sourceArray = worldBlocks[`${currentlyOpenChest.col},${currentlyOpenChest.row}`]?.inventory;
                    else if (sourceType === 'oven' || sourceType === 'magma_furnace' || sourceType === 'power_forge') sourceArray = worldBlocks[`${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`]?.inventory;
                    else if (sourceType === 'world_mover_fuel') sourceArray = worldBlocks[`${currentlyOpenWorldMover.col},${currentlyOpenWorldMover.row}`]?.inventory;
                    
                    if (!sourceArray) return;
                    const clickedSlotItem = sourceArray[slotIndex];

                    if (heldItem === null) {
                        // pick up half
                        if (clickedSlotItem && clickedSlotItem.count > 1) {
                            const halfCount = Math.ceil(clickedSlotItem.count / 2);
                            const timestamps = itemTypes[clickedSlotItem.type]?.spoilable ? _takeTimestamps(clickedSlotItem, halfCount) : null;
                            heldItem = {
                                type: clickedSlotItem.type,
                                count: halfCount,
                                durability: clickedSlotItem.durability,
                                maxDurability: clickedSlotItem.maxDurability,
                                acquiredTimes: timestamps
                            };
                            clickedSlotItem.count -= halfCount;
                            if (clickedSlotItem.count <= 0) sourceArray[slotIndex] = null;
                            heldItemSource = { type: sourceType, index: slotIndex };
                        }
                    } else { // place one from heldItem
                        if (heldItem.count > 0) {
                            // If placing one into the fuel slot, check if it's fuel
                            if (heldItem && (sourceType === 'oven' || sourceType === 'magma_furnace' || sourceType === 'power_forge') && slotIndex == 9 && heldItem.type !== 'pure_fuel') {
                                return; 
                            }
                            if (heldItem && sourceType === 'world_mover_fuel' && slotIndex == 0 && heldItem.type !== 'pure_fuel') {
                                return;
                            }

                            if (!clickedSlotItem) {
                                // create a single-unit slot
                                const timestamps = (itemTypes[heldItem.type]?.spoilable && Array.isArray(heldItem.acquiredTimes)) ? [heldItem.acquiredTimes.shift()] : (itemTypes[heldItem.type]?.spoilable ? [gameTime] : null);
                                sourceArray[slotIndex] = { type: heldItem.type, count: 1 };
                                if (itemTypes[heldItem.type]?.isTool) {
                                    sourceArray[slotIndex].durability = heldItem.durability ?? (itemTypes[heldItem.type]?.maxDurability ?? null);
                                    sourceArray[slotIndex].maxDurability = heldItem.maxDurability ?? (itemTypes[heldItem.type]?.maxDurability ?? null);
                                } else if (timestamps) {
                                    sourceArray[slotIndex].acquiredTimes = timestamps.slice();
                                }
                                heldItem.count--;
                            } else if (clickedSlotItem.type === heldItem.type && !(itemTypes[heldItem.type] || blockTypes[heldItem.type])?.isTool && clickedSlotItem.count < maxStackSize) {
                                // merge one into existing stack
                                const ts = (itemTypes[heldItem.type]?.spoilable && Array.isArray(heldItem.acquiredTimes)) ? heldItem.acquiredTimes.shift() : (itemTypes[heldItem.type]?.spoilable ? gameTime : null);
                                clickedSlotItem.count++;
                                if (ts) {
                                    if (!Array.isArray(clickedSlotItem.acquiredTimes)) _ensureAcquiredTimes(clickedSlotItem, gameTime);
                                    clickedSlotItem.acquiredTimes.push(ts);
                                }
                                heldItem.count--;
                            }
                            if (heldItem.count <= 0) {
                                heldItem = null; heldItemSource = { type: null, index: -1 };
                            }
                        }
                    }
                    // --- End of right-click splitting for other containers ---
                }
                
                // Update UI after right-click
                if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
                if (chestOverlay.style.display === 'flex') updateChestMenu();
                if (ovenOverlay.style.display === 'flex') updateFurnaceMenu();
				if (anvilOverlay.style.display === 'flex') updateAnvilMenu();
                if (voidChestOverlay.style.display === 'flex') updateVoidChestMenu();
                if (worldMoverConfigOverlay.style.display === 'flex') updateWorldMoverMenu();
                syncHotbarIndices();
                return; // End right-click handling
            }

            // --- Shift-Click Logic ---
            if (event.shiftKey) {
                let sourceArray, sourceItem, sourceSlotNumericIndex;
                let moved = false;
        
                if (sourceType === 'inventory') {
                    sourceArray = inventorySlots;
                    sourceSlotNumericIndex = parseInt(slotIndex);
                    sourceItem = sourceArray[sourceSlotNumericIndex];
                } else if (sourceType === 'chest') {
                    sourceArray = worldBlocks[`${currentlyOpenChest.col},${currentlyOpenChest.row}`]?.inventory;
                    sourceSlotNumericIndex = parseInt(slotIndex);
                    sourceItem = sourceArray ? sourceArray[sourceSlotNumericIndex] : null;
                } else if (sourceType === 'oven' || sourceType === 'magma_furnace' || sourceType === 'power_forge') {
                    sourceArray = worldBlocks[`${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`]?.inventory;
                } else if (sourceType === 'anvil') { // ADD THIS
                    sourceArray = anvilGridSlots;
                } else if (sourceType === 'armor') {
                    sourceSlotNumericIndex = parseInt(slotIndex);
                    sourceItem = sourceArray ? sourceArray[sourceSlotNumericIndex] : null;
                } else if (sourceType === 'armor') {
                    // Shift-clicking an armor slot
                    sourceItem = player.armor[slotIndex]; // slotIndex is 'helmet', etc.
                    if (!sourceItem) return;
                    
                    // Try to move it to main inventory
                    if (addToInventory(sourceItem.type, 1, sourceItem.durability, sourceItem.acquiredTimes, inventorySlots)) {
                        player.armor[slotIndex] = null;
                        moved = true;
                    }
                }
        
                if (!sourceItem) return;

                if (sourceType === 'inventory' || sourceType === 'chest' || sourceType === 'oven' || sourceType === 'magma_furnace' || sourceType === 'power_forge') {
                    // Check if it's armor and try to equip it
                    const itemProps = itemTypes[sourceItem.type];
                    if (itemProps && itemProps.armorType) {
                        const targetSlotKey = itemProps.armorType;
                        if (player.armor[targetSlotKey] === null) { // Equip only if slot is empty
                            player.armor[targetSlotKey] = sourceItem;
                            sourceArray[sourceSlotNumericIndex] = null;
                            moved = true;
                        }
                        // Note: We don't handle swapping with shift-click, just equipping to empty slot.
                    } else if (currentlyOpenAnvil) { // ADD THIS BLOCK
                        // Move between player inventory and anvil grid
                        const destinationArray = (sourceType === 'inventory') ? anvilGridSlots : inventorySlots;
                        if (addToInventory(sourceItem.type, sourceItem.count, sourceItem.durability, sourceItem.acquiredTimes, destinationArray)) {
                             sourceArray[sourceSlotNumericIndex] = null;
                             moved = true;
                        }
                    } else if (currentlyOpenChest) {
                        // Standard shift-click logic for chests
                        const destinationArray = (sourceType === 'inventory') ? worldBlocks[`${currentlyOpenChest.col},${currentlyOpenChest.row}`].inventory : inventorySlots;
                        if (addToInventory(sourceItem.type, sourceItem.count, sourceItem.durability, sourceItem.acquiredTimes, destinationArray)) {
                             sourceArray[sourceSlotNumericIndex] = null;
                             moved = true;
                        }
                    } else if (currentlyOpenFurnace) {
                         // Your existing shift-click furnace logic
                        let sourceSlot = sourceArray[sourceSlotNumericIndex];
                        let destinationArray = worldBlocks[`${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`].inventory;

                        if (sourceType === 'inventory') { // Player -> Furnace
                            if (sourceSlot.type === 'pure_fuel') {
                                let fuelSlot = destinationArray[9];
                                if (!fuelSlot) {
                                    destinationArray[9] = sourceSlot;
                                    sourceArray[sourceSlotNumericIndex] = null;
                                } else if (fuelSlot.type === 'pure_fuel' && fuelSlot.count < maxStackSize) {
                                    const space = maxStackSize - fuelSlot.count;
                                    const amountToMove = Math.min(sourceSlot.count, space);
                                    fuelSlot.count += amountToMove;
                                    sourceSlot.count -= amountToMove;
                                    if (sourceSlot.count <= 0) sourceArray[sourceSlotNumericIndex] = null;
                                }
                            } else { // Try to move to input slots
                                let remaining = sourceSlot.count;
                                for (let i = 0; i < 9; i++) {
                                    let inputSlot = destinationArray[i];
                                    if (inputSlot && inputSlot.type === sourceSlot.type && inputSlot.count < maxStackSize) {
                                        const space = maxStackSize - inputSlot.count;
                                        const amountToMove = Math.min(remaining, space);
                                        inputSlot.count += amountToMove;
                                        remaining -= amountToMove;
                                        sourceSlot.count = remaining;
                                        if (remaining <= 0) {
                                            sourceArray[sourceSlotNumericIndex] = null;
                                            break;
                                        }
                                    }
                                }
                                if (remaining > 0 && sourceArray[sourceSlotNumericIndex]) {
                                    for (let i = 0; i < 9; i++) {
                                        if (!destinationArray[i]) {
                                            destinationArray[i] = sourceSlot;
                                            sourceArray[sourceSlotNumericIndex] = null;
                                            break;
                                        }
                                    }
                                }
                            }
                        } else { // Furnace -> Player
                            if (addToInventory(sourceItem.type, sourceItem.count, sourceItem.durability, sourceItem.acquiredTimes, inventorySlots)) {
                                sourceArray[sourceSlotNumericIndex] = null;
                            }
                        }
                         moved = true; // Assume move was attempted
                    } else if (inventoryCraftingOverlay.style.display === 'flex') {
                        // Move between hotbar and main inventory
                         const targetIsHotbar = sourceSlotNumericIndex >= hotbarSize;
                         let movedToEmpty = false;
                         for (let i = 0; i < (targetIsHotbar ? hotbarSize : (inventorySlots.length - hotbarSize)); i++) {
                            const destinationIndex = targetIsHotbar ? i : hotbarSize + i;
                            if (destinationIndex >= inventorySlots.length) break;
                            if (!inventorySlots[destinationIndex]) {
                                inventorySlots[destinationIndex] = sourceItem;
                                sourceArray[sourceSlotNumericIndex] = null;
                                moved = true;
                                movedToEmpty = true;
                                break;
                            }
                        }
                        // If no empty slot, just return (or you could add merge logic here)
                        if (!movedToEmpty) return;
                    }
                }
                
                // Update all relevant UI elements
                if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
                if (chestOverlay.style.display === 'flex') updateChestMenu();
                if (ovenOverlay.style.display === 'flex') updateFurnaceMenu();
				if (anvilOverlay.style.display === 'flex') updateAnvilMenu();
				if (voidChestOverlay.style.display === 'flex') updateVoidChestMenu();
                syncHotbarIndices();
                return; // End the function here for shift-clicks
            }
            
            // --- Standard Left-Click Drag/Drop Logic ---

			if (sourceType === 'delete') {
				if (heldItem) {
					addToVoidStorage(heldItem.type, heldItem.count, heldItem.durability, heldItem.maxDurability);
					heldItem = null;
					heldItemSource = { type: null, index: -1 };
				}
				// Always update UI after a delete click
                if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
                if (chestOverlay.style.display === 'flex') updateChestMenu();
                if (ovenOverlay.style.display === 'flex') updateFurnaceMenu();
				if (anvilOverlay.style.display === 'flex') updateAnvilMenu();
                if (voidChestOverlay.style.display === 'flex') updateVoidChestMenu();
                if (worldMoverConfigOverlay.style.display === 'flex') updateWorldMoverMenu();
				return;
			}
            
            // Handle Void click logic separately
            if (sourceType === 'void') {
				// This intentionally prevents items from being picked up from the void.
				// Items can only be retrieved via the Void Trader.
				return;
			}

			let sourceArray;
            let sourceItem; // This will be a reference to the item in its slot
            
            // 1. Identify what we are clicking on
            if (sourceType === 'inventory') {
                sourceArray = inventorySlots;
                sourceItem = sourceArray[slotIndex];
            } else if (sourceType === 'crafting') {
                sourceArray = craftingGridSlots;
                sourceItem = sourceArray[slotIndex];
            } else if (sourceType === 'anvil') {
                sourceArray = anvilGridSlots;
            } else if (sourceType === 'armor') {
                sourceArray = player.armor;
                sourceItem = sourceArray[slotIndex]; // slotIndex is 'helmet', etc.
            } else if (sourceType === 'chest') {
				const chestData = worldBlocks[`${currentlyOpenChest.col},${currentlyOpenChest.row}`];
				if (chestData) sourceArray = chestData.inventory;
                sourceItem = sourceArray ? sourceArray[slotIndex] : null;
			} else if (sourceType === 'oven' || sourceType === 'magma_furnace' || sourceType === 'power_forge') {
                const furnaceData = worldBlocks[`${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`];
                if (furnaceData) sourceArray = furnaceData.inventory;
                sourceItem = sourceArray ? sourceArray[slotIndex] : null;
            } else if (sourceType === 'world_mover_fuel') {
                const moverData = worldBlocks[`${currentlyOpenWorldMover.col},${currentlyOpenWorldMover.row}`];
                if (moverData) sourceArray = moverData.inventory;
                sourceItem = sourceArray ? sourceArray[slotIndex] : null;
            }

			if (!sourceArray) return; // Safety check

            // 2. Handle the click logic
			if (heldItem === null) {
                // --- A. PICKING UP AN ITEM ---
				if (sourceItem) {
					heldItem = sourceItem; // Pick up the whole slot
                    sourceArray[slotIndex] = null; // Clear the source slot
					heldItemSource = { type: sourceType, index: slotIndex };
                    
                    // If taking from fridge, apply current gameTime to spoilage
                    if ((sourceType === 'chest' || sourceType === 'refrigerator' || sourceType === 'magical_chest') && itemTypes[heldItem.type]?.spoilable) {
						if (!Array.isArray(heldItem.acquiredTimes) || heldItem.acquiredTimes.length === 0) {
							heldItem.acquiredTimes = Array(heldItem.count).fill(gameTime);
						}
					}
				}
			} else {
                // --- B. PLACING AN ITEM ---

                // Special case: Placing into an armor slot
                if (sourceType === 'armor') {
                    const itemProps = itemTypes[heldItem.type];
                    // Is the held item the correct type for this armor slot?
                    if (itemProps && itemProps.armorType === slotIndex) {
                        // Yes. Swap the items.
                        sourceArray[slotIndex] = heldItem; // Place held item
                        heldItem = sourceItem; // Pick up whatever was there (even if null)
                        
                        if (heldItem === null) {
                            heldItemSource = { type: null, index: -1 };
                        } else {
                            heldItemSource = { type: sourceType, index: slotIndex };
                        }
                    }
                    // If invalid, do nothing (item stays on cursor)
                
                } else { // Standard inventory/grid/chest/oven logic
                    
                    // Prevent placing non-fuel in fuel slots
                    if (heldItem && (sourceType === 'oven' || sourceType === 'magma_furnace' || sourceType === 'power_forge') && slotIndex == 9 && heldItem.type !== 'pure_fuel') {
                         return; // Do nothing
                    }
                    if (heldItem && sourceType === 'world_mover_fuel' && slotIndex == 0 && heldItem.type !== 'pure_fuel') {
                        return; // Do nothing
                    }
                    
                    if (!sourceItem) {
                        // Placing into an empty slot
                        sourceArray[slotIndex] = heldItem;
                        
                        // If placing into fridge, remove spoilage timer
                        if ((sourceType === 'chest' || sourceType === 'refrigerator' || sourceType === 'magical_chest') && itemTypes[heldItem.type]?.spoilable) {
                            delete heldItem.acquiredTimes;
                        }

                        heldItem = null;
                        heldItemSource = { type: null, index: -1 };
                    } else if (sourceItem.type === heldItem.type && !(itemTypes[heldItem.type] || blockTypes[heldItem.type])?.isTool) {
                        // Merging stacks
                        const amountToTransfer = Math.min(heldItem.count, maxStackSize - sourceItem.count);
                        
                        if (itemTypes[heldItem.type]?.spoilable) {
                            if (!Array.isArray(sourceItem.acquiredTimes)) _ensureAcquiredTimes(sourceItem, gameTime);
							if (!Array.isArray(heldItem.acquiredTimes)) heldItem.acquiredTimes = Array(heldItem.count).fill(gameTime);
							
                            // If placing into fridge, don't transfer timestamps
                            if (sourceType !== 'chest' && sourceType !== 'refrigerator' && sourceType !== 'magical_chest') {
                                const transferringTimestamps = [];
                                for (let s = 0; s < amountToTransfer; s++) {
                                    transferringTimestamps.push(heldItem.acquiredTimes.shift() ?? gameTime);
                                }
                                sourceItem.acquiredTimes.push(...transferringTimestamps);
                            }
						}

						sourceItem.count += amountToTransfer;
						heldItem.count -= amountToTransfer;
						if (heldItem.count <= 0) {
							heldItem = null; heldItemSource = { type: null, index: -1 };
						}
                    } else {
                        // Swapping items
                        [heldItem, sourceArray[slotIndex]] = [sourceItem, heldItem];
                        heldItemSource = { type: sourceType, index: slotIndex };
                        
                        // Handle spoilage timers on swap
                        if (itemTypes[heldItem.type]?.spoilable && (sourceType === 'chest' || sourceType === 'refrigerator' || sourceType === 'magical_chest')) {
                            // Item leaving fridge needs a fresh timer
                            if (!Array.isArray(heldItem.acquiredTimes) || heldItem.acquiredTimes.length === 0) {
                                heldItem.acquiredTimes = Array(heldItem.count).fill(gameTime);
                            }
                        }
                        const placedItem = sourceArray[slotIndex];
                        if (itemTypes[placedItem.type]?.spoilable && (sourceType === 'chest' || sourceType === 'refrigerator' || sourceType === 'magical_chest')) {
                             // Item entering fridge loses its timer
                            delete placedItem.acquiredTimes;
                        }
                    }
                }
			}

			// 3. Update all UIs
			if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
			if (chestOverlay.style.display === 'flex') updateChestMenu();
			if (ovenOverlay.style.display === 'flex') updateFurnaceMenu();
			if (anvilOverlay.style.display === 'flex') updateAnvilMenu();
			if (voidChestOverlay.style.display === 'flex') updateVoidChestMenu();
			if (worldMoverConfigOverlay.style.display === 'flex') updateWorldMoverMenu();
			
            syncHotbarIndices();
		}

        function checkCraftingRecipe() {
            craftingOutputSlot.innerHTML = '';
            craftButton.disabled = true;
            craftButton.onclick = null;

            for (const recipe of recipes) {
                const requiredInput = recipe.input;
                const requiredKeys = Object.keys(requiredInput);
                const currentGridItems = {};
                let gridItemCount = 0;
                for(let i=0; i<16; i++) {
                    if(craftingGridSlots[i]) {
                        currentGridItems[i] = craftingGridSlots[i];
                        gridItemCount++;
                    }
                }

                if (requiredKeys.length !== gridItemCount) continue;

                let allMatch = true;

				for (const key of requiredKeys) {
					const required = requiredInput[key];
					const current = currentGridItems[key];

					// Check if the required item is missing or not enough count
					if (!current || current.count < required.count) {
						allMatch = false;
						break;
					}

					// Category: Any plank
					if (required.type === 'any_plank') {
						if (!current.type.startsWith('planked_')) {
							allMatch = false;
							break;
						}

					// Category: Any gilded item
					} else if (required.type === 'any_gilded') {
						if (
							!current.type.startsWith('gilded_') &&
							!current.type.startsWith('raw_gilded_') &&
							!current.type.startsWith('planked_gilded_')
						) {
							allMatch = false;
							break;
						}

					// Exact match (standard item type)
					} else if (current.type !== required.type) {
						allMatch = false;
						break;
					}
				}

                if (allMatch) {
                    const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
                    const outputSlotContent = createInventorySlot({ type: recipe.output, count: recipe.outputCount, durability: outputItemProps?.isTool ? outputItemProps.maxDurability : null, maxDurability: outputItemProps?.isTool ? outputItemProps.maxDurability : null }, -1, 'output');
                    craftingOutputSlot.appendChild(outputSlotContent);
                    craftButton.disabled = false;
                    craftButton.onclick = (event) => executeCraft(recipe, event.shiftKey);
                    return;
                }
            }
        }

        function executeCraft(recipe, isShiftClick = false) {
            let maxCrafts = 1;
        
            if (isShiftClick) {
                // 1. Calculate max crafts based on available materials
                let maxFromMaterials = Infinity;
                for (const key in recipe.input) {
                    const required = recipe.input[key];
                    const current = craftingGridSlots[key];
                    const possible = Math.floor(current.count / required.count);
                    if (possible < maxFromMaterials) {
                        maxFromMaterials = possible;
                    }
                }
        
                // 2. Calculate max crafts based on available inventory space
                let spaceAvailable = 0;
                const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
                if (outputItemProps.isTool) {
                     spaceAvailable = inventorySlots.filter(slot => !slot).length;
                } else {
                    inventorySlots.forEach(slot => {
                        if (!slot) {
                            spaceAvailable += maxStackSize;
                        } else if (slot.type === recipe.output) {
                            spaceAvailable += maxStackSize - slot.count;
                        }
                    });
                }
                const maxFromSpace = Math.floor(spaceAvailable / recipe.outputCount);
        
                // The true max is the smaller of the two limits
                maxCrafts = Math.min(maxFromMaterials, maxFromSpace);
            }
            
            if (maxCrafts <= 0) return;
        
			if (recipe.output === 'steel_brick_block') {
				unlockAchievement('DEDICATED_ONE');
			}
            if (recipe.output === 'hellsteel_pickaxe') {
				unlockAchievement('HELLFIRE_FORGED');
			}
            if (recipe.output === 'heavensteel_pickaxe') {
				unlockAchievement('HEAVEN_SENT');
			}
            if (recipe.output === 'mythicalithium_pickaxe') {
				unlockAchievement('MYTHICAL_MINER');
			}
            if (recipe.output === 'power_orb') {
    			unlockAchievement('ALCHEMIST');
    		}
            if (recipe.output === 'impotent_orb') {
    			unlockAchievement('MAD_SCIENTIST');
    		}
            if (recipe.output === 'book') {
    			unlockAchievement('BOOKWORM');
    		}
		
            // 3. Perform the craft loop
            for (let i = 0; i < maxCrafts; i++) {
                // Consume ingredients for one craft
                for (const key in recipe.input) {
                    const required = recipe.input[key];
                    const current = craftingGridSlots[key];
                    if(current) { // Check if item still exists before reducing count
                         current.count -= required.count;
                         if (current.count <= 0) craftingGridSlots[key] = null;
                    } else {
                        // This case should not be hit if maxCrafts is calculated correctly, but it's a safeguard
                        updateInventoryMenu();
                        return;
                    }
                }
                // Add one output to inventory
                const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
                addToInventory(recipe.output, recipe.outputCount, outputItemProps?.isTool ? outputItemProps.maxDurability : null);
            }
        
            // Refresh the UI once after all crafts are done
            updateInventoryMenu();
        }
		
		function normalizeForSearch(str) {
			if (!str && str !== 0) return '';
			str = String(str);
			// split camelCase (fooBar -> foo Bar)
			str = str.replace(/([a-z])([A-Z])/g, '$1 $2');
			// convert _ and - to spaces
			str = str.replace(/[_\-]+/g, ' ');
			// remove all non-alphanumeric (keep spaces)
			str = str.replace(/[^0-9a-zA-Z ]+/g, ' ');
			// collapse multiple spaces and trim
			str = str.replace(/\s+/g, ' ').trim();
			return str.toLowerCase();
		}
		
        function renderRecipes(filterText = '') {
            const recipeListDiv = document.getElementById('recipeListContainer'); // Find new container ID
            const iconContainer = document.getElementById('recipeIconContainer');
            recipeListDiv.innerHTML = '';
            iconContainer.innerHTML = '';
            
            const filterNormalized = normalizeForSearch(filterText);

			const filteredRecipes = recipes.filter(r => {
				// Normalize candidate strings
				const nameCandidate = normalizeForSearch(r.name || '');
				const outputCandidate = normalizeForSearch(r.output || '');
				// check name or output
				if ((nameCandidate && nameCandidate.includes(filterNormalized)) || (outputCandidate && outputCandidate.includes(filterNormalized))) {
					return true;
				}

				// Check ingredients (each r.input[i].type)
				for (const key in r.input) {
					const inputItem = r.input[key];
					if (!inputItem) continue;
					const inputTypeNorm = normalizeForSearch(inputItem.type || '');
					if (inputTypeNorm.includes(filterNormalized)) return true;
				}

				// Check fuel: allow matching "fuel", "pure fuel", "coal", etc. Normalize recipe.fuel type if available.
				// Some of your recipes store fuel as a count on pure_fuel; if you have a named fuel type, normalize it too.
				if (r.fuel) {
					// treat the word "fuel" specially: a user searching "fuel" should match recipes that require fuel
					if ('fuel'.includes(filterNormalized) && filterNormalized.length > 0) {
						// If the user typed only 'f' or 'fu' they'd matchavoid that by requiring the filter be at least 2 chars or exactly 'fuel'
						if (filterNormalized === 'fuel' || filterNormalized.length >= 2) {
							return true;
						}
					}
					// If you have explicit fuel type string (e.g., r.fuelType), check it:
					if (r.fuelType && normalizeForSearch(r.fuelType).includes(filterNormalized)) return true;
					// Also allow matching the literal token "pure_fuel"
					if (normalizeForSearch('pure_fuel').includes(filterNormalized)) return true;
				}

				// No match
				return false;
			});

            for (const recipe of filteredRecipes) {
                const recipeItemDiv = document.createElement('div');
                recipeItemDiv.classList.add('recipe-item');
                const inputGridDiv = document.createElement('div');
                inputGridDiv.classList.add('recipe-input-grid');
                const displayInput = recipe.altInputs?.[0] ?? recipe.input;
                for (let i = 0; i < 16; i++) {
                    const inputItem = displayInput[i];
                    const slot = createInventorySlot(inputItem ? {type: inputItem.type, count: inputItem.count} : null, -1, 'recipe');
                    inputGridDiv.appendChild(slot);
                }
                recipeItemDiv.appendChild(inputGridDiv);
                const arrowSpan = document.createElement('span');
                arrowSpan.classList.add('crafting-arrow');
                arrowSpan.textContent = '';
                recipeItemDiv.appendChild(arrowSpan);
                const outputDiv = document.createElement('div');
                outputDiv.classList.add('recipe-output');
                const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
                const outputSlot = createInventorySlot({ type: recipe.output, count: recipe.outputCount, durability: outputItemProps?.isTool ? outputItemProps.maxDurability : null }, -1, 'recipe');
                outputDiv.appendChild(outputSlot);
                const outputNameSpan = document.createElement('span');
                outputNameSpan.textContent = recipe.name || recipe.output.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                outputDiv.appendChild(outputNameSpan);
                recipeItemDiv.appendChild(outputDiv);
                recipeListDiv.appendChild(recipeItemDiv);
				if (cheatItems === true) {
					recipeItemDiv.addEventListener('click', () => {
						// Clear the current crafting grid
						craftingGridSlots.fill(null);

						// Populate the grid with the clicked recipe's items
						for (const key in recipe.input) {
							const required = recipe.input[key];
							// Note: This shows the pattern but doesn't consume items yet.
							craftingGridSlots[key] = { type: required.type, count: required.count };
						}

						// Update the UI to show the pattern in the grid
						updateInventoryMenu();
					});
				}
            }
			for (const recipe of filteredRecipes) {
                const iconSlot = createRecipeIconSlot(recipe);
                iconContainer.appendChild(iconSlot);
            }
        }
		
		function createRecipeIconSlot(recipe) {
            const slot = document.createElement('div');
            slot.classList.add('inventory-slot', 'recipe-icon-slot'); // Use existing styles
            
            const itemObject = { type: recipe.output, count: recipe.outputCount };
            const itemProps = itemTypes[itemObject.type] || blockTypes[itemObject.type];
            const itemImg = assets[itemObject.type];

            if (itemImg && !failedAssets[itemObject.type]) {
                const imgElement = document.createElement('img');
                imgElement.src = itemImg.src;
                slot.appendChild(imgElement);
            } else if (itemProps?.color) {
                const fallbackDiv = document.createElement('div');
                fallbackDiv.classList.add('fallback');
                fallbackDiv.style.backgroundColor = itemProps.color;
                fallbackDiv.textContent = itemObject.type.substring(0, 3).toUpperCase();
                slot.appendChild(fallbackDiv);
            }
            const countSpan = document.createElement('span');
            countSpan.classList.add('item-count');
            countSpan.textContent = itemObject.count;
            slot.appendChild(countSpan);
            
            // Add tooltip hover
            slot.onmouseenter = (e) => {
                let itemName = (recipe.name || recipe.output.replace(/_/g, ' ')).replace(/\b\w/g, l => l.toUpperCase());
                itemTooltip.textContent = itemName;
                itemTooltip.style.display = 'block';
            };
            slot.onmouseleave = (e) => {
                itemTooltip.style.display = 'none';
            };

            // Add click listener to show ingredients
            slot.onclick = () => {
                let recipeName = (recipe.name || recipe.output.replace(/_/g, ' ')).replace(/\b\w/g, l => l.toUpperCase());
            
                // Check if it's a furnace/oven recipe (9-slot) or crafting recipe (16-slot)
                const isFurnaceRecipe = recipe.fuel !== undefined;
                const gridSize = isFurnaceRecipe ? 9 : 16;
                const gridColumns = isFurnaceRecipe ? 3 : 4;

                // Start the HTML string
                let ingredientsHTML = `<h3 style="color: #00BFFF; margin-top: 0; text-align: center;">${recipeName}</h3>`;
                
                // Add grid styles inline since the message box is separate
                ingredientsHTML += `<div class="recipe-input-grid" style="display: grid; grid-template-columns: repeat(${gridColumns}, 35px); margin: 10px auto; width: ${gridColumns * 38}px; gap: 3px; justify-content: center;">`;

                // Use the recipe.input object
                for (let i = 0; i < gridSize; i++) {
                    const inputItem = recipe.input[i];
                    if (inputItem) {
                        // Manually build the slot HTML
                        const itemProps = itemTypes[inputItem.type] || blockTypes[inputItem.type];
                        const itemImg = assets[inputItem.type];
                        let slotContent = '';
                        
                        if (itemImg && !failedAssets[inputItem.type]) {
                            slotContent = `<img src="${itemImg.src}" style="width: 28px; height: 28px;  position: relative; z-index: 1;">`;
                        } else if (itemProps?.color) {
                            slotContent = `<div class="fallback" style="width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; font-size: 10px; background-color: ${itemProps.color};">${inputItem.type.substring(0, 3).toUpperCase()}</div>`;
                        }
                        
                        ingredientsHTML += `<div class="inventory-slot" style="width: 35px; height: 35px; background-color: #666; border: 1px solid #777; cursor: default; display: flex; justify-content: center; align-items: center; position: relative;">
                            ${slotContent}
                            <span class="item-count" style="font-size: 10px; position: absolute; bottom: 2px; right: 2px; z-index: 2; text-shadow: 1px 1px 2px black;">${inputItem.count}</span>
                        </div>`;
                    } else {
                        // Add an empty slot
                        ingredientsHTML += `<div class="inventory-slot" style="width: 35px; height: 35px; background-color: #666; border: 1px solid #777; cursor: default;"></div>`;
                    }
                }
                
                ingredientsHTML += `</div>`; // Close grid
                
                // Add fuel info if it's a furnace recipe
                if (recipe.fuel) {
                    const fuelImg = assets['pure_fuel'];
                    let fuelImgHtml = '';
                    if (fuelImg) {
                        fuelImgHtml = `<img src="${fuelImg.src}" style="width: 20px; height: 20px;  margin-right: 5px; vertical-align: middle;">`;
                    }
                    
                    ingredientsHTML += `<div style="display: flex; justify-content: center; align-items: center; gap: 5px; font-weight: bold; margin-top: 10px;">
                        Fuel: ${fuelImgHtml} ${recipe.fuel}x Pure Fuel
                    </div>`;
                }
                
                // Call showMessageBox with the new HTML content
                showMessageBox(ingredientsHTML, 'alert');
            };
            
            return slot;
        }

        function updatePlantGrowth() {
			if (isGamePaused) return;
			const currentTime = gameTime;
			
			// Create a temporary set to store plants that are done growing
			const plantsToRemove = new Set();

			// Loop over ONLY the active plants
			for (const key of activePlants) {
				const blockData = worldBlocks[key];
				
				// If block was destroyed or changed, remove it from the list
				if (!blockData || !blockData.type.startsWith('planted_')) {
					plantsToRemove.add(key);
					continue;
				}

				let growthTimeRequired;
				if (blockData.baseBlockType === 'fertilizer') {
					growthTimeRequired = 45000; // 45 seconds
				} else if (blockData.baseBlockType === 'soil') {
					growthTimeRequired = 90000; // 90 seconds
				} else { // 'dirt'
					growthTimeRequired = 180000; // 180 seconds
				}
				
				if (currentTime - blockData.plantTime >= growthTimeRequired) {
					const coords = key.split(',').map(Number);
					if (getBlockType(coords[0], coords[1] - 1) === '') {
						let cropType;
						if (blockData.type === 'planted_wheat_seeds') cropType = 'wheat';
						else if (blockData.type === 'planted_tomato_seeds') cropType = 'tomato_bush';
						else if (blockData.type === 'planted_pumpkin_seeds') cropType = 'pumpkin';
						else if (blockData.type === 'planted_cotton_seeds') cropType = 'cotton';
						else if (blockData.type === 'planted_rice_seeds') cropType = 'rice';
						else if (blockData.type === 'planted_hop_seeds') cropType = 'hop';
						else if (blockData.type === 'planted_coffee_seeds') cropType = 'coffee';
						else if (blockData.type === 'planted_oat_seeds') cropType = 'oat';
						else if (blockData.type === 'planted_corn_seeds') cropType = 'corn';
						else if (blockData.type === 'planted_barley_seeds') cropType = 'barley';
						else if (blockData.type === 'planted_onion_seeds') cropType = 'onion';
						else if (blockData.type === 'planted_garlic_seeds') cropType = 'garlic';
						else if (blockData.type === 'planted_chili_pepper_seeds') cropType = 'chili_pepper_bush';
						else if (blockData.type === 'planted_potato_seeds') cropType = 'potato_stem';
						
						if (cropType) {
							worldBlocks[`${coords[0]},${coords[1] - 1}`] = { type: cropType, mineProg: 0 };
							worldBlocks[key] = { type: blockData.baseBlockType, mineProg: 0 }; 
							plantsToRemove.add(key); // Done growing, remove from list
						}
					}
				}
			}
			
			// Clean up the main set
			for (const key of plantsToRemove) {
				activePlants.delete(key);
			}
		}
		
		function updateSpoilage() {
			if (isGamePaused) return;
			const currentTime = gameTime;

			function addSpoiledToInventoryArray(invArray, spoiledType, count) {
				// Merge into invArray (which may be player's inventory or a chest inventory)
				let remaining = count;
				// first fill existing stacks
				for (let i = 0; i < invArray.length && remaining > 0; i++) {
					const s = invArray[i];
					if (s && s.type === spoiledType && !(itemTypes[spoiledType] || blockTypes[spoiledType])?.isTool && s.count < maxStackSize) {
						const take = Math.min(remaining, maxStackSize - s.count);
						s.count += take;
						remaining -= take;
					}
				}
				// then create new stacks in empty slots
				for (let i = 0; i < invArray.length && remaining > 0; i++) {
					if (!invArray[i]) {
						const amount = Math.min(remaining, maxStackSize);
						invArray[i] = { type: spoiledType, count: amount };
						remaining -= amount;
					}
				}
				return remaining; // leftovers (0 expected normally)
			}

			const checkInventory = (inventory, isRefrigerator = false, isPlayerInventory = false) => {
				if (!inventory) return;
				for (let i = 0; i < inventory.length; i++) {
					const item = inventory[i];
					if (!item) continue;

					if (itemTypes[item.type]?.spoilable) {
						const spoilInfo = itemTypes[item.type].spoilable;

						// Refrigerator: pause spoilage by removing timestamps (existing code removed acquiredTime)
						if (isRefrigerator) {
							if (Array.isArray(item.acquiredTimes)) delete item.acquiredTimes;
							if (item.acquiredTime) delete item.acquiredTime;
							continue;
						}

						// Ensure per-unit timestamps exist
						_ensureAcquiredTimes(item, currentTime);

						// Count expired entries (oldest first). We assume oldest timestamps are at index 0 (FIFO).
						let expiredCount = 0;
						for (let t = 0; t < (item.acquiredTimes || []).length; t++) {
							if (currentTime - item.acquiredTimes[t] > spoilInfo.time) expiredCount++;
							else break; // timestamps are ordered by time of insertion => stop on first non-expired
						}

						if (expiredCount > 0) {
							// Remove expired timestamps and reduce item count
							item.acquiredTimes.splice(0, expiredCount);
							item.count -= expiredCount;

							// If the original stack is empty now, clear the slot *before* adding spoiled output
							if (item.count <= 0) {
								inventory[i] = null;
							}

							// Create or merge spoiled items into inventory
							const spoiledType = spoilInfo.into || 'spoiled'; // fallback if defined
							let leftover = 0;
							if (isPlayerInventory) {
								// add to player inventory (merge or create) using the global addToInventory
								addToInventory(spoiledType, expiredCount, null, null, inventorySlots);
							} else {
								// add to this chest/inventory array
								leftover = addSpoiledToInventoryArray(inventory, spoiledType, expiredCount);
								if (leftover > 0) {
									// try player inventory for leftovers
									const stillLeft = (leftover > 0) ? (addToInventory(spoiledType, leftover) ? 0 : leftover) : 0;
									if (stillLeft > 0) {
										console.warn(`No space for ${stillLeft} spoiled ${spoiledType}. They were discarded.`);
									}
								}
							}
						}
					}
				}
			};

			// Check player inventory (true -> it's player inventory, so add spoiled back into player inventory)
			checkInventory(inventorySlots, false, true);

			// Check chests and refrigerators
			for (const key in worldBlocks) {
				const block = worldBlocks[key];
				if (block.inventory && (block.type === 'chest' || block.type === 'dead_body_chest' || block.type === 'magical_chest')) {
					checkInventory(block.inventory, false, false);
				} else if (block.inventory && block.type === 'refrigerator') {
					checkInventory(block.inventory, true, false);
				}
			}
		}

        function toggleGameMenu() {
            if (inventoryCraftingOverlay.style.display === 'flex' || chestOverlay.style.display === 'flex') return;
            isGamePaused = !isGamePaused;
        
            const tipDisplay = document.getElementById('gameMenuTipText'); // Get the tip element
        
            if (isGamePaused) {
                gameMenuOverlay.style.display = 'flex';
                seedInput.value = '';
                seedInput.placeholder = `Current: ${currentSeed}`;
                maintainDurabilityCheckbox.checked = maintainBlockDurability;
                autosaveCheckbox.checked = autosave;
                animateDropsCheckbox.checked = animateDrops;
        
                // --- NEW TIP LOGIC STARTS HERE ---
        
                // Function to display the next tip
                const showNextTip = () => {
                    if (loadingTips.length === 0) return;
					const idx = Math.floor(Math.random() * loadingTips.length);
					tipDisplay.textContent = `Tip: ${loadingTips[idx]}`;
                };
        
                // Show the first tip immediately
                showNextTip();
        
                // Set an interval to change the tip every 6.5 seconds (6500 milliseconds)
                tipIntervalId = setInterval(showNextTip, 6500);
        
                // --- NEW TIP LOGIC ENDS HERE ---
        
            } else {
                gameMenuOverlay.style.display = 'none';
        
                // --- NEW: STOP THE TIMER WHEN THE MENU CLOSES ---
                // This is very important to prevent memory leaks!
                if (tipIntervalId) {
                    clearInterval(tipIntervalId);
                    tipIntervalId = null;
                }
                // --- END OF NEW LOGIC ---
        
                lastTime = performance.now();
            }
        }
		
		function updateDebugStats() {
			if (!showDebugStats) return; // Don't do work if it's hidden

			const loadedBlockCount = Object.keys(worldBlocks).length;

			debugStatsDiv.innerHTML = `
				FPS: ${currentFps}<br>
				Player Pos: (${player.x.toFixed(1)}, ${player.y.toFixed(1)})<br>
				Player Vel: (${player.dx.toFixed(1)}, ${player.dy.toFixed(1)})<br>
				Loaded Blocks: ${loadedBlockCount}<br>
				Particles: ${particles.length}<br>
				Item Drops: ${animatedDrops.length}<br>
				Game Time: ${(gameTime / 1000).toFixed(1)}s
			`;
		}
		
		// --- START OF WORLD MOVER FEATURE FUNCTIONS ---

        function toggleWorldMoverMenu(col, row) {
            isGamePaused = !isGamePaused;
            if (isGamePaused) {
                currentlyOpenWorldMover = { col, row };
                worldMoverConfigOverlay.style.display = 'flex';
                updateWorldMoverMenu();
            } else {
                worldMoverConfigOverlay.style.display = 'none';

                currentlyOpenWorldMover = null;
                if (heldItem) { // Return any held item as well
                    addToInventory(heldItem.type, heldItem.count, heldItem.durability);
                    heldItem = null;
                    heldItemSource = { type: null, index: -1 };
                }
                lastTime = performance.now();
            }
        }

        function updateWorldMoverMenu() {
            if (!currentlyOpenWorldMover) return;
            const moverKey = `${currentlyOpenWorldMover.col},${currentlyOpenWorldMover.row}`;
            const moverData = worldBlocks[moverKey];

            if (!moverData || moverData.type !== 'world_mover') {
                toggleWorldMoverMenu(); // Close if block is gone
                return;
            }

            // Initialize inventory if it doesn't exist (1 slot for fuel)
            if (!moverData.inventory) {
                moverData.inventory = new Array(1).fill(null);
            }
            
            worldMoverCodeInput.value = moverData.code || '';
            worldMoverFuelSlot.innerHTML = '';
            const slotDiv = createInventorySlot(moverData.inventory[0], 0, 'world_mover_fuel');
            worldMoverFuelSlot.appendChild(slotDiv);
        }

        function saveWorldMoverConfig() {
            if (!currentlyOpenWorldMover) return;
            const code = worldMoverCodeInput.value.trim();

            // Validate code: must be 3 digits
            if (!/^\d{3}$/.test(code)) {
                showMessageBox("Invalid Code. Must be exactly 3 digits.", 'alert');
                return;
            }

            // Validate code: must be unique
            if (!isWorldMoverCodeUnique(code, currentlyOpenWorldMover.col, currentlyOpenWorldMover.row)) {
                showMessageBox("This code is already in use by another World Mover.", 'alert');
                return;
            }

            const moverKey = `${currentlyOpenWorldMover.col},${currentlyOpenWorldMover.row}`;
            worldBlocks[moverKey].code = code;
            
            showMessageBox(`World Mover configured with code ${code}.`, 'alert');
            toggleWorldMoverMenu(); // This will close the menu
        }

        function isWorldMoverCodeUnique(code, currentCol, currentRow) {
            for (const key in worldBlocks) {
                const [col, row] = key.split(',').map(Number);
                if (col === currentCol && row === currentRow) continue; // Skip the one we're editing

                const block = worldBlocks[key];
                if (block.type === 'world_mover' && block.code === code) {
                    return false; // Found a duplicate
                }
            }
            return true;
        }

        function canOpenTeleportMenu() {
            for (const key in worldBlocks) {
                const block = worldBlocks[key];
                if (block.type === 'world_mover' && block.code && /^\d{3}$/.test(block.code)) {
                    return true; // Found at least one configured mover
                }
            }
            return false;
        }

        function toggleTeleportMenu() {
            if (isGamePaused && !isTeleportMenuOpen) return; // Don't open if another menu is up

            isTeleportMenuOpen = !isTeleportMenuOpen;
            isGamePaused = isTeleportMenuOpen;

            if (isTeleportMenuOpen) {
                worldMoverTeleportOverlay.style.display = 'flex';
                teleportCodeInput.value = '';
                teleportCodeInput.focus();
            } else {
                worldMoverTeleportOverlay.style.display = 'none';
                lastTime = performance.now();
            }
        }

        function executeTeleport() {
            const code = teleportCodeInput.value.trim();
            if (!/^\d{3}$/.test(code)) return; // Ignore invalid input

            let targetMoverKey = null;
            let targetMoverData = null;

            // Find the world mover with the matching code
            for (const key in worldBlocks) {
                const block = worldBlocks[key];
                if (block.type === 'world_mover' && block.code === code) {
                    targetMoverKey = key;
                    targetMoverData = block;
                    break;
                }
            }

            if (!targetMoverData) {
                showMessageBox(`No World Mover found with code ${code}.`, 'alert');
                return;
            }
            
            // Condition 1: Check for fuel
            const fuel = targetMoverData.inventory ? targetMoverData.inventory[0] : null;
            if (!fuel || fuel.type !== 'pure_fuel' || fuel.count < 20) {
                showMessageBox(`Destination Mover (Code: ${code}) lacks sufficient energy.`, 'alert');
                return;
            }

            // Condition 2: Check for clearance
            const [col, row] = targetMoverKey.split(',').map(Number);
            for (let i = 1; i <= 3; i++) {
                const blockAboveType = getBlockType(col, row - i);
                if (blockAboveType !== '' && blockAboveType !== 'sky') {
                    showMessageBox(`Destination Mover (Code: ${code}) is obstructed.`, 'alert');
                    return;
                }
            }

            // All conditions met! Teleport the player.
            player.x = col * tileSize;
            player.y = (row - playerHeightBlocks) * tileSize;
            player.dy = 0; // Prevent fall damage

            // Consume fuel
            fuel.count -= 20;
            if (fuel.count <= 0) {
                targetMoverData.inventory[0] = null;
            }

            showMessageBox(`Teleported to Mover ${code}!`, 'alert');
            toggleTeleportMenu(); // Close the menu
            unlockAchievement('GLOBETROTTER');
        }

        // --- END OF WORLD MOVER FEATURE FUNCTIONS ---

		function toggleVoidChestMenu() {
            // Get a reference to the container
            const voidCharacterContainer = document.getElementById('voidCharacterContainer');
        
            isGamePaused = !isGamePaused;
            isVoidChestOpen = isGamePaused;
            if (isVoidChestOpen) {
                voidChestOverlay.style.display = 'flex';
                voidCharacterContainer.style.display = 'flex'; // ADD THIS LINE to show the character
        
                if (!currentVoidTrade && voidStorage.length > 0) {
                    generateVoidTradeOffer();
                }
                updateVoidChestMenu();
                animateVoidCharacter();
            } else {
                voidCharacterContainer.style.display = 'none'; // This line is correct, just make sure it's there
                voidChestOverlay.style.display = 'none';
                if (heldItem) { 
                    addToVoidStorage(heldItem.type, heldItem.count, heldItem.durability, heldItem.maxDurability);
                    heldItem = null;
                    heldItemSource = { type: null, index: -1 };
                }
                lastTime = performance.now();
            }
        }

		function updateVoidChestMenu() {
			if (!isVoidChestOpen) return;

			voidChestGrid.innerHTML = '';
			voidChestPlayerInventoryGrid.innerHTML = '';

			// Aggregate items in voidStorage by type
			const aggregatedVoid = {};
			for (const item of voidStorage) {
				if (!item) continue;
				if (aggregatedVoid[item.type]) {
					aggregatedVoid[item.type].count += item.count;
				} else {
					aggregatedVoid[item.type] = { ...item }; // Create a copy
				}
			}

			// Convert aggregated map back to an array to display
			const displayableVoid = Object.values(aggregatedVoid);

			// Create slots for the void items
			for (let i = 0; i < displayableVoid.length; i++) {
				const item = displayableVoid[i];
				// We use a unique string identifier for the slot index for void items
				const slotDiv = createInventorySlot(item, item.type, 'void');
				voidChestGrid.appendChild(slotDiv);
			}

			// Player inventory
			for (let i = 0; i < totalInventorySlots; i++) {
				const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
				voidChestPlayerInventoryGrid.appendChild(slotDiv);
			}
			updateVoidTradeOfferUI(); 
		}

        function toggleChestMenu(col, row) {
            isGamePaused = !isGamePaused;
            if (isGamePaused) {
                currentlyOpenChest = { col, row };
                chestOverlay.style.display = 'flex';
                updateChestMenu();
            } else {
                chestOverlay.style.display = 'none';
                currentlyOpenChest = null;
                if (heldItem) {
                    addToInventory(heldItem.type, heldItem.count, heldItem.durability);
                    heldItem = null;
                    heldItemSource = { type: null, index: -1 };
                }
                lastTime = performance.now();
            }
        }
		
		let isTraderMenuOpen = false;
		let traderBob = 0;
		let traderBobDirection = 1;
		let currentTraderRef = null; // {col,row}

		// Call this to open/close
		function toggleTraderMenu(col, row) {
			isGamePaused = !isGamePaused;
			if (isGamePaused) {
				isTraderMenuOpen = true;
				currentTraderRef = { col, row };
				traderCharacterContainer.style.display = 'flex';
				updateTraderMenu();
				animateTraderCharacter(); // start bobbing
			} else {
				isTraderMenuOpen = false;
				traderCharacterContainer.style.display = 'none';
				// reset or refund held things if needed
				currentTraderRef = null;
				lastTime = performance.now();
			}
		}

		function updateTraderMenu() {
			if (!isTraderMenuOpen || !currentTraderRef) return;
			
			const { col, row } = currentTraderRef;
			let bottomRow = row;
			const middleBlock = worldBlocks[`${col},${row-1}`];
			const topBlock = worldBlocks[`${col},${row-2}`];

			// Find the bottom block of the trader, which holds the data
			if (middleBlock && middleBlock.type === 'trader' && middleBlock.part === 'bottom') bottomRow = row - 1;
			if (topBlock && topBlock.type === 'trader' && topBlock.part === 'bottom') bottomRow = row - 2;

			const bottomKey = `${col},${bottomRow}`;
			const bottomBlock = worldBlocks[bottomKey];

			if (!bottomBlock || bottomBlock.type !== 'trader' || bottomBlock.part !== 'bottom') {
				toggleTraderMenu(); // Trader disappeared or is invalid
				return;
			}

			const offerList = document.getElementById('traderOfferList');
			offerList.innerHTML = ''; // Clear previous offers
			
			// Use the trader's stored trades, or generate new ones if they don't exist
			if (!bottomBlock.trades) {
				bottomBlock.trades = pickRandomTradesFromPool(5);
			}
			const trades = bottomBlock.trades;

			trades.forEach((trade, index) => {
				const tradeRow = document.createElement('div');
				tradeRow.className = 'trade-row';

				// 1. Create Input Item Slot
				const inputSlot = createInventorySlot(trade.input, -1, 'trade_ui');
				
				// 2. Create Arrow
				const arrow = document.createElement('span');
				arrow.className = 'trade-arrow';
				arrow.innerHTML = '&rarr;'; // Right arrow

				// 3. Create Output Item Slot
				const outputSlot = createInventorySlot(trade.output, -1, 'trade_ui');

				// 4. Create Accept Button
				const acceptButton = document.createElement('button');
				acceptButton.textContent = 'Trade';
				
				// Check if player can afford it and disable button if not
				let playerHas = 0;
				inventorySlots.forEach(item => {
					if (item && item.type === trade.input.type) {
						playerHas += item.count;
					}
				});
				if (playerHas < trade.input.count) {
					acceptButton.disabled = true;
				}

				acceptButton.onclick = () => {
					// Re-check affordability on click
					let currentHas = 0;
					inventorySlots.forEach(item => { if (item && item.type === trade.input.type) currentHas += item.count; });

					if (currentHas >= trade.input.count) {
						// Remove cost from player inventory
						let remainingCost = trade.input.count;
						for (let i = inventorySlots.length - 1; i >= 0; i--) {
							const item = inventorySlots[i];
							if (item && item.type === trade.input.type) {
								const toRemove = Math.min(remainingCost, item.count);
								item.count -= toRemove;
								remainingCost -= toRemove;
								if (item.count <= 0) inventorySlots[i] = null;
								if (remainingCost <= 0) break;
							}
						}
						
						// Add output to player inventory
						addToInventory(trade.output.type, trade.output.count);
						
						unlockAchievement('BARTERIN_TIME');
						
						// Refresh the menu UI
						updateTraderMenu();
						syncHotbarIndices();
					} else {
						showMessageBox("You can no longer afford that.", 'alert');
						acceptButton.disabled = true;
					}
				};

				// Assemble the row
				tradeRow.appendChild(inputSlot);
				tradeRow.appendChild(arrow);
				tradeRow.appendChild(outputSlot);
				tradeRow.appendChild(acceptButton);
				
				offerList.appendChild(tradeRow);
			});
		}

		// bobbing
		function animateTraderCharacter() {
			if (!isTraderMenuOpen) {
				traderBob = 0;
				traderBobDirection = 1;
				document.getElementById('traderCharacterContainer').style.bottom = '20px';
				return;
			}
			traderBob += 0.25 * traderBobDirection;
			if (traderBob > 6) traderBobDirection = -1;
			if (traderBob < -2) traderBobDirection = 1;
			document.getElementById('traderCharacterContainer').style.bottom = (20 + traderBob) + 'px';
			requestAnimationFrame(animateTraderCharacter);
		}

		// hook up close button
		document.getElementById('traderDeclineButton').onclick = () => { toggleTraderMenu(); };


        function updateChestMenu() {
			if (!currentlyOpenChest) return;
			const chestKey = `${currentlyOpenChest.col},${currentlyOpenChest.row}`;
			const chestData = worldBlocks[chestKey];

			// Check if the chest is valid, otherwise close the menu
			if (!chestData || (chestData.type !== 'chest' && chestData.type !== 'dead_body_chest' && chestData.type !== 'refrigerator' && chestData.type !== 'magical_chest')) {
				toggleChestMenu();
				return;
			}

			// --- NEW: Dynamic Grid Size ---
			const currentChestSize = chestData.inventory.length;
			// Set grid columns. For a 50-slot chest, 10 columns looks good.
			const columns = (currentChestSize === 50) ? 10 : 9;
			chestGrid.style.gridTemplateColumns = `repeat(${columns}, minmax(45px, 1fr))`;
			// --- End of new logic ---

			chestTitle.textContent = chestData.label || 'Chest';
			if (chestData.type === 'magical_chest') {
				chestTitle.textContent = chestData.label || 'Magical Chest';
			}
			if (chestData.type === 'refrigerator') {
				chestTitle.textContent = chestData.label || 'Fridge';
			}
			chestLabelInput.value = chestData.label || '';
			if (chestData.type === 'dead_body_chest') {
				chestLabelInput.disabled = true; // Don't allow renaming a dead body chest
			} else {
				chestLabelInput.disabled = false;
			}


			chestGrid.innerHTML = '';
			chestPlayerInventoryGrid.innerHTML = '';

			// Chest inventory (now uses the dynamic size)
			for (let i = 0; i < currentChestSize; i++) {
				const slotDiv = createInventorySlot(chestData.inventory[i], i, 'chest');
				chestGrid.appendChild(slotDiv);
			}

			// Player inventory
			for (let i = 0; i < totalInventorySlots; i++) {
				const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
				chestPlayerInventoryGrid.appendChild(slotDiv);
			}
		}
		
		function transferAllFromChest() {
			if (!currentlyOpenChest) return;
			const chestKey = `${currentlyOpenChest.col},${currentlyOpenChest.row}`;
			const chestData = worldBlocks[chestKey];
			if (!chestData || !chestData.inventory) return;

			const chestInventory = chestData.inventory;
			const playerInventory = inventorySlots;

			// Loop through each slot in the chest
			for (let i = 0; i < chestInventory.length; i++) {
				let chestItem = chestInventory[i];
				if (!chestItem) continue;

				const itemProps = itemTypes[chestItem.type] || blockTypes[chestItem.type];
				const isSpoilable = itemProps?.spoilable;
				const isTool = itemProps?.isTool;

				// --- Pass 1: Add to existing stacks in player's inventory ---
				if (!isTool) { // Tools don't stack
					for (let j = 0; j < playerInventory.length; j++) {
						if (chestItem.count <= 0) break;
						let playerSlot = playerInventory[j];

						if (playerSlot && playerSlot.type === chestItem.type && playerSlot.count < maxStackSize) {
							const spaceAvailable = maxStackSize - playerSlot.count;
							const amountToMove = Math.min(chestItem.count, spaceAvailable);
							
							playerSlot.count += amountToMove;
							
							if (isSpoilable) {
								const timestampsToMove = _takeTimestamps(chestItem, amountToMove);
								_pushTimestampsIntoSlot(playerSlot, timestampsToMove);
							}
							chestItem.count -= amountToMove; // This must be after _takeTimestamps
						}
					}
				}

				// --- Pass 2: Add remaining items or tools to empty slots ---
				while (chestItem.count > 0) {
					let foundEmptySlot = false;
					for (let j = 0; j < playerInventory.length; j++) {
						if (!playerInventory[j]) { // Found an empty slot
							const amountToMove = isTool ? 1 : Math.min(chestItem.count, maxStackSize);
							
							const timestampsToMove = isSpoilable ? _takeTimestamps(chestItem, amountToMove) : null;
							
							// Create the new item in the player's inventory
							playerInventory[j] = {
								type: chestItem.type,
								count: amountToMove,
								durability: chestItem.durability, 
								maxDurability: chestItem.maxDurability,
								acquiredTimes: timestampsToMove
							};
							
							chestItem.count -= amountToMove;
							foundEmptySlot = true;
							
							// If the original stack is gone or we moved a tool, break to the next chest slot
							if (isTool || chestItem.count <= 0) break;
						}
					}
					// If we looped through the entire inventory and found no empty slot, stop trying to move this item.
					if (!foundEmptySlot) break;
				}


				// If the chest stack is now empty, nullify it
				if (chestItem.count <= 0) {
					chestInventory[i] = null;
				}
			}

			// Refresh the UI to show the changes
			updateChestMenu();
			syncHotbarIndices(); // Updates hotbar and hotbar display
		}
        
        chestLabelInput.addEventListener('change', () => {
			if (currentlyOpenChest) {
				const chestKey = `${currentlyOpenChest.col},${currentlyOpenChest.row}`;
				const chestData = worldBlocks[chestKey];
				if (chestData && (chestData.type === 'chest' || chestData.type === 'refrigerator' || chestData.type === 'magical_chest')) {
					chestData.label = chestLabelInput.value;
					chestTitle.textContent = chestData.label || (chestData.type === 'refrigerator' ? 'Refrigerator' : 'Chest');
				}
			}
		});
		
		function toggleFurnaceMenu(col, row, type) { // Added 'type' parameter
			isGamePaused = !isGamePaused;
			if (isGamePaused) {
				currentlyOpenFurnace = { col, row, type }; // Store the type
				ovenOverlay.style.display = 'flex';
				updateFurnaceMenu();

                // --- NEW Recipe Sidebar Logic ---
                const ovenSearch = document.getElementById('ovenRecipeSearchInput');
                const ovenList = document.getElementById('ovenRecipeListContainer');
                const ovenIcons = document.getElementById('ovenRecipeIconContainer');
                const ovenListToggle = document.getElementById('ovenRecipeViewToggleList');
                const ovenIconToggle = document.getElementById('ovenRecipeViewToggleIcons');
                
                // Search listener
                ovenSearch.oninput = () => {
                    renderFurnaceRecipes(ovenSearch.value);
                    // Ensure the current view is maintained after search
                    const isIconView = ovenIcons.style.display === 'grid';
                    ovenList.style.display = isIconView ? 'none' : 'block';
                    ovenIcons.style.display = isIconView ? 'grid' : 'none';
                };

                // FIX: Stop 'e' key from closing the menu
                ovenSearch.onkeydown = (e) => e.stopPropagation();
                
                // Toggle listeners
                ovenListToggle.onclick = () => {
                    ovenList.style.display = 'block';
                    ovenIcons.style.display = 'none';
                    ovenListToggle.classList.add('active');
                    ovenIconToggle.classList.remove('active');
                };
                ovenIconToggle.onclick = () => {
                    ovenList.style.display = 'none';
                    ovenIcons.style.display = 'grid';
                    ovenListToggle.classList.remove('active');
                    ovenIconToggle.classList.add('active');
                };
                
                // Set initial state
                if (ovenIcons.style.display !== 'grid') {
                    ovenListToggle.click(); // Default to list view
                }
                // --- END Recipe Sidebar Logic ---

            } else {
				ovenOverlay.style.display = 'none';

				if (currentlyOpenFurnace) {
					const furnaceKey = `${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`;
					const furnaceData = worldBlocks[furnaceKey];
					if (furnaceData && furnaceData.inventory) {
						for (let i = 0; i < furnaceData.inventory.length; i++) {
							const item = furnaceData.inventory[i];
							if (item) {
								addToInventory(item.type, item.count, item.durability);
								furnaceData.inventory[i] = null;
							}
						}
					}
				}

				currentlyOpenFurnace = null;
				if (heldItem) {
					addToInventory(heldItem.type, heldItem.count, heldItem.durability);
					heldItem = null;
					heldItemSource = { type: null, index: -1 };
				}
				lastTime = performance.now();
			}
		}
		
        function updateFurnaceMenu() {
			if (!currentlyOpenFurnace) return;
			const furnaceKey = `${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`;
			const furnaceData = worldBlocks[furnaceKey];
			if (!furnaceData || (furnaceData.type !== 'oven' && furnaceData.type !== 'magma_furnace' && furnaceData.type !== 'power_forge')) {
				toggleFurnaceMenu();
				// --- NEW Recipe Sidebar Logic ---
                const ovenSearch = document.getElementById('ovenRecipeSearchInput');
                const ovenList = document.getElementById('ovenRecipeListContainer');
                const ovenIcons = document.getElementById('ovenRecipeIconContainer');
                const ovenListToggle = document.getElementById('ovenRecipeViewToggleList');
                const ovenIconToggle = document.getElementById('ovenRecipeViewToggleIcons');
                
                // Search listener
                ovenSearch.oninput = () => {
                    renderFurnaceRecipes(ovenSearch.value);
                    // Ensure the current view is maintained after search
                    const isIconView = ovenIcons.style.display === 'grid';
                    ovenList.style.display = isIconView ? 'none' : 'block';
                    ovenIcons.style.display = isIconView ? 'grid' : 'none';
                };
                
                // Toggle listeners
                ovenListToggle.onclick = () => {
                    ovenList.style.display = 'block';
                    ovenIcons.style.display = 'none';
                    ovenListToggle.classList.add('active');
                    ovenIconToggle.classList.remove('active');
                };
                ovenIconToggle.onclick = () => {
                    ovenList.style.display = 'none';
                    ovenIcons.style.display = 'grid';
                    ovenListToggle.classList.remove('active');
                    ovenIconToggle.classList.add('active');
                };
                
                // Set initial state
                if (ovenIcons.style.display !== 'grid') {
                    ovenListToggle.click(); // Default to list view
                }
                // --- END Recipe Sidebar Logic ---
				return;
			}

			// Dynamically set the title
			const titleElement = document.querySelector('#ovenMenu h2');
			if (currentlyOpenFurnace.type === 'magma_furnace') {
				titleElement.textContent = 'Magma Furnace';
			} else if (currentlyOpenFurnace.type === 'power_forge') {
				titleElement.textContent = 'Power Forge';
			} else {
				titleElement.textContent = 'Oven';
			}

			ovenGrid.innerHTML = '';
			ovenFuelSlot.innerHTML = '';
			ovenOutputSlot.innerHTML = '';
			ovenPlayerInventoryGrid.innerHTML = '';

			for (let i = 0; i < 9; i++) {
				const slotDiv = createInventorySlot(furnaceData.inventory[i], i, currentlyOpenFurnace.type);
				ovenGrid.appendChild(slotDiv);
			}

			const fuelSlotDiv = createInventorySlot(furnaceData.inventory[9], 9, currentlyOpenFurnace.type);
			ovenFuelSlot.innerHTML = '';
			ovenFuelSlot.appendChild(fuelSlotDiv);

			const outputSlotDiv = createInventorySlot(furnaceData.inventory[10], 10, currentlyOpenFurnace.type);
			ovenOutputSlot.innerHTML = '';
			ovenOutputSlot.appendChild(outputSlotDiv);

            const byproductSlotDiv = createInventorySlot(furnaceData.inventory[11], 11, currentlyOpenFurnace.type);
            const ovenByproductSlot = document.getElementById('ovenByproductSlot'); // Get the new element
            ovenByproductSlot.innerHTML = '';
            ovenByproductSlot.appendChild(byproductSlotDiv);

			for (let i = 0; i < totalInventorySlots; i++) {
				const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
				ovenPlayerInventoryGrid.appendChild(slotDiv);
			}

			renderFurnaceRecipes();
			checkFurnaceRecipe();
		}

        function checkFurnaceRecipe() {
			cookButton.disabled = true;
			cookButton.onclick = null;
			if (!currentlyOpenFurnace) return;

			// Choose the correct recipe list
			const recipeList = currentlyOpenFurnace.type === 'magma_furnace' ? furnaceRecipes : currentlyOpenFurnace.type === 'power_forge' ? forgeRecipes : ovenRecipes;;

			const furnaceKey = `${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`;
			const furnaceData = worldBlocks[furnaceKey];
			if (!furnaceData) return;

			const currentGrid = furnaceData.inventory.slice(0, 9);
			const fuelItem = furnaceData.inventory[9];
			const outputItem = furnaceData.inventory[10];

			for (const recipe of recipeList) { // Use the selected recipe list
				// ... (rest of the function is identical)
				const requiredInput = recipe.input;
				const requiredKeys = Object.keys(requiredInput);

				let gridItemCount = 0;
				const currentGridItems = {};
				for (let i = 0; i < 9; i++) {
					if (currentGrid[i]) {
						currentGridItems[i] = currentGrid[i];
						gridItemCount++;
					}
				}

				if (requiredKeys.length !== gridItemCount) continue;

				let recipeMatch = true;
				for (const key of requiredKeys) {
					if (!currentGridItems[key] || currentGridItems[key].type !== requiredInput[key].type || currentGridItems[key].count < requiredInput[key].count) {
						recipeMatch = false;
						break;
					}
				}

				if (recipeMatch) {
					const hasEnoughFuel = fuelItem && fuelItem.type === 'pure_fuel' && fuelItem.count >= recipe.fuel;
					const outputItem = furnaceData.inventory[10];
                    const byproductItem = furnaceData.inventory[11]; // Get the byproduct slot item
                    
                    const canOutput = !outputItem || (outputItem.type === recipe.output && outputItem.count + recipe.outputCount <= maxStackSize);
                    
                    // Check if there is space for the byproduct, if the recipe has one
                    let canByproduct = true; // Assume true if no byproduct
                    if (recipe.byproduct) {
                        canByproduct = !byproductItem || (byproductItem.type === recipe.byproduct && byproductItem.count + recipe.byproductCount <= maxStackSize);
                    }
                    
                    if (hasEnoughFuel && canOutput && canByproduct) { // Add canByproduct to the condition
                        cookButton.disabled = false;
                        cookButton.onclick = () => executeCook(recipe);
                        return;
                    }
				}
			}
		}

        function executeCook(recipe) {
            if (!currentlyOpenFurnace) return;
            const ovenKey = `${currentlyOpenFurnace.col},${currentlyOpenFurnace.row}`;
            const furnaceData = worldBlocks[ovenKey];
            if (!furnaceData) return;

            // 1. Consume Input Items
            for (const key in recipe.input) {
                const required = recipe.input[key];
                furnaceData.inventory[key].count -= required.count;
                if (furnaceData.inventory[key].count <= 0) {
                    furnaceData.inventory[key] = null;
                }
            }

            // 2. Consume Fuel
            let consumeFuel = true;

            // --- GEOTHERMAL POWER CHECK START ---
            // Get the block *below* the furnace
            const [furnaceCol, furnaceRow] = ovenKey.split(',').map(Number);
            const blockBelow = getBlockType(furnaceCol, furnaceRow + 1);

            // If it's magma, 20% chance to *not* consume fuel
            if (blockBelow === 'magma_stone_block' && random() < 0.20) {
                consumeFuel = false;
                // Optional: show a "Sizzled!" particle effect or message here
            }
            // --- GEOTHERMAL POWER CHECK END ---

            if (consumeFuel) {
                furnaceData.inventory[9].count -= recipe.fuel;
                if (furnaceData.inventory[9].count <= 0) {
                    furnaceData.inventory[9] = null;
                }
            }

            // 3. Add to Output
            const outputSlot = furnaceData.inventory[10];
            // --- ADD THIS LINE ---
            const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output]; 
            
            if (!outputSlot) {
                // --- REPLACE THIS BLOCK ---
                // Create the new item object
                const newItem = { type: recipe.output, count: recipe.outputCount };
                if (outputItemProps?.isTool) { // Check if it's a tool
                    newItem.durability = outputItemProps.maxDurability;
                    newItem.maxDurability = outputItemProps.maxDurability;
                }
                furnaceData.inventory[10] = newItem; // Assign the complete object
                // --- END OF REPLACED BLOCK ---
            } else {
                // This logic is fine, as tools don't stack and this will only
                // be called for stackable (non-tool) items.
                outputSlot.count += recipe.outputCount;
            }
            
            // 4. Add Byproduct (if any)
            if (recipe.byproduct && recipe.byproductCount > 0) {
                const byproductSlot = furnaceData.inventory[11];
                if (!byproductSlot) {
                    furnaceData.inventory[11] = { type: recipe.byproduct, count: recipe.byproductCount };
                } else {
                    byproductSlot.count += recipe.byproductCount;
                }
            }
            
            // 5. Refresh UI
            updateFurnaceMenu();
        }
		
		function toggleAnvilMenu(col, row, type, power) {
            if (gameMenuOverlay.style.display === 'flex' && !isGamePaused) return;
            isGamePaused = !isGamePaused;
            if (isGamePaused) {
                currentlyOpenAnvil = { col, row, type, power };
                anvilOverlay.style.display = 'flex';
                updateAnvilMenu();
            } else {
                anvilOverlay.style.display = 'none';
                // Return crafting items to inventory
                for(let i = 0; i < anvilGridSlots.length; i++) {
                    const slot = anvilGridSlots[i];
                    if (slot && slot.type && slot.count > 0) {
                        addToInventory(slot.type, slot.count, slot.durability);
                        anvilGridSlots[i] = null;
                    }
                }
                // Return held item to inventory
                if (heldItem) {
                    addToInventory(heldItem.type, heldItem.count, heldItem.durability);
                    heldItem = null;
                    heldItemSource = { type: null, index: -1 };
                }
                currentlyOpenAnvil = null;
                lastTime = performance.now();
            }
        }

        function updateAnvilMenu() {
            if (!currentlyOpenAnvil) return;

            // Get all the specific anvil elements
            const playerGrid = document.getElementById('anvilPlayerInventoryGrid');
            const hotbarGrid = document.getElementById('anvilHotbarGrid');
            const gridDiv = document.getElementById('anvilGrid');

            playerGrid.innerHTML = '';
            hotbarGrid.innerHTML = '';
            gridDiv.innerHTML = '';
            //armorGrid.innerHTML = '';
            //paperDollDiv.innerHTML = ''; // Clear paper doll
            
            // Hotbar
            for (let i = 0; i < hotbarSize; i++) {
                const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
                slotDiv.classList.add('hotbar-slot');
                hotbarGrid.appendChild(slotDiv);
            }
            // Main inventory
            for (let i = hotbarSize; i < totalInventorySlots; i++) {
                const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
                playerGrid.appendChild(slotDiv);
            }
            
            // Anvil 4x4 Grid
            for (let i = 0; i < 16; i++) {
                const slotDiv = createInventorySlot(anvilGridSlots[i], i, 'anvil');
                gridDiv.appendChild(slotDiv);
            }

            // Setup Recipe Listeners
            const recipeSearch = document.getElementById('anvilRecipeSearchInput');
            const recipeList = document.getElementById('anvilRecipeListContainer');
            const recipeIcons = document.getElementById('anvilRecipeIconContainer');
            const listToggle = document.getElementById('anvilRecipeViewToggleList');
            const iconToggle = document.getElementById('anvilRecipeViewToggleIcons');

            recipeSearch.oninput = () => {
                renderAnvilRecipes(recipeSearch.value);
                const isIconView = recipeIcons.style.display === 'grid';
                recipeList.style.display = isIconView ? 'none' : 'block';
                recipeIcons.style.display = isIconView ? 'grid' : 'none';
            };
            recipeSearch.onkeydown = (e) => e.stopPropagation();
            
            listToggle.onclick = () => {
                recipeList.style.display = 'block';
                recipeIcons.style.display = 'none';
                listToggle.classList.add('active');
                iconToggle.classList.remove('active');
            };
            iconToggle.onclick = () => {
                recipeList.style.display = 'none';
                recipeIcons.style.display = 'grid';
                listToggle.classList.remove('active');
                iconToggle.classList.add('active');
            };
            
            if (recipeIcons.style.display !== 'grid') {
                listToggle.click();
            }

            renderAnvilRecipes();
            checkAnvilRecipe();
        }

        function renderAnvilRecipes(filterText = '') {
            const recipeListDiv = document.getElementById('anvilRecipeListContainer');
            const iconContainer = document.getElementById('anvilRecipeIconContainer');
            recipeListDiv.innerHTML = '';
            iconContainer.innerHTML = '';
            
            if (!currentlyOpenAnvil) return;
            const currentPower = currentlyOpenAnvil.power;
            const filterNormalized = normalizeForSearch(filterText);

            const filteredRecipes = anvilRecipes.filter(r => {
                // Filter by anvil power
                if (r.anvilPower > currentPower) {
                    return false;
                }
                
                // Filter by search text
                if (filterNormalized === '') return true;

                const nameCandidate = normalizeForSearch(r.name || '');
				const outputCandidate = normalizeForSearch(r.output || '');
				if ((nameCandidate && nameCandidate.includes(filterNormalized)) || (outputCandidate && outputCandidate.includes(filterNormalized))) {
					return true;
				}
				for (const key in r.input) {
					const inputItem = r.input[key];
					if (!inputItem) continue;
					const inputTypeNorm = normalizeForSearch(inputItem.type || '');
					if (inputTypeNorm.includes(filterNormalized)) return true;
				}
				return false;
			});

            // Render List View
            for (const recipe of filteredRecipes) {
                const recipeItemDiv = document.createElement('div');
                recipeItemDiv.classList.add('recipe-item');
                const inputGridDiv = document.createElement('div');
                inputGridDiv.classList.add('recipe-input-grid');
                for (let i = 0; i < 16; i++) {
                    const inputItem = recipe.input[i];
                    const slot = createInventorySlot(inputItem ? {type: inputItem.type, count: inputItem.count} : null, -1, 'recipe');
                    inputGridDiv.appendChild(slot);
                }
                recipeItemDiv.appendChild(inputGridDiv);
                const arrowSpan = document.createElement('span');
                arrowSpan.classList.add('crafting-arrow');
                arrowSpan.textContent = '';
                recipeItemDiv.appendChild(arrowSpan);
                const outputDiv = document.createElement('div');
                outputDiv.classList.add('recipe-output');
                const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
                const outputSlot = createInventorySlot({ type: recipe.output, count: recipe.outputCount, durability: outputItemProps?.isTool ? outputItemProps.maxDurability : null }, -1, 'recipe');
                outputDiv.appendChild(outputSlot);
                const outputNameSpan = document.createElement('span');
                outputNameSpan.textContent = recipe.name || recipe.output.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                outputDiv.appendChild(outputNameSpan);
                recipeItemDiv.appendChild(outputDiv);
                recipeListDiv.appendChild(recipeItemDiv);
				if (cheatItems === true) {
					recipeItemDiv.addEventListener('click', () => {
						anvilGridSlots.fill(null);
						for (const key in recipe.input) {
							const required = recipe.input[key];
							anvilGridSlots[key] = { type: required.type, count: required.count };
						}
						updateAnvilMenu();
					});
				}
            }
            
            // Render Icon View
			for (const recipe of filteredRecipes) {
                // We re-use createRecipeIconSlot, which is generic enough
                const iconSlot = createRecipeIconSlot(recipe); 
                iconContainer.appendChild(iconSlot);
            }
        }

        function checkAnvilRecipe() {
            anvilOutputSlot.innerHTML = '';
            anvilCraftButton.disabled = true;
            anvilCraftButton.onclick = null;
            if (!currentlyOpenAnvil) return;

            const currentPower = currentlyOpenAnvil.power;

            for (const recipe of anvilRecipes) {
                // Check if this anvil is powerful enough
                if (recipe.anvilPower > currentPower) {
                    continue;
                }

                const requiredInput = recipe.input;
                const requiredKeys = Object.keys(requiredInput);
                const currentGridItems = {};
                let gridItemCount = 0;
                for(let i=0; i<16; i++) {
                    if(anvilGridSlots[i]) {
                        currentGridItems[i] = anvilGridSlots[i];
                        gridItemCount++;
                    }
                }

                if (requiredKeys.length !== gridItemCount) continue;

                let allMatch = true;
				for (const key of requiredKeys) {
					const required = requiredInput[key];
					const current = currentGridItems[key];
					if (!current || current.count < required.count) {
						allMatch = false;
						break;
					}
					if (required.type === 'any_plank') {
						if (!current.type.startsWith('planked_')) {
							allMatch = false; break;
						}
					} else if (required.type === 'any_gilded') {
						if (!current.type.startsWith('gilded_') && !current.type.startsWith('raw_gilded_') && !current.type.startsWith('planked_gilded_')) {
							allMatch = false; break;
						}
					} else if (current.type !== required.type) {
						allMatch = false;
						break;
					}
				}

                if (allMatch) {
                    const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
                    const outputSlotContent = createInventorySlot({ type: recipe.output, count: recipe.outputCount, durability: outputItemProps?.isTool ? outputItemProps.maxDurability : null, maxDurability: outputItemProps?.isTool ? outputItemProps.maxDurability : null }, -1, 'output');
                    anvilOutputSlot.appendChild(outputSlotContent);
                    anvilCraftButton.disabled = false;
                    anvilCraftButton.onclick = (event) => executeAnvilCraft(recipe, event.shiftKey);
                    return;
                }
            }
        }

        function executeAnvilCraft(recipe, isShiftClick = false) {
            let maxCrafts = 1;
        
            if (isShiftClick) {
                let maxFromMaterials = Infinity;
                for (const key in recipe.input) {
                    const required = recipe.input[key];
                    const current = anvilGridSlots[key];
                    const possible = Math.floor(current.count / required.count);
                    if (possible < maxFromMaterials) {
                        maxFromMaterials = possible;
                    }
                }
        
                let spaceAvailable = 0;
                const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
                if (outputItemProps.isTool) {
                     spaceAvailable = inventorySlots.filter(slot => !slot).length;
                } else {
                    inventorySlots.forEach(slot => {
                        if (!slot) {
                            spaceAvailable += maxStackSize;
                        } else if (slot.type === recipe.output) {
                            spaceAvailable += maxStackSize - slot.count;
                        }
                    });
                }
                const maxFromSpace = Math.floor(spaceAvailable / recipe.outputCount);
                maxCrafts = Math.min(maxFromMaterials, maxFromSpace);
            }
            
            if (maxCrafts <= 0) return;
        
            for (let i = 0; i < maxCrafts; i++) {
                for (const key in recipe.input) {
                    const required = recipe.input[key];
                    const current = anvilGridSlots[key];
                    if(current) {
                         current.count -= required.count;
                         if (current.count <= 0) anvilGridSlots[key] = null;
                    } else {
                        updateAnvilMenu();
                        return;
                    }
                }
                const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
                addToInventory(recipe.output, recipe.outputCount, outputItemProps?.isTool ? outputItemProps.maxDurability : null);
            }
        
            updateAnvilMenu();
        }
		
        function renderFurnaceRecipes(filterText = '') {
            const ovenRecipeListContainer = document.getElementById('ovenRecipeListContainer'); // Find new container ID
            const iconContainer = document.getElementById('ovenRecipeIconContainer');
            ovenRecipeListContainer.innerHTML = '';
            iconContainer.innerHTML = '';

			// Choose the correct recipe list
			const recipeList = currentlyOpenFurnace.type === 'magma_furnace' ? furnaceRecipes : currentlyOpenFurnace.type === 'power_forge' ? forgeRecipes : ovenRecipes;

            const filter = filterText.toLowerCase();
            const filterNormalized = normalizeForSearch(filterText);

			const filteredRecipes = recipeList.filter(r => {
				// Normalize candidate strings
				const nameCandidate = normalizeForSearch(r.name || '');
				const outputCandidate = normalizeForSearch(r.output || '');
				// check name or output
				if ((nameCandidate && nameCandidate.includes(filterNormalized)) || (outputCandidate && outputCandidate.includes(filterNormalized))) {
					return true;
				}

				// Check ingredients (each r.input[i].type)
				for (const key in r.input) {
					const inputItem = r.input[key];
					if (!inputItem) continue;
					const inputTypeNorm = normalizeForSearch(inputItem.type || '');
					if (inputTypeNorm.includes(filterNormalized)) return true;
				}

				// Check fuel: allow matching "fuel", "pure fuel", "coal", etc. Normalize recipe.fuel type if available.
				// Some of your recipes store fuel as a count on pure_fuel; if you have a named fuel type, normalize it too.
				if (r.fuel) {
					// treat the word "fuel" specially: a user searching "fuel" should match recipes that require fuel
					if ('fuel'.includes(filterNormalized) && filterNormalized.length > 0) {
						// If the user typed only 'f' or 'fu' they'd matchavoid that by requiring the filter be at least 2 chars or exactly 'fuel'
						if (filterNormalized === 'fuel' || filterNormalized.length >= 2) {
							return true;
						}
					}
					// If you have explicit fuel type string (e.g., r.fuelType), check it:
					if (r.fuelType && normalizeForSearch(r.fuelType).includes(filterNormalized)) return true;
					// Also allow matching the literal token "pure_fuel"
					if (normalizeForSearch('pure_fuel').includes(filterNormalized)) return true;
				}

				// No match
				return false;
			});

			for (const recipe of filteredRecipes) {
                const recipeItemDiv = document.createElement('div');
                recipeItemDiv.classList.add('recipe-item');
                recipeItemDiv.style.justifyContent = 'center';
                recipeItemDiv.style.gap = '10px';
                
                // CREATE A GRID CONTAINER for the inputs
                const inputGridDiv = document.createElement('div');
                inputGridDiv.style.display = 'grid';
                inputGridDiv.style.gridTemplateColumns = 'repeat(3, 35px)'; // 3x3 grid
                inputGridDiv.style.gap = '3px';

                // LOOP 0-8 to create the full 3x3 grid
                for (let i = 0; i < 9; i++) {
                    const inputItem = recipe.input[i];
                    const slot = createInventorySlot(inputItem ? {type: inputItem.type, count: inputItem.count} : null, -1, 'recipe');
                    // Adjust slot size to fit the recipe display
                    slot.style.width = '35px';
                    slot.style.height = '35px';
                    inputGridDiv.appendChild(slot);
                }
                recipeItemDiv.appendChild(inputGridDiv);


                // Plus Sign and Fuel (This part was okay)
                const fuelInfo = document.createElement('div');
                fuelInfo.style.display = 'flex';
                fuelInfo.style.alignItems = 'center';
                fuelInfo.style.gap = '5px';
                fuelInfo.innerHTML = `<span>+</span>`;
                const fuelSlot = createInventorySlot({type: 'pure_fuel', count: recipe.fuel}, -1, 'recipe');
                fuelInfo.appendChild(fuelSlot);
                recipeItemDiv.appendChild(fuelInfo);

                // Arrow (This part was okay)
                const arrowSpan = document.createElement('span');
                arrowSpan.classList.add('crafting-arrow');
                arrowSpan.textContent = '';
                recipeItemDiv.appendChild(arrowSpan);

                // Display Output Item (This part was okay)
                const outputSlot = createInventorySlot({ type: recipe.output, count: recipe.outputCount }, -1, 'recipe');
                recipeItemDiv.appendChild(outputSlot);

                ovenRecipeListContainer.appendChild(recipeItemDiv);
            }
			for (const recipe of filteredRecipes) {
                const iconSlot = createRecipeIconSlot(recipe);
                iconContainer.appendChild(iconSlot);
            }
        }

        maintainDurabilityCheckbox.addEventListener('change', () => { maintainBlockDurability = maintainDurabilityCheckbox.checked; });
        autosaveCheckbox.addEventListener('change', () => { autosave = autosaveCheckbox.checked; });
		animateDropsCheckbox.addEventListener('change', () => { animateDrops = animateDropsCheckbox.checked; });
		const transferAllButton = document.getElementById('transferAllButton');
        transferAllButton.addEventListener('click', transferAllFromChest);

        function startNewGame(seedToUse) {
            // Pause the game if it's not already, and close the menu. Removed for causing tip bug.
            // if (!isGamePaused) toggleGameMenu();
            if (gameMenuOverlay.style.display === 'flex') gameMenuOverlay.style.display = 'none';
            isGamePaused = false;
        
            setSeed(seedToUse);
            
            // Clear all world data
            Object.keys(worldBlocks).forEach(key => delete worldBlocks[key]);
            Object.keys(fireBlocks).forEach(key => delete fireBlocks[key]);
			exploredMap = {};
            
            // Clear all height and biome maps
            Object.keys(columnSurfaceHeights).forEach(key => delete columnSurfaceHeights[key]);
            Object.keys(heavenColumnSurfaceHeights).forEach(key => delete heavenColumnSurfaceHeights[key]);
            Object.keys(superHeavenColumnSurfaceHeights).forEach(key => delete superHeavenColumnSurfaceHeights[key]);

            // --- THE BUG FIX IS HERE ---
            Object.keys(worldBiomes).forEach(key => delete worldBiomes[key]);
            lastBiomeEndCol = -1;
            firstBiomeStartCol = 0;

            Object.keys(underworldBiomes).forEach(key => delete underworldBiomes[key]); // <-- Add this
            lastUnderworldBiomeEndCol = -1; // <-- Add this
            firstUnderworldBiomeStartCol = 0; // <-- Add this

            Object.keys(heavenBiomes).forEach(key => delete heavenBiomes[key]); // <-- Add this
            lastHeavenBiomeEndCol = -1; // <-- Add this
            firstHeavenBiomeStartCol = 0; // <-- Add this
            // --- END OF FIX ---
            
            // Clear all feature tracking sets
            caveBlocks.clear();
            traderColumns.clear();
            watchtowerColumns.clear();
            sandstoneTempleColumns.clear();
            skyIslandColumns.clear();
            mineChamberColumns.clear();
            voidRealmColumns.clear();
            chasmColumns.clear();
            bunkerColumns.clear();
            plantationColumns.clear();
            redRockColumns.clear();
            graniteMountainColumns.clear();
            icyHillColumns.clear();
            jungleTempleColumns.clear();
            doomShackColumns.clear();
			ruinedPortalColumns.clear();

            // Reset player
            player.x = 0 * tileSize; player.y = 0; player.dx = 0; player.dy = 0; player.onGround = false;
            player.maxHealth = 100; player.health = player.maxHealth; player.bedSpawnPoint = null;
            player.armor = { helmet: null, chestGear: null, legGear: null, boots: null };
            deathCount = 0;
            insomnia = 0;
            guanoMined = 0;
			
			playerXP = 0;
			earnedAchievements = [];
			
			isPlayerOnHellfire = false;
            hellfireLevel = 1.0;
            isPlayerInHellfireZone = false;
			
			player.bloodAlcohol = 0;
            player.activeEffects = [];
            const vignette = document.getElementById('drunkVignette'); // --- ADD THIS ---
            if (canvas) canvas.style.filter = 'none';
            if (canvas) canvas.classList.remove('vibrating'); // --- ADD THIS ---
            if (vignette) vignette.style.display = 'none'; // --- ADD THIS ---
			
            // Reset inventory
            inventorySlots.fill(null); 
            hotbarIndices.fill(null); 
            selectedHotbarSlot = 0;
            craftingGridSlots.fill(null); 
            heldItem = null; 
            heldItemSource = { type: null, index: -1 };
            
            // Close any open trader UI
            if (isTraderMenuOpen) toggleTraderMenu();
            
            // Re-initialize and show message
            updateHotbar();
            init();
            //showMessageBox(`New game started with seed: ${seedToUse}`);
        }

        newGameButton.addEventListener('click', async () => {
            if (await showMessageBox("Starting a new game will overwrite current progress. Are you sure?", 'confirm')) {
                let newSeedValue = seedInput.value.trim();
                let seedToUse = newSeedValue === '' ? Date.now() : stringToHash(newSeedValue);
                startNewGame(seedToUse); // Call our new function
            }
        });

        resumeButton.addEventListener('click', toggleGameMenu);

        let lastTime = performance.now();
        let accumulator = 0.0;
        const fixedDeltaTime = 1000 / 60; // Run physics at 60 updates per second

        function gameLoop(currentTime) {
            if (isGameActive && !isGamePaused) {
                accumulator += currentTime - lastTime;
                lastTime = currentTime;

                // Prevent spiral of death on major lag spikes
                if (accumulator > 1000) {
                    accumulator = 1000;
                }
				
				frameCount++;
				if (currentTime - lastFpsUpdate >= 1000) {
					currentFps = frameCount;
					frameCount = 0;
					lastFpsUpdate = currentTime;
				}
				
                while (accumulator >= fixedDeltaTime) {
                    update(fixedDeltaTime); // Update with a fixed time step
                    accumulator -= fixedDeltaTime;
                }
            } else {
                // If paused, we still need to reset lastTime when resuming
                lastTime = currentTime;
            }
            
            draw(); // Draw as fast as possible
            requestAnimationFrame(gameLoop);
        }

        function updatePlayerEffects(dt) {
            if (player.activeEffects.length === 0) return;

            const now = gameTime;
            // Loop backwards so we can safely remove items
            for (let i = player.activeEffects.length - 1; i >= 0; i--) {
                const effect = player.activeEffects[i];
                
                // Check if the effect has expired
                if (now - effect.startTime > (effect.duration * 1000)) {
                    player.activeEffects.splice(i, 1); // Remove expired effect
                }
            }
        }
        
        let waiterGo = 0
		let waiterGone = 0
        
        function update(dt) {
            // Note: The 'dt' here is now a fixed value
			gameTime += dt;

            // --- ADD GUN ANGLE CALCULATION ---
            const equippedItemObject = getSelectedItem();
            const equippedItemProps = equippedItemObject ? itemTypes[equippedItemObject.type] : null;
            if (equippedItemProps && equippedItemProps.isGun) {
                const playerCenterX = player.x + playerWidth / 2;
                const playerCenterY = player.y + playerHeight / 2.5; // Hand position
                const worldMouseX = mouse.x + camera.x;
                const worldMouseY = mouse.y + camera.y;
                // Calculate and store the angle to the mouse
                heldItemState.gunAngle = Math.atan2(worldMouseY - playerCenterY, worldMouseX - playerCenterX);
            }

			if (player.bloodAlcohol > 0) {
                player.bloodAlcohol = Math.max(0, player.bloodAlcohol - 1.2 * (dt / 1000)); // Decays 1.2 per second
            }
            if (deathCount >= 100) unlockAchievement('PERSISTENT');
            updatePlayerEffects(dt);
			if (hellfireOn && !isPlayerOnHellfire) { // Don't update if already on permanent fire
                if (isPlayerInHellfireZone) {
                    // Calculate armor slowdown
                    let armorPieces = 0;
                    if (player.armor.helmet) armorPieces++;
                    if (player.armor.chestGear) armorPieces++;
                    if (player.armor.legGear) armorPieces++;
                    if (player.armor.boots) armorPieces++;

                    // Calculate slowdown (4 pieces = 80% slowdown)
                    const slowdown = Math.min(1.0, armorPieces * 0.20); // 0.0 (0%) to 0.8 (80%)
                    const currentRate = 1.0 - slowdown; // 1.0 (no armor) down to 0.2 (full armor)

                    // Calculate desaturation amount for this tick
                    const desatAmount = dt / HELLFIRE_DURATION_MS;
                    
                    hellfireLevel -= desatAmount * currentRate;

                    if (hellfireLevel <= 0) {
                        hellfireLevel = 0;
                        isPlayerOnHellfire = true; // Set on fire!
                    }
                }
            }
            updatePlayer(dt);
            updateCamera();
            updateMining(dt);
            handleBlockPlacement();
			updateAnimatedDrops(dt);
			updateFire(dt);
			updateBullets(dt);
            plantSpoilageAccumulator += dt;
			if (plantSpoilageAccumulator >= PLANT_SPOILAGE_INTERVAL) {
			  updatePlantGrowth();
			  updateSpoilage();
			  plantSpoilageAccumulator = 0;
			}
            waiterGo += 1
			waiterGone += 1
            if (waiterGo === 3) {
                waiterGo = 0
                updateParticles(dt);
                updateHeldItemAnimation(dt); // Possibly Optimizeable
                updateHotbar();
            }
            if (waiterGo === 1) {
                updateHeldItemAnimation(dt);
                updateParticles(dt);
            }
            if (waiterGone >= 60) { // 60 frames = 1 second
                waiterGone = 0;
                
                generateOffscreenChunks(); // <-- MOVED: Now runs 1/sec, not 20/sec
                updateDebugStats(); // <-- MOVED: Only needs to update 1/sec
            }

            const playerGridCoords = worldToGrid(player.x + playerWidth / 2, player.y + playerHeight / 2);
            coordsDisplay.textContent = `Coords: (${playerGridCoords.col}, ${playerGridCoords.row})`;
			deathDisplay.textContent = `Deaths: ${deathCount}`;
        }
		
		function drawHellfireIcon() {
            const icon = document.getElementById('hellfireIcon');
            if (hellfireOn && (isPlayerInHellfireZone || isPlayerOnHellfire)) {
                icon.style.display = 'block';
                // Update the saturation filter
                icon.style.filter = `saturate(${hellfireLevel * 100}%)`;
				unlockAchievement('DEATH_CATALYST');
            } else {
                icon.style.display = 'none';
            }
        }
		
		function drawMinimap() {
            if (!showMinimap) return;

            // Cache the canvas and context for performance
            if (!mmCanvas) mmCanvas = document.getElementById('minimapCanvas');
            if (!mmCtx) mmCtx = mmCanvas.getContext('2d');
            if (!mmCanvas || !mmCtx) return;

            const mapSize = 150; // 150x150 pixels
            const halfMapSize = Math.floor(mapSize / 2); // 75

            // Clear the minimap with its background color
            mmCtx.fillStyle = '#000000';
            mmCtx.fillRect(0, 0, mapSize, mapSize);

            // Get player's tile position
            const playerCol = Math.floor(player.x / tileSize);
            const playerRow = Math.floor(player.y / tileSize);

            // Calculate the top-left tile to start drawing from
            const startCol = playerCol - halfMapSize;
            const startRow = playerRow - halfMapSize;
            const endCol = playerCol + halfMapSize;
            const endRow = playerRow + halfMapSize;

            for (let col = startCol; col <= endCol; col++) {
                for (let row = startRow; row <= endRow; row++) {
                    const key = `${col},${row}`;
                    let color = exploredMap[key]; // Check the cache

                    if (color === undefined) {
                        // Not in cache, let's explore this tile
                        // --- FIX: Use getBlockData to ensure the block is loaded ---
                        const blockData = getBlockData(col, row);
                        const blockType = blockData.type;
                        
                        if (blockType !== '' && blockTypes[blockType] && blockTypes[blockType].solid) {
                            // It's a solid block, get its color
                            const blockProps = blockTypes[blockType];
                            // --- USE COMPUTED COLOR FIRST ---
                            color = /*blockProps.computedColor ||*/ blockProps.color || '#FFFFFF'; // Use new color, fallback to old color, then white
                        } else if (blockData.type === '') {
                            // It's explored, but it's air (sky, cave)
                            color = '#000000'; // Draw as black
                        } else {
                             // Block not solid or not loaded yet
                            color = null;
                        }
                        exploredMap[key] = color; // Save to cache
                    }

                    if (color) {
                        // Calculate where to draw this pixel on the minimap
                        const mmX = col - startCol;
                        const mmY = row - startRow;
                        
                        mmCtx.fillStyle = color;
                        mmCtx.fillRect(mmX, mmY, 1, 1); // Draw the 1x1 pixel
                    }
                }
            }

            // Draw the player icon in the center (a 3x3 red square)
            mmCtx.fillStyle = '#FF0000'; // Bright red
            mmCtx.fillRect(halfMapSize - 1, halfMapSize - 1, 3, 3);
        }
		
		function toggleFullscreenMap() {
			isFullscreenMapOpen = !isFullscreenMapOpen;
            isGamePaused = isFullscreenMapOpen;
            fullscreenMapOverlay.style.display = isFullscreenMapOpen ? 'flex' : 'none';

            if (isFullscreenMapOpen) {
                // Center map on player when opening
                fullscreenMapDrag.mapCol = Math.floor(player.x / tileSize);
                fullscreenMapDrag.mapRow = Math.floor(player.y / tileSize);
                
                // Resize canvas to fit screen
                fsMapCanvas.width = fullscreenMapOverlay.clientWidth;
                fsMapCanvas.height = fullscreenMapOverlay.clientHeight;
                
                drawFullscreenMap();
            } else {
                lastTime = performance.now(); // Resume game
            }
        }

        function drawFullscreenMap() {
            if (!isFullscreenMapOpen) return;

            const width = fsMapCanvas.width;
            const height = fsMapCanvas.height;
            const zoom = fullscreenMapDrag.zoom;

            // Clear with black
            fsMapCtx.fillStyle = '#000000';
            fsMapCtx.fillRect(0, 0, width, height);

            // Center of the screen in pixels
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Player's grid position
            const playerCol = Math.floor(player.x / tileSize);
            const playerRow = Math.floor(player.y / tileSize);

            // Calculate the screen position of a block at (col, row)
            const getScreenPos = (col, row) => {
                const screenX = centerX + (col - fullscreenMapDrag.mapCol) * zoom;
                const screenY = centerY + (row - fullscreenMapDrag.mapRow) * zoom;
                return { x: screenX, y: screenY };
            };

            // Iterate over all explored blocks
            for (const key in exploredMap) {
                const color = exploredMap[key];
                if (!color) continue; // Skip null/undefined (unexplored)

                const [col, row] = key.split(',').map(Number);
                const { x, y } = getScreenPos(col, row);

                // Culling: Don't draw if it's off-screen
                if (x + zoom < 0 || x > width || y + zoom < 0 || y > height) {
                    continue;
                }

                fsMapCtx.fillStyle = color;
                fsMapCtx.fillRect(x, y, zoom, zoom);
            }

            // Draw player icon (a larger red square)
            const playerPos = getScreenPos(playerCol, playerRow);
            fsMapCtx.fillStyle = '#FF0000';
            fsMapCtx.fillRect(playerPos.x - 2, playerPos.y - 2, zoom + 4, zoom + 4);
            fsMapCtx.strokeStyle = '#FFFFFF';
            fsMapCtx.strokeRect(playerPos.x - 2, playerPos.y - 2, zoom + 4, zoom + 4);
        }

        function setupMapListeners() {
            const closeButton = document.getElementById('fullscreenMapCloseButton');
            closeButton.addEventListener('click', toggleFullscreenMap);
            closeButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleFullscreenMap();
            });

            // Click minimap to open fullscreen map
            minimapContainer.addEventListener('click', toggleFullscreenMap);
            minimapContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleFullscreenMap();
            });

            // Drag to pan map (Mouse)
            fsMapCanvas.addEventListener('mousedown', (e) => {
                if (!isFullscreenMapOpen) return;
                fullscreenMapDrag.active = true;
                fullscreenMapDrag.lastX = e.clientX;
                fullscreenMapDrag.lastY = e.clientY;
                fsMapCanvas.style.cursor = 'grabbing';
            });
            fsMapCanvas.addEventListener('mousemove', (e) => {
                if (!isFullscreenMapOpen || !fullscreenMapDrag.active) return;
                const deltaX = e.clientX - fullscreenMapDrag.lastX;
                const deltaY = e.clientY - fullscreenMapDrag.lastY;

                fullscreenMapDrag.mapCol -= deltaX / fullscreenMapDrag.zoom;
                fullscreenMapDrag.mapRow -= deltaY / fullscreenMapDrag.zoom;

                fullscreenMapDrag.lastX = e.clientX;
                fullscreenMapDrag.lastY = e.clientY;
                drawFullscreenMap();
            });
            fsMapCanvas.addEventListener('mouseup', () => {
                fullscreenMapDrag.active = false;
                fsMapCanvas.style.cursor = 'grab';
            });
            fsMapCanvas.addEventListener('mouseleave', () => {
                fullscreenMapDrag.active = false;
                fsMapCanvas.style.cursor = 'grab';
            });

            // Drag to pan map (Touch)
            fsMapCanvas.addEventListener('touchstart', (e) => {
                if (!isFullscreenMapOpen || e.touches.length === 0) return;
                e.preventDefault();
                fullscreenMapDrag.active = true;
                fullscreenMapDrag.lastX = e.touches[0].clientX;
                fullscreenMapDrag.lastY = e.touches[0].clientY;
            }, { passive: false });

            fsMapCanvas.addEventListener('touchmove', (e) => {
                if (!isFullscreenMapOpen || !fullscreenMapDrag.active || e.touches.length === 0) return;
                e.preventDefault();
                const touch = e.touches[0];
                const deltaX = touch.clientX - fullscreenMapDrag.lastX;
                const deltaY = touch.clientY - fullscreenMapDrag.lastY;

                fullscreenMapDrag.mapCol -= deltaX / fullscreenMapDrag.zoom;
                fullscreenMapDrag.mapRow -= deltaY / fullscreenMapDrag.zoom;

                fullscreenMapDrag.lastX = touch.clientX;
                fullscreenMapDrag.lastY = touch.clientY;
                drawFullscreenMap();
            }, { passive: false });

            fsMapCanvas.addEventListener('touchend', () => {
                fullscreenMapDrag.active = false;
            });
        }
		
		function findAndConsumeAmmo() {
            // 1. Check hotbar first
            for (let i = 0; i < hotbarSize; i++) {
                const inventoryIndex = hotbarIndices[i];
                if (inventoryIndex === null) continue;
                const item = inventorySlots[inventoryIndex];
                if (item && itemTypes[item.type]?.isAmmo) {
                    lastAmmoTypeFired = item.type;  // <--- NEW
					const ammoPower = itemTypes[item.type].ammoPower || 0;
					removeItemFromInventory(i, 1);
					return ammoPower;
                }
            }
            // 2. Check main inventory
            for (let i = hotbarSize; i < totalInventorySlots; i++) {
                const item = inventorySlots[i];
                if (item && itemTypes[item.type]?.isAmmo) {
                    lastAmmoTypeFired = item.type;  // <--- NEW
					const ammoPower = itemTypes[item.type].ammoPower || 0;
					removeItemFromInventory(i, 1);
					return ammoPower;
                }
            }
            return null; // No ammo found
        }

        function handleShooting(dt) {
            if (gunCooldown > 0) {
                gunCooldown -= dt;
                return;
            }

            const equippedItemObject = getSelectedItem();
            const equippedItemProps = equippedItemObject ? itemTypes[equippedItemObject.type] : null;
            if (!equippedItemObject || !equippedItemProps || !equippedItemProps.isGun) {
                return;
            }

            // Find and consume ammo
            const bulletPower = findAndConsumeAmmo();
            if (bulletPower === null) {
                // No ammo, maybe play a "click" sound
                gunCooldown = 200; // Cooldown even on a dry fire
                return;
            }

            // Set cooldown based on gun's fireRate
            gunCooldown = equippedItemProps.fireRate * 1000;

            // Consume durability
            const fireLoss = equippedItemProps.fireLoss || {min: 1, max: 1};
            const durabilityLoss = fireLoss.min + random() * (fireLoss.max - fireLoss.min);
            equippedItemObject.durability -= durabilityLoss;

            if (equippedItemObject.durability <= 0) {
                removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
                updateHotbar();
                return; // Gun broke
            }
            
            // Trigger recoil animation
            heldItemState.isSwinging = true;
            heldItemState.swingTimer = 0;

            // Calculate trajectory
            const startX = player.x + playerWidth / 2;
            const startY = player.y + playerHeight / 2.5; // Match hand position
            const worldMouseX = mouse.x + camera.x;
            const worldMouseY = mouse.y + camera.y;

            const angle = Math.atan2(worldMouseY - startY, worldMouseX - startX);
            const dx = Math.cos(angle);
            const dy = Math.sin(angle);
            const totalDamage = (equippedItemProps.gunPower || 0) + bulletPower;

            // Create bullet entity
            bullets.push({
				x: startX,
				y: startY,
				dx: dx,
				dy: dy,
				damage: totalDamage,
				life: 1000,
				angle: angle,
				ammoType: lastAmmoTypeFired // <-- NEW
			});
        }

        function updateBullets(dt) {
            const timeFactor = dt / (1000 / 60); // Scale speed by dt

            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                bullet.life -= dt;
                if (bullet.life <= 0) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Update position
                bullet.x += bullet.dx * BULLET_SPEED * timeFactor;
                bullet.y += bullet.dy * BULLET_SPEED * timeFactor;

                const gridCol = Math.floor(bullet.x / tileSize);
                const gridRow = Math.floor(bullet.y / tileSize);
                const key = `${gridCol},${gridRow}`;

                if (isSolid(gridCol, gridRow)) {
                    unlockAchievement('PEW_PEW');
					const blockData = worldBlocks[key];
                    const blockProps = blockTypes[blockData.type];

                    // Check if block can be damaged
                    if (blockProps && blockProps.miningHardness > 0 && !blockProps.requiredTool) {
                        blockData.mineProg = (blockData.mineProg || 0) + bullet.damage;
                        
                        // Create impact particles
                        const originalParticleCount = particleCount;
                        particleCount = 3; // Small puff
                        createBlockBreakParticles(gridCol, gridRow, blockData.type);
                        particleCount = originalParticleCount;

                        // Check if block broke
                        if (blockData.mineProg >= blockProps.miningHardness) {
                            handleMiningDrops(blockProps, key);
                            createBlockBreakParticles(gridCol, gridRow, blockData.type); // Full break particles
                            worldBlocks[key] = { type: '', mineProg: 0 };
                            exploredMap[key] = '#000000';

                            // --- ADDED: Break foliage above logic ---
                            let currentRow = gridRow - 1; // Start with the block directly above
                            
                            while (true) {
                                const blockAboveKey = `${gridCol},${currentRow}`;
                                const blockAboveData = worldBlocks[blockAboveKey];
                            
                                if (blockAboveData && foliageTypes.includes(blockAboveData.type)) {
                                    const blockAboveProps = blockTypes[blockAboveData.type];
                            
                                    if (canInventoryAcceptDrops(blockAboveProps.drops)) {
                                        worldBlocks[blockAboveKey] = { type: '', mineProg: 0 };
                                        handleMiningDrops(blockAboveProps, blockAboveKey);
                                        currentRow--; 
                                    } else {
                                        break;
                                    }
                                } else {
                                    break;
                                }
                            }
                            // --- END OF FOLIAGE LOGIC ---
                        }
                    }
                    bullets.splice(i, 1); // Remove bullet on impact
                }
            }
        }

        function drawBullets() {
            if (bullets.length === 0) return;
            
            for (const bullet of bullets) {
				const ammoImgKey = bullet.ammoType ? bullet.ammoType : 'brass_bullet';
				const bulletImg = assets[ammoImgKey];

				if (!bulletImg || failedAssets['brass_bullet']) {
					// Fallback to yellow square if asset fails
					ctx.fillStyle = '#FFFF00';
					for (const bullet of bullets) {
						const screenX = bullet.x - camera.x;
						const screenY = bullet.y - camera.y;
						if (screenX < 0 || screenX > canvas.width || screenY < 0 || screenY > canvas.height) continue;
						ctx.fillRect(screenX - (BULLET_SIZE/2), screenY - (BULLET_SIZE/2), BULLET_SIZE, BULLET_SIZE);
					}
					return;
				}

				// Draw with rotated image
				for (const bullet of bullets) {
					const screenX = bullet.x - camera.x;
					const screenY = bullet.y - camera.y;

					// Culling (check a bit outside the screen)
					if (screenX < -BULLET_SIZE || screenX > canvas.width + BULLET_SIZE || screenY < -BULLET_SIZE || screenY > canvas.height + BULLET_SIZE) {
						continue;
					}
					
					ctx.save();
					// Translate to the bullet's center
					ctx.translate(screenX, screenY);
					// Rotate by the angle calculated during firing
					ctx.rotate(bullet.angle); 
					
					// --- ADD THIS FLIP LOGIC ---
					const isAimingLeft = Math.abs(bullet.angle) > (Math.PI / 2);
					if (isAimingLeft) {
						ctx.scale(1, -1); // Flip sprite vertically
					}
					// --- END OF ADDITION ---
					
					// Draw the image centered on the new (0,0) origin
					ctx.drawImage(bulletImg, -BULLET_SIZE / 2, -BULLET_SIZE / 2, BULLET_SIZE, BULLET_SIZE);
					
					ctx.restore();
				}
			}
        }
		
        function draw() {
			//ctx.imageSmoothingEnabled = isCinemaMode;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawWorld();
			drawAnimatedDrops();
			drawBullets();
			drawParticles();
            drawPlayer();
			drawHeldItem();
            drawmineProg();
			drawFire();
			drawPlayerFire();
            drawHealth();
			drawHellfireIcon();
            drawDrunkEffect();
			drawMinimap();
			drawBlockOutline();
        }
		
		function unlockAchievement(id) {
			if (!id || !achievements[id] || earnedAchievements.includes(id)) {
				return; // Invalid ID or already earned
			}

			// 1. Mark as earned and add XP
			earnedAchievements.push(id);
			const achievement = achievements[id];
			playerXP += achievement.xp;

			console.log(`Achievement Unlocked: ${achievement.name}! +${achievement.xp} XP`);

			// 2. Create the visual toast pop-up
			const toastContainer = document.getElementById('achievementToastContainer');
			
			const toast = document.createElement('div');
			toast.className = 'achievement-toast';

			// Find the icon image source
			// We check both itemTypes and blockTypes to find the icon
			const itemIconProps = itemTypes[achievement.icon.replace('.png', '')] || blockTypes[achievement.icon.replace('.png', '')];
			const iconSrc = itemIconProps ? itemIconProps.imgSrc : achievement.icon; // Use the direct filename as a fallback

			toast.innerHTML = `
				<img src="${iconSrc}" class="achievement-toast-icon" alt="">
				<div class="achievement-toast-text">
					<h4>${achievement.name}</h4>
					<p>${achievement.desc}</p>
					<span class="xp-gain">+${achievement.xp} XP</span>
				</div>
			`;

			toastContainer.appendChild(toast);

			// 3. Set timer to remove the toast
			setTimeout(() => {
				toast.remove();
			}, 5000); // Stays on screen for 5 seconds
		}
		
		function toggleXPMenu() {
			if (isGamePaused && xpMenuOverlay.style.display !== 'flex') {
				return; // Another menu is open, don't open this one
			}

			isGamePaused = !isGamePaused;

			if (isGamePaused) {
				xpMenuOverlay.style.display = 'flex';
				updateXPMenu();
			} else {
				xpMenuOverlay.style.display = 'none';
				lastTime = performance.now();
			}
		}

		function updateXPMenu() {
			const grid = document.getElementById('achievementGrid');
			const totalDisplay = document.getElementById('xpTotalDisplay');
			
			grid.innerHTML = '';
			totalDisplay.textContent = `${playerXP} XP`;

			// Iterate over the achievement definitions object
			for (const id in achievements) {
				const ach = achievements[id];
				const isEarned = earnedAchievements.includes(id);

				const slot = document.createElement('div');
				slot.className = 'achievement-slot';
				if (!isEarned) {
					slot.classList.add('unearned');
				}

				// Find icon source from assets
				const itemIconProps = itemTypes[ach.icon.replace('.png', '')] || blockTypes[ach.icon.replace('.png', '')];
				const iconSrc = itemIconProps ? itemIconProps.imgSrc : ach.icon;

				slot.innerHTML = `
					<img src="${iconSrc}" class="achievement-slot-icon" alt="${ach.name}">
					<span class="achievement-slot-name">${ach.name}</span>
					<span class="achievement-slot-xp">${ach.xp} XP</span>
					<p class="achievement-slot-desc">${ach.desc}</p>
					`;

				grid.appendChild(slot);
			}
		}

        function init() {
            resizeCanvas();
            setSeed(currentSeed);
            
            // Initial world generation around player spawn
            generateOffscreenChunks();

            const playerStartCol = Math.floor(player.x / tileSize);
            let actualSurfaceRowAtStart = baseSurfaceLevel;
            const maxSurfaceSevoidVoidArchDepth = 200;
            let sevoidVoidArchCount = 0;
            while(getBlockType(playerStartCol, actualSurfaceRowAtStart) === '' && sevoidVoidArchCount < maxSurfaceSevoidVoidArchDepth) {
                 actualSurfaceRowAtStart++;
                 sevoidVoidArchCount++;
            }
            if (sevoidVoidArchCount >= maxSurfaceSevoidVoidArchDepth) {
                console.warn("Could not find solid surface. Defaulting player Y.");
                actualSurfaceRowAtStart = baseSurfaceLevel + 10;
            }
            player.y = (actualSurfaceRowAtStart - playerHeightBlocks) * tileSize;
            player.spawnPoint = { x: player.x, y: player.y }; // Set initial spawn point
            setupLoadingScreenListeners();
			updateHotbar();
            lastTime = performance.now();
            if (!gameLoopId) {
                gameLoopId = requestAnimationFrame(gameLoop);
            }
			// Listener for the new "Achievements" button in the game menu
			achievementsButton.addEventListener('click', () => {
				// Close the game menu, then open the XP menu
				toggleGameMenu();
				toggleXPMenu();
			});

			// Listener for the mobile close button on the XP menu
			document.querySelector('#xpMenuOverlay .mobile-close-button').addEventListener('click', toggleXPMenu);
			document.querySelector('#xpMenuOverlay .mobile-close-button').addEventListener('touchstart', (e) => {
				e.preventDefault();
				e.stopPropagation();
				toggleXPMenu();
			});
        }
		
		loadSavedSkin();
        
        let gameLoopId;
        
        function exportWorldData() {
            const sanitizedWorldBlocks = {};
            for (const key in worldBlocks) {
                const block = worldBlocks[key];

                const sanitizedBlock = { tp: block.type };
                if (block.mineProg) sanitizedBlock.mP = block.mineProg;
                if (block.inventory) sanitizedBlock.inv = block.inventory;
                if (block.label) sanitizedBlock.lbl = block.label;
                if (block.part) sanitizedBlock.prt = block.part;
                if (block.plantTime) sanitizedBlock.pT = block.plantTime;
                if (block.baseBlockType) sanitizedBlock.bBT = block.baseBlockType;
                if (block.code) sanitizedBlock.cd = block.code;
                if (block.cloakedAs) sanitizedBlock.clk = block.cloakedAs;
                if (block.overlay) sanitizedBlock.ovr = block.overlay;
				// Book-specific data
                if (block.content) sanitizedBlock.con = block.content;
                if (block.published) sanitizedBlock.pub = block.published;
                if (block.title) sanitizedBlock.tit = block.title;
                if (block.cover) sanitizedBlock.cov = block.cover;

                if (block.item) sanitizedBlock.itm = block.item;
                
                sanitizedWorldBlocks[key] = sanitizedBlock;
            }

            const worldData = {
                seed: currentSeed,
                blocks: sanitizedWorldBlocks,
                heights: columnSurfaceHeights,
                heavenHeights: heavenColumnSurfaceHeights,
                biomes: worldBiomes,
                underworldBiomes: underworldBiomes,
                caves: Array.from(caveBlocks),
                islands: Array.from(skyIslandColumns),
                towers: Array.from(watchtowerColumns),
				temples: Array.from(sandstoneTempleColumns),
                player: {
                    x: player.x,
                    y: player.y,
                    h: player.health,
					mh: player.maxHealth,
					bac: player.bloodAlcohol,
                    eff: player.activeEffects,
                    bed: player.bedSpawnPoint,
                    armor: player.armor
                },
                inventory: inventorySlots,
                hotbar: hotbarIndices,
				void: voidStorage,
				trade: currentVoidTrade,
				death: deathCount,
                insomnia: insomnia,
                guanoMined: guanoMined,
				xp: playerXP,
				achievements: earnedAchievements,
				consoleHistory: commandHistory
            };

            const json = JSON.stringify(worldData);
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);

            const a = document.createElement("a");
            a.href = url;
            a.download = `world_${currentSeed}.bgu1`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessageBox("World Saved!");
        }

		document.addEventListener("keydown", (e) => {
			if (e.key === ']') {
				exportWorldData();
			}
		});

        document.addEventListener("keydown", (e) => {
			if (e.key === '*') {
                let seedToUse = Date.now(); // Always use a random seed for the hotkey
                startNewGame(seedToUse); // Call our new function
			}
		});

		document.getElementById("worldFileInput").addEventListener("change", function (event) {
			const file = event.target.files[0];
			if (!file) return;

			const reader = new FileReader();
			reader.onload = function (e) {
				try {
					const data = JSON.parse(e.target.result);
					importWorldData(data);
					showMessageBox("World data successfully imported!");
				} catch (err) {
					console.error("Error parsing world data:", err);
                    showMessageBox("Error: Could not load world file. It may be corrupted.");
				}
			};
			reader.readAsText(file);
		});

		function importWorldData(data) {
            // Clear existing world state
            Object.keys(worldBlocks).forEach(key => delete worldBlocks[key]);
			Object.keys(fireBlocks).forEach(key => delete fireBlocks[key]);
            Object.keys(columnSurfaceHeights).forEach(key => delete columnSurfaceHeights[key]);
            Object.keys(heavenColumnSurfaceHeights).forEach(key => delete heavenColumnSurfaceHeights[key]);
            Object.keys(worldBiomes).forEach(key => delete worldBiomes[key]);
            Object.keys(underworldBiomes).forEach(key => delete underworldBiomes[key]);
            traderColumns.clear();
            watchtowerColumns.clear();
			sandstoneTempleColumns.clear();
            skyIslandColumns.clear();
		    mineChamberColumns.clear();
        	voidRealmColumns.clear();
    		chasmColumns.clear();
            bunkerColumns.clear();
		    plantationColumns.clear();
		    redRockColumns.clear();
		    graniteMountainColumns.clear();
		    icyHillColumns.clear();
		    jungleTempleColumns.clear();
            doomShackColumns.clear();
			ruinedPortalColumns.clear();
			exploredMap = {};

            // Load new data
            setSeed(data.seed || Date.now());
            
            const loadedBlocks = data.blocks || {};
            for (const key in loadedBlocks) {
                const sBlock = loadedBlocks[key];
                const newBlock = { 
                    type: sBlock.tp, 
                    mineProg: sBlock.mP || 0,
                    inventory: sBlock.inv,
                    label: sBlock.lbl,
                    part: sBlock.prt,
                    plantTime: sBlock.pT,
                    baseBlockType: sBlock.bBT,
                    code: sBlock.cd
                };
                if (sBlock.clk) newBlock.cloakedAs = sBlock.clk;
                if (sBlock.ovr) newBlock.overlay = sBlock.ovr;
                if (sBlock.itm) newBlock.item = sBlock.itm;
				// Book-specific data
                if (sBlock.con) newBlock.content = sBlock.con;
                if (sBlock.pub) newBlock.published = sBlock.pub;
                if (sBlock.tit) newBlock.title = sBlock.tit;
                if (sBlock.cov) newBlock.cover = sBlock.cov;
                worldBlocks[key] = newBlock;
            }

            Object.assign(columnSurfaceHeights, data.heights || {});
            Object.assign(heavenColumnSurfaceHeights, data.heavenHeights || {});
            Object.assign(worldBiomes, data.biomes || {});
            Object.assign(underworldBiomes, data.underworldBiomes || {});
            (data.caves || []).forEach(key => caveBlocks.add(key));
            (data.islands || []).forEach(key => skyIslandColumns.add(key));
            (data.towers || []).forEach(key => watchtowerColumns.add(key));
			voidStorage = data.void || []; // Load void data, or initialize as empty array if not present
			currentVoidTrade = data.trade || null;
			
			// Load XP & Achievements
			playerXP = data.xp || 0;
            insomnia = data.insomnia || 0;
            guanoMined = data.guanoMined || 0;
			earnedAchievements = data.achievements || [];

			// Load Console History
			commandHistory = data.consoleHistory || [];
			historyIndex = commandHistory.length; // Reset history navigation

            // Load Player Data
            if (data.player) {
                player.x = data.player.x;
                player.y = data.player.y;
                player.health = data.player.h;
				player.maxHealth = data.player.mh;
				player.bloodAlcohol = data.player.bac || 0;
                player.activeEffects = data.player.eff || [];
                player.bedSpawnPoint = data.player.bed;
                player.armor = data.player.armor;
                player.armor = data.player.armor || { helmet: null, chestGear: null, legGear: null, boots: null };
            }

            // Load Inventory
            inventorySlots.fill(null);
            if(data.inventory) {
                for(let i=0; i < data.inventory.length; i++) {
                    inventorySlots[i] = data.inventory[i];
                }
            }
            hotbarIndices.fill(null);
             if(data.hotbar) {
                for(let i=0; i < data.hotbar.length; i++) {
                    hotbarIndices[i] = data.hotbar[i];
                }
            }
			
            updateHotbar();
            if(gameMenuOverlay.style.display === 'flex') toggleGameMenu();
            lastTime = performance.now(); // Reset time to prevent large dt jump
            console.log("World state updated from import.");
        }

		document.addEventListener("keydown", (e) => {
			if (e.key === "[") {
				document.getElementById("worldFileInput").click();
			}
		});

        // --------- BGU2 (ZIP with deflate) export/import utilities ---------

        // Helper: string -> Uint8Array
        function strToU8(s) {
          return new TextEncoder().encode(s);
        }
        // Helper: Uint8Array -> string
        function u8ToStr(u8) {
          return new TextDecoder().decode(u8);
        }
        
        // CRC32 (small fast implementation)
        function crc32(buf) {
          const table = (function() {
            let t = new Uint32Array(256);
            for (let i = 0; i < 256; i++) {
              let c = i;
              for (let k = 0; k < 8; k++) {
                c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
              }
              t[i] = c >>> 0;
            }
            return t;
          })();
          let crc = 0xffffffff;
          for (let i = 0; i < buf.length; i++) {
            crc = (crc >>> 8) ^ table[(crc ^ buf[i]) & 0xff];
          }
          return (crc ^ 0xffffffff) >>> 0;
        }
        
        // Get DOS date/time for zip headers
        function dosDateTime(ms = Date.now()) {
          const d = new Date(ms);
          const year = Math.max(1980, d.getFullYear()) - 1980;
          const month = d.getMonth() + 1;
          const day = d.getDate();
          const hours = d.getHours();
          const minutes = d.getMinutes();
          const seconds = Math.floor(d.getSeconds() / 2); // DOS stores seconds/2
          const dosTime = (hours << 11) | (minutes << 5) | seconds;
          const dosDate = (year << 9) | (month << 5) | day;
          return { dosTime, dosDate };
        }
        
        // Little-endian writer helper
        function writeLE(buffer, offset, value, bytes) {
          for (let i = 0; i < bytes; i++) {
            buffer[offset + i] = value & 0xff;
            value >>>= 8;
          }
        }
        
        // Build a minimal ZIP file with one filename entry and provided compressed bytes.
        // If compressionMethod === 8 => deflated data is expected. If 0 => stored (no compression).
        function buildSingleEntryZip(filename, compressedBytes, uncompressedSize, crcVal, compressionMethod = 8) {
          const filenameU8 = strToU8(filename);
          const localHeaderSize = 30 + filenameU8.length;
          const cdHeaderSize = 46 + filenameU8.length;
          const compressedSize = compressedBytes.length;
        
          const localHeader = new Uint8Array(localHeaderSize);
          // Local file header signature 0x04034b50
          writeLE(localHeader, 0, 0x04034b50, 4);
          writeLE(localHeader, 4, 20, 2); // version needed to extract
          writeLE(localHeader, 6, 0, 2); // gp bit flag
          writeLE(localHeader, 8, compressionMethod, 2); // compression method
          const dt = dosDateTime();
          writeLE(localHeader, 10, dt.dosTime, 2);
          writeLE(localHeader, 12, dt.dosDate, 2);
          writeLE(localHeader, 14, crcVal >>> 0, 4);
          writeLE(localHeader, 18, compressedSize >>> 0, 4);
          writeLE(localHeader, 22, uncompressedSize >>> 0, 4);
          writeLE(localHeader, 26, filenameU8.length, 2);
          writeLE(localHeader, 28, 0, 2); // extra length
          localHeader.set(filenameU8, 30);
        
          // Central Directory header
          const cdHeader = new Uint8Array(cdHeaderSize);
          writeLE(cdHeader, 0, 0x02014b50, 4); // central file header signature
          writeLE(cdHeader, 4, 0x0314, 2); // version made by (arbitrary)
          writeLE(cdHeader, 6, 20, 2); // version needed to extract
          writeLE(cdHeader, 8, 0, 2); // gp bit flag
          writeLE(cdHeader,10, compressionMethod, 2);
          writeLE(cdHeader,12, dt.dosTime, 2);
          writeLE(cdHeader,14, dt.dosDate, 2);
          writeLE(cdHeader,16, crcVal >>> 0, 4);
          writeLE(cdHeader,20, compressedSize >>> 0, 4);
          writeLE(cdHeader,24, uncompressedSize >>> 0, 4);
          writeLE(cdHeader,28, filenameU8.length, 2);
          writeLE(cdHeader,30, 0, 2); // extra len
          writeLE(cdHeader,32, 0, 2); // file comment len
          writeLE(cdHeader,34, 0, 2); // disk number start
          writeLE(cdHeader,36, 0, 2); // internal file attrs
          writeLE(cdHeader,38, 0, 4); // external file attrs
          writeLE(cdHeader,42, localHeaderSize >>> 0, 4); // relative offset of local header
          cdHeader.set(filenameU8, 46);
        
          // End of central directory
          const eocd = new Uint8Array(22);
          writeLE(eocd, 0, 0x06054b50, 4);
          writeLE(eocd, 4, 0, 2); // number of this disk
          writeLE(eocd, 6, 0, 2); // disk where central directory starts
          writeLE(eocd, 8, 1, 2); // number of central dir records on this disk
          writeLE(eocd,10, 1, 2); // total entries
          writeLE(eocd,12, cdHeaderSize >>> 0, 4); // size of central dir
          writeLE(eocd,16, (localHeaderSize + compressedSize) >>> 0, 4); // offset of central dir (right after local header + data)
          writeLE(eocd,20, 0, 2); // comment length
        
          // Compose final blob
          const out = new Uint8Array(localHeaderSize + compressedSize + cdHeaderSize + eocd.length);
          let pos = 0;
          out.set(localHeader, pos); pos += localHeaderSize;
          out.set(compressedBytes, pos); pos += compressedSize;
          out.set(cdHeader, pos); pos += cdHeaderSize;
          out.set(eocd, pos);
        
          return out;
        }
        
        // Deflate-raw using CompressionStream (returns Uint8Array)
        async function deflateRawUint8(inputU8) {
          if (typeof CompressionStream === 'function') {
            try {
              const cs = new CompressionStream('deflate-raw');
              const stream = new Response(new Blob([inputU8])).body.pipeThrough(cs);
              const deflated = await new Response(stream).arrayBuffer();
              return new Uint8Array(deflated);
            } catch (err) {
              console.warn('deflate-raw failed:', err);
              throw err;
            }
          } else {
            throw new Error('CompressionStream API (deflate-raw) not available in this browser.');
          }
        }
        
        // Inflate-raw using DecompressionStream (accepts Uint8Array) -> Uint8Array
        async function inflateRawUint8(compressedU8) {
          if (typeof DecompressionStream === 'function') {
            try {
              const ds = new DecompressionStream('deflate-raw');
              const stream = new Response(new Blob([compressedU8])).body.pipeThrough(ds);
              const inflated = await new Response(stream).arrayBuffer();
              return new Uint8Array(inflated);
            } catch (err) {
              console.warn('inflate-raw failed:', err);
              throw err;
            }
          } else {
            throw new Error('DecompressionStream API (deflate-raw) not available in this browser.');
          }
        }
        
        // Export function: compressed BGU2
        async function exportWorldBGU2() {
          try {
            // Reuse your world serialization logic (same as exportWorldData)
            const sanitizedWorldBlocks = {};
            for (const key in worldBlocks) {
              const block = worldBlocks[key];
              const sanitizedBlock = { tp: block.type };
              if (block.mineProg) sanitizedBlock.mP = block.mineProg;
              if (block.inventory) sanitizedBlock.inv = block.inventory;
              if (block.label) sanitizedBlock.lbl = block.label;
              if (block.part) sanitizedBlock.prt = block.part;
              if (block.plantTime) sanitizedBlock.pT = block.plantTime;
              if (block.cloakedAs) sanitizedBlock.clk = block.cloakedAs;
              if (block.overlay) sanitizedBlock.ovr = block.overlay;
			  // Book-specific data
              if (block.content) sanitizedBlock.con = block.content;
              if (block.published) sanitizedBlock.pub = block.published;
              if (block.title) sanitizedBlock.tit = block.title;
              if (block.cover) sanitizedBlock.cov = block.cover;

              if (block.item) sanitizedBlock.itm = block.item;
                
              sanitizedWorldBlocks[key] = sanitizedBlock;
            }
        
            const worldData = {
              seed: currentSeed,
              blocks: sanitizedWorldBlocks,
              heights: columnSurfaceHeights,
              heavenHeights: heavenColumnSurfaceHeights,
              biomes: worldBiomes,
              underworldBiomes: underworldBiomes,
              caves: Array.from(caveBlocks),
              islands: Array.from(skyIslandColumns),
              towers: Array.from(watchtowerColumns),
			  temples: Array.from(sandstoneTempleColumns),
              player: {
                x: player.x,
                y: player.y,
                h: player.health,
                mh: player.maxHealth,
				bac: player.bloodAlcohol,
                eff: player.activeEffects,
                bed: player.bedSpawnPoint,
                armor: player.armor
              },
              inventory: inventorySlots,
              hotbar: hotbarIndices,
			  void: voidStorage,
			  trade: currentVoidTrade,
			  death: deathCount,
              insomnia: insomnia,
              guanoMined: guanoMined,
			  xp: playerXP,
			  achievements: earnedAchievements,
			  consoleHistory: commandHistory
            };
        
            const json = JSON.stringify(worldData);
            const jsonU8 = strToU8(json);
            const crc = crc32(jsonU8);
            let compressedU8;
            let compressionMethod = 8;
        
            try {
              compressedU8 = await deflateRawUint8(jsonU8);
            } catch (err) {
              // if deflate isn't available, fallback to store (no compression)
              console.warn('Deflate unavailable, creating stored ZIP entry (no compression).');
              compressionMethod = 0;
              compressedU8 = jsonU8;
            }
        
            const filename = `world_${currentSeed}.json`;
            const zipU8 = buildSingleEntryZip(filename, compressedU8, jsonU8.length, crc, compressionMethod);
        
            const blob = new Blob([zipU8], { type: 'application/octet-stream' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `world_${currentSeed}.bgu2`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
            showMessageBox("World saved as .bgu2 (compressed).");
          } catch (err) {
            console.error("BGU2 export failed:", err);
            showMessageBox("Error: Could not export .bgu2 file. Check console for details.");
          }
        }
        
        // Parse the single-entry zip we created and return { filename, compressedU8, compressionMethod, uncompressedSize, crc }
        function parseSingleEntryZip(u8) {
          // Expect local header at offset 0
          let offset = 0;
          const sig = (u8[0] | (u8[1] << 8) | (u8[2] << 16) | (u8[3] << 24)) >>> 0;
          if (sig !== 0x04034b50) throw new Error('Not a zip file (missing local header).');
        
          const compressionMethod = u8[8] | (u8[9] << 8);
          const crc = (u8[14] | (u8[15] << 8) | (u8[16] << 16) | (u8[17] << 24)) >>> 0;
          const compressedSize = (u8[18] | (u8[19] << 8) | (u8[20] << 16) | (u8[21] << 24)) >>> 0;
          const uncompressedSize = (u8[22] | (u8[23] << 8) | (u8[24] << 16) | (u8[25] << 24)) >>> 0;
          const fnameLen = u8[26] | (u8[27] << 8);
          const extraLen = u8[28] | (u8[29] << 8);
          const localHeaderSize = 30 + fnameLen + extraLen;
          const filenameBytes = u8.slice(30, 30 + fnameLen);
          const filename = u8ToStr(filenameBytes);
          const compressedStart = localHeaderSize;
          const compressedEnd = compressedStart + compressedSize;
          if (compressedEnd > u8.length) throw new Error('Truncated zip data.');
          const compressedU8 = u8.slice(compressedStart, compressedEnd);
          return { filename, compressedU8, compressionMethod, uncompressedSize, crc };
        }
        
        // Import BGU2
        async function importBGU2File(file) {
          try {
            const ab = await file.arrayBuffer();
            const u8 = new Uint8Array(ab);
            // If it starts with PK.. then parse zip
            if (u8[0] === 0x50 && u8[1] === 0x4b && u8[2] === 0x03 && u8[3] === 0x04) {
              const parsed = parseSingleEntryZip(u8);
              let jsonU8;
              if (parsed.compressionMethod === 8) {
                try {
                  jsonU8 = await inflateRawUint8(parsed.compressedU8);
                } catch (err) {
                  throw new Error('Decompression failed: ' + err.message);
                }
              } else if (parsed.compressionMethod === 0) {
                jsonU8 = parsed.compressedU8;
              } else {
                throw new Error('Unsupported compression method in .bgu2: ' + parsed.compressionMethod);
              }
              // Validate CRC
              const calc = crc32(jsonU8);
              if (calc !== parsed.crc) {
                console.warn('Warning: CRC mismatch for imported .bgu2 (file may be corrupted).');
              }
              const jsonText = u8ToStr(jsonU8);
              let data;
              try {
                data = JSON.parse(jsonText);
              } catch (err) {
                throw new Error('JSON parse failed: ' + err.message);
              }
              importWorldData(data);
              showMessageBox("BGU2 world imported!");
              return;
            } else {
              // Not a zip; try to parse as plain JSON text (backwards-compatible)
              const txt = u8ToStr(u8);
              try {
                const data = JSON.parse(txt);
                importWorldData(data);
                showMessageBox("Imported world (plain JSON).");
                return;
              } catch (err) {
                throw new Error('Unrecognized file format for import.');
              }
            }
          } catch (err) {
            console.error("BGU2 import error:", err);
            showMessageBox("Error: Could not import .bgu2 file. See console for details.");
          }
        }
        
        // Create a hidden input for .bgu2 import (or reuse your existing worldFileInput)
        const bgu2Input = document.createElement('input');
        bgu2Input.type = 'file';
        bgu2Input.accept = '.bgu2';
        bgu2Input.style.display = 'none';
        bgu2Input.addEventListener('change', function (ev) {
          const file = ev.target.files[0];
          if (!file) return;
          importBGU2File(file);
          bgu2Input.value = '';
        });
        document.body.appendChild(bgu2Input);
        
        // Key bindings: } to export .bgu2, { to import .bgu2
        document.addEventListener('keydown', (e) => {
          // Avoid interfering with in-game console or typing contexts (mimic your existing checks if needed)
          if (isConsoleOpen && e.code !== 'Escape') return;
          if (e.key === '}') {
            e.preventDefault();
            exportWorldBGU2();
          } else if (e.key === '{') {
            e.preventDefault();
            bgu2Input.click();
          }
        });
		
		// --- Skin UI Functions ---

        function openSkinUploader() {
            isGamePaused = true;
            skinUploadOverlay.style.display = 'flex';
        }

        function closeSkinUploader() {
            isGamePaused = false;
            skinUploadOverlay.style.display = 'none';
            skinUploadInput.value = ''; // Clear file input
            lastTime = performance.now();
        }

        function handleSkinUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Check aspect ratio (width:height == 1:3)
                    // Use a small tolerance for floating point errors
                    const ratio = img.width / img.height;
                    if (Math.abs(ratio - (1/3)) < 0.01) {
                        // Success! Save to localStorage and apply
                        const dataUrl = e.target.result;
                        localStorage.setItem('customPlayerSkin', dataUrl);
                        applyCustomSkin(dataUrl);
                        showMessageBox('Skin applied successfully!', 'alert');
                        closeSkinUploader();
                    } else {
                        // Failure! Reset to default
                        resetPlayerSkin();
                        showMessageBox(`Upload failed. Image must have a 1:3 aspect ratio (like 50x150). Your skin has been reset.`, 'alert');
                        closeSkinUploader();
                    }
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function applyCustomSkin(dataUrl) {
            playerImg.src = dataUrl;
        }

        function resetPlayerSkin() {
            localStorage.removeItem('customPlayerSkin');
            playerImg.src = originalPlayerImgSrc;
        }

        function loadSavedSkin() {
            const savedSkin = localStorage.getItem('customPlayerSkin');
            if (savedSkin) {
                applyCustomSkin(savedSkin);
            }
        }
        
		// --- Book UI Functions ---

        function openBookEditor(slotIndex) {
            if (!inventorySlots[slotIndex]) return;

            isGamePaused = true;
            currentlyEditingBook = { slotIndex: slotIndex, inventory: inventorySlots };
            const bookItem = inventorySlots[slotIndex];

            bookContentInput.value = bookItem.content || '';
            bookMenuOverlay.style.display = 'flex';
            bookContentInput.focus();
        }

        function closeBookEditor() {
            isGamePaused = false;
            bookMenuOverlay.style.display = 'none';
            currentlyEditingBook = { slotIndex: -1, inventory: null };
            lastTime = performance.now();
        }

        function saveAndCloseBook() {
            if (currentlyEditingBook.slotIndex === -1) return;

            const bookItem = currentlyEditingBook.inventory[currentlyEditingBook.slotIndex];
            if (bookItem) {
                bookItem.content = bookContentInput.value.substring(0, 1000000);
            }
            closeBookEditor();
        }

        function exportBook() {
            const content = bookContentInput.value;
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'book_export.txt';
            a.click();
            URL.revokeObjectURL(url);
        }

        function handleBookImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                bookContentInput.value = e.target.result.substring(0, 1000000);
            };
            reader.readAsText(file);
            bookImportInput.value = ''; // Reset file input
        }

        // --- Publish UI Functions ---

        function openPublishMenu() {
            const bookItem = currentlyEditingBook.inventory[currentlyEditingBook.slotIndex];
            if (!bookItem) return;

            bookTitleInput.value = bookItem.title || '';
            coverPreview.src = bookItem.cover || '';
            coverPreview.style.display = bookItem.cover ? 'block' : 'none';
            publishMenuOverlay.style.display = 'flex';
        }

        function closePublishMenu() {
            publishMenuOverlay.style.display = 'none';
            bookTitleInput.value = '';
            bookCoverInput.value = '';
            coverPreview.src = '';
        }

        function handleCoverUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!['image/png', 'image/jpeg', 'image/jpg'].includes(file.type)) {
                showMessageBox("Invalid file type. Please use PNG, JPG, or JPEG.", 'alert');
                return;
            }

            if (file.size > 5 * 1024 * 1024) {
                showMessageBox("File is too large (> 5MB). Please choose a smaller image.", 'alert');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Resize image to max 400x400
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    let width = img.width;
                    let height = img.height;
                    const MAX_DIM = 400;

                    if (width > height) {
                        if (width > MAX_DIM) {
                            height *= MAX_DIM / width;
                            width = MAX_DIM;
                        }
                    } else {
                        if (height > MAX_DIM) {
                            width *= MAX_DIM / height;
                            height = MAX_DIM;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);

                    // Compress as JPEG
                    const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                    coverPreview.src = dataUrl;
                    coverPreview.style.display = 'block';
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function finalizePublish() {
            const bookItem = currentlyEditingBook.inventory[currentlyEditingBook.slotIndex];
            if (!bookItem) return;

            const title = bookTitleInput.value.trim();
            if (!title) {
                showMessageBox("A title is required to publish.", 'alert');
                return;
            }

            bookItem.title = title;
            bookItem.cover = coverPreview.src;
            bookItem.content = bookContentInput.value.substring(0, 1000000);
            bookItem.published = true;

            closePublishMenu();
            closeBookEditor();
            showMessageBox(`Book "${title}" published! It is no longer editable.`, 'alert');
        }

        // --- Book Reader Functions ---

        function openBookReader(bookItem) {
            isGamePaused = true;
            bookReaderTitle.textContent = bookItem.title || "Book";
            bookReaderCover.src = bookItem.cover || '';
            bookReaderCover.style.display = bookItem.cover ? 'block' : 'none';
            bookReaderContent.textContent = bookItem.content || '(This book is empty)';
            bookReaderOverlay.style.display = 'flex';
        }

        function closeBookReader() {
            isGamePaused = false;
            bookReaderOverlay.style.display = 'none';
            lastTime = performance.now();
        }

        // --- Add Event Listeners ---
        bookSaveButton.addEventListener('click', saveAndCloseBook);
        bookPublishButton.addEventListener('click', openPublishMenu);
        bookExportButton.addEventListener('click', exportBook);
        bookImportInput.addEventListener('change', handleBookImport);
        
        bookFinalizeButton.addEventListener('click', finalizePublish);
        bookCancelPublishButton.addEventListener('click', closePublishMenu);
        bookCoverInput.addEventListener('change', handleCoverUpload);
        bookCoverLabel.addEventListener('click', () => bookCoverInput.click()); // Link label to input

        bookContentInput.addEventListener('keydown', (e) => e.stopPropagation());
        bookTitleInput.addEventListener('keydown', (e) => e.stopPropagation());
		
		// Skin UI Listeners
        skinUploadLabel.addEventListener('click', () => skinUploadInput.click());
        skinUploadInput.addEventListener('change', handleSkinUpload);
        skinResetButton.addEventListener('click', () => {
            resetPlayerSkin();
            showMessageBox('Skin reset to default.', 'alert');
            closeSkinUploader();
        });
        skinUploadCancelButton.addEventListener('click', closeSkinUploader);

        function setupLoadingScreenListeners() {
			const loadingScreen = document.getElementById('loadingScreen');
			if (!loadingScreen) return;

			let tapCount = 0;
			let lastTapTime = 0;
			const tapTimeout = 500; // Max 500ms between taps

			loadingScreen.addEventListener('touchstart', (e) => {
				// Only trigger if the loading screen is visible
				if (loadingScreen.style.display === 'none') return;
				
				e.preventDefault(); // Prevent zoom on triple-tap
				const currentTime = Date.now();

				if (currentTime - lastTapTime > tapTimeout) {
					tapCount = 1; // Reset count if too much time has passed
				} else {
					tapCount++;
				}
				
				lastTapTime = currentTime;

				if (tapCount === 3) {
					console.log("Triple-tap detected! Opening texture uploader.");
					tapCount = 0; // Reset
					triggerTextureUpload(); // Call your existing function
				}
			}, { passive: false });
		}
		
        function setupMobileControls() {
            // If this isn't a touch device, don't show the controls
            if (!('ontouchstart' in window)) {
                return;
            }

            // --- 1. Get Element References ---
            const mobileControlsOverlay = document.getElementById('mobileControlsOverlay');
            const joystickContainer = document.getElementById('joystickContainer');
            const joystickKnob = document.getElementById('joystickKnob');
            
            const inventoryButton = document.getElementById('mobileInventoryButton');
            const bedButton = document.getElementById('mobileBedButton');
            const moverButton = document.getElementById('mobileMoverButton');

            const moreButton = document.getElementById('mobileMoreButton');
            const subMenu = document.getElementById('mobileSubMenu');
            const consoleButton = document.getElementById('mobileConsoleButton');
            const menuButton = document.getElementById('mobileMenuButton');
            const mapButton = document.getElementById('mobileMapButton');
			const mobileImportButton = document.getElementById('mobileImportButton');
            const mobileExportButton = document.getElementById('mobileExportButton');

            // Find ALL close buttons
            const closeButtons = document.querySelectorAll('.mobile-close-button');

            // Show all mobile controls
            mobileControlsOverlay.style.display = 'block';
            closeButtons.forEach(btn => btn.style.display = 'block');

            // --- 2. State Variables ---
            let joystickActive = false;
            let joystickBaseX = 0;
            let joystickBaseY = 0;
            const joystickRadius = joystickContainer.clientWidth / 2;
            const knobRadius = joystickKnob.clientWidth / 2;
            const joystickDeadzone = 20;
            const jumpThreshold = -45; // How far "up" to pull to jump

            let miningTouchIdentifier = null;
            let longPressTimer = null;
            const longPressDuration = 200; // 200ms hold to start mining

            // --- 3. Helper Function ---
            function findTouch(touchList, identifier) {
                if (identifier === null) return null;
                for (let i = 0; i < touchList.length; i++) {
                    if (touchList[i].identifier === identifier) {
                        return touchList[i];
                    }
                }
                return null;
            }

            // --- 4. Joystick Listeners (Movement) ---
            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                joystickActive = true;
                
                const rect = joystickContainer.getBoundingClientRect();
                joystickBaseX = rect.left + joystickRadius;
                joystickBaseY = rect.top + joystickRadius;
                
                joystickKnob.style.transition = 'none'; // Allow instant dragging
                
                // Handle first touch
                handleJoystickMove(e.changedTouches[0]);
            }, { passive: false });

            joystickContainer.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!joystickActive) return;
                handleJoystickMove(e.changedTouches[0]);
            }, { passive: false });

            joystickContainer.addEventListener('touchend', (e) => {
                e.preventDefault();
                joystickActive = false;
                
                // Reset knob position
                joystickKnob.style.transition = 'transform 0.1s linear';
                joystickKnob.style.transform = 'translate(0px, 0px)';
                
                // Reset keys
                keys['ArrowLeft'] = false;
                keys['KeyA'] = false;
                keys['ArrowRight'] = false;
                keys['KeyD'] = false;
                keys['ArrowUp'] = false;
                keys['KeyW'] = false;
            }, { passive: false });

            function handleJoystickMove(touch) {
                let deltaX = touch.clientX - joystickBaseX;
                let deltaY = touch.clientY - joystickBaseY;

                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                let knobX = deltaX;
                let knobY = deltaY;

                // Clamp knob visual position to the edge of the joystick
                if (distance > joystickRadius - knobRadius) {
                    knobX = (deltaX / distance) * (joystickRadius - knobRadius);
                    knobY = (deltaY / distance) * (joystickRadius - knobRadius);
                }
                
                joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;

                // --- Update Game Keys ---
                
                // Horizontal (Left/Right)
                if (deltaX < -joystickDeadzone) {
                    keys['ArrowLeft'] = true;
                    keys['KeyA'] = true;
                    keys['ArrowRight'] = false;
                    keys['KeyD'] = false;
                } else if (deltaX > joystickDeadzone) {
                    keys['ArrowLeft'] = false;
                    keys['KeyA'] = false;
                    keys['ArrowRight'] = true;
                    keys['KeyD'] = true;
                } else {
                    keys['ArrowLeft'] = false;
                    keys['KeyA'] = false;
                    keys['ArrowRight'] = false;
                    keys['KeyD'] = false;
                }

                // Vertical (Jump)
                if (deltaY < jumpThreshold) {
                    keys['ArrowUp'] = true;
                    keys['KeyW'] = true;
                } else {
                    keys['ArrowUp'] = false;
                    keys['KeyW'] = false;
                }
            }

            // --- 5. Canvas Listeners (Mining/Placing) ---
            canvas.addEventListener('touchstart', (e) => {
                if (isGamePaused || miningTouchIdentifier !== null) return;
                
                e.preventDefault();
                const touch = e.changedTouches[0];
                miningTouchIdentifier = touch.identifier;
                
                // Update mouse aim position
                const rect = canvas.getBoundingClientRect();
                mouse.x = touch.clientX - rect.left;
                mouse.y = touch.clientY - rect.top;

                // Start a timer to see if this is a "long press" (for mining)
                longPressTimer = setTimeout(() => {
                    if (miningTouchIdentifier === touch.identifier) {
                        mouse.down = true; // Start mining
                    }
                    longPressTimer = null;
                }, longPressDuration);

            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                if (isGamePaused) return;
                
                const touch = findTouch(e.changedTouches, miningTouchIdentifier);
                if (touch) {
                    e.preventDefault();
                    // Update mouse aim position
                    const rect = canvas.getBoundingClientRect();
                    mouse.x = touch.clientX - rect.left;
                    mouse.y = touch.clientY - rect.top;
                }
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                if (isGamePaused) return;

                const touch = findTouch(e.changedTouches, miningTouchIdentifier);
                if (touch) {
                    e.preventDefault();
                    
                    if (longPressTimer) {
                        // This was a "tap" (press and release < 200ms)
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                        
                        // Simulate a right-click to place/eat
                        mouse.rightDown = true;
                        // Reset it immediately after this frame
                        setTimeout(() => { mouse.rightDown = false; }, 0);

                    } else if (mouse.down) {
                        // This was a "long press" that just ended
                        mouse.down = false; // Stop mining
                    }
                    
                    miningTouchIdentifier = null;
                }
            }, { passive: false });

            // --- 6. UI Button Listeners ---
            inventoryButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleInventoryMenu();
            });

            bedButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (player.bedSpawnPoint) {
                    if (player.health > 50) {
                        applyDamage(10);
                        player.x = player.bedSpawnPoint.x;
                        player.y = player.bedSpawnPoint.y;
                    } else {
                        showMessageBox("You are too weak to teleport to bed.", 'alert');
                    }
                } else {
                    showMessageBox("You haven't set a bed spawn point!", 'alert');
                }
            });
            
            moverButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (canOpenTeleportMenu()) {
                    toggleTeleportMenu();
                } else {
                    showMessageBox("You haven't configured any World Movers yet.", 'alert');
                }
            });

            // --- 7. Close Button Listeners ---
            // This is complex, but we find the button's parent menu and call the correct toggle function
            closeButtons.forEach(button => {
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const parentMenu = e.target.closest('[id$="Overlay"]'); // Finds nearest parent with an ID ending in "Overlay"
                    if (!parentMenu) return;

                    switch(parentMenu.id) {
                        // ADDED THESE TWO
                        case 'gameMenuOverlay': toggleGameMenu(); break;
                        case 'devConsoleOverlay': toggleDevConsole(); break;
						case 'anvilOverlay': toggleAnvilMenu(); break;

                        // EXISTING
                        case 'inventoryCraftingOverlay': toggleInventoryMenu(); break;
                        case 'chestOverlay': toggleChestMenu(); break;
                        case 'voidChestOverlay': toggleVoidChestMenu(); break;
                        case 'ovenOverlay': toggleFurnaceMenu(); break;
                        case 'worldMoverConfigOverlay': toggleWorldMoverMenu(); break;
                        case 'worldMoverTeleportOverlay': toggleTeleportMenu(); break;
                        case 'bookMenuOverlay': saveAndCloseBook(); break;
                        case 'publishMenuOverlay': closePublishMenu(); break;
                        case 'bookReaderOverlay': closeBookReader(); break;
                        case 'skinUploadOverlay': closeSkinUploader(); break;
                    }
                });
            });
            // --- 8. "More" Button Listeners ---
            moreButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                subMenu.classList.toggle('show'); // Toggle visibility
            });
    
            consoleButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleDevConsole();
                subMenu.classList.remove('show'); // Close sub-menu
            });
    
            menuButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleGameMenu();
                subMenu.classList.remove('show'); // Close sub-menu
            });
    
            mapButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                showMinimap = !showMinimap;
                document.getElementById('minimapContainer').style.display = showMinimap ? 'block' : 'none';
                subMenu.classList.remove('show'); // Close sub-menu
            });

            // --- ADD THESE LISTENERS ---
            mobileImportButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                bgu2Input.click(); // Open the hidden file input
                subMenu.classList.remove('show');
            });

            mobileExportButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                exportWorldBGU2(); // Call the export function
                subMenu.classList.remove('show');
            });
            // --- END OF ADDITION ---

        }
		
        setupMapListeners();
		setupMobileControls();
		setupLoadingScreenListeners();
        loadAssets();
		
		//The story is written from the view of a man named Cornelius Zaezit, who is writing a somber and solemn letter to a dear friend who passed away named Gorge Lanbridge. He is writing about how he is sorry for his death. It should include these BGU lore details and expanded: The governments and cities were thriving with people until the meteors started falling. At first, they left chasms through the Earth that created literal hell gates, but eventually the chasms resulted in a sickness that left things overgrown with "pest" and disease. Places became sick, magma pooled on the surface, and food spoiled. People turned on each other and burnt their houses and buildings down with lighters and broke them with axes and tools. Many people built underground mineshafts and minechambers, and some created watchtowers to look down at others. Some people found their way into dungeons, caves, but many rural plantations where peaceful in the fields. It wasn't until the whole world heated that everyone died, except miraculously from the dead bodies of those people who overheated, traders emerged with masks, but their grief paralyzed ALL of the millions of traders, so they couldn't move. They simply traded supplies and spoke, unresistant to anything. The void gates opened beneath hell and the underworld, and demons along with doom shacks rose. Eventually the demons died when heaven came into contact with the clouds of the mortal world, but so did the [laggy] cows and everything disappeared that was once living. Cornelius says the only hope rests in an unnamed man, who was chosen to live and survive on his own with no companions except that of the void trader and the traders.
		
		// Created By Bryant Reitzel 
		// Ideas And Mechanics All From The Mind Of Bryant Reitzel
    </script>
</body>
</html>