<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Game Ultimate [HTML EDITION]</title>
	<link rel="icon" type="image/png" href="Grass Dirt Block.png">
	<input type="file" id="worldFileInput" accept=".bgu1" style="display: none;">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #70b6d5; /* Set body background to sky blue */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: sans-serif;
            color: white;
            transition: background-color 1s ease; /* Smooth background transition */
        }
        canvas {
            border: 2px solid #555;
            display: block;
            width: 100%; /* Make canvas fill container width */
            height: 100%; /* Make canvas fill container height */
        }
        #gameContainer {
            position: relative;
            display: inline-block; /* To center the container */
            width: 100vw; /* Ensure game container takes full viewport width */
            height: 100vh; /* Ensure game container takes full viewport height */
            overflow: hidden; /* Hide overflow from canvas scaling */
        }
        #hotbar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 5px;
            z-index: 50;
        }
        .hotbar-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #aaa;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            cursor: pointer;
            position: relative;
            background-color: rgba(255, 255, 255, 0.2);
        }
        .hotbar-slot.selected {
            border-color: yellow;
        }
        .hotbar-slot span {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            color: white; /* Ensure count is visible */
            text-shadow: 1px 1px 2px black; /* Add shadow for readability */
        }
        .hotbar-slot img {
             /* Represents the block image */
            width: 30px;
            height: 30px;
            image-rendering: pixelated; /* Optional: for pixel art style */
        }
         /* Style for fallback text/color in hotbar if image fails */
        .hotbar-slot .fallback {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            text-align: center;
            word-break: break-word; /* Prevent long names from overflowing */
            padding: 2px;
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
		#itemTooltip {
			display: none; /* Hidden by default */
			position: fixed; /* Stays in place on the screen */
			background-color: rgba(0, 0, 0, 0.8);
			color: white;
			padding: 5px 8px;
			border-radius: 4px;
			font-size: 14px;
			pointer-events: none; /* So it doesn't interfere with mouse clicks */
			z-index: 9999; /* Ensures it's on top of everything */
			white-space: nowrap; /* Prevents the name from wrapping to a new line */
		}
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            z-index: 100;
        }
         #coordsDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 50; /* Ensure it's above the canvas */
        }
        /* Player Health Bar */
        #healthBar {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 2px;
            z-index: 50;
        }
        #healthBar img {
            width: 18px;
            height: 18px;
            image-rendering: pixelated;
        }
        /* Game Menu Styles */
        #gameMenuOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85); /* Darker, more opaque overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* On top of everything */
            font-family: 'Inter', sans-serif; /* Use Inter font */
            color: #E0E0E0; /* Light gray text */
            flex-direction: column;
            gap: 20px;
            display: none; /* Hidden by default */
        }

        #gameMenu {
            background-color: #333; /* Darker background for the menu */
            padding: 30px;
            border-radius: 15px; /* More rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); /* Stronger shadow */
            width: 90%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            border: 2px solid #555; /* Subtle border */
            max-height: 90vh; /* Make the menu itself scrollable */
            overflow-y: auto; /* Enable vertical scrolling */
        }

        #gameMenu h2 {
            color: #00BFFF; /* Deep sky blue for headings */
            text-align: center;
            margin-bottom: 20px;
            font-size: 2em; /* Larger heading */
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }

        #seedInput {
            width: calc(100% - 24px); /* Adjust for padding */
            padding: 12px;
            margin-top: 10px;
            border: 1px solid #666;
            border-radius: 8px;
            background-color: #555;
            color: white;
            font-size: 1em;
            box-sizing: border-box; /* Include padding in width */
        }

        #seedInput::placeholder {
            color: #AAA;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .menu-buttons button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .menu-buttons button:hover {
            transform: translateY(-2px);
        }

        #resumeButton, #newGameButton {
            background-color: #6c757d; /* Gray */
            color: white;
        }
        #resumeButton:hover, #newGameButton:hover {
            background-color: #5a6268;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 600px) {
            #gameMenu {
                padding: 20px;
                width: 95%;
            }
            #gameMenu h2 {
                font-size: 1.5em;
            }
            .menu-buttons button {
                width: 100%;
            }
        }

        /* Custom Message Box Styles */
        #customMessageBoxOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Higher than game menu */
            font-family: 'Inter', sans-serif;
            color: white;
            display: none; /* Hidden by default */
        }

        #customMessageBox {
            background-color: #444;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            text-align: center;
            max-width: 400px;
            width: 80%;
            border: 1px solid #666;
        }

        #messageBoxText {
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        #messageBoxButtons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        #messageBoxButtons button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            transition: background-color 0.2s ease;
        }

        #messageBoxButtons button:hover {
            background-color: #0056b3;
        }

        #messageBoxCancelButton {
            background-color: #6c757d;
        }
        #messageBoxCancelButton:hover {
            background-color: #5a6268;
        }

        /* Inventory & Crafting Menu Styles */
        #inventoryCraftingOverlay, #chestOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.85);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-family: 'Inter', sans-serif;
            color: #E0E0E0;
        }

        #inventoryCraftingMenu, #chestMenu {
            background-color: #333;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 90%;
            max-width: 600px;
            border: 2px solid #555;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 90vh; /* Make the menu itself scrollable */
            overflow-y: auto; /* Enable vertical scrolling */
        }

        #inventoryCraftingMenu h2, #chestMenu h2 {
            color: #00BFFF;
            text-align: center;
            margin: 0 0 10px 0;
        }
        
        .inventory-section {
            padding: 10px;
            background-color: #444;
            border-radius: 10px;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
            gap: 8px;
        }

        .inventory-slot {
            width: 45px;
            height: 45px;
            border: 2px solid #777;
            background-color: #555;
            border-radius: 5px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        .inventory-slot:hover {
            background-color: #666;
        }
        .inventory-slot img {
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
        }
        .inventory-slot .item-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        /* New style for hotbar slots within the inventory menu */
        #inventoryHotbarGrid .hotbar-slot {
            border-color: yellow; /* Distinguish hotbar slots in inventory */
        }


        .crafting-area {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        #craftingGrid {
            display: grid;
            grid-template-columns: repeat(4, 45px); /* Changed to 4x4 */
            grid-template-rows: repeat(4, 45px); /* Changed to 4x4 */
            gap: 5px;
        }
        
        .crafting-arrow {
            font-size: 2em;
            color: #999;
        }

        #craftingOutput {
            width: 50px;
            height: 50px;
            border: 2px dashed #999;
        }
        
        #craftButton {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #28a745;
            color: white;
            font-weight: bold;
            align-self: center;
        }
        #craftButton:disabled {
            background-color: #5a6268;
            cursor: not-allowed;
        }

        /* Recipe Menu Styles */
        #recipeMenu {
            padding: 10px;
            background-color: #444;
            border-radius: 10px;
            margin-top: 20px;
        }

        #recipeMenu h3 {
            color: #00BFFF;
            margin-top: 0;
            margin-bottom: 10px;
        }

        .recipe-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            background-color: #555;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #666;
        }

        .recipe-input-grid {
            display: grid;
            grid-template-columns: repeat(4, 35px); /* Smaller grid for recipe display */
            grid-template-rows: repeat(4, 35px);
            gap: 3px;
            margin-right: 10px;
            flex-shrink: 0; /* Prevent shrinking */
        }

        .recipe-input-grid .inventory-slot {
            width: 35px;
            height: 35px;
            border: 1px solid #777;
            background-color: #666;
        }

        .recipe-output {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: bold;
        }

        .recipe-output .inventory-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #777;
            background-color: #555;
            border-radius: 5px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .recipe-output .inventory-slot img {
            width: 28px;
            height: 28px;
        }
        .recipe-output .inventory-slot .item-count {
            font-size: 10px;
        }

        /* Durability Bar for Pickaxe */
        .durability-bar {
            position: absolute;
            bottom: 0px; /* Position at the bottom of the slot */
            left: 0;
            width: 100%;
            height: 4px; /* Thin bar */
            background-color: #555; /* Background for empty part */
            border-radius: 2px;
            overflow: hidden;
        }

        .durability-fill {
            height: 100%;
            background-color: #28a745; /* Green for full durability */
            width: 100%; /* Default to full width */
            transition: width 0.1s linear; /* Smooth transition for durability changes */
        }
        /* Chest Label Input */
        #chestLabelInput {
            width: calc(100% - 20px);
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #666;
            border-radius: 5px;
            background-color: #555;
            color: white;
            font-size: 0.9em;
        }

        /* Delete Slot */
        #deleteSlot {
            width: 45px;
            height: 45px;
            border: 2px dashed #dc3545;
            background-color: rgba(220, 53, 69, 0.2);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #dc3545;
            font-size: 24px;
            font-weight: bold;
            margin-top: 10px;
        }
        #deleteSlot:hover {
            background-color: rgba(220, 53, 69, 0.4);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="healthBar"></div>
        <div id="hotbar"></div>
        <div id="loadingScreen">Loading Assets...</div>
        <div id="coordsDisplay">Coords: (0, 0)</div>
    </div>

    <!-- Game Menu Overlay -->
    <div id="gameMenuOverlay" oncontextmenu="return false;">
        <div id="gameMenu">
            <h2>Game Menu</h2>
            <div class="menu-item" style="margin-bottom: 15px;">
                <label for="seedInput" style="display: block; margin-bottom: 5px; color: #CCC; text-align: center;">World Seed (optional):</label>
                <input type="text" id="seedInput" placeholder="Leave empty for random seed">
            </div>
            <div class="menu-buttons">
                <button id="newGameButton">New Game</button>
                <button id="resumeButton">Resume Game</button>
            </div>
            <label style="margin-top: 10px; display: flex; align-items: center; justify-content: center;">
                <input type="checkbox" id="maintainDurabilityCheckbox" style="margin-right: 8px;"> Maintain Block Durability
            </label>
        </div>
    </div>

    <!-- Inventory & Crafting Menu Overlay -->
    <div id="inventoryCraftingOverlay" oncontextmenu="return false;">
        <div id="inventoryCraftingMenu">
            <h2>Inventory & Crafting</h2>
            <div class="inventory-section">
				<h3>Crafting</h3>
                <div class="crafting-area">
                    <div id="craftingGrid">
                        <!-- Crafting grid slots will be dynamically generated here -->
                    </div>
                    <div class="crafting-arrow">&#10144;</div>
                    <div class="inventory-slot" id="craftingOutput"></div>
                </div>
                 <button id="craftButton" disabled>Craft</button>
            </div>
            
            <div class="inventory-section">
                <h3>Your Inventory</h3>
                <div id="playerInventoryGrid" class="inventory-grid">
                    <!-- Player's full inventory will be shown here -->
                </div>
            </div>
             <div class="inventory-section">
                <h3>Hotbar Slots</h3>
                <div id="inventoryHotbarGrid" class="inventory-grid">
                    <!-- Hotbar slots will be duplicated here for rearrangement -->
                </div>
            </div>
            <div class="inventory-section" style="text-align: center;">
                <h3>Delete Item</h3>
                <div id="deleteSlot" class="inventory-slot" data-source-type="delete" data-slot-index="0">X</div>
            </div>
            <div id="recipeMenu" class="inventory-section">
                <h3>Recipes</h3>
                <div id="recipeList">
                    <!-- Recipes will be dynamically generated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Chest Menu Overlay -->
    <div id="chestOverlay" oncontextmenu="return false;">
        <div id="chestMenu">
            <h2 id="chestTitle">Chest (Esc to Exit)</h2>
            <div class="inventory-section">
                 <input type="text" id="chestLabelInput" placeholder="Chest Label..." maxlength="30">
                <div id="chestGrid" class="inventory-grid">
                    <!-- Chest inventory slots will be dynamically generated here -->
                </div>
            </div>
            <div class="inventory-section">
                <h3>Your Inventory</h3>
                <div id="chestPlayerInventoryGrid" class="inventory-grid">
                    <!-- Player's inventory will be shown here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Message Box Overlay -->
    <div id="customMessageBoxOverlay">
        <div id="customMessageBox">
            <p id="messageBoxText"></p>
            <div id="messageBoxButtons">
                <!-- Buttons will be dynamically added here -->
            </div>
        </div>
    </div>
	<!-- Item Name Tooltip -->
<div id="itemTooltip"></div>
    <script>
		const itemTooltip = document.getElementById('itemTooltip');
		console.log('This is the monitor and cheat console! Try using this command: addToInventory("sky", 120)');
		const playerImg = new Image();
		playerImg.src = 'Player.png'; //Non constant to enable console cheats
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        inventorySize = 40 //Non constant to enable console cheats
		const hotbarSize = 10;
        const totalInventorySlots = hotbarSize + (inventorySize); // 10 + 40 = 50 slots
        const chestInventorySize = 27; // 4 rows of 10
        maxStackSize = 120; // Max stack size for non-tool items, non constant to enable console cheats
		handMiningPower = 0.1 //Non constant to enable console cheats
		
		let gameTime = 0; // Tracks total elapsed time
		const DAY_CYCLE_DURATION = 600000; // 10 minutes in milliseconds for a full day-night cycle
		let plantSpoilageAccumulator = 0;
		const PLANT_SPOILAGE_INTERVAL = 1000; // ms (once per second)

        const hotbarDiv = document.getElementById('hotbar');
        const loadingScreen = document.getElementById('loadingScreen');
        const coordsDisplay = document.getElementById('coordsDisplay');
        const healthBarDiv = document.getElementById('healthBar');
        
        // Game Menu
        const gameMenuOverlay = document.getElementById('gameMenuOverlay');
        const gameMenu = document.getElementById('gameMenu');
        const seedInput = document.getElementById('seedInput');
        const newGameButton = document.getElementById('newGameButton');
        const resumeButton = document.getElementById('resumeButton');
        const maintainDurabilityCheckbox = document.getElementById('maintainDurabilityCheckbox');

        // Inventory/Crafting Menu
        const inventoryCraftingOverlay = document.getElementById('inventoryCraftingOverlay');
        const playerInventoryGrid = document.getElementById('playerInventoryGrid');
        const inventoryHotbarGrid = document.getElementById('inventoryHotbarGrid');
        const craftingGridDiv = document.getElementById('craftingGrid'); // Reference to the 4x4 crafting grid container
        const craftingOutputSlot = document.getElementById('craftingOutput');
        const craftButton = document.getElementById('craftButton');
        const recipeListDiv = document.getElementById('recipeList'); // New: Recipe list container
        const deleteSlot = document.getElementById('deleteSlot');


        // Chest Menu
        const chestOverlay = document.getElementById('chestOverlay');
        const chestGrid = document.getElementById('chestGrid');
        const chestPlayerInventoryGrid = document.getElementById('chestPlayerInventoryGrid');
        const chestTitle = document.getElementById('chestTitle');
        const chestLabelInput = document.getElementById('chestLabelInput');
        let currentlyOpenChest = null; // Will store {col, row} of the open chest

        // Custom Message Box elements
        const customMessageBoxOverlay = document.getElementById('customMessageBoxOverlay');
        const messageBoxText = document.getElementById('messageBoxText');
        const messageBoxButtons = document.getElementById('messageBoxButtons');

        let heldItem = null; // Stores the item object being dragged by the cursor {type, count, durability}
        let heldItemSource = { type: null, index: -1 }; // type: 'inventory', 'crafting', 'chest'

        const tileSize = 40;
        const playerHeightBlocks = 3;
        const playerWidthBlocks = 1;
        playerHeight = playerHeightBlocks * tileSize; //Non constant to enable console cheats
        playerWidth = playerWidthBlocks * tileSize; //Non constant to enable console cheats

        // World generation parameters
        const generationBuffer = 60; // How many blocks to render off-screen
        const baseSurfaceLevel = 0;
        const minSurfaceVariation = 0;
        maxSurfaceVariation = 8; //Non constant to enable console cheats
        const surfaceLevelRange = maxSurfaceVariation - minSurfaceVariation + 1;
        
        // --- Vein & Structure Probabilities ---
        // Ore Probabilities
        const coalVeinProbability = 0.025;
		const deepCoalVeinProbability = 0.003;
        const copperVeinProbability = 0.002;
        const tinVeinProbability = 0.002;
        const amethystVeinProbability = 0.002;
        const ironVeinProbability = 0.001;
        const goldVeinProbability = ironVeinProbability / 5; 
        const topazVeinProbability = ironVeinProbability / 10;
		const sapphireVeinProbability = ironVeinProbability / 12;
		const diamondVeinProbability = ironVeinProbability / 12;
		const emeraldVeinProbability = ironVeinProbability / 14;
		const rubyVeinProbability = ironVeinProbability / 16; 
        const opalVeinProbability = ironVeinProbability / 20;
		const hellsteelVeinProbability = 0.005;
        const obsidianVeinProbability = 0.008;

        // Stone & Gravel Vein Probabilities
        const gravelVeinProbability = 0.03;
        const slateVeinProbability = 0.003;
        const schistVeinProbability = 0.003;
        const graniteVeinProbability = 0.002;
        const antLarvaVeinProbability = 0.015;
        const boneSpineProbability = 0.001;

        // Structure Probabilities
        caveProbability = 0.0004; //Non constant to enable console cheats
        mineshaftProbability = 0.00005; //Non constant to enable console cheats
        dungeonProbability = 0.00003; //Non constant to enable console cheats
        skyIslandProbability = 0.01; //Non constant to enable console cheats
        watchtowerProbability = 0.0005; //Non constant to enable console cheats
        
        // Foliage Probabilities
        const treeProbability = 0.12;
		const cowProbability = 0.02; // ADD THIS - 2% chance to spawn on a grass block
        const grassProbability = 0.4;
        const tallGrassProbability = 0.1;
        const cactusProbability = 0.1;
        const anthillMoundProbability = 0.5;

        // Biome generation variables
        const worldBiomes = {};
        let lastBiomeEndCol = -1; 
        let firstBiomeStartCol = 0;
        const underworldBiomes = {};
        let lastUnderworldBiomeEndCol = -1;
        let firstUnderworldBiomeStartCol = 0;

        const columnSurfaceHeights = {};
        const heavenColumnSurfaceHeights = {}; // NEW: For heaven variation
        const worldBlocks = {}; // Stores block data for generated and modified blocks
        const caveBlocks = new Set(); // Stores 'x,y' strings for cave locations
        const skyIslandColumns = new Set(); // Stores column indices where islands have been generated
		const voidRealmColumns = new Set();
        const watchtowerColumns = new Set(); // NEW: To prevent tower overlap

        // --- Seeded PRNG Implementation ---
        function mulberry32(a) {
            return function() {
                var t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        // Simple string hashing function to convert text seeds to numbers
        function stringToHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash |= 0; // Convert to 32bit integer
            }
            return Math.abs(hash); // Ensure positive hash
        }

        let currentSeed = Date.now(); // Default seed
        let random = mulberry32(currentSeed); // Initialize PRNG

        // Sets the seed for the PRNG
        function setSeed(seed) {
            currentSeed = seed;
            random = mulberry32(seed);
        }

		function generateHellWoodTree(col, surfaceRow) {
				const trunkBlockType = 'raw_hell_wood';
				const bushBlockType = 'hell_wood_bush';
				const minTrunkHeight = 6;
				const maxTrunkHeight = 10;
				const canopyRadius = 3;

				const trunkHeight = minTrunkHeight + Math.floor(random() * (maxTrunkHeight - minTrunkHeight + 1));

				// Build trunk
				for (let i = 0; i < trunkHeight; i++) {
					const row = surfaceRow - 1 - i;
					const key = `${col},${row}`;
					if (getBlockType(col, row) === 'sky') {
						worldBlocks[key] = { type: trunkBlockType, mineProg: 0 };
					} else {
						break;
					}
				}

				const topOfTrunkRow = surfaceRow - trunkHeight;

				// Build bushy top
				for (let dy = -canopyRadius; dy <= canopyRadius; dy++) {
					for (let dx = -canopyRadius; dx <= canopyRadius; dx++) {
						const dist = Math.sqrt(dx * dx + dy * dy);
						if (dist <= canopyRadius && random() < 0.85) {
							const leafCol = col + dx;
							const leafRow = topOfTrunkRow + dy;
							const key = `${leafCol},${leafRow}`;
							if (getBlockType(leafCol, leafRow) === 'sky') {
								worldBlocks[key] = { type: bushBlockType, mineProg: 0 };
							}
						}
					}
				}
			}
		// THINGS COMING SOON: Hay, Barley, Coffee

        // Block types and their properties (imgSrc, solid, mining hardness, drops, color - for fallback)
        const blockTypes = {
            'sky': { imgSrc: null, solid: false, miningHardness: 0, drops: [], color: '#87ceeb' },
            'cobweb': { imgSrc: 'Cobweb.png', solid: false, miningHardness: 50, drops: [], color: '#EEEEEE' },
            'bed': { imgSrc: 'Bed.png', solid: true, miningHardness: 100, drops: [{item: 'bed', chance: 1, min: 1, max: 1}], color: '#FF0000' },
            'chest': { imgSrc: 'Chest.png', solid: true, miningHardness: 150, drops: [{item: 'chest', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'refrigerator': { imgSrc: 'Refrigerator.png', solid: true, miningHardness: 150, drops: [{item: 'refrigerator', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'oven': { imgSrc: 'Oven.png', solid: true, miningHardness: 750, drops: [{item: 'oven', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'stone_stairs_right': { imgSrc: 'Stone Stairs Right.png', solid: true, miningHardness: 500, drops: [{item: 'stone_stairs_right', chance: 1, min: 1, max: 1}], color: '#C2B280' },
			'stone_stairs_left': { imgSrc: 'Stone Stairs Left.png', solid: true, miningHardness: 500, drops: [{item: 'stone_stairs_left', chance: 1, min: 1, max: 1}], color: '#C2B280' },
			'dead_body_chest': { imgSrc: 'Dead Body Chest.png', solid: true, miningHardness: 150, drops: [{item: 'dead_body_block', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'dead_body_block': { imgSrc: 'Dead Body Chest.png', solid: true, miningHardness: 150, drops: [{item: 'dead_body_block', chance: 1, min: 1, max: 1}], color: '#8B4513' },
            'grass_dirt_block': { imgSrc: 'Grass Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#8B4513' },
            'dirt': { imgSrc: 'Dirt Block.png', solid: true, miningHardness: 50, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'stone': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 500, drops: [{item: 'stone', chance: 1, min: 1, max: 1}], color: '#808080' },
			'watchtower_stone_block': { imgSrc: 'Watchtower Stone Block.png', solid: true, miningHardness: 800, drops: [{item: 'watchtower_stone_block', chance: 1, min: 1, max: 1}], color: '#686868' },
            'rock_block': { imgSrc: 'Rock Block.png', solid: true, miningHardness: 500, drops: [{item: 'rock_block', chance: 1, min: 1, max: 1}], color: '#A9A9A9' },
            'sand_block': { imgSrc: 'Sand Block.png', solid: true, miningHardness: 40, drops: [{item: 'sand_block', chance: 1, min: 1, max: 1}], color: '#F4A460' },
            'sandstone_block': { imgSrc: 'Sandstone Block.png', solid: true, miningHardness: 450, drops: [{item: 'sandstone_block', chance: 1, min: 1, max: 1}], color: '#E3B48E' },
            'compacting_stone': { imgSrc: 'Compacting Stone Block.png', solid: true, miningHardness: 750, drops: [{item: 'compacted_stone', chance: 1, min: 1, max: 1}], color: '#696969' },
            'glass_block': { imgSrc: 'Glass Block.png', solid: true, miningHardness: 40, drops: [{item: 'glass_block', chance: 1, min: 1, max: 1}], color: '#F4A460' },
			'compacted_stone': { imgSrc: 'Compacted Stone Block.png', solid: true, miningHardness: 1000, drops: [{item: 'compacted_stone', chance: 1, min: 1, max: 1}], color: '#708090' },
			'compressed_stone': { imgSrc: 'Compressed Stone Block.png', solid: true, miningHardness: 10000, drops: [{item: 'compressed_stone', chance: 1, min: 1, max: 1}], color: '#708090' },
			'void_stone': { imgSrc: 'Void Stone Block.png', solid: true, miningHardness: 1000, drops: [{item: 'void_stone', chance: 1, min: 1, max: 1}], color: '#708090' },
			'void_dust_block': { imgSrc: 'Void Dust Block.png', solid: true, miningHardness: 100, drops: [{item: 'void_dust', chance: 1, min: 1, max: 16}], color: '#708090' },
			'void_crystal': { imgSrc: 'Void Crystal Block.png', solid: true, miningHardness: 1000, drops: [{item: 'void_crystal', chance: 1, min: 1, max: 1}], color: '#708090' },
			'bedrock_stone': { imgSrc: 'Bedrock Stone Block.png', solid: true, miningHardness: 50000, drops: [{item: 'void_stone', chance: 1, min: 1, max: 1}], color: '#708090', requiredMiningPower: 2.5 },
			'hellstone': { imgSrc: 'Hellstone Block.png', solid: true, miningHardness: 500, drops: [{item: 'hellstone', chance: 1, min: 1, max: 1}], color: '#808080' },
			'hellsteel_hellstone': { imgSrc: 'Hellsteel Hellstone Block.png', solid: true, miningHardness: 750, drops: [{item: 'hellsteel_nugget', chance: 1, min: 1, max: 3}], color: '#808080' },
            'grass_soil': { imgSrc: 'Grass Soil Block.png', solid: true, miningHardness: 80, drops: [{item: 'soil', chance: 1, min: 1, max: 1}], color: '#90EE90' },
            'soil': { imgSrc: 'Soil Block.png', solid: true, miningHardness: 70, drops: [{item: 'soil', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'fertilizer': { imgSrc: 'Fertilizer Block.png', solid: true, miningHardness: 70, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}], color: '#5C4033' },
			'stone_brick_block': { imgSrc: 'Stone Brick Block.png', solid: true, miningHardness: 500, drops: [{item: 'stone_brick_block', chance: 1, min: 1, max: 1}], color: '#A0522D' },
			'clay_brick_block': { imgSrc: 'Clay Brick Block.png', solid: true, miningHardness: 400, drops: [{item: 'clay_brick_block', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'steel_brick_block': { imgSrc: 'Steel Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'steel_brick_block', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'bronze_brick_block': { imgSrc: 'Bronze Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'bronze_brick_block', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'gold_brick_block': { imgSrc: 'Gold Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'gold_brick_block', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'iron_brick_block': { imgSrc: 'Iron Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'iron_brick_block', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'tin_brick_block': { imgSrc: 'Tin Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'tin_brick_block', chance: 1, min: 1, max: 1}], color: '#FCC201' },
			'copper_brick_block': { imgSrc: 'Copper Brick Block.png', solid: true, miningHardness: 800, drops: [{item: 'copper_brick_block', chance: 1, min: 1, max: 1}], color: '#FCC201' },
            'heaven_brick_block': { imgSrc: 'Heaven Brick Block.png', solid: true, miningHardness: 1200, drops: [{item: 'heaven_brick_block', chance: 1, min: 1, max: 1}], color: '#F0EAD6' },
            'coal_stone': { imgSrc: 'Coal Stone Block.png', solid: true, miningHardness: 750, drops: [{item: 'coal', chance: 1, min: 1, max: 1}], color: '#36454F' },
			'coal_compacted_stone': { imgSrc: 'Coal Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'coal', chance: 1, min: 1, max: 1}], color: '#36454F' },
            'copper_compacted_stone': { imgSrc: 'Copper Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'copper_nugget', chance: 1, min: 1, max: 1}], color: '#B87333' },
            'tin_compacted_stone': { imgSrc: 'Tin Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'tin_nugget', chance: 1, min: 1, max: 1}], color: '#C0C0C0' },
            'iron_compacted_stone': { imgSrc: 'Iron Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'iron_nugget', chance: 1, min: 1, max: 1}], color: '#A19D94' },
            'gold_compacted_stone': { imgSrc: 'Gold Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'gold_nugget', chance: 1, min: 1, max: 1}], color: '#FFD700' },
            'ruby_compacted_stone': { imgSrc: 'Ruby Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'ruby_nugget', chance: 1, min: 1, max: 1}], color: '#E0115F' },
            'diamond_compacted_stone': { imgSrc: 'Diamond Compacted Stone Block.png', solid: true, miningHardness: 2000, drops: [{item: 'diamond_nugget', chance: 1, min: 1, max: 1}], color: '#B9F2FF' },
            'raw_oak': { imgSrc: 'Raw Oak Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_oak', chance: 1, min: 1, max: 1}], color: '#654321' },
            'oak_bush': { imgSrc: 'Oak Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'oak_bush', chance: 0.05, min: 1, max: 1}], color: '#228B22' },
            'planked_oak': { imgSrc: 'Planked Oak Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_oak', chance: 1, min: 1, max: 1}], color: '#D2B48C' },
            'raw_birch': { imgSrc: 'Raw Birch Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_birch', chance: 1, min: 1, max: 1}], color: '#C0C0C0' },
            'birch_bush': { imgSrc: 'Birch Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'birch_bush', chance: 0.05, min: 1, max: 1}], color: '#6B8E23' },
            'planked_birch': { imgSrc: 'Planked Birch Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_birch', chance: 1, min: 1, max: 1}], color: '#F5DEB3' },
            'raw_spruce': { imgSrc: 'Raw Spruce Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_spruce', chance: 1, min: 1, max: 1}], color: '#4A3B2F' },
            'spruce_bush': { imgSrc: 'Spruce Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'spruce_bush', chance: 0.05, min: 1, max: 1}], color: '#0A4A2A' },
			'planked_spruce': { imgSrc: 'Planked Spruce Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_spruce', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'meat_wood': { imgSrc: 'Meat Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'meat_wood', chance: 0.1, min: 1, max: 1}, {item: 'beef', chance: 0.3, min: 1, max: 3}, {item: 'pork', chance: 0.3, min: 1, max: 3}, {item: 'human_flesh', chance: 0.2, min: 1, max: 3}], color: '#4A3B2F' },
			'spoiled_meat_wood': { imgSrc: 'Spoiled Meat Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'spoiled_meat_wood', chance: 0.1, min: 1, max: 1}, {item: 'spoiled_beef', chance: 0.3, min: 1, max: 3}, {item: 'spoiled_pork', chance: 0.3, min: 1, max: 3}, {item: 'human_flesh', chance: 0.2, min: 1, max: 3}], color: '#4A3B2F' },
			'raw_hell_wood': { imgSrc: 'Raw Hell Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'raw_hell_wood', chance: 1, min: 1, max: 1}], color: '#4A3B2F' },
            'hell_wood_bush': { imgSrc: 'Hell Wood Bush Block.png', solid: true, miningHardness: 20, drops: [{item: 'hell_wood_bush', chance: 0.05, min: 1, max: 1}], color: '#0A4A2A' },
			'planked_hell_wood': { imgSrc: 'Planked Hell Wood Block.png', solid: true, miningHardness: 150, drops: [{item: 'planked_hell_wood', chance: 1, min: 1, max: 1}], color: '#8B4513' },
            'grass': { imgSrc: 'Grass.png', solid: false, miningHardness: 10, drops: [{item: 'wheat_seeds', chance: 0.2, min: 1, max: 2}, {item: 'barley_seeds', chance: 0.2, min: 1, max: 2}], color: '#7CFC00' },
            'tall_grass': { imgSrc: 'Tall Grass.png', solid: false, miningHardness: 20, drops: [{item: 'wheat_seeds', chance: 0.3, min: 1, max: 3}, {item: 'cotton_seeds', chance: 0.1, min: 1, max: 2}], color: '#6B8E23' },
            'snow': { imgSrc: 'Snow Pile.png', solid: false, miningHardness: 5, drops: [{item: 'snow_ball', chance: 1, min: 1, max: 1}], color: '#FFFAFA' },
            'large_snow_pile': { imgSrc: 'Large Snow Pile.png', solid: false, miningHardness: 10, drops: [{item: 'snow_ball', chance: 1, min: 2, max: 2}], color: '#F0FFFF' },
            'snow_block': { imgSrc: 'Snow Block.png', solid: true, miningHardness: 25, drops: [{item: 'snow_block', chance: 1, min: 1, max: 1}], color: '#F0FFFF' },
            'desert_brush': { imgSrc: 'Desert Brush.png', solid: false, miningHardness: 5, drops: [{item: 'tomato_seeds', chance: 0.2, min: 1, max: 2}], color: '#D2B48C' },
            'prickly_pear_cactus': { imgSrc: 'Prickly Pear Cactus.png', solid: false, miningHardness: 5, drops: [{item: 'prickly_pear_fruit', chance: 0.6, min: 1, max: 1}], color: '#93C572' },
            'cactus_block': { imgSrc: 'Cactus Block.png', solid: true, miningHardness: 80, drops: [{item: 'cactus_block', chance: 1, min: 1, max: 1}], color: '#556B2F' },
            'anthill_sand_block': { imgSrc: 'Anthill Sand Block.png', solid: true, miningHardness: 45, drops: [{item: 'anthill_sand_block', chance: 1, min: 1, max: 1}], color: '#C19A6B' },
            'colony_heart_sand_block': { imgSrc: 'Colony Heart Sand Block.png', solid: true, miningHardness: 500, drops: [{item: 'colony_heart', chance: 1, min: 1, max: 1}], color: '#FF4444' },
            'anthill_sand_mound': { imgSrc: 'Anthill Sand Mound.png', solid: false, miningHardness: 10, drops: [], color: '#D2B48C' },
            'slate_block': { imgSrc: 'Slate Block.png', solid: true, miningHardness: 600, drops: [{item: 'slate_block', chance: 1, min: 1, max: 1}], color: '#708090' },
            'schist_block': { imgSrc: 'Schist Block.png', solid: true, miningHardness: 600, drops: [{item: 'schist_block', chance: 1, min: 1, max: 1}], color: '#848482' },
            'granite_block': { imgSrc: 'Granite Block.png', solid: true, miningHardness: 700, drops: [{item: 'granite_block', chance: 1, min: 1, max: 1}], color: '#F8C8DC' },
			'asphalt_block': { imgSrc: 'Asphalt Block.png', solid: true, miningHardness: 600, drops: [{item: 'asphalt_fragment', chance: 1, min: 1, max: 4}], color: '#F8C8DC' },
            'vine_stone_block': { imgSrc: 'Vine Stone Block.png', solid: true, miningHardness: 550, drops: [{item: 'stone', chance: 1, min: 1, max: 1}], color: '#556B2F' },
            'packed_ice_block': { imgSrc: 'Packed Ice Block.png', solid: true, miningHardness: 80, drops: [{item: 'packed_ice_block', chance: 1, min: 1, max: 1}], color: '#ADD8E6' },
            'gravel_block': { imgSrc: 'Gravel Block.png', solid: true, miningHardness: 60, drops: [{item: 'gravel_block', chance: 1, min: 1, max: 1}], color: '#A9A9A9' },
            'topaz_compacted_stone': { imgSrc: 'Topaz Compacted Stone Block.png', solid: true, miningHardness: 1600, drops: [{item: 'topaz_nugget', chance: 1, min: 1, max: 1}], color: '#FFC87C' },
            'sapphire_compacted_stone': { imgSrc: 'Sapphire Compacted Stone Block.png', solid: true, miningHardness: 1600, drops: [{item: 'sapphire_nugget', chance: 1, min: 1, max: 1}], color: '#0F52BA' },
            'emerald_compacted_stone': { imgSrc: 'Emerald Compacted Stone Block.png', solid: true, miningHardness: 2100, drops: [{item: 'emerald_nugget', chance: 1, min: 1, max: 1}], color: '#50C878' },
            'amethyst_compacted_stone': { imgSrc: 'Amethyst Compacted Stone Block.png', solid: true, miningHardness: 1500, drops: [{item: 'amethyst_nugget', chance: 1, min: 1, max: 1}], color: '#9966CC' },
            'opal_compacted_stone': { imgSrc: 'Opal Compacted Stone Block.png', solid: true, miningHardness: 2200, drops: [{item: 'opal_nugget', chance: 1, min: 1, max: 1}], color: '#E0E9E7' },
            // Overgrown Forest Blocks
            'dark_moss_dirt': { imgSrc: 'Dark Moss Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#4A442A' },
            'weed_dirt_block': { imgSrc: 'Weed Dirt Block.png', solid: true, miningHardness: 65, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#5A5030' },
            'mud_block': { imgSrc: 'Mud Block.png', solid: true, miningHardness: 70, drops: [{item: 'mud_block', chance: 1, min: 1, max: 1}], color: '#5C4033' },
            'pest_dirt_block': { imgSrc: 'Pest Dirt Block.png', solid: true, miningHardness: 70, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'pest', chance: 1, min: 1, max: 3}], color: '#6B4226' },
            'raw_darkwood': { imgSrc: 'Raw Darkwood Block.png', solid: true, miningHardness: 160, drops: [{item: 'raw_darkwood', chance: 1, min: 1, max: 1}], color: '#2F271B' },
            'darkwood_bush': { imgSrc: 'Darkwood Bush Block.png', solid: true, miningHardness: 25, drops: [{item: 'darkwood_bush', chance: 0.05, min: 1, max: 1}], color: '#3A3125' },
            'planked_darkwood': { imgSrc: 'Planked Darkwood Block.png', solid: true, miningHardness: 160, drops: [{item: 'planked_darkwood', chance: 1, min: 1, max: 1}], color: '#4A3B2F' },
            'pest_stone_block_weak': { imgSrc: 'Pest Stone Block (Weak).png', solid: true, miningHardness: 400, drops: [{item: 'stone', chance: 1, min: 1, max: 1}, {item: 'pest', chance: 1, min: 1, max: 1}], color: '#6A675A' },
            'pest_stone_block_strong': { imgSrc: 'Pest Stone Block (Strong).png', solid: true, miningHardness: 600, drops: [{item: 'stone', chance: 1, min: 1, max: 1}, {item: 'pest', chance: 1, min: 1, max: 5}], color: '#5A574A' },
            'moss': { imgSrc: 'Moss.png', solid: false, miningHardness: 5, drops: [], color: '#4A5D23' },
            'dark_moss': { imgSrc: 'Dark Moss.png', solid: false, miningHardness: 5, drops: [], color: '#3B4A1C' },
            'weed': { imgSrc: 'Weed.png', solid: false, miningHardness: 5, drops: [], color: '#6B8E23' },
            'shroom': { imgSrc: 'Shroom.png', solid: false, miningHardness: 10, drops: [{item: 'shroom', chance: 1, min: 1, max: 1}], color: '#8B0000' },
            // ---FARMING SECTION---
            'hay_bale': { imgSrc: 'Hay Bale Block.png', solid: true, miningHardness: 100, drops: [{item: 'hat_bale', chance: 1, min: 1, max: 2}], color: '#F0F0F0' },
		    'cotton': { imgSrc: 'Cotton.png', solid: false, miningHardness: 10, drops: [{item: 'cotton_item', chance: 1, min: 1, max: 2}, {item: 'cotton_seeds', chance: 0.2, min: 0, max: 2}], color: '#F0F0F0' },
			'cotton_dirt_block': { imgSrc: 'Cotton Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'cotton_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'cotton_soil_block': { imgSrc: 'Cotton Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'cotton_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
			'cotton_fertilizer_block': { imgSrc: 'Cotton Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'cotton_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033' },
			'planted_cotton_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'rice': { imgSrc: 'Rice.png', solid: false, miningHardness: 10, drops: [{item: 'rice_item', chance: 1, min: 1, max: 2}, {item: 'rice_seeds', chance: 0.2, min: 0, max: 2}], color: '#FFFFFF' },
            'rice_dirt_block': { imgSrc: 'Rice Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'rice_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'rice_soil_block': { imgSrc: 'Rice Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'rice_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'rice_fertilizer_block': { imgSrc: 'Rice Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'rice_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033' },
            'planted_rice_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
            'wheat': { imgSrc: 'Wheat.png', solid: false, miningHardness: 10, drops: [{item: 'wheat_item', chance: 1, min: 1, max: 2}, {item: 'wheat_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'wheat_dirt_block': { imgSrc: 'Wheat Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'wheat_soil_block': { imgSrc: 'Wheat Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'wheat_fertilizer_block': { imgSrc: 'Wheat Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033' },
			'planted_wheat_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'barley': { imgSrc: 'Barley.png', solid: false, miningHardness: 10, drops: [{item: 'barley_item', chance: 1, min: 1, max: 2}, {item: 'wheat_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'barley_dirt_block': { imgSrc: 'Barley Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'barley_soil_block': { imgSrc: 'Barley Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'barley_fertilizer_block': { imgSrc: 'Barley Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'wheat_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033' },
			'planted_barley_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'tomato_bush': { imgSrc: 'Tomato Bush.png', solid: false, miningHardness: 10, drops: [{item: 'tomato', chance: 1, min: 1, max: 3}, {item: 'tomato_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'tomato_dirt_block': { imgSrc: 'Tomato Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'tomato_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'tomato_soil_block': { imgSrc: 'Tomato Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'tomato_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'tomato_fertilizer_block': { imgSrc: 'Tomato Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'tomato_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033' },
			'planted_tomato_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'hop': { imgSrc: 'Hop Plant.png', solid: false, miningHardness: 10, drops: [{item: 'hop_item', chance: 1, min: 1, max: 4}, {item: 'hop_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'hop_dirt_block': { imgSrc: 'Hop Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'hop_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'hop_soil_block': { imgSrc: 'Hop Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'hop_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'hop_fertilizer_block': { imgSrc: 'Hop Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'hop_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033' },
			'planted_hop_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'oat': { imgSrc: 'Oat.png', solid: false, miningHardness: 10, drops: [{item: 'oat_item', chance: 1, min: 1, max: 2}, {item: 'oat_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'oat_dirt_block': { imgSrc: 'Oat Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'oat_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'oat_soil_block': { imgSrc: 'Oat Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'oat_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'oat_fertilizer_block': { imgSrc: 'Oat Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'oat_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033' },
			'planted_oat_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
			'corn': { imgSrc: 'Corn.png', solid: false, miningHardness: 10, drops: [{item: 'corn_item', chance: 1, min: 1, max: 2}, {item: 'corn_seeds', chance: 0.2, min: 0, max: 3}], color: '#FF6347' },
            'corn_dirt_block': { imgSrc: 'Corn Seed Dirt Block.png', solid: true, miningHardness: 100, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}, {item: 'corn_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'corn_soil_block': { imgSrc: 'Corn Seed Soil Block.png', solid: true, miningHardness: 140, drops: [{item: 'soil', chance: 1, min: 1, max: 1}, {item: 'corn_seeds', chance: 1, min: 1, max: 1}], color: '#A0522D' },
            'corn_fertilizer_block': { imgSrc: 'Corn Seed Fertilizer Block.png', solid: true, miningHardness: 140, drops: [{item: 'fertilizer', chance: 1, min: 1, max: 1}, {item: 'corn_seeds', chance: 1, min: 1, max: 1}], color: '#5C4033' },
			'planted_corn_seeds': { imgSrc: null, solid: true, miningHardness: 100, drops: [], color: '#D2B48C' },
            // NEW Golden City & Sky Island Blocks
            'gilded_grass_dirt_block_block': { imgSrc: 'Gilded Grass Dirt Block.png', solid: true, miningHardness: 80, drops: [{item: 'gilded_dirt_block', chance: 1, min: 1, max: 1}], color: '#F0E68C' },
            'gilded_dirt_block': { imgSrc: 'Gilded Dirt Block.png', solid: true, miningHardness: 70, drops: [{item: 'gilded_dirt_block', chance: 1, min: 1, max: 1}], color: '#DAA520' },
            'raw_gilded_wood': { imgSrc: 'Raw Gilded Wood Block.png', solid: true, miningHardness: 180, drops: [{item: 'raw_gilded_wood', chance: 1, min: 1, max: 1}], color: '#BDB76B' },
            'planked_gilded_wood': { imgSrc: 'Planked Gilded Wood Block.png', solid: true, miningHardness: 180, drops: [{item: 'planked_gilded_wood', chance: 1, min: 1, max: 1}], color: '#CFB53B' },
            'gilded_tree_bush': { imgSrc: 'Gilded Tree Bush Block.png', solid: true, miningHardness: 30, drops: [{item: 'gilded_tree_bush', chance: 0.05, min: 1, max: 1}], color: '#FFD700' },
            'cloud_block': { imgSrc: 'Cloud Block.png', solid: true, miningHardness: 10, drops: [], color: '#F0F8FF' },
			'meat_block': { imgSrc: 'Meat Block.png', solid: true, miningHardness: 200, drops: [{item: 'meat_block', chance: 0.1, min: 1, max: 1}, {item: 'beef', chance: 0.3, min: 1, max: 3}, {item: 'pork', chance: 0.3, min: 1, max: 3}, {item: 'human_flesh', chance: 0.2, min: 1, max: 3}], color: '#E0DBCB' },
			'spoiled_meat_block': { imgSrc: 'Spoiled Meat Block.png', solid: true, miningHardness: 200, drops: [{item: 'spoiled_meat_block', chance: 0.1, min: 1, max: 1}, {item: 'spoiled_beef', chance: 0.3, min: 1, max: 3}, {item: 'spoiled_pork', chance: 0.3, min: 1, max: 3}, {item: 'human_flesh', chance: 0.2, min: 1, max: 3}], color: '#E0DBCB' },
			'flesh_block': { imgSrc: 'Flesh Block.png', solid: true, miningHardness: 300, drops: [{item: 'flesh_block', chance: 1, min: 1, max: 1}], color: '#E0DBCB' },
			// NEWLY IMPLEMENTED
			'bone_block': { imgSrc: 'Bone Block.png', solid: true, miningHardness: 500, drops: [{item: 'bone_block', chance: 1, min: 1, max: 1}], color: '#E0DBCB' },
			'obsidian_block': { imgSrc: 'Obsidian Block.png', solid: true, miningHardness: 300, drops: [{item: 'obsidian_block', chance: 1, min: 1, max: 1}], color: '#3C2A4D' },
			'ant_larva_block': { imgSrc: 'Ant Larva Block.png', solid: true, miningHardness: 30, drops: [], color: '#F5F5DC' },
			// To Be Implemented Into Future Biomes
			// Experimental And In Waiting
			'dark_grass_dirt_block': { imgSrc: 'Dark Grass Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'moss_dirt_block': { imgSrc: 'Moss Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'flesh_grass_dirt_block': { imgSrc: 'Flesh Grass Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'flesh_grass_soil_block': { imgSrc: 'Flesh Grass Soil Block.png', solid: true, miningHardness: 60, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'doom_grass_dirt_block': { imgSrc: 'Doom Grass Dirt Block.png', solid: true, miningHardness: 60, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			'doom_grass_soil_block': { imgSrc: 'Doom Grass Soil Block.png', solid: true, miningHardness: 60, drops: [{item: 'dirt', chance: 1, min: 1, max: 1}], color: '#8B4513' },
			// World Creator Blocks
			'invisible_barrier': { imgSrc: 'Barrier Invisible.png', solid: true, miningHardness: 1000000000, drops: [], color: '#8B4513' },
			'visible_barrier': { imgSrc: 'Barrier Visible.png', solid: true, miningHardness: 1000000000, drops: [], color: '#8B4513' },
			'master_block': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 1000000000, drops: [{item: 'stone', chance: 1, min: 240, max: 240}], color: '#8B4513' },
			'test_block_mine_power': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 100, drops: [{item: 'stone', chance: 1, min: 1, max: 1}], color: '#8B4513', requiredMiningPower: 0.5 },
			'test_block_test_axe': { imgSrc: 'Stone Block.png', solid: true, miningHardness: 100, drops: [{item: 'stone', chance: 1, min: 1, max: 1}], color: '#8B4513', requiredTool: 'test_axe' },
			
        };

        // Item types and their properties (imgSrc, isTool, miningPower, maxDurability, color - for fallback)
        const itemTypes = {
			 'cooked_beef': { imgSrc: 'Cooked Beef.png', color: '#802600', isFood: true, healAmount: 10 },
			 'wooden_bowl': { imgSrc: 'Wooden Bowl.png', color: '#8B4513' },
			 'glass_cup': { imgSrc: 'Glass Cup.png', color: '#8B4513' },
             'asphalt_fragment': { imgSrc: 'Asphalt Fragment.png', color: '#36454F' },
			 'void_dust': { imgSrc: 'Void Dust.png', color: '#36454F' },
             'snow_ball': { imgSrc: 'Snow Ball.png', color: '#FFFAFA' },
             'prickly_pear_fruit': { imgSrc: 'Prickly Pear Fruit.png', color: '#8B008B', isFood: true, healAmount: 2 },
             'wooden_stick': { imgSrc: 'Wooden Stick.png', color: '#8B4513' },
             'wheat_bread': { imgSrc: 'Wheat Bread.png', color: '#E6BF83', isFood: true, healAmount: 4 },
			 'barley_bread': { imgSrc: 'Barley Bread.png', color: '#E6BF83', isFood: true, healAmount: 4 },
             'fertilizer': { imgSrc: 'Fertilizer Block.png', color: '#654321' },
             'colony_heart': { imgSrc: 'Colony Heart.png', color: '#FF0000' },
             'anthill_sand_block': { imgSrc: 'Anthill Sand Block.png', color: '#C19A6B' },
			 'paper': { imgSrc: 'Paper.png', color: '#36454F', isFuel: true, fuelAmount: 1 },
			 // ---NUGGETS---
             'coal': { imgSrc: 'Coal Nugget.png', color: '#36454F', isFuel: true, fuelAmount: 5 },
			 'copper_nugget': { imgSrc: 'Copper Nugget.png', color: '#B87333' },
			 'tin_nugget': { imgSrc: 'Tin Nugget.png', color: '#C0C0C0' },
             'bronze_nugget': { imgSrc: 'Bronze Nugget.png', color: '#CD7F32' },
             'iron_nugget': { imgSrc: 'Iron Nugget.png', color: '#A19D94' },
             'gold_nugget': { imgSrc: 'Gold Nugget.png', color: '#FFD700' },
             'ruby_nugget': { imgSrc: 'Ruby Nugget.png', color: '#E0115F' },
             'diamond_nugget': { imgSrc: 'Diamond Nugget.png', color: '#B9F2FF' },
             'steel_nugget': { imgSrc: 'Steel Nugget.png', color: '#43464B' },
			 'topaz_nugget': { imgSrc: 'Topaz Nugget.png', color: '#FFC87C' },
             'sapphire_nugget': { imgSrc: 'Sapphire Nugget.png', color: '#0F52BA' },
             'emerald_nugget': { imgSrc: 'Emerald Nugget.png', color: '#50C878' },
             'amethyst_nugget': { imgSrc: 'Amethyst Nugget.png', color: '#9966CC' },
             'opal_nugget': { imgSrc: 'Opal Nugget.png', color: '#E0E9E7' },
			 'hellsteel_nugget': { imgSrc: 'Hellsteel Nugget.png', color: '#CD7F32' },
			 // ---FARMING SECTION---
			 'plant_mush': { imgSrc: 'Plant Mush.png', color: '#FF0000', isFood: true, healAmount: 1 },
			 'tomato_seeds': { imgSrc: 'Tomato Seeds.png', color: '#FF6347' },
             'tomato': { imgSrc: 'Tomato.png', color: '#FF0000', isFood: true, healAmount: 2, spoilable: { into: 'plant_mush', time: 300000 } },
			 'wheat_seeds': { imgSrc: 'Wheat Seeds.png', color: '#F5DEB3' },
			 'wheat_item': { imgSrc: 'Wheat.png', color: '#F5DEB3', spoilable: { into: 'plant_mush', time: 300000 } },
			 'barley_seeds': { imgSrc: 'Barley Seeds.png', color: '#F5DEB3' },
			 'barley_item': { imgSrc: 'Barley.png', color: '#F5DEB3', spoilable: { into: 'plant_mush', time: 300000 } },
			 'cotton_seeds': { imgSrc: 'Cotton Seeds.png', color: '#D3D3D3' },
             'cotton_item': { imgSrc: 'Cotton.png', color: '#F5F5F5', spoilable: { into: 'plant_mush', time: 300000 } },
             'rice_seeds': { imgSrc: 'Rice Seeds.png', color: '#F5F5DC' },
             'rice_item': { imgSrc: 'Rice.png', color: '#FFFFFF', spoilable: { into: 'plant_mush', time: 300000 } },
			 'hop_seeds': { imgSrc: 'Hop Seeds.png', color: '#F5F5DC' },
             'hop_item': { imgSrc: 'Hop.png', color: '#FFFFFF', spoilable: { into: 'plant_mush', time: 300000 } },
			 'oat_seeds': { imgSrc: 'Oat Seeds.png', color: '#F5F5DC' },
             'oat_item': { imgSrc: 'Oat.png', color: '#FFFFFF', spoilable: { into: 'plant_mush', time: 300000 } },
			 'corn_seeds': { imgSrc: 'Corn Seeds.png', color: '#F5F5DC' },
             'corn_item': { imgSrc: 'Corn.png', color: '#FFFFFF', isFood: true, healAmount: 6, spoilable: { into: 'plant_mush', time: 300000 } },
			 // ---(CRAFTED) FOOD/DRINK SECTION---
			 'taco_salad': { imgSrc: 'Taco Salad.png', color: '#FFFFFF', isFood: true, healAmount: 12 },
			 'mushroom_soup': { imgSrc: 'Mushroom Soup.png', color: '#FFFFFF', isFood: true, healAmount: 4 },
			 'tomato_soup': { imgSrc: 'Tomato Soup.png', color: '#FFFFFF', isFood: true, healAmount: 7 },
			 'tomato_sandwich': { imgSrc: 'Tomato Sandwich.png', color: '#D24F33', isFood: true, healAmount: 20 },
			 'beef': { imgSrc: 'Beef.png', color: '#C04040', isFood: true, healAmount: 4, spoilable: { into: 'spoiled_beef', time: 300000 }, cookable: { into: 'cooked_beef' } },
			 'spoiled_beef': { imgSrc: 'Spoiled Beef.png', color: '#D24F33', isFood: true, healAmount: 0 },
			 'pork': { imgSrc: 'Pork.png', color: '#C04040', isFood: true, healAmount: 3, spoilable: { into: 'spoiled_pork', time: 300000 }, cookable: { into: 'cooked_pork' } },
			 'spoiled_pork': { imgSrc: 'Spoiled Pork.png', color: '#D24F33', isFood: true, healAmount: 0 },
			 'human_flesh': { imgSrc: 'Human Flesh.png', color: '#D24F33', isFood: true, healAmount: 1 },
			 'cup_of_coffee': { imgSrc: 'Cup Of Coffee.png', color: '#D24F33', isFood: true, healAmount: 2 },
			 'cup_of_beer': { imgSrc: 'Cup Of Beer.png', color: '#D24F33', isFood: true, healAmount: 5 },
			 // ---PICKAXE SECTION---
			 'wooden_pickaxe': { imgSrc: 'Wooden Pickaxe.png', color: '#A0522D', isTool: true, miningPower: 0.2, maxDurability: 15000 },
             'rock_pickaxe': { imgSrc: 'Rock Pickaxe.png', color: '#888888', isTool: true, miningPower: 0.3, maxDurability: 25000 },
             'copper_pickaxe': { imgSrc: 'Copper Pickaxe.png', color: '#B87333', isTool: true, miningPower: 0.5, maxDurability: 40000 },
             'tin_pickaxe': { imgSrc: 'Tin Pickaxe.png', color: '#C0C0C0', isTool: true, miningPower: 0.5, maxDurability: 7500 },
             'bronze_pickaxe': { imgSrc: 'Bronze Pickaxe.png', color: '#CD7F32', isTool: true, miningPower: 0.8, maxDurability: 60000 },
             'iron_pickaxe': { imgSrc: 'Iron Pickaxe.png', color: '#A19D94', isTool: true, miningPower: 1.0, maxDurability: 50000 },
             'steel_pickaxe': { imgSrc: 'Steel Pickaxe.png', color: '#43464B', isTool: true, miningPower: 1.5, maxDurability: 150000 },
			 'hellsteel_pickaxe': { imgSrc: 'Hellsteel Pickaxe.png', color: '#43464B', isTool: true, miningPower: 2.5, maxDurability: 300000 },
             'ruby_plated_steel_pickaxe': { imgSrc: 'Ruby Plated Steel Pickaxe.png', color: '#E0115F', isTool: true, miningPower: 1.8, maxDurability: 200000 },
             'diamond_plated_steel_pickaxe': { imgSrc: 'Diamond Plated Steel Pickaxe.png', color: '#B9F2FF', isTool: true, miningPower: 2.1, maxDurability: 250000 },
			 'pest': { imgSrc: 'Pest.png', color: '#36454F' },
             'shroom': { imgSrc: 'Shroom.png', color: '#8B0000' },
             'watchtower_stone_block': { imgSrc: 'Watchtower Stone Block.png', color: '#686868' },
			 // Currently Useless Items
			 'bucket': { imgSrc: 'Bucket.png', color: '#A9A9A9' },
			 'test_axe': { imgSrc: 'Wooden Pickaxe.png', color: '#A0522D', isTool: true, miningPower: 0.5, maxDurability: 10000 },
        };

        // Breaking stage assets for visual feedback during mining
        const breakingStageAssets = {
            'breaking_stage_1': { imgSrc: 'Breaking Stage 1.png' },
            'breaking_stage_2': { imgSrc: 'Breaking Stage 2.png' },
            'breaking_stage_3': { imgSrc: 'Breaking Stage 3.png' }
        };

        // Health icon assets
        const healthAssets = {
            'full_heart': { imgSrc: 'Full Heart Icon.png' },
            'half_heart': { imgSrc: 'Half Heart Icon.png' },
            'empty_heart': { imgSrc: 'Empty Heart Icon.png' }
        };

        // Combine all assets to load
        const assetsToLoadList = { ...blockTypes, ...itemTypes, ...breakingStageAssets, ...healthAssets };
        const assets = {}; // Stores loaded image objects
        let assetsToLoad = 0;
        let assetsLoaded = 0;
        const failedAssets = {}; // Tracks assets that failed to load

        // Loads all image assets required for the game
        function loadAssets() {
            for (const type in assetsToLoadList) {
                if (assetsToLoadList[type].imgSrc) {
                    assetsToLoad++;
                    const img = new Image();
                    img.onload = () => {
                        assetsLoaded++;
                        assets[type] = img;
                        checkAllAssetsLoaded();
                    };
                    img.onerror = () => {
                        console.error(`Failed to load asset: ${assetsToLoadList[type].imgSrc}`);
                        failedAssets[type] = true; // Mark as failed
                        assetsLoaded++;
                        checkAllAssetsLoaded();
                    };
                    img.src = assetsToLoadList[type].imgSrc;
                }
            }
            if (assetsToLoad === 0) {
                 loadingScreen.style.display = 'none';
                 init();
            }
        }

        // Checks if all assets have finished loading and then initializes the game
        function checkAllAssetsLoaded() {
             if (assetsLoaded === assetsToLoad) {
                 loadingScreen.style.display = 'none';
                 init();
            }
        }
		
		const playerReach = 5 * tileSize; // For example, 5 tiles

        const player = {
            x: 0 * tileSize, y: 0, dx: 0, dy: 0,
            speed: 5, jumpStrength: -15, onGround: false, gravity: 0.8,
            health: 100, maxHealth: 100,
            fallStartY: 0, // Y-position where a fall started
            spawnPoint: { x: 0 * tileSize, y: -10 },
            bedSpawnPoint: null
        };

        let playerMiningPower = 0.1; // Base mining power
        const camera = { x: 0, y: 0 };
        const keys = {}; // Tracks pressed keys
		const npcs = []; // ADD THIS
        const mouse = { x: 0, y: 0, down: false, rightDown: false }; // Tracks mouse state
        let miningTarget = null; // Stores information about the block currently being mined
        
        const inventorySlots = new Array(totalInventorySlots).fill(null);
        const hotbarIndices = new Array(hotbarSize).fill(null);

        let selectedHotbarSlot = 0;
        let isGameActive = true; 
        let isGamePaused = false; 
        let maintainBlockDurability = false;

        function isTreeBlock(type) {
            return type === 'raw_oak' || type === 'oak_bush' ||
                   type === 'raw_birch' || type === 'birch_bush' ||
                   type === 'raw_spruce' || type === 'spruce_bush' ||
                   type === 'raw_darkwood' || type === 'darkwood_bush' ||
                   type === 'raw_gilded_wood' || type === 'gilded_tree_bush';
        }

        // REVISED: Dedicated function for generating cacti
        function generateCactus(col, surfaceRow) {
            const height = 2 + Math.floor(random() * 4); // Generates a height of 2, 3, 4, or 5
            for (let i = 0; i < height; i++) {
                const key = `${col},${surfaceRow - 1 - i}`;
                // Check if the space is available before placing
                if (getBlockType(col, surfaceRow - 1 - i) === 'sky') {
                    worldBlocks[key] = { type: 'cactus_block', mineProg: 0 };
                } else {
                    // Stop if we hit an obstacle
                    break; 
                }
            }
        }
        
        function generateGildedTree(col, surfaceRow) {
            const trunkBlockType = 'raw_gilded_wood';
            const bushBlockType = 'gilded_tree_bush';
            const minTrunkHeight = 7;
            const maxTrunkHeight = 11;
            const canopyRadius = 4;

            const trunkHeight = minTrunkHeight + Math.floor(random() * (maxTrunkHeight - minTrunkHeight + 1));

            // Build trunk
            for (let i = 0; i < trunkHeight; i++) {
                const row = surfaceRow - 1 - i;
                const key = `${col},${row}`;
                if (getBlockType(col, row) === 'sky') {
                    worldBlocks[key] = { type: trunkBlockType, mineProg: 0 };
                } else {
                    break;
                }
            }

            const topOfTrunkRow = surfaceRow - trunkHeight;

            // Build bushy top
            for (let dy = -canopyRadius; dy <= canopyRadius; dy++) {
                for (let dx = -canopyRadius; dx <= canopyRadius; dx++) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= canopyRadius && random() < 0.9) {
                        const leafCol = col + dx;
                        const leafRow = topOfTrunkRow + dy;
                        const key = `${leafCol},${leafRow}`;
                        if (getBlockType(leafCol, leafRow) === 'sky') {
                            worldBlocks[key] = { type: bushBlockType, mineProg: 0 };
                        }
                    }
                }
            }
        }
		
		function generateMeatTree(col, surfaceRow) {
            const trunkBlockType = 'meat_wood';
            const bushBlockType = 'meat_block';
            const minTrunkHeight = 25;
            const maxTrunkHeight = 30;
            const canopyRadius = 4;

            const trunkHeight = minTrunkHeight + Math.floor(random() * (maxTrunkHeight - minTrunkHeight + 1));

            // Build trunk
            for (let i = 0; i < trunkHeight; i++) {
                const row = surfaceRow - 1 - i;
                const key = `${col},${row}`;
                if (getBlockType(col, row) === 'sky') {
                    worldBlocks[key] = { type: trunkBlockType, mineProg: 0 };
                } else {
                    break;
                }
            }

            const topOfTrunkRow = surfaceRow - trunkHeight;

            // Build bushy top
            for (let dy = -canopyRadius; dy <= canopyRadius; dy++) {
                for (let dx = -canopyRadius; dx <= canopyRadius; dx++) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= canopyRadius && random() < 0.9) {
                        const leafCol = col + dx;
                        const leafRow = topOfTrunkRow + dy;
                        const key = `${leafCol},${leafRow}`;
                        if (getBlockType(leafCol, leafRow) === 'sky') {
                            worldBlocks[key] = { type: bushBlockType, mineProg: 0 };
                        }
                    }
                }
            }
        }
		
		function generateSpoiledMeatTree(col, surfaceRow) {
            const trunkBlockType = 'spoiled_meat_wood';
            const bushBlockType = 'spoiled_meat_block';
            const minTrunkHeight = 20;
            const maxTrunkHeight = 25;
            const canopyRadius = 4;

            const trunkHeight = minTrunkHeight + Math.floor(random() * (maxTrunkHeight - minTrunkHeight + 1));

            // Build trunk
            for (let i = 0; i < trunkHeight; i++) {
                const row = surfaceRow - 1 - i;
                const key = `${col},${row}`;
                if (getBlockType(col, row) === 'sky') {
                    worldBlocks[key] = { type: trunkBlockType, mineProg: 0 };
                } else {
                    break;
                }
            }

            const topOfTrunkRow = surfaceRow - trunkHeight;

            // Build bushy top
            for (let dy = -canopyRadius; dy <= canopyRadius; dy++) {
                for (let dx = -canopyRadius; dx <= canopyRadius; dx++) {
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= canopyRadius && random() < 0.9) {
                        const leafCol = col + dx;
                        const leafRow = topOfTrunkRow + dy;
                        const key = `${leafCol},${leafRow}`;
                        if (getBlockType(leafCol, leafRow) === 'sky') {
                            worldBlocks[key] = { type: bushBlockType, mineProg: 0 };
                        }
                    }
                }
            }
        }

        function generateTree(col, surfaceRow, treeType) {
            let trunkBlockType, bushBlockType, minTrunkHeight, maxTrunkHeight, trunkHeight, minCanopyRadius, maxCanopyRadius, horizontalSpreadFactorMin, horizontalSpreadFactorMax;

            if (treeType === 'oak') {
                trunkBlockType = 'raw_oak'; bushBlockType = 'oak_bush'; minTrunkHeight = 6; maxTrunkHeight = 10;
                minCanopyRadius = 3; maxCanopyRadius = 4; horizontalSpreadFactorMin = 0.5; horizontalSpreadFactorMax = 1.5;
            } else if (treeType === 'birch') {
                trunkBlockType = 'raw_birch'; bushBlockType = 'birch_bush'; minTrunkHeight = 4; maxTrunkHeight = 8;
                minCanopyRadius = 2; maxCanopyRadius = 3; horizontalSpreadFactorMin = 0.7; horizontalSpreadFactorMax = 0.9;
            } else if (treeType === 'spruce') {
                trunkBlockType = 'raw_spruce'; bushBlockType = 'spruce_bush'; minTrunkHeight = 8; maxTrunkHeight = 12;
                const canopyBaseWidth = 5; minCanopyRadius = 1; maxCanopyRadius = 2.5;
            } else if (treeType === 'darkwood') { // NEW: Darkwood tree generation
                trunkBlockType = 'raw_darkwood'; bushBlockType = 'darkwood_bush'; minTrunkHeight = 9; maxTrunkHeight = 15;
                minCanopyRadius = 4; maxCanopyRadius = 6; horizontalSpreadFactorMin = 0.8; horizontalSpreadFactorMax = 1.2;
            } else { return; }
            
            trunkHeight = minTrunkHeight + Math.floor(random() * (maxTrunkHeight - minTrunkHeight + 1));
            const trunkBaseWidth = (random() < 0.4 && (treeType === 'oak' || treeType === 'darkwood')) ? 2 : 1;

            for (let i = 0; i < trunkHeight; i++) {
                const currentTrunkWidth = (i < 2 && trunkBaseWidth === 2) ? 2 : 1; // Wider base for darkwood/oak
                for (let w = 0; w < currentTrunkWidth; w++) {
                    const trunkCol = col - Math.floor((currentTrunkWidth - 1) / 2) + w;
                    const key = `${trunkCol},${surfaceRow - 1 - i}`;
                    const biome = getBiome(trunkCol);
                    const validBaseBlock = biome === 'overgrown_forest' ? 'dark_moss_dirt' : (biome === 'forest' ? 'grass_dirt_block' : 'grass_soil');
                    if (getBlockType(trunkCol, surfaceRow - 1 - i) === 'sky' || (i === 0 && getBlockType(trunkCol, surfaceRow) === validBaseBlock)) {
                        worldBlocks[key] = { type: trunkBlockType, mineProg: 0 };
                    }
                }
            }


            const topOfTrunkRow = surfaceRow - trunkHeight;

            if (treeType === 'oak' || treeType === 'birch' || treeType === 'darkwood') {
                const canopyRadius = minCanopyRadius + Math.floor(random() * (maxCanopyRadius - minCanopyRadius + 1));
                for (let yOffset = 0; yOffset <= canopyRadius + 2; yOffset++) {
                    let currentLayerRadius = Math.max(0, canopyRadius - Math.floor(yOffset / 1.5));
                    const horizontalSpread = horizontalSpreadFactorMin + random() * (horizontalSpreadFactorMax - horizontalSpreadFactorMin);
                    const effectiveRadius = currentLayerRadius * horizontalSpread;
                    for (let x = -Math.ceil(effectiveRadius); x <= Math.ceil(effectiveRadius); x++) {
                        if (random() < 0.85) {
                            const leafCol = col + Math.round(x);
                            const leafRow = topOfTrunkRow - yOffset;
                            const key = `${leafCol},${leafRow}`;
                            if (getBlockType(leafCol, leafRow) === 'sky' && (!worldBlocks[key] || worldBlocks[key].type !== trunkBlockType)) {
                                worldBlocks[key] = { type: bushBlockType, mineProg: 0 };
                            }
                        }
                    }
                }
                if (treeType === 'oak' || treeType === 'darkwood') { // Branches for oak and darkwood
                    const branchCount = Math.floor(random() * (treeType === 'darkwood' ? 5 : 3));
                    for(let i = 0; i < branchCount; i++) {
                        const branchY = topOfTrunkRow + 1 - Math.floor(random() * 4);
                        const branchDir = random() < 0.5 ? -1 : 1;
                        const branchLength = 1 + Math.floor(random() * (treeType === 'darkwood' ? 4 : 2));
                        for(let l = 1; l <= branchLength; l++) {
                            const branchCol = col + (l * branchDir);
                            const branchKey = `${branchCol},${branchY}`;
                            if(getBlockType(branchCol, branchY) === 'sky') {
                                 worldBlocks[branchKey] = { type: trunkBlockType, mineProg: 0 };
                            }
                        }
                        const leafClusterRadius = 1 + Math.floor(random() * 1.5);
                        for (let lx = -leafClusterRadius; lx <= leafClusterRadius; lx++) {
                            for (let ly = -leafClusterRadius; ly <= leafClusterRadius; ly++) {
                                const leafCol = col + (branchLength * branchDir) + lx;
                                if (lx*lx + ly*ly <= leafClusterRadius*leafClusterRadius && random() < 0.9) {
                                    const leafKey = `${leafCol},${branchY - 1 + ly}`;
                                    if(getBlockType(leafCol, branchY - 1 + ly) === 'sky' && (!worldBlocks[leafKey] || worldBlocks[leafKey].type !== trunkBlockType)) {
                                        worldBlocks[leafKey] = { type: bushBlockType, mineProg: 0 };
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (treeType === 'spruce') {
                const canopyBottomRow = topOfTrunkRow + Math.floor(trunkHeight * 0.3);
                for (let r = canopyBottomRow; r >= topOfTrunkRow - 3; r--) {
                    let currentCanopyRadius = Math.max(0, Math.floor(maxCanopyRadius - (canopyBottomRow - r) / 1.5));
                    for (let x = -currentCanopyRadius; x <= currentCanopyRadius; x++) {
                        const leafCol = col + x;
                        const key = `${leafCol},${r}`;
                        if (getBlockType(leafCol, r) === 'sky' && (!worldBlocks[key] || worldBlocks[key].type !== trunkBlockType)) {
                            if (random() < 0.95) {
                                worldBlocks[key] = { type: bushBlockType, mineProg: 0 };
                            }
                        }
                    }
                }
            }
        }
		
		// --- VOID REALM ISLAND GENERATION ---

        // Generates a small, floating platform of Void Dust
        function generateDustPad(startX, startY) {
            const padSize = 30 + Math.floor(random() * 31); // 30-60 blocks
            let blocksPlaced = 0;
            const toPlace = new Set([`${startX},${startY}`]);
            const placed = new Set();

            while (blocksPlaced < padSize && toPlace.size > 0) {
                const currentKey = Array.from(toPlace)[Math.floor(random() * toPlace.size)];
                toPlace.delete(currentKey);

                if (placed.has(currentKey) || worldBlocks[currentKey]) continue;

                worldBlocks[currentKey] = { type: 'void_dust_block', mineProg: 0 };
                placed.add(currentKey);
                blocksPlaced++;

                // Add neighbors to the list of potential blocks to place
                const [x, y] = currentKey.split(',').map(Number);
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        // Use a chance to create a more blob-like, less square shape
                        if (random() < 0.6) {
                            const nextKey = `${x + dx},${y + dy}`;
                            if (!placed.has(nextKey)) {
                                toPlace.add(nextKey);
                            }
                        }
                    }
                }
            }
        }

		// VERY RARE: generate a solid void-crystal geode (circle-ish, ~20-30 blocks)
		function generateGeode(cx, cy) {
			// prefer radius 3 (area ~28) but allow 2..4 for variety
			const radius = 2 + Math.floor(random() * 3); // 2,3,4
			const bboxRadius = radius + 1;

			// check area is mostly empty (don't stomp existing content). Try a few small offsets.
			let placed = false;
			const tries = 5;
			for (let t = 0; t < tries && !placed; t++) {
				const offX = Math.floor((random() - 0.5) * 6); // shift -3..+2
				const offY = Math.floor((random() - 0.5) * 6);
				const baseX = cx + offX;
				const baseY = cy + offY;

				// quick bounding-box emptiness check
				let ok = true;
				for (let dx = -bboxRadius; dx <= bboxRadius && ok; dx++) {
					for (let dy = -bboxRadius; dy <= bboxRadius; dy++) {
						const k = `${baseX + dx},${baseY + dy}`;
						// allow sky (empty) only; if anything else exists, abort this try
						if (worldBlocks[k]) { ok = false; break; }
					}
				}
				if (!ok) continue;

				// place filled circle of void_crystal
				for (let dx = -radius; dx <= radius; dx++) {
					for (let dy = -radius; dy <= radius; dy++) {
						// circle-ish mask (soft edge)
						if (Math.hypot(dx, dy) <= radius + 0.2) {
							const px = baseX + dx;
							const py = baseY + dy;
							const k = `${px},${py}`;
							// double-check safety
							if (!worldBlocks[k]) {
								worldBlocks[k] = { type: 'void_crystal', mineProg: 0 };
							}
						}
					}
				}

				// optional: add a tiny halo of void_stone around it so it reads as a geode clump
				for (let dx = -radius-1; dx <= radius+1; dx++) {
					for (let dy = -radius-1; dy <= radius+1; dy++) {
						const dist = Math.hypot(dx, dy);
						if (dist > radius + 0.9 && dist <= radius + 1.2 && random() < 0.5) {
							const hx = baseX + dx;
							const hy = baseY + dy;
							const hk = `${hx},${hy}`;
							if (!worldBlocks[hk]) worldBlocks[hk] = { type: 'void_stone', mineProg: 0 };
						}
					}
				}

				placed = true;
			}
			// if not placed after tries, skip (keeps them rare and non-destructive)
		}

        // Generates a long, winding arch made of void_stone with ore pockets contained inside the void stone
		function generateArch(startX, startY) {
			const archLength = 300 + Math.floor(random() * 401); // 300..700
			let cx = startX;
			let cy = startY;
			let dirX = (random() < 0.5 ? 1 : -1);
			let dirY = 0;

			// configuration local to this function (tweak if you want)
			const baseThickness = 2;             // minimum radius of the arch cross-section
			const extraThicknessChance = 0.4;    // chance to expand cross-section occasionally
			const orePocketChance = 0.08;        // chance per segment to spawn an ore pocket
			const orePocketSizeMin = 3;
			const orePocketSizeMax = 8;
			const oreSpawnMultiplier = 2.5;      // ores are more likely inside arches

			// helper: choose ore type by combining your existing ore probability variables
			function pickOreType() {
				// collect weights from global vein probability variables (assumes these exist)
				const weights = [
					['copper_compacted_stone', (typeof copperVeinProbability === 'number' ? copperVeinProbability : 0)],
					['tin_compacted_stone', (typeof tinVeinProbability === 'number' ? tinVeinProbability : 0)],
					['coal_compacted_stone', (typeof deepCoalVeinProbability === 'number' ? deepCoalVeinProbability : 0)],
					['iron_compacted_stone', (typeof ironVeinProbability === 'number' ? ironVeinProbability : 0)],
					['gold_compacted_stone', (typeof goldVeinProbability === 'number' ? goldVeinProbability : 0)],
					['amethyst_compacted_stone', (typeof amethystVeinProbability === 'number' ? amethystVeinProbability : 0)],
					['ruby_compacted_stone', (typeof rubyVeinProbability === 'number' ? rubyVeinProbability : 0)],
					['sapphire_compacted_stone', (typeof sapphireVeinProbability === 'number' ? sapphireVeinProbability : 0)],
					['topaz_compacted_stone', (typeof topazVeinProbability === 'number' ? topazVeinProbability : 0)],
					['diamond_compacted_stone', (typeof diamondVeinProbability === 'number' ? diamondVeinProbability : 0)],
					['emerald_compacted_stone', (typeof emeraldVeinProbability === 'number' ? emeraldVeinProbability : 0)],
					['opal_compacted_stone', (typeof opalVeinProbability === 'number' ? opalVeinProbability : 0)]
				];

				// apply multiplier and compute total
				let total = 0;
				for (let i = 0; i < weights.length; i++) {
					weights[i][1] *= oreSpawnMultiplier;
					total += weights[i][1];
				}
				if (total <= 0) return null;

				let r = random() * total;
				for (let i = 0; i < weights.length; i++) {
					if (r < weights[i][1]) return weights[i][0];
					r -= weights[i][1];
				}
				return null;
			}

			// helper: place a small ore cluster centered at (ox,oy). Only replace blocks that are void_stone (so ores stay contained)
			function placeOreCluster(ox, oy, size, oreType) {
				let px = ox;
				let py = oy;
				for (let i = 0; i < size; i++) {
					const key = `${px},${py}`;
					// place only if there's a void_stone here OR we just placed void stone earlier
					if (worldBlocks[key] && worldBlocks[key].type === 'void_stone') {
						worldBlocks[key] = { type: oreType, mineProg: 0 };
						// ensure immediate neighbors are void_stone to 'encase' the ore (if empty)
						const neighbors = [[1,0],[-1,0],[0,1],[0,-1]];
						for (const n of neighbors) {
							const nk = `${px + n[0]},${py + n[1]}`;
							if (!worldBlocks[nk]) worldBlocks[nk] = { type: 'void_stone', mineProg: 0 };
							else if (worldBlocks[nk].type !== 'void_stone' && worldBlocks[nk].type.indexOf('compacted_stone') === -1) {
								// if neighbor is something odd, prefer preserving it (skip)
							}
						}
					}
					// random walk to next placement position
					const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
					const d = dirs[Math.floor(random() * dirs.length)];
					px += d[0]; py += d[1];
				}
			}

			for (let i = 0; i < archLength; i++) {
				// gentle random direction change to create winding paths
				if (random() < 0.06) {
					const d = Math.floor(random() * 4);
					if (d === 0) { dirX = 1; dirY = 0; }
					else if (d === 1) { dirX = -1; dirY = 0; }
					else if (d === 2) { dirX = 0; dirY = 1; }
					else { dirX = 0; dirY = -1; }
				}

				cx += dirX;
				cy += dirY;

				// occasionally make the arch thicker
				let thickness = baseThickness;
				if (random() < extraThicknessChance) thickness += 1 + Math.floor(random() * 2); // +1..+2

				// place a rounded cross-section (circle-ish)
				for (let dx = -thickness; dx <= thickness; dx++) {
					for (let dy = -thickness; dy <= thickness; dy++) {
						// circular mask
						if (Math.hypot(dx, dy) > thickness + 0.2) continue;
						const bx = cx + dx;
						const by = cy + dy;
						const key = `${bx},${by}`;

						// only write into empty space (don't stomp existing important world blocks)
						if (!worldBlocks[key]) {
							worldBlocks[key] = { type: 'void_stone', mineProg: 0 };
						}
					}
				}

				// small chance to create an internal ore pocket inside this arch segment
				if (random() < orePocketChance) {
					const oreType = pickOreType();
					if (oreType) {
						const pocketSize = orePocketSizeMin + Math.floor(random() * (orePocketSizeMax - orePocketSizeMin + 1));
						// pick a center inside the current cross-section (bias toward the core)
						const offX = Math.floor((random() - 0.5) * (thickness - 0.5) * 2);
						const offY = Math.floor((random() - 0.5) * (thickness - 0.5) * 2);
						const ox = cx + offX;
						const oy = cy + offY;
						placeOreCluster(ox, oy, pocketSize, oreType);
					}
				}

				// slight drift up/down so arches aren't perfectly straight
				if (random() < 0.04) cy += (random() < 0.5 ? -1 : 1);
			}
		}

        // Determines the biome for a given column, now generates in both directions
        function getBiome(col) {
            if (worldBiomes[col]) {
                return worldBiomes[col].type;
            }

            // Function to determine the next biome type
            function selectNextBiome() {
                const biomeRoll = random();
                // Anthill ~4%, Overgrown Forest ~10%, Forest ~40%, Desert ~26%, Rocky ~20%
                if (biomeRoll < 0.04) return 'anthill';
                if (biomeRoll < 0.14) return 'overgrown_forest';
                if (biomeRoll < 0.54) return 'forest';
                if (biomeRoll < 0.80) return 'desert';
                return 'rocky';
            }

            // Generate to the right (positive columns)
            if (col > lastBiomeEndCol) {
                const biomeType = selectNextBiome();
                const biomeWidth = 40 + Math.floor(random() * 21); // 40-60 blocks wide
                const biomeStartCol = lastBiomeEndCol + 1;
                const biomeEndCol = biomeStartCol + biomeWidth - 1;

                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    worldBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                lastBiomeEndCol = biomeEndCol;
            } 
            // Generate to the left (negative columns)
            else if (col < firstBiomeStartCol) {
                const biomeType = selectNextBiome();
                const biomeWidth = 40 + Math.floor(random() * 21); // 40-60 blocks wide
                const biomeEndCol = firstBiomeStartCol - 1;
                const biomeStartCol = biomeEndCol - biomeWidth + 1;

                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    worldBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                firstBiomeStartCol = biomeStartCol;
            }
            
            return worldBiomes[col] ? worldBiomes[col].type : 'forest'; // Fallback
        }
        
        function getUnderworldBiome(col) {
            if (underworldBiomes[col]) {
                return underworldBiomes[col].type;
            }

            function selectNextUnderworldBiome() {
				return random() < 0.6 ? 'hell' : (random() < 0.75 ? 'meat_world' : 'golden_city');
			}

            if (col > lastUnderworldBiomeEndCol) {
                const biomeType = selectNextUnderworldBiome();
                const biomeWidth = 50 + Math.floor(random() * 31); // 50-80 blocks wide
                const biomeStartCol = lastUnderworldBiomeEndCol + 1;
                const biomeEndCol = biomeStartCol + biomeWidth - 1;
                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    underworldBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                lastUnderworldBiomeEndCol = biomeEndCol;
            } else if (col < firstUnderworldBiomeStartCol) {
                const biomeType = selectNextUnderworldBiome();
                const biomeWidth = 50 + Math.floor(random() * 31);
                const biomeEndCol = firstUnderworldBiomeStartCol - 1;
                const biomeStartCol = biomeEndCol - biomeWidth + 1;
                for (let i = biomeStartCol; i <= biomeEndCol; i++) {
                    underworldBiomes[i] = { type: biomeType, start: biomeStartCol, end: biomeEndCol };
                }
                firstUnderworldBiomeStartCol = biomeStartCol;
            }
            
            return underworldBiomes[col] ? underworldBiomes[col].type : 'hell'; // Fallback
        }

        function getBlockData(col, row) {
            const key = `${col},${row}`;
            if (worldBlocks[key] !== undefined) {
                return worldBlocks[key];
            }

            // NEW: Heaven generation
            const heavenStartHeight = -145;
            if (row < heavenStartHeight + 25) { // Check if in the heaven layer y-range
                let heavenSurfaceHeight;
                if (heavenColumnSurfaceHeights[col] !== undefined) {
                    heavenSurfaceHeight = heavenColumnSurfaceHeights[col];
                } else {
                    let prevSurface = 0;
                     if (heavenColumnSurfaceHeights[col - 1] !== undefined) {
                        prevSurface = heavenColumnSurfaceHeights[col - 1];
                    } else if (heavenColumnSurfaceHeights[col + 1] !== undefined) {
                        prevSurface = heavenColumnSurfaceHeights[col + 1];
                    }
                    const offset = Math.floor(random() * 5) - 2; // -2 to 2
                    let potentialHeight = prevSurface + offset;
                    heavenSurfaceHeight = Math.max(0, Math.min(20, potentialHeight)); // Clamp between 0 and 20
                    heavenColumnSurfaceHeights[col] = heavenSurfaceHeight;
                }
                
                const heavenBaseY = heavenStartHeight - heavenSurfaceHeight;

                if (row >= heavenBaseY) {
                    // Check for houses
                    const houseChunk = Math.floor(col / 50);
                    const housePos = houseChunk * 50 + 25;
                    const houseWidth = 10;
                    const houseHeight = 6;
                    if (col >= housePos && col < housePos + houseWidth && row < heavenBaseY + houseHeight && row >= heavenBaseY) {
                         const houseX = col - housePos;
                         const houseY = row - heavenBaseY;
                         if (houseX === 0 || houseX === houseWidth - 1 || houseY === 0) {
                             return (worldBlocks[key] = { type: 'heaven_brick_block', mineProg: 0 });
                         } else {
                              return (worldBlocks[key] = { type: 'sky', mineProg: 0 });
                         }
                    }
                    return (worldBlocks[key] = { type: 'cloud_block', mineProg: 0 });
                }
            }


            const biome = getBiome(col);

            let surfaceHeight;
            if (columnSurfaceHeights[col] !== undefined) {
                surfaceHeight = columnSurfaceHeights[col];
            } else {
                let prevSurface = baseSurfaceLevel + Math.floor(surfaceLevelRange / 2);
                if (columnSurfaceHeights[col - 1] !== undefined) {
                    prevSurface = columnSurfaceHeights[col - 1];
                } else if (columnSurfaceHeights[col + 1] !== undefined) {
                     prevSurface = columnSurfaceHeights[col + 1];
                }
                const offset = Math.floor(random() * 3) - 1;
                let potentialHeight = prevSurface + offset;
                surfaceHeight = Math.max(baseSurfaceLevel + minSurfaceVariation, Math.min(baseSurfaceLevel + maxSurfaceVariation, potentialHeight));
                columnSurfaceHeights[col] = surfaceHeight;

                // Sky Island Check
                if (random() < skyIslandProbability && !skyIslandColumns.has(col)) {
                    const islandCenterY = surfaceHeight - 60 - Math.floor(random() * 20);
                    generateSkyIsland(col, islandCenterY);
                }
                // Watchtower Check
                if (random() < watchtowerProbability && !watchtowerColumns.has(col)) {
                    generateWatchtower(col, surfaceHeight);
                }
            }

            let blockType;
            const depth = row - surfaceHeight;

            if (depth < 0) {
                blockType = 'sky';
            } else {
                // Determine base terrain by biome
                if (biome === 'forest') {
                    const isSoilPatch = random() < 0.05; // 5% chance for a soil patch
                    if (depth === 0) blockType = isSoilPatch ? 'grass_soil' : 'grass_dirt_block';
                    else if (depth >= 1 && depth <= 9) blockType = isSoilPatch ? 'soil' : 'dirt';
                } else if (biome === 'rocky') {
                    if (depth >= 0 && depth <= 9) blockType = (random() < 0.03) ? 'packed_ice_block' : 'rock_block';
                } else if (biome === 'desert') {
                    if (depth >= 0 && depth <= 9) blockType = 'sand_block';
                } else if (biome === 'anthill') {
                    if (depth >= 0 && depth <= 9) { // Top layer of anthill
                        const blockRoll = random();
                        if (blockRoll < 0.88) blockType = 'anthill_sand_block';       
                        else if (blockRoll < 0.92) blockType = 'sky';                 
                        else if (blockRoll < 0.96) blockType = 'sand_block';          
                        else if (blockRoll < 0.999) blockType = 'sandstone_block';    
                        else blockType = 'colony_heart_sand_block';                   
                    }
                    if (blockType === 'anthill_sand_block' && random() < antLarvaVeinProbability) {
                        generateVein(col, row, 'ant_larva_block', 6, 8, 'anthill_sand_block');
                        blockType = 'ant_larva_block';
                    }
                } else if (biome === 'overgrown_forest') { // NEW: Overgrown Forest terrain
                    if (depth === 0) blockType = random() < 0.3 ? 'weed_dirt_block' : 'dark_moss_dirt';
                    else if (depth >= 1 && depth <= 9) {
                        const subRoll = random();
                        if (subRoll < 0.6) blockType = 'dirt';
                        else if (subRoll < 0.8) blockType = 'mud_block';
                        else if (subRoll < 0.95) blockType = 'pest_dirt_block';
                        else blockType = 'raw_darkwood';
                    }
                }

                // Deeper layers are consistent across biomes
				if (!blockType) {
					if (depth >= 10 && depth <= 19) {
						blockType = 'stone';
					} else if (depth === 20) {
						blockType = 'compacting_stone';
					} else if (depth >= 21 && depth <= 199) {
						blockType = 'compacted_stone';
					} else if (depth >= 200 && depth <= 205) {
						blockType = 'compressed_stone';
					} else if (depth >= 206 && depth <= 299) {
						blockType = 'sky';
					}
					// existing underworld from 300 up to the void entrance (keep your existing getUnderworldBiome logic)
					else if (depth >= 300 && depth < 600) {
						const underworldBiome = getUnderworldBiome(col);
						if (underworldBiome === 'golden_city' && depth < 315) {
							if (depth === 300) blockType = 'gilded_grass_dirt_block_block';
							else blockType = 'gilded_dirt_block';
						} else if (underworldBiome === 'meat_world' && depth < 315) {
							if (depth === 300) {
								const b = random();
								if (b < 0.6) blockType = 'meat_block';
								else if (b < 0.95) blockType = 'spoiled_meat_block';
								else blockType = 'flesh_block';
							} else {
								const b = random();
								if (b < 0.7) blockType = 'meat_block';
								else if (b < 0.95) blockType = 'spoiled_meat_block';
								else blockType = 'flesh_block';
							}
						} else {
							blockType = 'hellstone';
						}
					}
					// VOID REALM (minimal inline values): depth 600..899
					else if (depth >= 600 && depth < 900) {
						// entrance wall: 13 blocks wide, 5 blocks tall, centered on player column if available else column 0
						const entranceCenter = (typeof player !== 'undefined' && player && typeof tileSize !== 'undefined')
							? Math.floor(player.x / tileSize)
							: 0;
						const entranceLeft = entranceCenter - Math.floor(13 / 2);
						const entranceRight = entranceCenter + Math.floor(13 / 2);

						// if row is within the 5-block tall entrance and this column lies within the entrance width -> bedrock
						if (depth >= 600 && depth < 600 + 5) {
							blockType = 'bedrock_stone';
						} else {
							// default: sky (void)
							blockType = 'sky';

							// run generation once per column (small chance to spawn dust pad or arch)
							if (!voidRealmColumns.has(col)) {
								voidRealmColumns.add(col);

								const spawnY = surfaceHeight + 600 + 10 + Math.floor(random() * (900 - 600 - 20)); // avoid edges

								// existing: inside if (!voidRealmColumns.has(col)) { voidRealmColumns.add(col); const spawnY = ...; const r = random(); ... }
								const r = random();

								// VERY RARE geode: ~0.5% chance per new column (tweak lower/higher if you want)
								if (r < 0.12) {
									generateGeode(col, spawnY);
								}
								else if (r < 0.2) {
									generateArch(col, spawnY);
								}
								else if (r < 0.8) {
									generateDustPad(col, spawnY);
								}
								else {
									if (random() < 0.02) {
										generateDustPad(col + (random() < 0.5 ? -1 : 1), spawnY + (Math.floor(random() * 5) - 2));
									}
								}
							}
						}
					}
					// below void: infinite compacted stone
					else if (depth >= 900) {
						blockType = 'compacted_stone';
					}
				}

                // Specific replacements
                if (biome === 'desert' && blockType === 'sand_block' && random() < 0.2) {
                    blockType = 'sandstone_block';
                }
                if (biome === 'overgrown_forest' && blockType === 'stone' && random() < 0.15) {
                    blockType = random() < 0.6 ? 'pest_stone_block_weak' : 'pest_stone_block_strong';
                }
            }
            
            // Gravel Veins in Stone Layer
            if (blockType === 'stone' && random() < gravelVeinProbability) {
                 blockType = 'gravel_block';
            }

            // Cave, Mineshaft, and Dungeon Generation
            if (blockType === 'compacted_stone') {
                if (random() < dungeonProbability) {
                    generateDungeon(col, row);
                    blockType = worldBlocks[key] ? worldBlocks[key].type : getBlockType(col, row);
                } else if (random() < mineshaftProbability) {
                    generateMineshaft(col, row);
                    blockType = worldBlocks[key] ? worldBlocks[key].type : getBlockType(col, row);
                } else if (random() < caveProbability) {
                    generateCave(col, row);
                    blockType = worldBlocks[key] ? worldBlocks[key].type : 'sky';
                }
            }
            
            // Check if this block is adjacent to a cave for boosted ore rates
            let isNearCave = false;
            if (row > baseSurfaceLevel + 25) { // Only check deep underground
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        if (caveBlocks.has(`${col + dx},${row + dy}`)) {
                            isNearCave = true;
                            break;
                        }
                    }
                    if (isNearCave) break;
                }
            }
            const oreSpawnMultiplier = isNearCave ? 2 : 1;


            // Ore generation logic
            if (blockType === 'stone' && random() < coalVeinProbability * oreSpawnMultiplier) {
                blockType = 'coal_stone';
            }
            
            // Stone Veins in Compacted Stone
            if (blockType === 'compacted_stone') {
                const veinRoll = random();
                if (veinRoll < graniteVeinProbability) {
                    generateVein(col, row, 'granite_block', 4, 6, 'compacted_stone');
                    blockType = 'granite_block';
                } else if (veinRoll < graniteVeinProbability + schistVeinProbability) {
                    generateVein(col, row, 'schist_block', 4, 6, 'compacted_stone');
                    blockType = 'schist_block';
                } else if (veinRoll < graniteVeinProbability + schistVeinProbability + slateVeinProbability) {
                    generateVein(col, row, 'slate_block', 4, 6, 'compacted_stone');
                    blockType = 'slate_block';
                }
            }


            if (blockType === 'compacted_stone') {
                // Layer 1: Compacted Coal, Copper, Tin
                if (depth >= 21) { 
                    if (random() < copperVeinProbability * oreSpawnMultiplier) blockType = 'copper_compacted_stone';
                    else if (random() < tinVeinProbability * oreSpawnMultiplier) blockType = 'tin_compacted_stone';
					else if (random() < deepCoalVeinProbability * oreSpawnMultiplier) blockType = 'coal_compacted_stone';
                } 
                // Layer 2: Iron
                if (depth >= 35) { 
                    if (random() < ironVeinProbability * oreSpawnMultiplier) blockType = 'iron_compacted_stone';
                } 
                // Layer 3: Gold
                if (depth >= 45) { 
                    if (random() < goldVeinProbability * oreSpawnMultiplier) blockType = 'gold_compacted_stone';
                } 
                // Layer 4: Ruby, Sapphire, Topaz, Amethyst
                if (depth >= 60) { 
                    if (random() < amethystVeinProbability * oreSpawnMultiplier) blockType = 'amethyst_compacted_stone';
                    else if (random() < rubyVeinProbability * oreSpawnMultiplier) blockType = 'ruby_compacted_stone';
                    else if (random() < sapphireVeinProbability * oreSpawnMultiplier) blockType = 'sapphire_compacted_stone';
                    else if (random() < topazVeinProbability * oreSpawnMultiplier) blockType = 'topaz_compacted_stone';
                }
                // Layer 5: Diamond, Emerald
                if (depth >= 60) {
                     if (random() < diamondVeinProbability * oreSpawnMultiplier) blockType = 'diamond_compacted_stone';
                     else if (random() < emeraldVeinProbability * oreSpawnMultiplier) blockType = 'emerald_compacted_stone';
                }
                // Layer 6: Opal
                if (depth >= 65) {
                    if (random() < opalVeinProbability * oreSpawnMultiplier) blockType = 'opal_compacted_stone';
                }
            }
			
			if (blockType === 'hellstone') {
                if (random() < hellsteelVeinProbability * oreSpawnMultiplier) {
                    blockType = 'hellsteel_hellstone';
                } else if (random() < obsidianVeinProbability) {
                    generateVein(col, row, 'obsidian_block', 3, 5, 'hellstone');
                    blockType = 'obsidian_block';
                } else if (random() < boneSpineProbability) {
                    generateSpinalVein(col, row, 'bone_block', 20, 30);
                    blockType = 'bone_block';
                }
            }

            // Surface cover / foliage generation
            if (depth === 0) { // Only check for surface blocks
                if (biome === 'forest') {
                    if (getBlockType(col, row - 1) === 'sky') {
                        if (random() < tallGrassProbability) worldBlocks[`${col},${row - 1}`] = { type: 'tall_grass', mineProg: 0 };
                        else if (random() < grassProbability) worldBlocks[`${col},${row - 1}`] = { type: 'grass', mineProg: 0 };
                    }
                    if (random() < treeProbability && getBlockType(col, row - 1) === 'sky') {
                        generateTree(col, row, random() < 0.33 ? 'oak' : (random() < 0.66 ? 'birch' : 'spruce'));
                    }
                } else if (biome === 'overgrown_forest') { 
                    if (getBlockType(col, row - 1) === 'sky') {
                        const foliageRoll = random();
                        if (foliageRoll < 0.1) worldBlocks[`${col},${row - 1}`] = { type: 'grass', mineProg: 0 };
                        else if (foliageRoll < 0.2) worldBlocks[`${col},${row - 1}`] = { type: 'weed', mineProg: 0 };
                        else if (foliageRoll < 0.3) worldBlocks[`${col},${row - 1}`] = { type: 'shroom', mineProg: 0 };
                        else if (foliageRoll < 0.5) worldBlocks[`${col},${row - 1}`] = { type: 'dark_moss', mineProg: 0 };
                        else if (foliageRoll < 0.7) worldBlocks[`${col},${row - 1}`] = { type: 'moss', mineProg: 0 };
                    }
                    if (random() < treeProbability * 2 && getBlockType(col, row - 1) === 'sky') { // Higher tree chance
                        generateTree(col, row, 'darkwood');
                    }
                } else if (biome === 'rocky') {
                    if (getBlockType(col, row - 1) === 'sky') {
                        if (random() < 0.2) worldBlocks[`${col},${row - 1}`] = { type: 'large_snow_pile', mineProg: 0 };
                        else worldBlocks[`${col},${row - 1}`] = { type: 'snow', mineProg: 0 };
                    }
                } else if (biome === 'desert') {
                    if (blockType === 'sand_block' && getBlockType(col, row - 1) === 'sky') {
                        const foliageRoll = random();
                        if (foliageRoll < cactusProbability) generateCactus(col, row);
                        else if (foliageRoll < 0.20) worldBlocks[`${col},${row - 1}`] = { type: 'prickly_pear_cactus', mineProg: 0 };
                        else if (foliageRoll < 0.40) worldBlocks[`${col},${row - 1}`] = { type: 'desert_brush', mineProg: 0 };
                    }
                } else if (biome === 'anthill') {
                     if (blockType === 'anthill_sand_block' && getBlockType(col, row - 1) === 'sky' && random() < anthillMoundProbability) {
                        worldBlocks[`${col},${row - 1}`] = { type: 'anthill_sand_mound', mineProg: 0 };
                    }
                }
            }
            // Underworld foliage
			if (blockType === 'hellstone' && depth === 300 && random() < 0.05) {
				generateHellWoodTree(col, row);
			}
            if (blockType === 'gilded_grass_dirt_block_block' && depth === 300 && random() < 0.2) {
                generateGildedTree(col, row);
            }
			if (blockType === 'meat_block' && depth === 300 && random() < 0.2) {
                generateMeatTree(col, row);
            }
			if (blockType === 'meat_block' && depth === 300 && random() < 0.2) {
                generateSpoiledMeatTree(col, row);
            }


            const newBlockData = { type: blockType, mineProg: 0 };
            worldBlocks[key] = newBlockData;
            return newBlockData;
        }
        
        // Generic Vein generator
        function generateVein(startX, startY, veinBlockType, minSize, maxSize, replaceBlock) {
            const veinSize = minSize + Math.floor(random() * (maxSize - minSize + 1));
            for (let i = 0; i < veinSize; i++) {
                const vCol = startX + Math.floor(random() * 3) - 1;
                const vRow = startY + Math.floor(random() * 3) - 1;
                const vKey = `${vCol},${vRow}`;
                const existingBlock = getBlockType(vCol, vRow);
                if (existingBlock === replaceBlock) {
                     worldBlocks[vKey] = { type: veinBlockType, mineProg: 0 };
                }
            }
        }

        // Spinal Vein Generator
        function generateSpinalVein(startX, startY, veinBlockType, minLength, maxLength) {
            const length = minLength + Math.floor(random() * (maxLength - minLength + 1));
            let currentX = startX;
            let currentY = startY;
            let directionX = random() < 0.5 ? 1 : -1;

            for (let i = 0; i < length; i++) {
                // Main spine
                worldBlocks[`${currentX},${currentY}`] = { type: veinBlockType, mineProg: 0 };

                // Ribs
                if (i % 2 === 0) {
                    worldBlocks[`${currentX},${currentY - 1}`] = { type: veinBlockType, mineProg: 0 };
                    worldBlocks[`${currentX},${currentY + 1}`] = { type: veinBlockType, mineProg: 0 };
                    if (random() < 0.5) {
                         worldBlocks[`${currentX},${currentY - 2}`] = { type: veinBlockType, mineProg: 0 };
                         worldBlocks[`${currentX},${currentY + 2}`] = { type: veinBlockType, mineProg: 0 };
                    }
                }

                // Change direction occasionally
                if (random() < 0.2) directionX *= -1;
                if (random() < 0.4) currentY += (random() < 0.5 ? 1 : -1);
                
                currentX += directionX;
            }
        }


        // --- CAVE GENERATION ---
        function generateCave(startX, startY) {
            console.log("Cave Generated");
			const caveSize = 100 + Math.floor(random() * 101); // 100-200 blocks
            let blocksCarved = 0;
            const toCarve = new Set([`${startX},${startY}`]);
            const carved = new Set();

            while (blocksCarved < caveSize && toCarve.size > 0) {
                // Get a random block from the list of blocks to be carved
                const currentKey = Array.from(toCarve)[Math.floor(random() * toCarve.size)];
                toCarve.delete(currentKey);

                if (carved.has(currentKey)) continue;

                const [x, y] = currentKey.split(',').map(Number);

                // Carve out the block and its immediate neighbors to make tunnels wider
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const carveX = x + dx;
                        const carveY = y + dy;
                        const key = `${carveX},${carveY}`;
                        
                        // Don't carve too close to the surface
                        if (carveY < baseSurfaceLevel + 25) continue; 

                        // Replace the original block with a vine stone block
                        const originalBlock = getBlockType(carveX, carveY);
                        if(originalBlock !== 'sky') {
                            worldBlocks[key] = { type: 'vine_stone_block', mineProg: 0 };
                        }

                        // Carve out the center block into air
                        if (dx === 0 && dy === 0) {
                             worldBlocks[key] = { type: 'sky', mineProg: 0 };
                             caveBlocks.add(key); // Add to the set for ore checking
                             carved.add(key);
                             blocksCarved++;
                        }
                    }
                }

                // Add new potential carving paths
                for (let i = 0; i < 4; i++) { // Add more branching
                    if (random() < 0.6) { // Chance to branch off
                        const direction = Math.floor(random() * 4);
                        let nextX = x, nextY = y;
                        if (direction === 0) nextX++;
                        else if (direction === 1) nextX--;
                        else if (direction === 2) nextY++;
                        else nextY--;
                        
                        const nextKey = `${nextX},${nextY}`;
                        if (!carved.has(nextKey)) {
                            toCarve.add(nextKey);
                        }
                    }
                }
            }
        }
        
        // --- MINESHAFT GENERATION (REVISED) ---
        function generateMineshaft(startX, startY) {
            console.log("Mineshaft Generated");
			const width = 20 + Math.floor(random() * 31); // 20-50 blocks wide
            const height = 4; // Always 4 blocks tall air space

            for (let x = startX; x < startX + width; x++) {
                for (let y = startY; y < startY + height + 2; y++) { // +2 for floor and ceiling
                    const key = `${x},${y}`;
                    // Floor and Ceiling
                    if (y === startY || y === startY + height + 1) {
                        worldBlocks[key] = { type: 'planked_oak', mineProg: 0 };
                    } 
                    // Walls
                    else if (x === startX || x === startX + width - 1) {
                        worldBlocks[key] = { type: 'planked_spruce', mineProg: 0 };
                    }
                    // Inside the mineshaft
                    else {
                        // 15% chance of cobweb, otherwise air
                        if (random() < 0.3) {
                            worldBlocks[key] = { type: 'cobweb', mineProg: 0 };
                        } else {
                            worldBlocks[key] = { type: 'sky', mineProg: 0 };
                        }
                    }
                }
            }

            // Add loot chest in the bottom corner
            const chestCol = startX + 1;
            const chestRow = startY + height;
            const chestKey = `${chestCol},${chestRow}`;
            
            const loot = [];
            const lootTypes = ['wooden_pickaxe', 'steel_nugget', 'asphalt_block', 'rock_pickaxe', 'wheat_bread', 'planked_hell_wood', 'rice_seeds'];
			const toolDurability = {'wooden_pickaxe': 15000, 'rock_pickaxe': 25000};
            const randomOre = lootTypes[Math.floor(random() * lootTypes.length)];
			//Add loot items to the array
			loot.push({ type: 'iron_nugget', count: 1 + Math.floor(random() * 5) });
			loot.push({ type: 'copper_nugget', count: 1 + Math.floor(random() * 5) });
			loot.push({ type: 'raw_birch', count: 1 + Math.floor(random() * 5) });
            loot.push({ type: 'rice_seeds', count: 1 + Math.floor(random() * 3) });

			// Handle randomOre logic
			if (toolDurability[randomOre]) {
				loot.push({
					type: randomOre,
					durability: toolDurability[randomOre],
					maxDurability: toolDurability[randomOre],
					count: 1
				});
			} else {
				loot.push({ type: randomOre, count: 1 + (randomOre === 'rice_seeds' ? Math.floor(random() * 3) : 0) });
			}

            // Create chest with inventory
            worldBlocks[chestKey] = { 
                type: 'chest', 
                mineProg: 0, 
                inventory: new Array(chestInventorySize).fill(null),
                label: 'Mineshaft Chest'
            };

            // Place loot into the chest inventory
            loot.forEach((item, index) => {
                if (index < chestInventorySize) {
                    worldBlocks[chestKey].inventory[index] = item;
                }
            });
        }

        // --- NEW DUNGEON GENERATION ---
        function generateDungeon(startX, startY) {
            console.log("Dungeon Generated at", startX, startY);
            const mainChamberWidth = 15 + Math.floor(random() * 10);
            const mainChamberHeight = 10 + Math.floor(random() * 6);
            
            // Carve main chamber
            for (let x = startX; x < startX + mainChamberWidth; x++) {
                for (let y = startY; y < startY + mainChamberHeight; y++) {
                    const key = `${x},${y}`;
                    // Walls and Floor
                    if (x === startX || x === startX + mainChamberWidth - 1 || y === startY || y === startY + mainChamberHeight - 1) {
                        worldBlocks[key] = { type: random() < 0.5 ? 'planked_spruce' : 'planked_darkwood', mineProg: 0 };
                    } else { // Inside
                        worldBlocks[key] = { type: 'sky', mineProg: 0 };
                        if (random() < 0.2) { // Add cobwebs inside
                             worldBlocks[`${x},${y}`] = { type: 'cobweb', mineProg: 0 };
                        }
                    }
                }
            }

            // Add 3 rooms
            const roomWidth = 5 + Math.floor(random() * 3);
            const roomHeight = 4 + Math.floor(random() * 2);
            for (let i = 0; i < 3; i++) {
                const roomStartX = startX + 2 + i * (roomWidth + 1);
                const roomStartY = startY + mainChamberHeight; // Rooms are below the main chamber

                // Check if room fits
                if (roomStartX + roomWidth >= startX + mainChamberWidth - 1) continue;

                // Carve room and separator
                for (let x = roomStartX - 1; x < roomStartX + roomWidth + 1; x++) {
                    for (let y = roomStartY - 1; y < roomStartY + roomHeight + 1; y++) {
                        const key = `${x},${y}`;
                        // Separator wall
                        if (y === roomStartY - 1) {
                            worldBlocks[key] = { type: 'vine_stone_block', mineProg: 0 };
                        } 
                        // Room walls/floor
                        else if (x === roomStartX - 1 || x === roomStartX + roomWidth || y === roomStartY + roomHeight) {
                             worldBlocks[key] = { type: random() < 0.5 ? 'planked_spruce' : 'planked_darkwood', mineProg: 0 };
                        }
                        // Inside the room
                        else {
                            worldBlocks[key] = { type: 'sky', mineProg: 0 };
                            if (random() < 0.3) { // More cobwebs in rooms
                                worldBlocks[key] = { type: 'cobweb', mineProg: 0 };
                            }
                        }
                    }
                }
                
                // Add a chest to each room
                const chestCol = roomStartX + Math.floor(roomWidth / 2);
                const chestRow = roomStartY + roomHeight - 1;
                const chestKey = `${chestCol},${chestRow}`;
                worldBlocks[chestKey] = { 
                    type: 'chest', 
                    mineProg: 0, 
                    inventory: new Array(chestInventorySize).fill(null),
                    label: 'Dungeon Chest'
                };
                // Add dungeon loot
                const loot = [];
                loot.push({ type: 'gold_nugget', count: 2 + Math.floor(random() * 6) });
                loot.push({ type: 'iron_nugget', count: 3 + Math.floor(random() * 8) });
                if (random() < 0.3) loot.push({ type: 'diamond_nugget', count: 1 + Math.floor(random() * 2) });
                if (random() < 0.5) loot.push({ type: 'corn_seeds', count: 2 + Math.floor(random() * 5) });
                if (random() < 0.2) loot.push({ type: 'iron_pickaxe', count: 1, durability: 50000, maxDurability: 50000 });
                loot.forEach((item, index) => {
                    if (index < chestInventorySize) {
                        worldBlocks[chestKey].inventory[index] = item;
                    }
                });
            }
        }

		// GENERATE Sky Island!!!
        function generateSkyIsland(centerX, centerY) {
            console.log("Sky Island Generated");
			const islandSize = 100 + Math.floor(random() * 301); // 100-400 blocks
            let blocksPlaced = 0;
            const toPlace = new Set([`${centerX},${centerY}`]);
            const placed = new Set();

            // Generate the cloud
            while (blocksPlaced < islandSize && toPlace.size > 0) {
                const currentKey = Array.from(toPlace)[Math.floor(random() * toPlace.size)];
                toPlace.delete(currentKey);
                if (placed.has(currentKey)) continue;

                const [x, y] = currentKey.split(',').map(Number);
                worldBlocks[currentKey] = { type: 'cloud_block', mineProg: 0 };
                placed.add(currentKey);
                blocksPlaced++;

                for (let i = 0; i < 4; i++) {
                    if (random() < 0.75) {
                        const direction = Math.floor(random() * 4);
                        let nextX = x, nextY = y;
                        if (direction === 0) nextX++; else if (direction === 1) nextX--;
                        else if (direction === 2) nextY++; else nextY--;
                        const nextKey = `${nextX},${nextY}`;
                        if (!placed.has(nextKey)) toPlace.add(nextKey);
                    }
                }
            }

            // Find the top surface to build the house
            let topY = centerY;
            while(placed.has(`${centerX},${topY - 1}`)) {
                topY--;
            }

            // Build a simple house
            const houseWidth = 5;
            const houseHeight = 4;
            const houseStartX = centerX - Math.floor(houseWidth / 2);
            const houseStartY = topY - houseHeight;

            for (let x = houseStartX; x < houseStartX + houseWidth; x++) {
                for (let y = houseStartY; y < houseStartY + houseHeight; y++) {
                    const key = `${x},${y}`;
                    if (x === houseStartX || x === houseStartX + houseWidth - 1 || y === houseStartY) {
                        worldBlocks[key] = { type: 'clay_brick_block', mineProg: 0 };
                    } else {
                        worldBlocks[key] = { type: 'sky', mineProg: 0 };
                    }
                }
            }
            
            // Add loot chest
            const chestCol = centerX;
            const chestRow = topY - 1;
            const chestKey = `${chestCol},${chestRow}`;
            worldBlocks[chestKey] = { 
                type: 'chest', 
                mineProg: 0, 
                inventory: new Array(chestInventorySize).fill(null),
                label: 'Sky Chest'
            };
            const loot = [];
            loot.push({ type: 'diamond_nugget', count: 3 + Math.floor(random() * 4) });
            loot.push({ type: 'coal', count: 1 + Math.floor(random() * 25) });
            loot.push({ type: 'steel_pickaxe', count: 1, durability: 150000, maxDurability: 150000 });
			loot.push({ type: 'oat_seeds', count: 1 + Math.floor(random() * 3) });
			loot.push({ type: 'beef', count: 2 + Math.floor(random() * 3) });
            loot.forEach((item, index) => {
                if (index < chestInventorySize) {
                    worldBlocks[chestKey].inventory[index] = item;
                }
            });

            skyIslandColumns.add(centerX);
        }

        // NEW: Watchtower Generation
        function generateWatchtower(startCol, surfaceRow) {
            console.log("Attempting to generate Watchtower at", startCol);
            const towerWidth = 6;
            const towerHeight = 40 + Math.floor(random() * 21); // 40-60 blocks tall

            // 1. Check for flat ground
            let minSurface = surfaceRow;
            let maxSurface = surfaceRow;
            for (let i = 1; i < towerWidth; i++) {
                const currentSurface = columnSurfaceHeights[startCol + i] || surfaceRow;
                if (currentSurface < minSurface) minSurface = currentSurface;
                if (currentSurface > maxSurface) maxSurface = currentSurface;
            }
            if (maxSurface - minSurface > 2) {
                console.log("Ground not flat enough for watchtower.");
                return; // Abort if ground is not flat enough
            }
            const baseRow = maxSurface;

            // 2. Mark columns as used
            for (let i = 0; i < towerWidth; i++) {
                watchtowerColumns.add(startCol + i);
            }

            // 3. Build foundation
            for (let c = 0; c < towerWidth; c++) {
                for (let r = 0; r < 5; r++) {
                    worldBlocks[`${startCol + c},${baseRow + r}`] = { type: 'stone', mineProg: 0 };
                }
            }

            // 4. Build the tower structure
            for (let y = 0; y < towerHeight; y++) {
                const currentRow = baseRow - 1 - y;
                for (let x = 0; x < towerWidth; x++) {
                    const currentCol = startCol + x;
                    const isWall = x === 0 || x === towerWidth - 1 || (y > 0 && (x === 1 || x === towerWidth - 2) && (y % 8 === 0)); // Add some windows

                    if (isWall) {
                        worldBlocks[`${currentCol},${currentRow}`] = { type: 'stone', mineProg: 0 };
                    } else { // Inside
                        worldBlocks[`${currentCol},${currentRow}`] = { type: 'sky', mineProg: 0 };
                    }
                }
                
                // Add floors and stairs
                if (y > 0 && y % 5 === 0) { // Floor every 5 blocks
                     for (let x = 1; x < towerWidth - 1; x++) {
                        worldBlocks[`${startCol + x},${currentRow}`] = { type: 'planked_oak', mineProg: 0 };
                    }
                }
                // Switchback stairs
                const stairY = y % 10;
                if (stairY < 5 && stairY > 0) { // Going up left side
                     worldBlocks[`${startCol + 1},${currentRow}`] = { type: 'planked_spruce', mineProg: 0 };
                } else if (stairY > 5) { // Going up right side
                     worldBlocks[`${startCol + towerWidth - 2},${currentRow}`] = { type: 'planked_spruce', mineProg: 0 };
                }
            }
            
            // 5. Build the top platform
            const topRow = baseRow - towerHeight;
            for (let x = 0; x < towerWidth; x++) {
                for (let y = 0; y < 2; y++) {
                     worldBlocks[`${startCol + x},${topRow + y}`] = { type: 'stone', mineProg: 0 };
                }
                if (x === 0 || x === towerWidth - 1) { // Crenellations
                     worldBlocks[`${startCol + x},${topRow - 1}`] = { type: 'stone', mineProg: 0 };
                }
            }
            
            // 6. Add loot chest
            const chestCol = startCol + Math.floor(towerWidth / 2);
            const chestRow = topRow - 1;
            worldBlocks[`${chestCol},${chestRow}`] = { 
                type: 'chest', 
                mineProg: 0, 
                inventory: new Array(chestInventorySize).fill(null),
                label: 'Watchtower Chest'
            };
            const loot = [];
            loot.push({ type: 'watchtower_stone_block', count: 10 + Math.floor(random() * 21) });
            loot.push({ type: 'gold_nugget', count: 2 + Math.floor(random() * 5) });
            if (random() < 0.4) loot.push({ type: 'diamond_nugget', count: 1 + Math.floor(random() * 3) });
            loot.forEach((item, index) => {
                if (index < chestInventorySize) {
                    worldBlocks[`${chestCol},${chestRow}`].inventory[index] = item;
                }
            });
        }


        function getBlockType(col, row) {
            const blockData = worldBlocks[`${col},${row}`];
            // If the block isn't modified, return sky. This prevents infinite loops.
            return blockData ? blockData.type : 'sky'; 
        }

        function isSolid(col, row) {
            const blockData = getBlockData(col, row);
            return blockTypes[blockData.type] && blockTypes[blockData.type].solid;
        }

        function worldToGrid(x, y) {
            return { col: Math.floor(x / tileSize), row: Math.floor(y / tileSize) };
        }

        function gridToWorld(col, row) {
            return { x: col * tileSize, y: row * tileSize };
        }

        function rectIntersects(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
        }

        function respawnPlayer() {
			// --- NEW: Death Chest Logic ---
			const playerHasItems = inventorySlots.some(item => item !== null);

			if (playerHasItems) {
				const deathCol = Math.floor((player.x + playerWidth / 2) / tileSize);
				const deathRow = Math.floor((player.y + playerHeight) / tileSize) - 1; // Place it at the player's feet
				const deathKey = `${deathCol},${deathRow}`;

				// Create a new inventory for the chest with 50 slots
				const deathChestInventory = new Array(50).fill(null);

				// Copy items from player's inventory to the chest's inventory
				for (let i = 0; i < inventorySlots.length; i++) {
					if (inventorySlots[i]) {
						let itemToDrop = inventorySlots[i];

						// --- ADDED: Immediate Spoilage Logic ---
						const spoilInfo = itemTypes[itemToDrop.type]?.spoilable;
						if (spoilInfo) {
							itemToDrop.type = spoilInfo.into;
							delete itemToDrop.acquiredTime;
						}
						// --- End of Immediate Spoilage Logic ---

						deathChestInventory[i] = itemToDrop;
					}
				}

				// Place the chest in the world
				worldBlocks[deathKey] = {
					type: 'dead_body_chest',
					mineProg: 0,
					inventory: deathChestInventory,
					label: 'Dead Body' // Give it a label
				};

				// Clear player's inventory
				inventorySlots.fill(null);
				hotbarIndices.fill(null);
				updateHotbar();
			}


			// Original respawn logic continues here
			player.x = 0;
			player.y = -320;
			if (player.bedSpawnPoint) {
				player.x = player.bedSpawnPoint.x;
				player.y = player.bedSpawnPoint.y;
			}
			player.health = player.maxHealth;
		}

        function updatePlayer(dt) {
            const factor = isGameActive ? dt / 1000 * 60 : 0;
            
            // Check for cobweb slowdown and more
            const playerGridPos = worldToGrid(player.x + playerWidth / 2, player.y + playerHeight / 2);
            const blockUnderPlayer = getBlockType(playerGridPos.col, playerGridPos.row);
			const blockUnderPlayerU = getBlockType(playerGridPos.col, playerGridPos.row +1);
			const blockUnderPlayerB = getBlockType(playerGridPos.col, playerGridPos.row -1);
			const feetRow = Math.floor((player.y + playerHeight) / tileSize);
			const blockBelowFeet = getBlockType(playerGridPos.col, feetRow);
			const isOnAsphalt = blockBelowFeet === 'asphalt_block';
            const isInCobweb = blockUnderPlayer === 'cobweb' || blockUnderPlayerU === 'cobweb' || blockUnderPlayerB === 'cobweb';
			
            const currentSpeed = isInCobweb ? player.speed * 0.2 : isOnAsphalt ? player.speed * 1.5 : player.speed;
            const currentJumpStrength = isInCobweb ? player.jumpStrength * 0.2 : player.jumpStrength;
            const currentGravity = isInCobweb ? player.gravity * 0.1 : player.gravity;

            player.dy += currentGravity * factor;

            if (keys['ArrowLeft']) player.dx = -currentSpeed;
            else if (keys['ArrowRight']) player.dx = currentSpeed;
            else player.dx = 0;

            // --- Fall Damage Logic ---
            if (!player.onGround && player.dy > 0) {
                // If we just started falling, record the start position
                if (player.fallStartY === 0) {
                    player.fallStartY = player.y;
                }
            }

            let nextPlayerX = player.x + player.dx * factor;
            let nextPlayerY = player.y + player.dy * factor;

            const playerRectY = { x: player.x, y: nextPlayerY, width: playerWidth, height: playerHeight };
            const startRowY = Math.floor(Math.min(player.y, nextPlayerY) / tileSize) - 2;
            const endRowY = Math.ceil(Math.max(player.y + playerHeight, nextPlayerY + playerHeight) / tileSize) + 2;
            const startColY = Math.floor(player.x / tileSize);
            const endColY = Math.floor((player.x + playerWidth - 1) / tileSize);

            let wasOnGround = player.onGround;
            player.onGround = false;
            for (let col = startColY; col <= endColY; col++) {
                for (let row = startRowY; row <= endRowY; row++) {
                    if (isSolid(col, row)) {
                        const blockRect = { x: col * tileSize, y: row * tileSize, width: tileSize, height: tileSize };
                        if (rectIntersects(playerRectY, blockRect)) {
                            if (player.dy > 0) {
                                player.y = blockRect.y - playerHeight;
                                player.dy = 0;
                                player.onGround = true;
                            } else if (player.dy < 0) {
                                player.y = blockRect.y + tileSize;
                                player.dy = 0;
                            }
                            nextPlayerY = player.y;
                        }
                    }
                }
            }
            player.y = nextPlayerY;

            // Calculate fall damage when landing
			// Check if player is inside a cobweb
			const playerBodyCol = Math.floor((player.x + playerWidth / 2) / tileSize);
			const playerBodyRow = Math.floor((player.y + playerHeight / 2) / tileSize);
			const blockAtPlayerBody = getBlockType(playerBodyCol, playerBodyRow);

			// If in a cobweb, reset fall distance continuously
			if (isInCobweb || blockAtPlayerBody === 'cobweb') {
				player.fallStartY = player.y;
			}
            if (player.onGround && !wasOnGround && player.fallStartY !== 0) {
                const fallDistance = player.y - player.fallStartY;
                const fallDistanceInBlocks = fallDistance / tileSize;
                if (fallDistanceInBlocks > (5 / player.gravity)) {
                    const damage = Math.floor(fallDistanceInBlocks - (5 / player.gravity)) * 3 * player.gravity;
                    player.health -= damage;
                    if (player.health <= 0) {
                        respawnPlayer();
						let titleCycle = ["Block Game Ultimate [HTML EDITION]", "Block Game Ultimate [STOP DYING]", "Block Game Ultimate [TRY WINNING]"];
						let i = 0;
						setInterval(() => {
							document.title = titleCycle[i % titleCycle.length];
							i++;
						}, 600);
                    }
                }
                player.fallStartY = 0; // Reset fall tracker
            } else if (!player.onGround && wasOnGround) {
                player.fallStartY = player.y; // Start tracking fall
            }

            const playerRectX = { x: nextPlayerX, y: player.y, width: playerWidth, height: playerHeight };
            const startColX = Math.floor(Math.min(player.x, nextPlayerX) / tileSize) - 2;
            const endColX = Math.ceil(Math.max(player.x + playerWidth, nextPlayerX + playerWidth) / tileSize) + 2;
            const startRowX = Math.floor(player.y / tileSize);
            const endRowX = Math.floor((player.y + playerHeight - 1) / tileSize);

            for (let col = startColX; col <= endColX; col++) {
                for (let row = startRowX; row <= endRowX; row++) {
                    if (isSolid(col, row)) {
                        const blockRect = { x: col * tileSize, y: row * tileSize, width: tileSize, height: tileSize };
                        if (rectIntersects(playerRectX, blockRect)) {
                            if (player.dx > 0) nextPlayerX = blockRect.x - playerWidth;
                            else if (player.dx < 0) nextPlayerX = blockRect.x + tileSize;
                            player.dx = 0;
                        }
                    }
                }
            }
            player.x = nextPlayerX;

            if (keys['ArrowUp'] && player.onGround) {
                player.dy = currentJumpStrength;
                player.onGround = false;
            }
        }

        function updateCamera() {
            camera.x = player.x + playerWidth / 2 - canvas.width / 2;
            camera.y = player.y + playerHeight / 2 - canvas.height / 2;
        }

        function handleMiningDrops(blockProps, targetKey) {
            const blockData = worldBlocks[targetKey];
            
            // If the block was a chest, drop its contents
            if (blockData && blockData.type === 'chest' && blockData.inventory) {
                blockData.inventory.forEach(item => {
                    if (item) {
                        addToInventory(item.type, item.count, item.durability);
                    }
                });
            }
            
            // If the block was part of a bed, handle bed breaking
      if (blockData && blockData.type === 'bed') {
        const [col, row] = targetKey.split(',').map(Number);
        const bedPart = blockData.part;
        let startCol = col;
        // Find the starting (left) part of the bed
        if (bedPart === 'middle') {
          startCol = col - 1;
        } else if (bedPart === 'right') {
          startCol = col - 2;
        }
        // Check if all parts are still there before removing
        let bedIntact = true;
        for (let i = 0; i < 3; i++) {
          const partKey = `${startCol + i},${row}`;
          if (!worldBlocks[partKey] || worldBlocks[partKey].type !== 'bed') {
            bedIntact = false;
            break;
          }
        }
        if (bedIntact) {
          // Replace all three parts of the bed with sky
          for (let i = 0; i < 3; i++) {
            const key = `${startCol + i},${row}`;
						player.bedSpawnPoint = null
            worldBlocks[key] = {
              type: 'sky',
              solid: false
            };
            // If you need to redraw the block:
            // redrawBlock(key);
          }
          // Drop a single bed item
          addToInventory('bed', 1);
        }
        return; // Stop further processing for this block
      }

            // Handle the block's own drops
            if (blockProps && blockProps.drops) {
                blockProps.drops.forEach(drop => {
                    if (random() < drop.chance) {
                        const count = drop.min + Math.floor(random() * (drop.max - drop.min + 1));
                        if (count > 0) {
                            addToInventory(drop.item, count);
                        }
                    }
                });
            }
        }
        
        // New function to check if inventory can accept drops
        function canInventoryAcceptDrops(drops) {
            if (!drops || drops.length === 0) return true;

            // Create a deep copy of the inventory to simulate adding items
            const tempInventory = JSON.parse(JSON.stringify(inventorySlots));

            for (const drop of drops) {
                let remainingCount = drop.min; // Check for minimum guaranteed drop
                const itemType = drop.item;
                const itemProps = itemTypes[itemType] || blockTypes[itemType];
                
                if (itemProps.isTool) {
                    let hasEmptySlot = false;
                    for (let i = 0; i < totalInventorySlots; i++) {
                        if (!tempInventory[i]) {
                            tempInventory[i] = { type: itemType, count: 1 }; // Placeholder
                            hasEmptySlot = true;
                            remainingCount--;
                            break;
                        }
                    }
                    if (!hasEmptySlot) return false; // No space for the tool

                } else {
                    // First pass: fill existing stacks
                    for (let i = 0; i < totalInventorySlots; i++) {
                        if (remainingCount === 0) break;
                        const slot = tempInventory[i];
                        if (slot && slot.type === itemType && slot.count < maxStackSize) {
                            const canAdd = Math.min(remainingCount, maxStackSize - slot.count);
                            slot.count += canAdd;
                            remainingCount -= canAdd;
                        }
                    }

                    // Second pass: use empty slots
                    if (remainingCount > 0) {
                        for (let i = 0; i < totalInventorySlots; i++) {
                            if (remainingCount === 0) break;
                            if (!tempInventory[i]) {
                                const canAdd = Math.min(remainingCount, maxStackSize);
                                tempInventory[i] = { type: itemType, count: canAdd }; // Placeholder
                                remainingCount -= canAdd;
                            }
                        }
                    }
                }
                
                if (remainingCount > 0) return false; // Not enough space for this drop
            }

            return true; // All drops can be accommodated
        }


        function updateMining(dt) {
			if (!isGameActive || isGamePaused) return;

			const worldMouseX = mouse.x + camera.x;
			const worldMouseY = mouse.y + camera.y;
			const targetCol = Math.floor(worldMouseX / tileSize);
			const targetRow = Math.floor(worldMouseY / tileSize);
			const targetKey = `${targetCol},${targetRow}`;
			let blockData = worldBlocks[targetKey] || getBlockData(targetCol, targetRow);

			// Determine the effective block type and its properties
			let effectiveBlockType = blockData.type;
			if (blockData.type.startsWith('planted_')) {
				const seedType = blockData.type.replace('planted_', '').replace('_seeds', '');
				effectiveBlockType = `${seedType}_${blockData.baseBlockType}_block`;
			}
			const blockPropsForMining = blockTypes[effectiveBlockType];

			// Determine player's current mining capabilities
			const equippedItemObject = getSelectedItem();
			const equippedItemProps = equippedItemObject ? itemTypes[equippedItemObject.type] : null;
			const equippedItemType = equippedItemObject ? equippedItemObject.type : null;
			let currentMiningPower = playerMiningPower; // handMiningPower
			if (equippedItemProps && equippedItemProps.isTool) {
				currentMiningPower = equippedItemProps.miningPower;
			}

			// --- NEW: ADVANCED MINING CHECKS ---
			let canMine = true;
			if (blockPropsForMining) {
				// 1. Check for required power level
				if (blockPropsForMining.requiredMiningPower && currentMiningPower < blockPropsForMining.requiredMiningPower) {
					canMine = false;
				}

				// 2. Check for a specific required tool
				if (blockPropsForMining.requiredTool) {
					const required = blockPropsForMining.requiredTool;
					if (Array.isArray(required)) {
						// If it's an array, check if the held tool is in the array
						if (!required.includes(equippedItemType)) {
							canMine = false;
						}
					} else {
						// If it's a single string, check for an exact match
						if (equippedItemType !== required) {
							canMine = false;
						}
					}
				}
			}
			// --- END OF NEW CHECKS ---

			// If the mouse is pressed on a new block, and we can mine it, set it as the target.
			if (mouse.down && (!miningTarget || miningTarget.col !== targetCol || miningTarget.row !== targetRow)) {
				if (blockData && blockPropsForMining?.miningHardness > 0 && canMine) { // <-- Added canMine check
					miningTarget = {
						col: targetCol,
						row: targetRow,
						progress: maintainBlockDurability ? (blockData.mineProg || 0) : 0,
						requiredProgress: blockPropsForMining.miningHardness
					};
				} else {
					miningTarget = null;
				}
			}

			// If holding mouse down on a valid target, continue mining
			if (mouse.down && miningTarget && miningTarget.col === targetCol && miningTarget.row === targetRow) {
				// Double-check that conditions are still met (e.g., tool didn't break)
				if (!canMine || !blockData || blockPropsForMining?.miningHardness === 0) {
					if (maintainBlockDurability && worldBlocks[targetKey]) worldBlocks[targetKey].mineProg = 0;
					miningTarget = null;
					return;
				}

				// Check for special inventory-not-empty case for chests
				const blockToMine = worldBlocks[targetKey];
				if (blockToMine && (blockToMine.type === 'chest' || blockToMine.type === 'dead_body_chest' || blockToMine.type === 'refrigerator')) {
					if (blockToMine.inventory && blockToMine.inventory.some(item => item !== null)) {
						miningTarget = null;
						return;
					}
				}

				miningTarget.progress += dt * currentMiningPower;
				if (maintainBlockDurability) worldBlocks[targetKey].mineProg = miningTarget.progress;

				// Decrease tool durability
				if (equippedItemObject && equippedItemProps?.isTool && equippedItemObject.durability !== undefined) {
					equippedItemObject.durability -= dt; // Simplified durability loss
					if (equippedItemObject.durability <= 0) {
						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
						miningTarget = null;
						updateHotbar();
						return;
					}
				}

				// Check if block is fully mined
				if (miningTarget.progress >= miningTarget.requiredProgress) {
					const minedBlockProps = blockTypes[effectiveBlockType];
					
					if (!canInventoryAcceptDrops(minedBlockProps.drops)) {
						miningTarget.progress = miningTarget.requiredProgress - 1;
						return;
					}

					handleMiningDrops(minedBlockProps, targetKey);

					if (blockData.type !== 'bed') {
						worldBlocks[targetKey] = { type: 'sky', mineProg: 0 };
					}

					// Break foliage above the mined block
					const blockAboveKey = `${targetCol},${targetRow - 1}`;
					const blockAboveData = worldBlocks[blockAboveKey];
					if (blockAboveData && (['grass', 'tall_grass', 'wheat', 'snow', 'large_snow_pile', 'desert_brush', 'prickly_pear_cactus', 'tomato_bush', 'anthill_sand_mound', 'cobweb', 'moss', 'dark_moss', 'weed', 'shroom', 'cotton', 'rice', 'hop', 'oat', 'corn', 'barley'].includes(blockAboveData.type))) {
						const blockAboveProps = blockTypes[blockAboveData.type];
						if (canInventoryAcceptDrops(blockAboveProps.drops)) {
							worldBlocks[blockAboveKey] = { type: 'sky', mineProg: 0 };
							handleMiningDrops(blockAboveProps, blockAboveKey);
						}
					}
					miningTarget = null;
				}
			} else if (!mouse.down && miningTarget) {
				// If mouse is released, reset mining progress (if not maintaining durability)
				if (!maintainBlockDurability && worldBlocks[`${miningTarget.col},${miningTarget.row}`]) {
					worldBlocks[`${miningTarget.col},${miningTarget.row}`].mineProg = 0;
				}
				miningTarget = null;
			}
		}

        function handleBlockPlacement() {
            if (!isGameActive || isGamePaused || !mouse.rightDown) return;
            
			    //  Eat food instead of placing if selected item is edible
				const selectedItemObject = getSelectedItem();
				const selectedItemType = selectedItemObject ? selectedItemObject.type : null;

				if (
					selectedItemObject &&
					selectedItemObject.count > 0 &&
					itemTypes[selectedItemType]?.isFood
				) {
					const healAmount = itemTypes[selectedItemType].healAmount || 0;

					if (player.health < player.maxHealth && healAmount > 0) {
						player.health += healAmount;
						if (player.health > player.maxHealth) player.health = player.maxHealth;

						removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);

						mouse.rightDown = false;
						return; // Stop block placement
					}
				}
			
            const worldMouseX = mouse.x + camera.x;
            const worldMouseY = mouse.y + camera.y;
            const targetCol = Math.floor(worldMouseX / tileSize);
            const targetRow = Math.floor(worldMouseY / tileSize);
            const targetKey = `${targetCol},${targetRow}`;
            const blockAtTarget = getBlockData(targetCol, targetRow);

            // Check for chest/bed interaction first
            if (blockAtTarget.type === 'chest' || blockAtTarget.type === 'dead_body_chest' || blockAtTarget.type === 'refrigerator') {
                toggleChestMenu(targetCol, targetRow);
                mouse.rightDown = false;
                return;
            }
            if (blockAtTarget.type === 'bed') {
                player.bedSpawnPoint = { x: (targetCol - 1) * tileSize, y: (targetRow - playerHeightBlocks) * tileSize };
                showMessageBox("Bed point set! Press the ; key to teleport to bed as long as your health is above 50! It will cost you 10 health points though!", 'alert');
                mouse.rightDown = false;
                return;
            }

            if (selectedItemObject && selectedItemObject.count > 0) {
                const selectedItemIsPlaceableBlock = selectedItemType && blockTypes[selectedItemType] && blockTypes[selectedItemType].solid;
                const selectedItemIsBed = selectedItemType === 'bed';
                const selectedItemIsSeeds = selectedItemType === 'wheat_seeds' || selectedItemType === 'tomato_seeds' || selectedItemType === 'cotton_seeds' || selectedItemType === 'rice_seeds' || selectedItemType === 'hop_seeds' || selectedItemType === 'oat_seeds' || selectedItemType === 'corn_seeds' || selectedItemType === 'barley_seeds';
                const currentBlockAtTarget = getBlockType(targetCol, targetRow);
                const placementRect = { x: targetCol * tileSize, y: targetRow * tileSize, width: tileSize, height: tileSize };
                const playerRect = { x: player.x, y: player.y, width: playerWidth, height: playerHeight };

                if (rectIntersects(placementRect, playerRect)) {
                    mouse.rightDown = false;
                    return;
                }

                if (selectedItemIsBed) {
                    // Check for 3x1 flat, empty space
                    const canPlaceBed = isSolid(targetCol, targetRow + 1) && isSolid(targetCol - 1, targetRow + 1) && isSolid(targetCol + 1, targetRow + 1) &&
                                        getBlockType(targetCol, targetRow) === 'sky' && getBlockType(targetCol - 1, targetRow) === 'sky' && getBlockType(targetCol + 1, targetRow) === 'sky';
                    
                    if (canPlaceBed) {
                        // Place the 3 parts of the bed
                        worldBlocks[`${targetCol - 1},${targetRow}`] = { type: 'bed', part: 'left' };
                        worldBlocks[`${targetCol},${targetRow}`] = { type: 'bed', part: 'middle' };
                        worldBlocks[`${targetCol + 1},${targetRow}`] = { type: 'bed', part: 'right' };
                        removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
                    }
                } else if (selectedItemIsSeeds) {
                    if (['dirt', 'soil', 'fertilizer'].includes(currentBlockAtTarget)) {
                        worldBlocks[targetKey] = { type: `planted_${selectedItemType}`, mineProg: 0, plantTime: gameTime, baseBlockType: currentBlockAtTarget };
                        removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
                    }
                } else if (selectedItemIsPlaceableBlock) {
					const replaceableBlocks = ['sky', 'grass', 'tall_grass', 'wheat', 'oak_bush', 'birch_bush', 'spruce_bush', 'snow', 'large_snow_pile', 'desert_brush', 'prickly_pear_cactus', 'tomato_bush', 'anthill_sand_mound', 'cobweb', 'moss', 'dark_moss', 'weed', 'shroom', 'cotton', 'rice', 'hop', 'oat', 'corn', 'barley'];
                    if (replaceableBlocks.includes(currentBlockAtTarget)) {
                        if (currentBlockAtTarget !== 'sky') {
                            const replacedBlockProps = blockTypes[currentBlockAtTarget];
                            handleMiningDrops(replacedBlockProps, targetKey);
                        }
                        // If placing a chest, initialize its inventory and label
                        if (selectedItemType === 'chest' || selectedItemType === 'refrigerator') {
							worldBlocks[targetKey] = { type: selectedItemType, mineProg: 0, inventory: new Array(chestInventorySize).fill(null), label: '' };
						} else {
							worldBlocks[targetKey] = { type: selectedItemType, mineProg: 0 };
						}
                        removeItemFromInventory(hotbarIndices[selectedHotbarSlot], 1);
                    }
                }
            }
        }

		// ----------------- Per-item spoilage helpers -----------------
		function _ensureAcquiredTimes(slot, now) {
			// Convert legacy acquiredTime or create the array to match slot.count.
			if (!slot) return;
			now = now ?? gameTime;
			if (!Array.isArray(slot.acquiredTimes)) {
				if (slot.acquiredTime !== undefined) {
					slot.acquiredTimes = Array(slot.count || 0).fill(slot.acquiredTime);
					delete slot.acquiredTime;
				} else {
					slot.acquiredTimes = Array(slot.count || 0).fill(now);
				}
			} else {
				// keep length matching count (trim oldest if too many, fill with now if too few)
				while (slot.acquiredTimes.length < (slot.count || 0)) slot.acquiredTimes.push(now);
				while (slot.acquiredTimes.length > (slot.count || 0)) slot.acquiredTimes.shift();
			}
		}

		function _takeTimestamps(slot, takeCount) {
			// Remove 'takeCount' timestamps from the *oldest* side (FIFO), return them.
			// If slot has no timestamps, returns an array of gameTime values for fallback.
			if (!slot) return [];
			if (!Array.isArray(slot.acquiredTimes)) {
				// fallback - create an array with current gameTime for each removed
				const now = gameTime;
				slot.acquiredTimes = Array(slot.count || 0).fill(now);
			}
			const taken = slot.acquiredTimes.splice(0, takeCount);
			// If it returned fewer than requested (shouldn't happen if counts sync), pad
			while (taken.length < takeCount) taken.push(gameTime);
			return taken;
		}

		function _pushTimestampsIntoSlot(slot, timestamps) {
			if (!slot) return;
			if (!Array.isArray(slot.acquiredTimes)) slot.acquiredTimes = [];
			slot.acquiredTimes.push(...timestamps);
			// maintain length = count (caller should have updated slot.count)
			while (slot.acquiredTimes.length > slot.count) slot.acquiredTimes.shift();
		}

        function addToInventory(itemType, count = 1, durability = null, acquiredTimes = null, inventory = inventorySlots) {
			// Adds to the given inventory array (defaults to player inventory).
			// acquiredTimes: optional array (length == count) to transfer timestamps (useful when moving items between containers)
			if (!itemTypes[itemType] && !blockTypes[itemType]) {
				console.warn(`Attempted to add unknown item type: ${itemType}`);
				return false;
			}
			const itemProps = itemTypes[itemType] || blockTypes[itemType];
			let remaining = count;
			const now = gameTime;

			// helper to take some timestamps out of acquiredTimes param
			function takeFromParam(n) {
				if (!acquiredTimes) return Array(n).fill(now);
				return acquiredTimes.splice(0, n).concat(Array(Math.max(0, n - (acquiredTimes ? acquiredTimes.length : 0))).fill(now));
			}

			if (itemProps?.isTool) {
				// Tools don't stack: place individually
				for (let i = 0; i < inventory.length && remaining > 0; i++) {
					if (!inventory[i]) {
						inventory[i] = { type: itemType, count: 1, durability: durability ?? itemProps.maxDurability, maxDurability: itemProps.maxDurability };
						
						// --- THIS IS THE FIX ---
						// If the empty slot is on the hotbar, link it.
						if (i < hotbarSize && hotbarIndices[i] === null) {
							hotbarIndices[i] = i;
						}
						// --- END OF FIX ---

						remaining--;
					}
				}
			} else {
				// First fill existing stacks (for non-tools)
				for (let i = 0; i < inventory.length && remaining > 0; i++) {
					const slot = inventory[i];
					if (slot && slot.type === itemType && slot.count < maxStackSize) {
						const amountToAdd = Math.min(remaining, maxStackSize - slot.count);
						const timestamps = takeFromParam(amountToAdd);
						slot.count += amountToAdd;
						if (itemProps?.spoilable) {
							if (!Array.isArray(slot.acquiredTimes)) _ensureAcquiredTimes(slot, now);
							_pushTimestampsIntoSlot(slot, timestamps);
						}
						remaining -= amountToAdd;
					}
				}
				// Then create new stacks into empty slots
				for (let i = 0; i < inventory.length && remaining > 0; i++) {
					if (!inventory[i]) {
						const amountForNewStack = Math.min(remaining, maxStackSize);
						const timestamps = takeFromParam(amountForNewStack);
						inventory[i] = { type: itemType, count: amountForNewStack };
						if (itemProps?.isTool) {
							inventory[i].durability = durability ?? itemProps.maxDurability;
							inventory[i].maxDurability = itemProps.maxDurability;
						} else if (itemProps?.spoilable) {
							inventory[i].acquiredTimes = timestamps.slice(); // array of timestamps per unit
						}
						// This logic was already correct for stackable items
						if (i < hotbarSize && hotbarIndices[i] === null) {
							hotbarIndices[i] = i;
						}
						remaining -= amountForNewStack;
					}
				}
			}

			updateHotbar();
			if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
			if (chestOverlay.style.display === 'flex') updateChestMenu();

			if (remaining > 0) {
				console.warn(`Inventory full, could not add remaining ${remaining} of ${itemType}`);
			}
			return remaining < count; // true if at least one added
		}

        function removeItemFromInventory(slotIndex, count = 1, inventory = inventorySlots) {
			if (slotIndex === null || slotIndex === undefined || !inventory[slotIndex]) {
				console.warn(`Attempted to remove item from empty or invalid slot: ${slotIndex}`);
				return;
			}
			const itemInSlot = inventory[slotIndex];
			const toRemove = Math.min(count, itemInSlot.count);
			// if spoilable and has acquiredTimes, remove their timestamps (oldest first)
			if (itemTypes[itemInSlot.type]?.spoilable && Array.isArray(itemInSlot.acquiredTimes)) {
				itemInSlot.acquiredTimes.splice(0, toRemove);
			}
			itemInSlot.count -= toRemove;
			if (itemInSlot.count <= 0) {
				inventory[slotIndex] = null;
				const hotbarIdx = hotbarIndices.indexOf(slotIndex);
				if (hotbarIdx !== -1) hotbarIndices[hotbarIdx] = null;
			}
			updateHotbar();
			if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
			if (chestOverlay.style.display === 'flex') updateChestMenu();
		}

        function getSelectedItem() {
            const hotbarSlotIndex = hotbarIndices[selectedHotbarSlot];
            return (hotbarSlotIndex !== null && hotbarSlotIndex !== undefined) ? inventorySlots[hotbarSlotIndex] : null;
        }

        function updateHotbar() {
            hotbarDiv.innerHTML = '';
            for (let i = 0; i < hotbarSize; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.classList.add('hotbar-slot');
                if (i === selectedHotbarSlot) slotDiv.classList.add('selected');
                
                const inventorySlotIndex = hotbarIndices[i];
                const itemObject = (inventorySlotIndex !== null && inventorySlotIndex !== undefined) ? inventorySlots[inventorySlotIndex] : null;

                if (itemObject) {
                    const itemProps = itemTypes[itemObject.type] || blockTypes[itemObject.type];
                    const itemImg = assets[itemObject.type];
                    if (itemImg && !failedAssets[itemObject.type]) {
                        const imgElement = document.createElement('img');
                        imgElement.src = itemImg.src;
                        slotDiv.appendChild(imgElement);
                    } else if (itemProps?.color) {
                        const fallbackDiv = document.createElement('div');
                        fallbackDiv.classList.add('fallback');
                        fallbackDiv.style.backgroundColor = itemProps.color;
                        fallbackDiv.textContent = itemObject.type.substring(0, 3).toUpperCase();
                        slotDiv.appendChild(fallbackDiv);
                    }
                    const countSpan = document.createElement('span');
                    countSpan.textContent = itemObject.count;
                    slotDiv.appendChild(countSpan);

                    if (itemProps?.isTool && itemObject.durability !== null && itemObject.durability !== undefined) {
                        const durabilityBar = document.createElement('div');
                        durabilityBar.classList.add('durability-bar');
                        const durabilityFill = document.createElement('div');
                        durabilityFill.classList.add('durability-fill');
                        const durabilityRatio = itemObject.durability / itemObject.maxDurability;
                        durabilityFill.style.width = `${Math.max(0, durabilityRatio * 100)}%`;
                        durabilityFill.style.backgroundColor = durabilityRatio > 0.6 ? '#28a745' : (durabilityRatio > 0.3 ? '#ffc107' : '#dc3545');
                        durabilityBar.appendChild(durabilityFill);
                        slotDiv.appendChild(durabilityBar);
                    }
                }
                hotbarDiv.appendChild(slotDiv);
            }

		   const selectedToolObject = getSelectedItem();
            const selectedToolProps = selectedToolObject ? itemTypes[selectedToolObject.type] : null;
            playerMiningPower = (selectedToolObject && selectedToolProps?.isTool) ? selectedToolProps.miningPower : handMiningPower;
        }

        // New function to pre-generate chunks off-screen
        function generateOffscreenChunks() {
            const playerCol = Math.floor((player.x + playerWidth / 2) / tileSize);
            const playerRow = Math.floor((player.y + playerHeight / 2) / tileSize);
            
            const viewWidthInTiles = Math.ceil(canvas.width / tileSize);
            const viewHeightInTiles = Math.ceil(canvas.height / tileSize);

            const startCol = playerCol - Math.floor(viewWidthInTiles / 2) - generationBuffer;
            const endCol = playerCol + Math.ceil(viewWidthInTiles / 2) + generationBuffer;
            const startRow = playerRow - Math.floor(viewHeightInTiles / 2) - generationBuffer;
            const endRow = playerRow + Math.ceil(viewHeightInTiles / 2) + generationBuffer;

            for (let col = startCol; col < endCol; col++) {
                // Generate deeper to ensure caves/ores are ready
                for (let row = Math.max(-250, startRow); row < endRow + 50; row++) { 
                    getBlockData(col, row); // This function already prevents re-generation
                }
            }
        }

        function drawWorld() {
            // Background color change based on depth
            const playerGridY = Math.floor(player.y / tileSize);
            if (playerGridY < -145) { // Heaven
                document.body.style.backgroundColor = '#d8d043';
            } else if (playerGridY > 205) { // Underworld
                document.body.style.backgroundColor = '#4d0f0f';
            } else if (playerGridY > 20) { // Compacted Stone
                document.body.style.backgroundColor = '#2e2e2e';
            } else if (playerGridY > 10) { // Stone
                document.body.style.backgroundColor = '#4e626d';
            } else { // Surface / Sky
                document.body.style.backgroundColor = '#94d4d0';
            }


            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const startCol = Math.floor(camera.x / tileSize) - 1;
            const endCol = Math.ceil((camera.x + canvas.width) / tileSize) + 1;
            const startRow = Math.floor(camera.y / tileSize) - 1;
            const endRow = Math.ceil((camera.y + canvas.height) / tileSize) + 1;

            for (let col = startCol; col < endCol; col++) {
                for (let row = startRow; row < endRow; row++) {
                    const key = `${col},${row}`;
					const blockData = worldBlocks[key];
					if (!blockData || blockData.type === 'sky') continue; // skip empty/air tiles
                    let blockType = blockData.type;
                    let blockProps = blockTypes[blockType];
                    const screenX = col * tileSize - camera.x;
                    const screenY = row * tileSize - camera.y;

                    if (blockData.type.startsWith('planted_')) {
                        const seedType = blockData.type.replace('planted_', '').replace('_seeds', '');
                        blockType = `${seedType}_${blockData.baseBlockType}_block`;
                        blockProps = blockTypes[blockType];
                    }

                    if (blockType !== 'sky' && blockProps) {
                        const blockImg = assets[blockType];
                        if (blockImg && !failedAssets[blockType]) {
                            // Special drawing for beds (3 blocks wide)
                            if (blockType === 'bed' && blockData.part === 'left') {
                                ctx.drawImage(blockImg, screenX, screenY, tileSize * 3, tileSize);
                            } else if (blockType !== 'bed') { // Draw normal blocks
                                ctx.drawImage(blockImg, screenX, screenY, tileSize, tileSize);
                            }
                        } else if (blockProps.color) {
                             ctx.fillStyle = blockProps.color;
                             ctx.fillRect(screenX, screenY, tileSize, tileSize);
                        }
                        if (maintainBlockDurability && blockData.mineProg > 0) {
                            let effectiveMiningHardness = blockTypes[blockData.type].miningHardness;
                            // ... (rest of the durability drawing logic, no changes needed here)
                            const progressRatio = blockData.mineProg / effectiveMiningHardness;
                            let overlayImage = null;
                            if (progressRatio >= 0.75) overlayImage = assets['breaking_stage_3'];
                            else if (progressRatio >= 0.50) overlayImage = assets['breaking_stage_2'];
                            else if (progressRatio >= 0.25) overlayImage = assets['breaking_stage_1'];
                            if (overlayImage) ctx.drawImage(overlayImage, screenX, screenY, tileSize, tileSize);
                        }
                    }
                }
            }
        }

        function drawPlayer() {
			ctx.drawImage(
				playerImg,
				player.x - camera.x,
				player.y - camera.y,
				playerWidth,
				playerHeight
			);
		}

        function drawmineProg() {
            if (miningTarget) {
                const progressRatio = miningTarget.progress / miningTarget.requiredProgress;
                const screenX = miningTarget.col * tileSize - camera.x;
                const screenY = miningTarget.row * tileSize - camera.y;
                let overlayImage = null;
                if (progressRatio >= 0.75) overlayImage = assets['breaking_stage_3'];
                else if (progressRatio >= 0.50) overlayImage = assets['breaking_stage_2'];
                else if (progressRatio >= 0.25) overlayImage = assets['breaking_stage_1'];
                if (overlayImage) ctx.drawImage(overlayImage, screenX, screenY, tileSize, tileSize);
            }
        }

        function drawHealth() {
            healthBarDiv.innerHTML = '';
            const totalHearts = player.maxHealth / 20; // 5 hearts
            let health = player.health;

            for (let i = 0; i < totalHearts; i++) {
                const img = document.createElement('img');
                if (health > 10) {
                    img.src = assets['full_heart'].src;
                    health -= 20;
                } else if (health > 0) {
                    img.src = assets['half_heart'].src;
                    health = 0;
                } else {
                    img.src = assets['empty_heart'].src;
                }
                healthBarDiv.appendChild(img);
            }
        }

        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Escape') {
                if (isGamePaused && inventoryCraftingOverlay.style.display === 'flex') toggleInventoryMenu();
                else if (isGamePaused && chestOverlay.style.display === 'flex') toggleChestMenu();
                else if (isGamePaused && gameMenuOverlay.style.display === 'flex') toggleGameMenu();
                else toggleGameMenu();
            } 
            if (e.code === 'KeyE') {
                if (isGamePaused && chestOverlay.style.display === 'flex') return; // Don't open crafting if chest is open
                if (!isGamePaused || (isGamePaused && inventoryCraftingOverlay.style.display === 'flex')) toggleInventoryMenu();
            }
            if (!isGamePaused) {
                if (e.key >= '1' && e.key <= '9') selectedHotbarSlot = parseInt(e.key) - 1;
                else if (e.key === '0') selectedHotbarSlot = 9;
                updateHotbar();
            }
			if (e.key === ';' && player.health > 50) {
				if (player.bedSpawnPoint) {
					player.health -= 10
					player.x = player.bedSpawnPoint.x;
					player.y = player.bedSpawnPoint.y;
				}
			}
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'Space'].includes(e.code)) e.preventDefault();
        });

        window.addEventListener('keyup', (e) => { keys[e.code] = false; });
		document.addEventListener('mousemove', (e) => {
			// Position the tooltip slightly below and to the right of the cursor
			itemTooltip.style.left = (e.clientX + 15) + 'px';
			itemTooltip.style.top = (e.clientY + 10) + 'px';
		});
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (!isGamePaused) {
                if (e.button === 0) mouse.down = true;
                else if (e.button === 2) mouse.rightDown = true;
            }
        });
        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            if (e.button === 0) mouse.down = false;
            else if (e.button === 2) mouse.rightDown = false;
        });
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.y;
        });
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        document.addEventListener('visibilitychange', () => {
            isGameActive = !document.hidden;
            if (isGameActive) lastTime = performance.now();
        });
        window.addEventListener('resize', resizeCanvas);
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            draw();
        }

        function showMessageBox(message, type = 'alert', callback = null) {
            messageBoxText.textContent = message;
            messageBoxButtons.innerHTML = '';
            return new Promise(resolve => {
                const okButton = document.createElement('button');
                okButton.textContent = 'OK';
                okButton.onclick = () => { customMessageBoxOverlay.style.display = 'none'; resolve(true); if (callback) callback(true); };
                messageBoxButtons.appendChild(okButton);
                if (type === 'confirm') {
                    const cancelButton = document.createElement('button');
                    cancelButton.textContent = 'Cancel';
                    cancelButton.onclick = () => { customMessageBoxOverlay.style.display = 'none'; resolve(false); if (callback) callback(false); };
                    messageBoxButtons.appendChild(cancelButton);
                }
                customMessageBoxOverlay.style.display = 'flex';
            });
        }

        const recipes = [
            { name: "Bed",
                input: { 0: { type: 'cotton_item', count: 1 }, 1: { type: 'cotton_item', count: 1 }, 2: { type: 'cotton_item', count: 1 }, 3: { type: 'cotton_item', count: 1 }, 4: { type: 'any_plank', count: 1 }, 5: { type: 'any_plank', count: 1 }, 6: { type: 'any_plank', count: 1 }, 7: { type: 'any_plank', count: 1 } },
                output: 'bed', outputCount: 1,
				altInputs: [ { 0: { type: 'cotton_item', count: 1 }, 1: { type: 'cotton_item', count: 1 }, 2: { type: 'cotton_item', count: 1 }, 3: { type: 'cotton_item', count: 1 }, 4: { type: 'planked_oak', count: 1 }, 5: { type: 'planked_oak', count: 1 }, 6: { type: 'planked_oak', count: 1 }, 7: { type: 'planked_oak', count: 1 } } ]
            },
            { name: "Chest", 
                input: { 0: { type: 'any_plank', count: 1 }, 1: { type: 'any_plank', count: 1 }, 2: { type: 'any_plank', count: 1 }, 3: { type: 'any_plank', count: 1 }, 4: { type: 'any_plank', count: 1 }, 5: { type: 'any_plank', count: 1 }, 6: { type: 'any_plank', count: 1 }, 7: { type: 'any_plank', count: 1 } },
                output: 'chest', outputCount: 1,
                altInputs: [ { 0: { type: 'planked_oak', count: 1 }, 1: { type: 'planked_oak', count: 1 }, 2: { type: 'planked_oak', count: 1 }, 3: { type: 'planked_oak', count: 1 }, 4: { type: 'planked_oak', count: 1 }, 5: { type: 'planked_oak', count: 1 }, 6: { type: 'planked_oak', count: 1 }, 7: { type: 'planked_oak', count: 1 } } ]
            },
			{ name: "Refrigerator",
				input: { 0: { type: 'chest', count: 1 }, 1: { type: 'packed_ice_block', count: 1 } },
				output: 'refrigerator', outputCount: 1
			},
			{ name: "Oven",
				input: { 0: { type: 'stone', count: 1 }, 1: { type: 'stone', count: 1 }, 2: { type: 'stone', count: 1 }, 3: { type: 'stone', count: 1 }, 4: { type: 'coal', count: 1 }, 5: { type: 'compacted_stone', count: 1 }, 6: { type: 'compacted_stone', count: 1 }, 7: { type: 'coal', count: 1 } },
				output: 'oven', outputCount: 1
			},
            { name: "Paper",
				input: { 0: { type: 'any_plank', count: 1 }, 3: { type: 'any_plank', count: 1 } },
				output: 'paper', outputCount: 1,
                altInputs: [ { 0: { type: 'planked_oak', count: 1 }, 3: { type: 'planked_oak', count: 1 } } ]
            },
			{ name: "Wooden Sticks", input: { 0: { type: 'any_plank', count: 1 } }, output: 'wooden_stick', outputCount: 3,
                altInputs: [ { 0: { type: 'planked_oak', count: 1 } } ]
            },
			{ name: "Wooden Bowl",
                input: { 0: { type: 'any_plank', count: 1 }, 3: { type: 'any_plank', count: 1 }, 4: { type: 'any_plank', count: 1 }, 7: { type: 'any_plank', count: 1 }, 8: { type: 'any_plank', count: 1 }, 9: { type: 'any_plank', count: 1 }, 10: { type: 'any_plank', count: 1 }, 11: { type: 'any_plank', count: 1 } },
                output: 'wooden_bowl', outputCount: 3,
                altInputs: [{ 0: { type: 'planked_oak', count: 1 }, 3: { type: 'planked_oak', count: 1 }, 4: { type: 'planked_oak', count: 1 }, 7: { type: 'planked_oak', count: 1 }, 8: { type: 'planked_oak', count: 1 }, 9: { type: 'planked_oak', count: 1 }, 10: { type: 'planked_oak', count: 1 }, 11: { type: 'planked_oak', count: 1 } }]
            },
			{ name: "Taco Salad",
                input: { 0: { type: 'wooden_bowl', count: 1 }, 1: { type: 'tomato', count: 1 }, 2: { type: 'corn_item', count: 1 }, 3: { type: 'rice_item', count: 1 } },
                output: 'taco_salad', outputCount: 1
            },
			{ name: "Mushroom Soup",
                input: { 0: { type: 'wooden_bowl', count: 1 }, 1: { type: 'shroom', count: 1 }, 2: { type: 'shroom', count: 1 }, 3: { type: 'shroom', count: 1 } },
                output: 'mushroom_soup', outputCount: 1
            },
			{ name: "Tomato Soup",
                input: { 0: { type: 'wooden_bowl', count: 1 }, 1: { type: 'tomato', count: 1 }, 2: { type: 'tomato', count: 1 }, 3: { type: 'tomato', count: 1 } },
                output: 'tomato_soup', outputCount: 1
            },
			{ name: "Cup Of Beer",
                input: { 0: { type: 'glass_cup', count: 1 }, 1: { type: 'barley_item', count: 1 }, 2: { type: 'corn_item', count: 1 }, 4: { type: 'hop_item', count: 1 }, 5: { type: 'hop_item', count: 1 }, 6: { type: 'hop_item', count: 1 } },
                output: 'cup_of_beer', outputCount: 1
            },
            { name: "Wooden Pickaxe",
                input: { 0: { type: 'any_plank', count: 1 }, 1: { type: 'any_plank', count: 1 }, 2: { type: 'any_plank', count: 1 }, 3: { type: 'any_plank', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'wooden_pickaxe', outputCount: 1,
                altInputs: [{ 0: { type: 'planked_oak', count: 1 }, 1: { type: 'planked_oak', count: 1 }, 2: { type: 'planked_oak', count: 1 }, 3: { type: 'planked_oak', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } }]
            },
            { name: "Rock Pickaxe",
                input: { 0: { type: 'rock_block', count: 1 }, 1: { type: 'rock_block', count: 1 }, 2: { type: 'rock_block', count: 1 }, 3: { type: 'rock_block', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'rock_pickaxe', outputCount: 1
            },
            { name: "Copper Pickaxe",
                input: { 0: { type: 'copper_nugget', count: 1 }, 1: { type: 'copper_nugget', count: 1 }, 2: { type: 'copper_nugget', count: 1 }, 3: { type: 'copper_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'copper_pickaxe', outputCount: 1
            },
            { name: "Tin Pickaxe",
                input: { 0: { type: 'tin_nugget', count: 1 }, 1: { type: 'tin_nugget', count: 1 }, 2: { type: 'tin_nugget', count: 1 }, 3: { type: 'tin_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'tin_pickaxe', outputCount: 1
            },
            { name: "Bronze Nugget", input: { 0: { type: 'tin_nugget', count: 1 }, 1: { type: 'copper_nugget', count: 1 } }, output: 'bronze_nugget', outputCount: 1 },
            { name: "Bronze Pickaxe",
                input: { 0: { type: 'bronze_nugget', count: 1 }, 1: { type: 'bronze_nugget', count: 1 }, 2: { type: 'bronze_nugget', count: 1 }, 3: { type: 'bronze_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'bronze_pickaxe', outputCount: 1
            },
            { name: "Iron Pickaxe",
                input: { 0: { type: 'iron_nugget', count: 1 }, 1: { type: 'iron_nugget', count: 1 }, 2: { type: 'iron_nugget', count: 1 }, 3: { type: 'iron_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'iron_pickaxe', outputCount: 1
            },
            { name: "Steel Nugget",
                input: { 1: { type: 'coal', count: 1 }, 4: { type: 'coal', count: 1 }, 5: { type: 'iron_nugget', count: 1 }, 6: { type: 'coal', count: 1 }, 9: { type: 'coal', count: 1 }, 10: { type: 'coal', count: 1 } },
                output: 'steel_nugget', outputCount: 1
            },
            { name: "Steel Pickaxe",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 2: { type: 'steel_nugget', count: 1 }, 3: { type: 'steel_nugget', count: 1 }, 5: { type: 'wooden_stick', count: 1 }, 9: { type: 'wooden_stick', count: 1 }, 13: { type: 'wooden_stick', count: 1 } },
                output: 'steel_pickaxe', outputCount: 1
            },
			{ name: "Hellsteel Pickaxe",
                input: { 0: { type: 'hellsteel_nugget', count: 1 }, 1: { type: 'hellsteel_nugget', count: 1 }, 2: { type: 'hellsteel_nugget', count: 1 }, 3: { type: 'hellsteel_nugget', count: 1 }, 5: { type: 'steel_pickaxe', count: 1 }, 9: { type: 'steel_pickaxe', count: 1 }, 13: { type: 'steel_pickaxe', count: 1 } },
                output: 'hellsteel_pickaxe', outputCount: 1
            },
            { name: "Ruby Plated Steel Pickaxe",
                input: { 0: { type: 'ruby_nugget', count: 1 }, 1: { type: 'steel_pickaxe', count: 1 }, 2: { type: 'ruby_nugget', count: 1 }, 5: { type: 'ruby_nugget', count: 1 } },
                output: 'ruby_plated_steel_pickaxe', outputCount: 1
            },
            { name: "Diamond Plated Steel Pickaxe",
                input: { 0: { type: 'diamond_nugget', count: 1 }, 1: { type: 'steel_pickaxe', count: 1 }, 2: { type: 'diamond_nugget', count: 1 }, 5: { type: 'diamond_nugget', count: 1 } },
                output: 'diamond_plated_steel_pickaxe', outputCount: 1
            },
            { name: "Snow Block",
                input: { 0: { type: 'snow_ball', count: 1 }, 1: { type: 'snow_ball', count: 1 }, 2: { type: 'snow_ball', count: 1 }, 4: { type: 'snow_ball', count: 1 }, 5: { type: 'snow_ball', count: 1 }, 6: { type: 'snow_ball', count: 1 }, 8: { type: 'snow_ball', count: 1 }, 9: { type: 'snow_ball', count: 1 }, 10: { type: 'snow_ball', count: 1 } },
                output: 'snow_block', outputCount: 1
            },
            { name: "Oak Planks", input: { 0: { type: 'raw_oak', count: 1 } }, output: 'planked_oak', outputCount: 3 },
            { name: "Birch Planks", input: { 0: { type: 'raw_birch', count: 1 } }, output: 'planked_birch', outputCount: 3 },
            { name: "Spruce Planks", input: { 0: { type: 'raw_spruce', count: 1 } }, output: 'planked_spruce', outputCount: 3 },
			{ name: "Hell Wood Planks", input: { 0: { type: 'raw_hell_wood', count: 1 } }, output: 'planked_hell_wood', outputCount: 3 },
            { name: "Darkwood Planks", input: { 0: { type: 'raw_darkwood', count: 1 } }, output: 'planked_darkwood', outputCount: 3 },
            { name: "Gilded Wood Planks", input: { 0: { type: 'raw_gilded_wood', count: 1 } }, output: 'planked_gilded_wood', outputCount: 3 },
            { name: "Hay Bale",
                input: { 0: { type: 'wheat_item', count: 1 }, 1: { type: 'barley_item', count: 1 }, 4: { type: 'barley_item', count: 1 }, 5: { type: 'wheat_item', count: 1 } },
                output: 'hay_bale', outputCount: 1
            },
			{ name: "Wheat Bread",
                input: { 0: { type: 'wheat_item', count: 1 }, 1: { type: 'wheat_item', count: 1 }, 2: { type: 'wheat_item', count: 1 } },
                output: 'wheat_bread', outputCount: 1
            },
			{ name: "Barley Bread",
                input: { 0: { type: 'barley_item', count: 1 }, 1: { type: 'barley_item', count: 1 }, 2: { type: 'barley_item', count: 1 } },
                output: 'barley_bread', outputCount: 1
            },
            { name: "Tomato Sandwich",
                input: { 1: { type: 'wheat_bread', count: 1 }, 5: { type: 'tomato', count: 1 }, 6: { type: 'tomato', count: 1 }, 7: { type: 'tomato', count: 1 }, 9: { type: 'wheat_bread', count: 1 } },
                output: 'tomato_sandwich', outputCount: 1,
            },
			{ name: "Tomato Sandwich",
                input: { 1: { type: 'barley_bread', count: 1 }, 5: { type: 'tomato', count: 1 }, 6: { type: 'tomato', count: 1 }, 7: { type: 'tomato', count: 1 }, 9: { type: 'barley_bread', count: 1 } },
                output: 'tomato_sandwich', outputCount: 1,
            },
            { name: "Fertilizer",
                input: { 0: { type: 'soil', count: 1 }, 1: { type: 'coal', count: 1 } },
                output: 'fertilizer', outputCount: 1
            },
			{ name: "Stone Stairs Right",
				input: { 3: { type: 'stone', count: 1 }, 6: { type: 'stone', count: 1 }, 7: { type: 'stone', count: 1 }, 9: { type: 'stone', count: 1 }, 10: { type: 'stone', count: 1 }, 11: { type: 'stone', count: 1 }, 12: { type: 'stone', count: 1 }, 13: { type: 'stone', count: 1 }, 14: { type: 'stone', count: 1 }, 15: { type: 'stone', count: 1 } },
				output: 'stone_stairs_right', outputCount: 10
			},
			{ name: "Stone Stairs Left",
				input: { 0: { type: 'stone', count: 1 }, 4: { type: 'stone', count: 1 }, 5: { type: 'stone', count: 1 }, 8: { type: 'stone', count: 1 }, 9: { type: 'stone', count: 1 }, 10: { type: 'stone', count: 1 }, 12: { type: 'stone', count: 1 }, 13: { type: 'stone', count: 1 }, 14: { type: 'stone', count: 1 }, 15: { type: 'stone', count: 1 } },
				output: 'stone_stairs_left', outputCount: 10
			},
			{ name: "Clay Brick Block",
                input: { 0: { type: 'soil', count: 1 }, 1: { type: 'sand_block', count: 1 }, 4: { type: 'sand_block', count: 1 }, 5: { type: 'soil', count: 1 } },
                output: 'clay_brick_block', outputCount: 1
            },
			{ name: "Stone Brick Block",
                input: { 0: { type: 'stone', count: 1 }, 1: { type: 'compacted_stone', count: 1 }, 4: { type: 'compacted_stone', count: 1 }, 5: { type: 'stone', count: 1 } },
                output: 'stone_brick_block', outputCount: 3
            },
			{ name: "Asphalt Block",
                input: { 0: { type: 'stone', count: 1 }, 1: { type: 'schist_block', count: 1 }, 2: { type: 'slate_block', count: 1 }, 3: { type: 'granite_block', count: 1 }, 5: { type: 'compacted_stone', count: 1 }, 6: { type: 'rock_block', count: 1 } },
                output: 'asphalt_block', outputCount: 6
            },
			{ name: "Asphalt Block",
                input: { 0: { type: 'asphalt_fragment', count: 1 }, 1: { type: 'asphalt_fragment', count: 1 }, 2: { type: 'asphalt_fragment', count: 1 }, 3: { type: 'asphalt_fragment', count: 1 } },
                output: 'asphalt_block', outputCount: 1
            },
			{ name: "Bronze Brick Block",
                input: { 0: { type: 'bronze_nugget', count: 1 }, 1: { type: 'bronze_nugget', count: 1 }, 4: { type: 'bronze_nugget', count: 1 }, 5: { type: 'bronze_nugget', count: 1 } },
                output: 'bronze_brick_block', outputCount: 1
            },
			{ name: "Steel Brick Block",
                input: { 0: { type: 'steel_nugget', count: 1 }, 1: { type: 'steel_nugget', count: 1 }, 4: { type: 'steel_nugget', count: 1 }, 5: { type: 'steel_nugget', count: 1 } },
                output: 'steel_brick_block', outputCount: 1
            },
			{ name: "Iron Brick Block",
                input: { 0: { type: 'iron_nugget', count: 1 }, 1: { type: 'iron_nugget', count: 1 }, 4: { type: 'iron_nugget', count: 1 }, 5: { type: 'iron_nugget', count: 1 } },
                output: 'iron_brick_block', outputCount: 1
            },
			{ name: "Tin Brick Block",
                input: { 0: { type: 'tin_nugget', count: 1 }, 1: { type: 'tin_nugget', count: 1 }, 4: { type: 'tin_nugget', count: 1 }, 5: { type: 'tin_nugget', count: 1 } },
                output: 'tin_brick_block', outputCount: 1
            },
			{ name: "Copper Brick Block",
                input: { 0: { type: 'copper_nugget', count: 1 }, 1: { type: 'copper_nugget', count: 1 }, 4: { type: 'copper_nugget', count: 1 }, 5: { type: 'copper_nugget', count: 1 } },
                output: 'copper_brick_block', outputCount: 1
            },
            { name: "Gold Brick Block",
                input: { 0: { type: 'gold_nugget', count: 1 }, 1: { type: 'gold_nugget', count: 1 }, 4: { type: 'gold_nugget', count: 1 }, 5: { type: 'gold_nugget', count: 1 } },
                output: 'gold_brick_block', outputCount: 1
            },
            { name: "Gold Nugget",
                input: { 0: { type: 'any_gilded', count: 1 }, 1: { type: 'any_gilded', count: 1 }, 2: { type: 'any_gilded', count: 1 }, 3: { type: 'any_gilded', count: 1 }, 4: { type: 'any_gilded', count: 1 }, 5: { type: 'any_gilded', count: 1 }, 6: { type: 'any_gilded', count: 1 }, 7: { type: 'any_gilded', count: 1 }, 8: { type: 'any_gilded', count: 1 }, 9: { type: 'any_gilded', count: 1 }, 10: { type: 'any_gilded', count: 1 }, 11: { type: 'any_gilded', count: 1 }, 12: { type: 'any_gilded', count: 1 }, 13: { type: 'any_gilded', count: 1 }, 14: { type: 'any_gilded', count: 1}, 15: { type: 'any_gilded', count: 1 } },
                output: 'gold_nugget', outputCount: 1,
                altInputs: [{ 0: { type: 'gilded_dirt_block', count: 1 }, 1: { type: 'gilded_dirt_block', count: 1 }, 2: { type: 'gilded_dirt_block', count: 1 }, 3: { type: 'gilded_dirt_block', count: 1 }, 4: { type: 'gilded_dirt_block', count: 1 }, 5: { type: 'gilded_dirt_block', count: 1 }, 6: { type: 'gilded_dirt_block', count: 1 }, 7: { type: 'gilded_dirt_block', count: 1 }, 8: { type: 'gilded_dirt_block', count: 1 }, 9: { type: 'gilded_dirt_block', count: 1 }, 10: { type: 'gilded_dirt_block', count: 1 }, 11: { type: 'gilded_dirt_block', count: 1 }, 12: { type: 'gilded_dirt_block', count: 1 }, 13: { type: 'gilded_dirt_block', count: 1 }, 14: { type: 'gilded_dirt_block', count: 1 }, 15: { type: 'gilded_dirt_block', count: 1 } }]
            },
			{ name: "Glass Block",
                input: { 0: { type: 'sand_block', count: 1 } },
                output: 'glass_block', outputCount: 1
            },
			{ name: "Glass Cup",
                input: { 0: { type: 'glass_block', count: 1 }, 2: { type: 'glass_block', count: 1 }, 4: { type: 'glass_block', count: 1 }, 6: { type: 'glass_block', count: 1 }, 8: { type: 'glass_block', count: 1 }, 10: { type: 'glass_block', count: 1 }, 12: { type: 'glass_block', count: 1 }, 13: { type: 'glass_block', count: 1 }, 14: { type: 'glass_block', count: 1 } },
                output: 'glass_cup', outputCount: 4
            },
        ];

        let craftingGridSlots = new Array(16).fill(null);

        function toggleInventoryMenu() {
            if (gameMenuOverlay.style.display === 'flex' && !isGamePaused) return;
            isGamePaused = !isGamePaused;
            if (isGamePaused) {
                inventoryCraftingOverlay.style.display = 'flex';
                updateInventoryMenu();
                renderRecipes();
            } else {
                inventoryCraftingOverlay.style.display = 'none';
                // Return crafting items to inventory
                for(let i = 0; i < craftingGridSlots.length; i++) {
                    const slot = craftingGridSlots[i];
                    if (slot && slot.type && slot.count > 0) {
                        addToInventory(slot.type, slot.count, slot.durability);
                        craftingGridSlots[i] = null;
                    }
                }
                // Return held item to inventory
                if (heldItem) {
                    addToInventory(heldItem.type, heldItem.count, heldItem.durability);
                    heldItem = null;
                    heldItemSource = { type: null, index: -1 };
                }
                lastTime = performance.now();
            }
        }

        function updateInventoryMenu() {
            playerInventoryGrid.innerHTML = '';
            inventoryHotbarGrid.innerHTML = '';
            // Hotbar section in the inventory menu
            for (let i = 0; i < hotbarSize; i++) {
                const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
                slotDiv.classList.add('hotbar-slot');
                inventoryHotbarGrid.appendChild(slotDiv);
            }
            // Main inventory section
            for (let i = hotbarSize; i < totalInventorySlots; i++) {
                const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
                playerInventoryGrid.appendChild(slotDiv);
            }
            // Crafting grid section
            craftingGridDiv.innerHTML = '';
            for (let i = 0; i < 16; i++) {
                const slotDiv = createInventorySlot(craftingGridSlots[i], i, 'crafting');
                craftingGridDiv.appendChild(slotDiv);
            }
            // Delete Slot
            deleteSlot.onmousedown = (e) => handleSlotClick(e);

            checkCraftingRecipe();
        }

        function createInventorySlot(itemObject, slotIndex, sourceType) {
			const slot = document.createElement('div');
			slot.classList.add('inventory-slot');
			slot.dataset.slotIndex = slotIndex;
			slot.dataset.sourceType = sourceType;
			slot.onmousedown = (e) => handleSlotClick(e);

			// --- NEW: Add mouse hover events ---
			slot.onmouseenter = (e) => {
				if (itemObject) {
					// Format the name: replace underscores with spaces and capitalize words
					const itemName = (itemObject.type.replace(/_/g, ' ')).replace(/\b\w/g, l => l.toUpperCase());
					itemTooltip.textContent = itemName;
					itemTooltip.style.display = 'block';
				}
			};
			slot.onmouseleave = (e) => {
				itemTooltip.style.display = 'none';
			};

            if (sourceType === 'delete') {
                slot.id = 'deleteSlot';
                slot.innerHTML = 'X';
                return slot;
            }

            if (heldItemSource.type === sourceType && heldItemSource.index === slotIndex) {
                slot.style.backgroundColor = '#888';
            }

            if (itemObject && itemObject.type && itemObject.count > 0) {
                const itemProps = itemTypes[itemObject.type] || blockTypes[itemObject.type];
                const itemImg = assets[itemObject.type];
                if (itemImg && !failedAssets[itemObject.type]) {
                    const imgElement = document.createElement('img');
                    imgElement.src = itemImg.src;
                    slot.appendChild(imgElement);
                } else if (itemProps?.color) {
                    const fallbackDiv = document.createElement('div');
                    fallbackDiv.classList.add('fallback');
                    fallbackDiv.style.backgroundColor = itemProps.color;
                    fallbackDiv.textContent = itemObject.type.substring(0, 3).toUpperCase();
                    slot.appendChild(fallbackDiv);
                }
                const countSpan = document.createElement('span');
                countSpan.classList.add('item-count');
                countSpan.textContent = itemObject.count;
                slot.appendChild(countSpan);
                if (itemProps?.isTool && itemObject.durability !== null && itemObject.durability !== undefined) {
                    const durabilityBar = document.createElement('div');
                    durabilityBar.classList.add('durability-bar');
                    const durabilityFill = document.createElement('div');
                    durabilityFill.classList.add('durability-fill');
                    const durabilityRatio = itemObject.durability / itemObject.maxDurability;
                    durabilityFill.style.width = `${Math.max(0, durabilityRatio * 100)}%`;
                    durabilityFill.style.backgroundColor = durabilityRatio > 0.6 ? '#28a745' : (durabilityRatio > 0.3 ? '#ffc107' : '#dc3545');
                    durabilityBar.appendChild(durabilityFill);
                    slot.appendChild(durabilityBar);
                }
            }
            return slot;
        }

        function handleSlotClick(event) {
			event.preventDefault();
			const slotDiv = event.currentTarget;
			const sourceType = slotDiv.dataset.sourceType;
			const slotIndex = parseInt(slotDiv.dataset.slotIndex);

			if (sourceType === 'delete') {
				if (heldItem) {
					heldItem = null;
					heldItemSource = { type: null, index: -1 };
					updateInventoryMenu();
					updateChestMenu();
				}
				return;
			}

			let sourceArray;
			if (sourceType === 'inventory') sourceArray = inventorySlots;
			else if (sourceType === 'crafting') sourceArray = craftingGridSlots;
			else if (sourceType === 'chest') {
				const chestData = worldBlocks[`${currentlyOpenChest.col},${currentlyOpenChest.row}`];
				if (chestData) sourceArray = chestData.inventory;
			}
			if (!sourceArray) return;

			const clickedSlotItem = sourceArray[slotIndex];

			if (event.button === 2) { // Right-click for splitting / place-one
				if (heldItem === null) {
					// pick up half
					if (clickedSlotItem && clickedSlotItem.count > 1) {
						const halfCount = Math.ceil(clickedSlotItem.count / 2);
						// build heldItem as a shallow copy, taking timestamps if present
						const timestamps = itemTypes[clickedSlotItem.type]?.spoilable ? _takeTimestamps(clickedSlotItem, halfCount) : null;
						heldItem = {
							type: clickedSlotItem.type,
							count: halfCount,
							durability: clickedSlotItem.durability,
							maxDurability: clickedSlotItem.maxDurability,
							acquiredTimes: timestamps
						};
						clickedSlotItem.count -= halfCount;
						if (clickedSlotItem.count <= 0) sourceArray[slotIndex] = null;
						heldItemSource = { type: sourceType, index: slotIndex };
					}
				} else { // place one from heldItem
					if (heldItem.count > 0) {
						if (!clickedSlotItem) {
							// create a single-unit slot
							const timestamps = (itemTypes[heldItem.type]?.spoilable && Array.isArray(heldItem.acquiredTimes)) ? [heldItem.acquiredTimes.shift()] : (itemTypes[heldItem.type]?.spoilable ? [gameTime] : null);
							sourceArray[slotIndex] = { type: heldItem.type, count: 1 };
							if (itemTypes[heldItem.type]?.isTool) {
								sourceArray[slotIndex].durability = heldItem.durability ?? (itemTypes[heldItem.type]?.maxDurability ?? null);
								sourceArray[slotIndex].maxDurability = heldItem.maxDurability ?? (itemTypes[heldItem.type]?.maxDurability ?? null);
							} else if (timestamps) {
								sourceArray[slotIndex].acquiredTimes = timestamps.slice();
							}
							heldItem.count--;
						} else if (clickedSlotItem.type === heldItem.type && !(itemTypes[heldItem.type] || blockTypes[heldItem.type])?.isTool && clickedSlotItem.count < maxStackSize) {
							// merge one into existing stack
							const ts = (itemTypes[heldItem.type]?.spoilable && Array.isArray(heldItem.acquiredTimes)) ? heldItem.acquiredTimes.shift() : (itemTypes[heldItem.type]?.spoilable ? gameTime : null);
							clickedSlotItem.count++;
							if (ts) {
								if (!Array.isArray(clickedSlotItem.acquiredTimes)) _ensureAcquiredTimes(clickedSlotItem, gameTime);
								clickedSlotItem.acquiredTimes.push(ts);
							}
							heldItem.count--;
						}
						if (heldItem.count <= 0) {
							heldItem = null; heldItemSource = { type: null, index: -1 };
						}
					}
				}
			} else { // Left-click for moving whole stack or swapping
				if (heldItem === null) {
					if (clickedSlotItem) {
						// pick up the whole slot (transfer object)
						heldItem = clickedSlotItem;
						sourceArray[slotIndex] = null;
						heldItemSource = { type: sourceType, index: slotIndex };

						// If we just took items out of a chest/fridge and they are spoilable,
						// we want to restart their timer (original code did acquiredTime = Date.now()).
						if ((sourceType === 'chest' || sourceType === 'refrigerator') && itemTypes[heldItem.type]?.spoilable) {
							// If they came from refrigerator / chest that had no timestamps (paused), create fresh timestamps
							if (!Array.isArray(heldItem.acquiredTimes) || heldItem.acquiredTimes.length === 0) {
								heldItem.acquiredTimes = Array(heldItem.count).fill(gameTime);
							}
						}
					}
				} else { // we have something held and clicking to place / merge / swap
					if (!clickedSlotItem) {
						// place whole heldItem into empty slot
						sourceArray[slotIndex] = heldItem;
						heldItem = null; heldItemSource = { type: null, index: -1 };
					} else if (clickedSlotItem.type === heldItem.type && !(itemTypes[heldItem.type] || blockTypes[heldItem.type])?.isTool) {
						// merge stacks (respect maxStackSize)
						const amountToTransfer = Math.min(heldItem.count, maxStackSize - clickedSlotItem.count);
						// transfer timestamps if spoilable
						if (itemTypes[heldItem.type]?.spoilable) {
							// ensure arrays
							if (!Array.isArray(clickedSlotItem.acquiredTimes)) _ensureAcquiredTimes(clickedSlotItem, gameTime);
							if (!Array.isArray(heldItem.acquiredTimes)) heldItem.acquiredTimes = Array(heldItem.count).fill(gameTime);
							const transferringTimestamps = [];
							for (let s = 0; s < amountToTransfer; s++) {
								transferringTimestamps.push(heldItem.acquiredTimes.shift() ?? gameTime);
							}
							clickedSlotItem.acquiredTimes.push(...transferringTimestamps);
						}
						clickedSlotItem.count += amountToTransfer;
						heldItem.count -= amountToTransfer;
						if (heldItem.count <= 0) {
							heldItem = null; heldItemSource = { type: null, index: -1 };
						}
					} else {
						// swap
						[heldItem, sourceArray[slotIndex]] = [sourceArray[slotIndex], heldItem];
						heldItemSource = { type: sourceType, index: slotIndex };
					}
				}
			}

			// UI updates
			if (inventoryCraftingOverlay.style.display === 'flex') updateInventoryMenu();
			if (chestOverlay.style.display === 'flex') updateChestMenu();
			updateHotbar();
		}

        function checkCraftingRecipe() {
            craftingOutputSlot.innerHTML = '';
            craftButton.disabled = true;
            craftButton.onclick = null;

            for (const recipe of recipes) {
                const requiredInput = recipe.input;
                const requiredKeys = Object.keys(requiredInput);
                const currentGridItems = {};
                let gridItemCount = 0;
                for(let i=0; i<16; i++) {
                    if(craftingGridSlots[i]) {
                        currentGridItems[i] = craftingGridSlots[i];
                        gridItemCount++;
                    }
                }

                if (requiredKeys.length !== gridItemCount) continue;

                let allMatch = true;

				for (const key of requiredKeys) {
					const required = requiredInput[key];
					const current = currentGridItems[key];

					// Check if the required item is missing or not enough count
					if (!current || current.count < required.count) {
						allMatch = false;
						break;
					}

					// Category: Any plank
					if (required.type === 'any_plank') {
						if (!current.type.startsWith('planked_')) {
							allMatch = false;
							break;
						}

					// Category: Any gilded item
					} else if (required.type === 'any_gilded') {
						if (
							!current.type.startsWith('gilded_') &&
							!current.type.startsWith('raw_gilded_') &&
							!current.type.startsWith('planked_gilded_')
						) {
							allMatch = false;
							break;
						}

					// Exact match (standard item type)
					} else if (current.type !== required.type) {
						allMatch = false;
						break;
					}
				}

                if (allMatch) {
                    const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
                    const outputSlotContent = createInventorySlot({ type: recipe.output, count: recipe.outputCount, durability: outputItemProps?.isTool ? outputItemProps.maxDurability : null, maxDurability: outputItemProps?.isTool ? outputItemProps.maxDurability : null }, -1, 'output');
                    craftingOutputSlot.appendChild(outputSlotContent);
                    craftButton.disabled = false;
                    craftButton.onclick = () => executeCraft(recipe);
                    return;
                }
            }
        }

        function executeCraft(recipe) {
            for (const key in recipe.input) {
                const required = recipe.input[key];
                const current = craftingGridSlots[key];
                current.count -= required.count;
                if (current.count <= 0) craftingGridSlots[key] = null;
            }
            const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
            addToInventory(recipe.output, recipe.outputCount, outputItemProps?.isTool ? outputItemProps.maxDurability : null);
            updateInventoryMenu();
        }

        function renderRecipes() {
            recipeListDiv.innerHTML = '';
            for (const recipe of recipes) {
                const recipeItemDiv = document.createElement('div');
                recipeItemDiv.classList.add('recipe-item');
                const inputGridDiv = document.createElement('div');
                inputGridDiv.classList.add('recipe-input-grid');
                const displayInput = recipe.altInputs?.[0] ?? recipe.input;
                for (let i = 0; i < 16; i++) {
                    const inputItem = displayInput[i];
                    const slot = createInventorySlot(inputItem ? {type: inputItem.type, count: inputItem.count} : null, -1, 'recipe');
                    inputGridDiv.appendChild(slot);
                }
                recipeItemDiv.appendChild(inputGridDiv);
                const arrowSpan = document.createElement('span');
                arrowSpan.classList.add('crafting-arrow');
                arrowSpan.textContent = '';
                recipeItemDiv.appendChild(arrowSpan);
                const outputDiv = document.createElement('div');
                outputDiv.classList.add('recipe-output');
                const outputItemProps = itemTypes[recipe.output] || blockTypes[recipe.output];
                const outputSlot = createInventorySlot({ type: recipe.output, count: recipe.outputCount, durability: outputItemProps?.isTool ? outputItemProps.maxDurability : null }, -1, 'recipe');
                outputDiv.appendChild(outputSlot);
                const outputNameSpan = document.createElement('span');
                outputNameSpan.textContent = recipe.name || recipe.output.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                outputDiv.appendChild(outputNameSpan);
                recipeItemDiv.appendChild(outputDiv);
                recipeListDiv.appendChild(recipeItemDiv);
            }
        }

        function updatePlantGrowth() {
            if (isGamePaused) return;
            const currentTime = gameTime;
            for (const key in worldBlocks) {
                const blockData = worldBlocks[key];
                if (blockData.type.startsWith('planted_')) {
                    let growthTimeRequired;
                    if (blockData.baseBlockType === 'fertilizer') {
                        growthTimeRequired = 45000; // 45 seconds
                    } else if (blockData.baseBlockType === 'soil') {
                        growthTimeRequired = 90000; // 90 seconds
                    } else { // 'dirt'
                        growthTimeRequired = 180000; // 180 seconds
                    }
                    
                    if (currentTime - blockData.plantTime >= growthTimeRequired) {
                        const coords = key.split(',').map(Number);
                        if (getBlockType(coords[0], coords[1] - 1) === 'sky') {
                            let cropType;
                            if (blockData.type === 'planted_wheat_seeds') cropType = 'wheat';
                            else if (blockData.type === 'planted_tomato_seeds') cropType = 'tomato_bush';
                            else if (blockData.type === 'planted_cotton_seeds') cropType = 'cotton';
                            else if (blockData.type === 'planted_rice_seeds') cropType = 'rice';
							else if (blockData.type === 'planted_hop_seeds') cropType = 'hop';
							else if (blockData.type === 'planted_oat_seeds') cropType = 'oat';
							else if (blockData.type === 'planted_corn_seeds') cropType = 'corn';
							else if (blockData.type === 'planted_barley_seeds') cropType = 'barley';
                            
                            if (cropType) {
                                worldBlocks[`${coords[0]},${coords[1] - 1}`] = { type: cropType, mineProg: 0 };
                                worldBlocks[key] = { type: blockData.baseBlockType, mineProg: 0 }; 
                            }
                        }
                    }
                }
            }
        }
		
		function updateSpoilage() {
			if (isGamePaused) return;
			const currentTime = gameTime;

			function addSpoiledToInventoryArray(invArray, spoiledType, count) {
				// Merge into invArray (which may be player's inventory or a chest inventory)
				let remaining = count;
				// first fill existing stacks
				for (let i = 0; i < invArray.length && remaining > 0; i++) {
					const s = invArray[i];
					if (s && s.type === spoiledType && !(itemTypes[spoiledType] || blockTypes[spoiledType])?.isTool && s.count < maxStackSize) {
						const take = Math.min(remaining, maxStackSize - s.count);
						s.count += take;
						remaining -= take;
					}
				}
				// then create new stacks in empty slots
				for (let i = 0; i < invArray.length && remaining > 0; i++) {
					if (!invArray[i]) {
						const amount = Math.min(remaining, maxStackSize);
						invArray[i] = { type: spoiledType, count: amount };
						remaining -= amount;
					}
				}
				return remaining; // leftovers (0 expected normally)
			}

			const checkInventory = (inventory, isRefrigerator = false, isPlayerInventory = false) => {
				if (!inventory) return;
				for (let i = 0; i < inventory.length; i++) {
					const item = inventory[i];
					if (!item) continue;

					if (itemTypes[item.type]?.spoilable) {
						const spoilInfo = itemTypes[item.type].spoilable;

						// Refrigerator: pause spoilage by removing timestamps (existing code removed acquiredTime)
						if (isRefrigerator) {
							if (Array.isArray(item.acquiredTimes)) delete item.acquiredTimes;
							if (item.acquiredTime) delete item.acquiredTime;
							continue;
						}

						// Ensure per-unit timestamps exist
						_ensureAcquiredTimes(item, currentTime);

						// Count expired entries (oldest first). We assume oldest timestamps are at index 0 (FIFO).
						let expiredCount = 0;
						for (let t = 0; t < (item.acquiredTimes || []).length; t++) {
							if (currentTime - item.acquiredTimes[t] > spoilInfo.time) expiredCount++;
							else break; // timestamps are ordered by time of insertion => stop on first non-expired
						}

						if (expiredCount > 0) {
							// Remove expired timestamps and reduce item count
							item.acquiredTimes.splice(0, expiredCount);
							item.count -= expiredCount;

							// If the original stack is empty now, clear the slot *before* adding spoiled output
							if (item.count <= 0) {
								inventory[i] = null;
							}

							// Create or merge spoiled items into inventory
							const spoiledType = spoilInfo.into || 'spoiled'; // fallback if defined
							let leftover = 0;
							if (isPlayerInventory) {
								// add to player inventory (merge or create) using the global addToInventory
								addToInventory(spoiledType, expiredCount, null, null, inventorySlots);
							} else {
								// add to this chest/inventory array
								leftover = addSpoiledToInventoryArray(inventory, spoiledType, expiredCount);
								if (leftover > 0) {
									// try player inventory for leftovers
									const stillLeft = (leftover > 0) ? (addToInventory(spoiledType, leftover) ? 0 : leftover) : 0;
									if (stillLeft > 0) {
										console.warn(`No space for ${stillLeft} spoiled ${spoiledType}. They were discarded.`);
									}
								}
							}

							// If the original stack fully consumed, clear the slot
							if (item.count <= 0) {
								inventory[i] = null;
							}
						}
					}
				}
			};

			// Check player inventory (true -> it's player inventory, so add spoiled back into player inventory)
			checkInventory(inventorySlots, false, true);

			// Check chests and refrigerators
			for (const key in worldBlocks) {
				const block = worldBlocks[key];
				if (block.inventory && (block.type === 'chest' || block.type === 'dead_body_chest')) {
					checkInventory(block.inventory, false, false);
				} else if (block.inventory && block.type === 'refrigerator') {
					checkInventory(block.inventory, true, false);
				}
			}
		}

        function toggleGameMenu() {
            if (inventoryCraftingOverlay.style.display === 'flex' || chestOverlay.style.display === 'flex') return;
            isGamePaused = !isGamePaused;
            if (isGamePaused) {
                gameMenuOverlay.style.display = 'flex';
				seedInput.value = '';
				seedInput.placeholder = `Current: ${currentSeed}`;
                maintainDurabilityCheckbox.checked = maintainBlockDurability;
            } else {
                gameMenuOverlay.style.display = 'none';
                resolvePlayerVerticalCollision();
                lastTime = performance.now();
            }
        }

        function toggleChestMenu(col, row) {
            isGamePaused = !isGamePaused;
            if (isGamePaused) {
                currentlyOpenChest = { col, row };
                chestOverlay.style.display = 'flex';
                updateChestMenu();
            } else {
                chestOverlay.style.display = 'none';
                currentlyOpenChest = null;
                if (heldItem) {
                    addToInventory(heldItem.type, heldItem.count, heldItem.durability);
                    heldItem = null;
                    heldItemSource = { type: null, index: -1 };
                }
                lastTime = performance.now();
            }
        }

        function updateChestMenu() {
			if (!currentlyOpenChest) return;
			const chestKey = `${currentlyOpenChest.col},${currentlyOpenChest.row}`;
			const chestData = worldBlocks[chestKey];

			// Check if the chest is valid, otherwise close the menu
			if (!chestData || (chestData.type !== 'chest' && chestData.type !== 'dead_body_chest' && chestData.type !== 'refrigerator')) {
				toggleChestMenu();
				return;
			}

			// --- NEW: Dynamic Grid Size ---
			const currentChestSize = chestData.inventory.length;
			// Set grid columns. For a 50-slot chest, 10 columns looks good.
			const columns = (currentChestSize === 50) ? 10 : 9;
			chestGrid.style.gridTemplateColumns = `repeat(${columns}, minmax(45px, 1fr))`;
			// --- End of new logic ---

			chestTitle.textContent = chestData.label || 'Chest';
			chestLabelInput.value = chestData.label || '';
			if (chestData.type === 'dead_body_chest') {
				chestLabelInput.disabled = true; // Don't allow renaming a dead body chest
			} else {
				chestLabelInput.disabled = false;
			}


			chestGrid.innerHTML = '';
			chestPlayerInventoryGrid.innerHTML = '';

			// Chest inventory (now uses the dynamic size)
			for (let i = 0; i < currentChestSize; i++) {
				const slotDiv = createInventorySlot(chestData.inventory[i], i, 'chest');
				chestGrid.appendChild(slotDiv);
			}

			// Player inventory
			for (let i = 0; i < totalInventorySlots; i++) {
				const slotDiv = createInventorySlot(inventorySlots[i], i, 'inventory');
				chestPlayerInventoryGrid.appendChild(slotDiv);
			}
		}
        
        chestLabelInput.addEventListener('change', () => {
			if (currentlyOpenChest) {
				const chestKey = `${currentlyOpenChest.col},${currentlyOpenChest.row}`;
				const chestData = worldBlocks[chestKey];
				if (chestData && (chestData.type === 'chest' || chestData.type === 'refrigerator')) {
					chestData.label = chestLabelInput.value;
					chestTitle.textContent = chestData.label || (chestData.type === 'refrigerator' ? 'Refrigerator' : 'Chest');
				}
			}
		});

        maintainDurabilityCheckbox.addEventListener('change', () => { maintainBlockDurability = maintainBlockDurability.checked; });

        newGameButton.addEventListener('click', async () => {
            if (await showMessageBox("Starting a new game will overwrite current progress. Are you sure?", 'confirm')) {
                let newSeedValue = seedInput.value.trim();
                let seedToUse = newSeedValue === '' ? Date.now() : stringToHash(newSeedValue);
                setSeed(seedToUse);
                Object.keys(worldBlocks).forEach(key => delete worldBlocks[key]);
                Object.keys(columnSurfaceHeights).forEach(key => delete columnSurfaceHeights[key]);
                Object.keys(worldBiomes).forEach(key => delete worldBiomes[key]); // Clear biome data
                caveBlocks.clear(); // Clear cave data
                skyIslandColumns.clear();
                lastBiomeEndCol = -1; 
                firstBiomeStartCol = 0;
                player.x = 0 * tileSize; player.y = 0; player.dx = 0; player.dy = 0; player.onGround = false;
                player.health = player.maxHealth; player.bedSpawnPoint = null;
                inventorySlots.fill(null); hotbarIndices.fill(null); selectedHotbarSlot = 0; playerMiningPower = 0.1;
                craftingGridSlots.fill(null); heldItem = null; heldItemSource = { type: null, index: -1 };
                updateHotbar();
                init();
                toggleGameMenu();
                showMessageBox(`New game started with seed: ${seedToUse}`);
            }
        });

        resumeButton.addEventListener('click', toggleGameMenu);

        function resolvePlayerVerticalCollision() {
            const playerCol = Math.floor(player.x / tileSize);
            const playerRow = Math.floor(player.y / tileSize);
            player.onGround = false;
            for (let r = playerRow; r < playerRow + playerHeightBlocks + 2; r++) {
                for (let c = playerCol; c < playerCol + playerWidthBlocks; c++) {
                    if (isSolid(c, r)) {
                        player.y = r * tileSize - playerHeight;
                        player.dy = 0;
                        player.onGround = true;
                        return;
                    }
                }
            }
        }

        let lastTime = performance.now();
        let accumulator = 0.0;
        const fixedDeltaTime = 1000 / 60; // Run physics at 60 updates per second

        function gameLoop(currentTime) {
            if (isGameActive && !isGamePaused) {
                accumulator += currentTime - lastTime;
                lastTime = currentTime;

                // Prevent spiral of death on major lag spikes
                if (accumulator > 1000) {
                    accumulator = 1000;
                }

                while (accumulator >= fixedDeltaTime) {
                    update(fixedDeltaTime); // Update with a fixed time step
                    accumulator -= fixedDeltaTime;
                }
            } else {
                // If paused, we still need to reset lastTime when resuming
                lastTime = currentTime;
            }
            
            draw(); // Draw as fast as possible
            requestAnimationFrame(gameLoop);
        }

        function update(dt) {
            // Note: The 'dt' here is now a fixed value
			gameTime += dt;
            generateOffscreenChunks(); 
            updatePlayer(dt);
            updateCamera();
            updateMining(dt);
            handleBlockPlacement();
            plantSpoilageAccumulator += dt;
			if (plantSpoilageAccumulator >= PLANT_SPOILAGE_INTERVAL) {
			  updatePlantGrowth();
			  updateSpoilage();
			  plantSpoilageAccumulator = 0;
			}

            const playerGridCoords = worldToGrid(player.x + playerWidth / 2, player.y + playerHeight / 2);
            coordsDisplay.textContent = `Coords: (${playerGridCoords.col}, ${playerGridCoords.row})`;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawWorld();
            drawPlayer();
            drawmineProg();
            drawHealth();
        }

        function init() {
            resizeCanvas();
            setSeed(currentSeed);
            
            // Initial world generation around player spawn
            generateOffscreenChunks();

            const playerStartCol = Math.floor(player.x / tileSize);
            let actualSurfaceRowAtStart = baseSurfaceLevel;
            const maxSurfaceSearchDepth = 200;
            let searchCount = 0;
            while(getBlockType(playerStartCol, actualSurfaceRowAtStart) === 'sky' && searchCount < maxSurfaceSearchDepth) {
                 actualSurfaceRowAtStart++;
                 searchCount++;
            }
            if (searchCount >= maxSurfaceSearchDepth) {
                console.warn("Could not find solid surface. Defaulting player Y.");
                actualSurfaceRowAtStart = baseSurfaceLevel + 10;
            }
            player.y = (actualSurfaceRowAtStart - playerHeightBlocks) * tileSize;
            player.spawnPoint = { x: player.x, y: player.y }; // Set initial spawn point
            resolvePlayerVerticalCollision();
            updateHotbar();
            lastTime = performance.now();
            if (!gameLoopId) {
                gameLoopId = requestAnimationFrame(gameLoop);
            }
        }
        
        let gameLoopId;
        
        function exportWorldData() {
            const sanitizedWorldBlocks = {};
            for (const key in worldBlocks) {
                const block = worldBlocks[key];

                const sanitizedBlock = { tp: block.type };
                if (block.mineProg) sanitizedBlock.mP = block.mineProg;
                if (block.inventory) sanitizedBlock.inv = block.inventory;
                if (block.label) sanitizedBlock.lbl = block.label;
                if (block.part) sanitizedBlock.prt = block.part;
                if (block.plantTime) sanitizedBlock.pT = block.plantTime;
                if (block.baseBlockType) sanitizedBlock.bBT = block.baseBlockType;

                sanitizedWorldBlocks[key] = sanitizedBlock;
            }

            const worldData = {
                seed: currentSeed,
                blocks: sanitizedWorldBlocks,
                heights: columnSurfaceHeights,
                heavenHeights: heavenColumnSurfaceHeights,
                biomes: worldBiomes,
                underworldBiomes: underworldBiomes,
                caves: Array.from(caveBlocks),
                islands: Array.from(skyIslandColumns),
                towers: Array.from(watchtowerColumns),
                player: {
                    x: player.x,
                    y: player.y,
                    h: player.health,
                    bed: player.bedSpawnPoint
                },
                inventory: inventorySlots,
                hotbar: hotbarIndices
            };

            const json = JSON.stringify(worldData);
            const blob = new Blob([json], { type: "application/json" });
            const url = URL.createObjectURL(blob);

            const a = document.createElement("a");
            a.href = url;
            a.download = `world_${currentSeed}.bgu1`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessageBox("World Saved!");
        }

		document.addEventListener("keydown", (e) => {
			if (e.key === "]") {
				exportWorldData();
			}
		});

		document.getElementById("worldFileInput").addEventListener("change", function (event) {
			const file = event.target.files[0];
			if (!file) return;

			const reader = new FileReader();
			reader.onload = function (e) {
				try {
					const data = JSON.parse(e.target.result);
					importWorldData(data);
					showMessageBox("World data successfully imported!");
				} catch (err) {
					console.error("Error parsing world data:", err);
                    showMessageBox("Error: Could not load world file. It may be corrupted.");
				}
			};
			reader.readAsText(file);
		});

		function importWorldData(data) {
            // Clear existing world state
            Object.keys(worldBlocks).forEach(key => delete worldBlocks[key]);
            Object.keys(columnSurfaceHeights).forEach(key => delete columnSurfaceHeights[key]);
            Object.keys(heavenColumnSurfaceHeights).forEach(key => delete heavenColumnSurfaceHeights[key]);
            Object.keys(worldBiomes).forEach(key => delete worldBiomes[key]);
            Object.keys(underworldBiomes).forEach(key => delete underworldBiomes[key]);
            caveBlocks.clear();
            skyIslandColumns.clear();
            watchtowerColumns.clear();

            // Load new data
            setSeed(data.seed || Date.now());
            
            const loadedBlocks = data.blocks || {};
            for (const key in loadedBlocks) {
                const sBlock = loadedBlocks[key];
                const newBlock = { 
                    type: sBlock.tp, 
                    mineProg: sBlock.mP || 0,
                    inventory: sBlock.inv,
                    label: sBlock.lbl,
                    part: sBlock.prt,
                    plantTime: sBlock.pT,
                    baseBlockType: sBlock.bBT
                };
                worldBlocks[key] = newBlock;
            }

            Object.assign(columnSurfaceHeights, data.heights || {});
            Object.assign(heavenColumnSurfaceHeights, data.heavenHeights || {});
            Object.assign(worldBiomes, data.biomes || {});
            Object.assign(underworldBiomes, data.underworldBiomes || {});
            (data.caves || []).forEach(key => caveBlocks.add(key));
            (data.islands || []).forEach(key => skyIslandColumns.add(key));
            (data.towers || []).forEach(key => watchtowerColumns.add(key));

            // Load Player Data
            if (data.player) {
                player.x = data.player.x;
                player.y = data.player.y;
                player.health = data.player.h;
                player.bedSpawnPoint = data.player.bed;
            }

            // Load Inventory
            inventorySlots.fill(null);
            if(data.inventory) {
                for(let i=0; i < data.inventory.length; i++) {
                    inventorySlots[i] = data.inventory[i];
                }
            }
            hotbarIndices.fill(null);
             if(data.hotbar) {
                for(let i=0; i < data.hotbar.length; i++) {
                    hotbarIndices[i] = data.hotbar[i];
                }
            }

            updateHotbar();
            if(gameMenuOverlay.style.display === 'flex') toggleGameMenu();
            lastTime = performance.now(); // Reset time to prevent large dt jump
            console.log("World state updated from import.");
        }

		document.addEventListener("keydown", (e) => {
			if (e.key === "[") {
				document.getElementById("worldFileInput").click();
			}
		});
        
        loadAssets();

    </script>
</body>
</html>
